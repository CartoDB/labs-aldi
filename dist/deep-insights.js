(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.cartodb || (g.cartodb = {})).deepInsights = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  createDashboard: require('./src/create-dashboard')
};

},{"./src/create-dashboard":25}],2:[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],3:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = require('./src/js/main');

},{"./src/js/main":9}],4:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

function oldAdd(element, className) {
  var classes = element.className.split(' ');
  if (classes.indexOf(className) < 0) {
    classes.push(className);
  }
  element.className = classes.join(' ');
}

function oldRemove(element, className) {
  var classes = element.className.split(' ');
  var idx = classes.indexOf(className);
  if (idx >= 0) {
    classes.splice(idx, 1);
  }
  element.className = classes.join(' ');
}

exports.add = function (element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    oldAdd(element, className);
  }
};

exports.remove = function (element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    oldRemove(element, className);
  }
};

exports.list = function (element) {
  if (element.classList) {
    return Array.prototype.slice.apply(element.classList);
  } else {
    return element.className.split(' ');
  }
};

},{}],5:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var DOM = {};

DOM.e = function (tagName, className) {
  var element = document.createElement(tagName);
  element.className = className;
  return element;
};

DOM.appendTo = function (child, parent) {
  parent.appendChild(child);
  return child;
};

function cssGet(element, styleName) {
  return window.getComputedStyle(element)[styleName];
}

function cssSet(element, styleName, styleValue) {
  if (typeof styleValue === 'number') {
    styleValue = styleValue.toString() + 'px';
  }
  element.style[styleName] = styleValue;
  return element;
}

function cssMultiSet(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val.toString() + 'px';
    }
    element.style[key] = val;
  }
  return element;
}

DOM.css = function (element, styleNameOrObject, styleValue) {
  if (typeof styleNameOrObject === 'object') {
    // multiple set with object
    return cssMultiSet(element, styleNameOrObject);
  } else {
    if (typeof styleValue === 'undefined') {
      return cssGet(element, styleNameOrObject);
    } else {
      return cssSet(element, styleNameOrObject, styleValue);
    }
  }
};

DOM.matches = function (element, query) {
  if (typeof element.matches !== 'undefined') {
    return element.matches(query);
  } else {
    if (typeof element.matchesSelector !== 'undefined') {
      return element.matchesSelector(query);
    } else if (typeof element.webkitMatchesSelector !== 'undefined') {
      return element.webkitMatchesSelector(query);
    } else if (typeof element.mozMatchesSelector !== 'undefined') {
      return element.mozMatchesSelector(query);
    } else if (typeof element.msMatchesSelector !== 'undefined') {
      return element.msMatchesSelector(query);
    }
  }
};

DOM.remove = function (element) {
  if (typeof element.remove !== 'undefined') {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
};

DOM.queryChildren = function (element, selector) {
  return Array.prototype.filter.call(element.childNodes, function (child) {
    return DOM.matches(child, selector);
  });
};

module.exports = DOM;

},{}],6:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var EventElement = function (element) {
  this.element = element;
  this.events = {};
};

EventElement.prototype.bind = function (eventName, handler) {
  if (typeof this.events[eventName] === 'undefined') {
    this.events[eventName] = [];
  }
  this.events[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function (eventName, handler) {
  var isHandlerProvided = (typeof handler !== 'undefined');
  this.events[eventName] = this.events[eventName].filter(function (hdlr) {
    if (isHandlerProvided && hdlr !== handler) {
      return true;
    }
    this.element.removeEventListener(eventName, hdlr, false);
    return false;
  }, this);
};

EventElement.prototype.unbindAll = function () {
  for (var name in this.events) {
    this.unbind(name);
  }
};

var EventManager = function () {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function (element) {
  var ee = this.eventElements.filter(function (eventElement) {
    return eventElement.element === element;
  })[0];
  if (typeof ee === 'undefined') {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function (element, eventName, handler) {
  this.eventElement(element).unbind(eventName, handler);
};

EventManager.prototype.unbindAll = function () {
  for (var i = 0; i < this.eventElements.length; i++) {
    this.eventElements[i].unbindAll();
  }
};

EventManager.prototype.once = function (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (e) {
    ee.unbind(eventName, onceHandler);
    handler(e);
  };
  ee.bind(eventName, onceHandler);
};

module.exports = EventManager;

},{}],7:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = (function () {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }
  return function () {
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
           s4() + '-' + s4() + s4() + s4();
  };
})();

},{}],8:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('./class')
  , d = require('./dom');

exports.toInt = function (x) {
  return parseInt(x, 10) || 0;
};

exports.clone = function (obj) {
  if (obj === null) {
    return null;
  } else if (typeof obj === 'object') {
    var result = {};
    for (var key in obj) {
      result[key] = this.clone(obj[key]);
    }
    return result;
  } else {
    return obj;
  }
};

exports.extend = function (original, source) {
  var result = this.clone(original);
  for (var key in source) {
    result[key] = this.clone(source[key]);
  }
  return result;
};

exports.isEditable = function (el) {
  return d.matches(el, "input,[contenteditable]") ||
         d.matches(el, "select,[contenteditable]") ||
         d.matches(el, "textarea,[contenteditable]") ||
         d.matches(el, "button,[contenteditable]");
};

exports.removePsClasses = function (element) {
  var clsList = cls.list(element);
  for (var i = 0; i < clsList.length; i++) {
    var className = clsList[i];
    if (className.indexOf('ps-') === 0) {
      cls.remove(element, className);
    }
  }
};

exports.outerWidth = function (element) {
  return this.toInt(d.css(element, 'width')) +
         this.toInt(d.css(element, 'paddingLeft')) +
         this.toInt(d.css(element, 'paddingRight')) +
         this.toInt(d.css(element, 'borderLeftWidth')) +
         this.toInt(d.css(element, 'borderRightWidth'));
};

exports.startScrolling = function (element, axis) {
  cls.add(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.add(element, 'ps-' + axis);
  } else {
    cls.add(element, 'ps-x');
    cls.add(element, 'ps-y');
  }
};

exports.stopScrolling = function (element, axis) {
  cls.remove(element, 'ps-in-scrolling');
  if (typeof axis !== 'undefined') {
    cls.remove(element, 'ps-' + axis);
  } else {
    cls.remove(element, 'ps-x');
    cls.remove(element, 'ps-y');
  }
};

exports.env = {
  isWebKit: 'WebkitAppearance' in document.documentElement.style,
  supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: window.navigator.msMaxTouchPoints !== null
};

},{"./class":4,"./dom":5}],9:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var destroy = require('./plugin/destroy')
  , initialize = require('./plugin/initialize')
  , update = require('./plugin/update');

module.exports = {
  initialize: initialize,
  update: update,
  destroy: destroy
};

},{"./plugin/destroy":11,"./plugin/initialize":19,"./plugin/update":23}],10:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

module.exports = {
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  stopPropagationOnClick: true,
  suppressScrollX: false,
  suppressScrollY: false,
  swipePropagation: true,
  useBothWheelAxes: false,
  useKeyboard: true,
  useSelectionScroll: false,
  wheelPropagation: false,
  wheelSpeed: 1
};

},{}],11:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances');

module.exports = function (element) {
  var i = instances.get(element);

  if (!i) {
    return;
  }

  i.event.unbindAll();
  d.remove(i.scrollbarX);
  d.remove(i.scrollbarY);
  d.remove(i.scrollbarXRail);
  d.remove(i.scrollbarYRail);
  h.removePsClasses(element);

  instances.remove(element);
};

},{"../lib/dom":5,"../lib/helper":8,"./instances":20}],12:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindClickRailHandler(element, i) {
  function pageOffset(el) {
    return el.getBoundingClientRect();
  }
  var stopPropagation = window.Event.prototype.stopPropagation.bind;

  if (i.settings.stopPropagationOnClick) {
    i.event.bind(i.scrollbarY, 'click', stopPropagation);
  }
  i.event.bind(i.scrollbarYRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarYHeight / 2);
    var positionTop = i.railYRatio * (e.pageY - window.scrollY - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
    var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
    var positionRatio = positionTop / maxPositionTop;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    updateScroll(element, 'top', (i.contentHeight - i.containerHeight) * positionRatio);
    updateGeometry(element);

    e.stopPropagation();
  });

  if (i.settings.stopPropagationOnClick) {
    i.event.bind(i.scrollbarX, 'click', stopPropagation);
  }
  i.event.bind(i.scrollbarXRail, 'click', function (e) {
    var halfOfScrollbarLength = h.toInt(i.scrollbarXWidth / 2);
    var positionLeft = i.railXRatio * (e.pageX - window.scrollX - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
    var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
    var positionRatio = positionLeft / maxPositionLeft;

    if (positionRatio < 0) {
      positionRatio = 0;
    } else if (positionRatio > 1) {
      positionRatio = 1;
    }

    updateScroll(element, 'left', ((i.contentWidth - i.containerWidth) * positionRatio) - i.negativeScrollAdjustment);
    updateGeometry(element);

    e.stopPropagation();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindClickRailHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],13:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../../lib/dom')
  , h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindMouseScrollXHandler(element, i) {
  var currentLeft = null;
  var currentPageX = null;

  function updateScrollLeft(deltaX) {
    var newLeft = currentLeft + (deltaX * i.railXRatio);
    var maxLeft = i.scrollbarXRail.getBoundingClientRect().left + (i.railXRatio * (i.railXWidth - i.scrollbarXWidth));

    if (newLeft < 0) {
      i.scrollbarXLeft = 0;
    } else if (newLeft > maxLeft) {
      i.scrollbarXLeft = maxLeft;
    } else {
      i.scrollbarXLeft = newLeft;
    }

    var scrollLeft = h.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - (i.railXRatio * i.scrollbarXWidth))) - i.negativeScrollAdjustment;
    updateScroll(element, 'left', scrollLeft);
  }

  var mouseMoveHandler = function (e) {
    updateScrollLeft(e.pageX - currentPageX);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'x');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
    currentPageX = e.pageX;
    currentLeft = h.toInt(d.css(i.scrollbarX, 'left')) * i.railXRatio;
    h.startScrolling(element, 'x');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

function bindMouseScrollYHandler(element, i) {
  var currentTop = null;
  var currentPageY = null;

  function updateScrollTop(deltaY) {
    var newTop = currentTop + (deltaY * i.railYRatio);
    var maxTop = i.scrollbarYRail.getBoundingClientRect().top + (i.railYRatio * (i.railYHeight - i.scrollbarYHeight));

    if (newTop < 0) {
      i.scrollbarYTop = 0;
    } else if (newTop > maxTop) {
      i.scrollbarYTop = maxTop;
    } else {
      i.scrollbarYTop = newTop;
    }

    var scrollTop = h.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - (i.railYRatio * i.scrollbarYHeight)));
    updateScroll(element, 'top', scrollTop);
  }

  var mouseMoveHandler = function (e) {
    updateScrollTop(e.pageY - currentPageY);
    updateGeometry(element);
    e.stopPropagation();
    e.preventDefault();
  };

  var mouseUpHandler = function () {
    h.stopScrolling(element, 'y');
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  };

  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
    currentPageY = e.pageY;
    currentTop = h.toInt(d.css(i.scrollbarY, 'top')) * i.railYRatio;
    h.startScrolling(element, 'y');

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    e.stopPropagation();
    e.preventDefault();
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseScrollXHandler(element, i);
  bindMouseScrollYHandler(element, i);
};

},{"../../lib/dom":5,"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],14:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindKeyboardHandler(element, i) {
  var hovered = false;
  i.event.bind(element, 'mouseenter', function () {
    hovered = true;
  });
  i.event.bind(element, 'mouseleave', function () {
    hovered = false;
  });

  var shouldPrevent = false;
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented()) {
      return;
    }

    if (!hovered) {
      return;
    }

    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      // go deeper if element is a webcomponent
      while (activeElement.shadowRoot) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      if (h.isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
    case 37: // left
      deltaX = -30;
      break;
    case 38: // up
      deltaY = 30;
      break;
    case 39: // right
      deltaX = 30;
      break;
    case 40: // down
      deltaY = -30;
      break;
    case 33: // page up
      deltaY = 90;
      break;
    case 32: // space bar
      if (e.shiftKey) {
        deltaY = 90;
      } else {
        deltaY = -90;
      }
      break;
    case 34: // page down
      deltaY = -90;
      break;
    case 35: // end
      if (e.ctrlKey) {
        deltaY = -i.contentHeight;
      } else {
        deltaY = -i.containerHeight;
      }
      break;
    case 36: // home
      if (e.ctrlKey) {
        deltaY = element.scrollTop;
      } else {
        deltaY = i.containerHeight;
      }
      break;
    default:
      return;
    }

    updateScroll(element, 'top', element.scrollTop - deltaY);
    updateScroll(element, 'left', element.scrollLeft + deltaX);
    updateGeometry(element);

    shouldPrevent = shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent) {
      e.preventDefault();
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindKeyboardHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],15:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindMouseWheelHandler(element, i) {
  var shouldPrevent = false;

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    return [deltaX, deltaY];
  }

  function shouldBeConsumedByTextarea(deltaX, deltaY) {
    var hoveredTextarea = element.querySelector('textarea:hover');
    if (hoveredTextarea) {
      var maxScrollTop = hoveredTextarea.scrollHeight - hoveredTextarea.clientHeight;
      if (maxScrollTop > 0) {
        if (!(hoveredTextarea.scrollTop === 0 && deltaY > 0) &&
            !(hoveredTextarea.scrollTop === maxScrollTop && deltaY < 0)) {
          return true;
        }
      }
      var maxScrollLeft = hoveredTextarea.scrollLeft - hoveredTextarea.clientWidth;
      if (maxScrollLeft > 0) {
        if (!(hoveredTextarea.scrollLeft === 0 && deltaX < 0) &&
            !(hoveredTextarea.scrollLeft === maxScrollLeft && deltaX > 0)) {
          return true;
        }
      }
    }
    return false;
  }

  function mousewheelHandler(e) {
    // FIXME: this is a quick fix for the select problem in FF and IE.
    // If there comes an effective way to deal with the problem,
    // this lines should be removed.
    if (!h.env.isWebKit && element.querySelector('select:focus')) {
      return;
    }

    var delta = getDeltaFromEvent(e);

    var deltaX = delta[0];
    var deltaY = delta[1];

    if (shouldBeConsumedByTextarea(deltaX, deltaY)) {
      return;
    }

    shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
      updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
      } else {
        updateScroll(element, 'top', element.scrollTop + (deltaX * i.settings.wheelSpeed));
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
      } else {
        updateScroll(element, 'left', element.scrollLeft - (deltaY * i.settings.wheelSpeed));
      }
      shouldPrevent = true;
    }

    updateGeometry(element);

    shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
    if (shouldPrevent) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
}

module.exports = function (element) {
  var i = instances.get(element);
  bindMouseWheelHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],16:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('../instances')
  , updateGeometry = require('../update-geometry');

function bindNativeScrollHandler(element, i) {
  i.event.bind(element, 'scroll', function () {
    updateGeometry(element);
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindNativeScrollHandler(element, i);
};

},{"../instances":20,"../update-geometry":21}],17:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var h = require('../../lib/helper')
  , instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindSelectionHandler(element, i) {
  function getRangeNode() {
    var selection = window.getSelection ? window.getSelection() :
                    document.getSelection ? document.getSelection() : '';
    if (selection.toString().length === 0) {
      return null;
    } else {
      return selection.getRangeAt(0).commonAncestorContainer;
    }
  }

  var scrollingLoop = null;
  var scrollDiff = {top: 0, left: 0};
  function startScrolling() {
    if (!scrollingLoop) {
      scrollingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(scrollingLoop);
          return;
        }

        updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
        updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
        updateGeometry(element);
      }, 50); // every .1 sec
    }
  }
  function stopScrolling() {
    if (scrollingLoop) {
      clearInterval(scrollingLoop);
      scrollingLoop = null;
    }
    h.stopScrolling(element);
  }

  var isSelected = false;
  i.event.bind(i.ownerDocument, 'selectionchange', function () {
    if (element.contains(getRangeNode())) {
      isSelected = true;
    } else {
      isSelected = false;
      stopScrolling();
    }
  });
  i.event.bind(window, 'mouseup', function () {
    if (isSelected) {
      isSelected = false;
      stopScrolling();
    }
  });

  i.event.bind(window, 'mousemove', function (e) {
    if (isSelected) {
      var mousePosition = {x: e.pageX, y: e.pageY};
      var containerGeometry = {
        left: element.offsetLeft,
        right: element.offsetLeft + element.offsetWidth,
        top: element.offsetTop,
        bottom: element.offsetTop + element.offsetHeight
      };

      if (mousePosition.x < containerGeometry.left + 3) {
        scrollDiff.left = -5;
        h.startScrolling(element, 'x');
      } else if (mousePosition.x > containerGeometry.right - 3) {
        scrollDiff.left = 5;
        h.startScrolling(element, 'x');
      } else {
        scrollDiff.left = 0;
      }

      if (mousePosition.y < containerGeometry.top + 3) {
        if (containerGeometry.top + 3 - mousePosition.y < 5) {
          scrollDiff.top = -5;
        } else {
          scrollDiff.top = -20;
        }
        h.startScrolling(element, 'y');
      } else if (mousePosition.y > containerGeometry.bottom - 3) {
        if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
          scrollDiff.top = 5;
        } else {
          scrollDiff.top = 20;
        }
        h.startScrolling(element, 'y');
      } else {
        scrollDiff.top = 0;
      }

      if (scrollDiff.top === 0 && scrollDiff.left === 0) {
        stopScrolling();
      } else {
        startScrolling();
      }
    }
  });
}

module.exports = function (element) {
  var i = instances.get(element);
  bindSelectionHandler(element, i);
};

},{"../../lib/helper":8,"../instances":20,"../update-geometry":21,"../update-scroll":22}],18:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('../instances')
  , updateGeometry = require('../update-geometry')
  , updateScroll = require('../update-scroll');

function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = element.scrollTop;
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
          ((deltaY > 0) && (scrollTop === 0))) {
        return !i.settings.swipePropagation;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
          ((deltaX > 0) && (scrollLeft === 0))) {
        return !i.settings.swipePropagation;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    updateScroll(element, 'top', element.scrollTop - differenceY);
    updateScroll(element, 'left', element.scrollLeft - differenceX);

    updateGeometry(element);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  var inGlobalTouch = false;
  var inLocalTouch = false;

  function globalTouchStart() {
    inGlobalTouch = true;
  }
  function globalTouchEnd() {
    inGlobalTouch = false;
  }

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (shouldHandle(e)) {
      inLocalTouch = true;

      var touch = getTouch(e);

      startOffset.pageX = touch.pageX;
      startOffset.pageY = touch.pageY;

      startTime = (new Date()).getTime();

      if (easingLoop !== null) {
        clearInterval(easingLoop);
      }

      e.stopPropagation();
    }
  }
  function touchMove(e) {
    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = (new Date()).getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPreventDefault(differenceX, differenceY)) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (!inGlobalTouch && inLocalTouch) {
      inLocalTouch = false;

      clearInterval(easingLoop);
      easingLoop = setInterval(function () {
        if (!instances.get(element)) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (supportsTouch) {
    i.event.bind(window, 'touchstart', globalTouchStart);
    i.event.bind(window, 'touchend', globalTouchEnd);
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  }

  if (supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(window, 'pointerdown', globalTouchStart);
      i.event.bind(window, 'pointerup', globalTouchEnd);
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(window, 'MSPointerDown', globalTouchStart);
      i.event.bind(window, 'MSPointerUp', globalTouchEnd);
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
}

module.exports = function (element, supportsTouch, supportsIePointer) {
  var i = instances.get(element);
  bindTouchHandler(element, i, supportsTouch, supportsIePointer);
};

},{"../instances":20,"../update-geometry":21,"../update-scroll":22}],19:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('../lib/class')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateGeometry = require('./update-geometry');

// Handlers
var clickRailHandler = require('./handler/click-rail')
  , dragScrollbarHandler = require('./handler/drag-scrollbar')
  , keyboardHandler = require('./handler/keyboard')
  , mouseWheelHandler = require('./handler/mouse-wheel')
  , nativeScrollHandler = require('./handler/native-scroll')
  , selectionHandler = require('./handler/selection')
  , touchHandler = require('./handler/touch');

module.exports = function (element, userSettings) {
  userSettings = typeof userSettings === 'object' ? userSettings : {};

  cls.add(element, 'ps-container');

  // Create a plugin instance.
  var i = instances.add(element);

  i.settings = h.extend(i.settings, userSettings);

  clickRailHandler(element);
  dragScrollbarHandler(element);
  mouseWheelHandler(element);
  nativeScrollHandler(element);

  if (i.settings.useSelectionScroll) {
    selectionHandler(element);
  }

  if (h.env.supportsTouch || h.env.supportsIePointer) {
    touchHandler(element, h.env.supportsTouch, h.env.supportsIePointer);
  }
  if (i.settings.useKeyboard) {
    keyboardHandler(element);
  }

  updateGeometry(element);
};

},{"../lib/class":4,"../lib/helper":8,"./handler/click-rail":12,"./handler/drag-scrollbar":13,"./handler/keyboard":14,"./handler/mouse-wheel":15,"./handler/native-scroll":16,"./handler/selection":17,"./handler/touch":18,"./instances":20,"./update-geometry":21}],20:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , defaultSettings = require('./default-setting')
  , EventManager = require('../lib/event-manager')
  , guid = require('../lib/guid')
  , h = require('../lib/helper');

var instances = {};

function Instance(element) {
  var i = this;

  i.settings = h.clone(defaultSettings);
  i.containerWidth = null;
  i.containerHeight = null;
  i.contentWidth = null;
  i.contentHeight = null;

  i.isRtl = d.css(element, 'direction') === "rtl";
  i.isNegativeScroll = (function () {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  })();
  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  i.event = new EventManager();
  i.ownerDocument = element.ownerDocument || document;

  i.scrollbarXRail = d.appendTo(d.e('div', 'ps-scrollbar-x-rail'), element);
  i.scrollbarX = d.appendTo(d.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
  i.scrollbarXActive = null;
  i.scrollbarXWidth = null;
  i.scrollbarXLeft = null;
  i.scrollbarXBottom = h.toInt(d.css(i.scrollbarXRail, 'bottom'));
  i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
  i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : h.toInt(d.css(i.scrollbarXRail, 'top'));
  i.railBorderXWidth = h.toInt(d.css(i.scrollbarXRail, 'borderLeftWidth')) + h.toInt(d.css(i.scrollbarXRail, 'borderRightWidth'));
  // Set rail to display:block to calculate margins
  d.css(i.scrollbarXRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  d.css(i.scrollbarXRail, 'display', '');
  i.railXWidth = null;
  i.railXRatio = null;

  i.scrollbarYRail = d.appendTo(d.e('div', 'ps-scrollbar-y-rail'), element);
  i.scrollbarY = d.appendTo(d.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
  i.scrollbarYActive = null;
  i.scrollbarYHeight = null;
  i.scrollbarYTop = null;
  i.scrollbarYRight = h.toInt(d.css(i.scrollbarYRail, 'right'));
  i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
  i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : h.toInt(d.css(i.scrollbarYRail, 'left'));
  i.scrollbarYOuterWidth = i.isRtl ? h.outerWidth(i.scrollbarY) : null;
  i.railBorderYWidth = h.toInt(d.css(i.scrollbarYRail, 'borderTopWidth')) + h.toInt(d.css(i.scrollbarYRail, 'borderBottomWidth'));
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));
  d.css(i.scrollbarYRail, 'display', '');
  i.railYHeight = null;
  i.railYRatio = null;
}

function getId(element) {
  if (typeof element.dataset === 'undefined') {
    return element.getAttribute('data-ps-id');
  } else {
    return element.dataset.psId;
  }
}

function setId(element, id) {
  if (typeof element.dataset === 'undefined') {
    element.setAttribute('data-ps-id', id);
  } else {
    element.dataset.psId = id;
  }
}

function removeId(element) {
  if (typeof element.dataset === 'undefined') {
    element.removeAttribute('data-ps-id');
  } else {
    delete element.dataset.psId;
  }
}

exports.add = function (element) {
  var newId = guid();
  setId(element, newId);
  instances[newId] = new Instance(element);
  return instances[newId];
};

exports.remove = function (element) {
  delete instances[getId(element)];
  removeId(element);
};

exports.get = function (element) {
  return instances[getId(element)];
};

},{"../lib/dom":5,"../lib/event-manager":6,"../lib/guid":7,"../lib/helper":8,"./default-setting":10}],21:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var cls = require('../lib/class')
  , d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateScroll = require('./update-scroll');

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = {width: i.railXWidth};
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + element.scrollTop;
  }
  d.css(i.scrollbarXRail, xRailOffset);

  var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  d.css(i.scrollbarYRail, yRailOffset);

  d.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
  d.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
}

module.exports = function (element) {
  var i = instances.get(element);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  var existingRails;
  if (!element.contains(i.scrollbarXRail)) {
    existingRails = d.queryChildren(element, '.ps-scrollbar-x-rail');
    if (existingRails.length > 0) {
      existingRails.forEach(function (rail) {
        d.remove(rail);
      });
    }
    d.appendTo(i.scrollbarXRail, element);
  }
  if (!element.contains(i.scrollbarYRail)) {
    existingRails = d.queryChildren(element, '.ps-scrollbar-y-rail');
    if (existingRails.length > 0) {
      existingRails.forEach(function (rail) {
        d.remove(rail);
      });
    }
    d.appendTo(i.scrollbarYRail, element);
  }

  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(i, h.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
    i.scrollbarXLeft = h.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
  } else {
    i.scrollbarXActive = false;
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }

  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(i, h.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
    i.scrollbarYTop = h.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
  } else {
    i.scrollbarYActive = false;
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    updateScroll(element, 'top', 0);
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  cls[i.scrollbarXActive ? 'add' : 'remove'](element, 'ps-active-x');
  cls[i.scrollbarYActive ? 'add' : 'remove'](element, 'ps-active-y');
};

},{"../lib/class":4,"../lib/dom":5,"../lib/helper":8,"./instances":20,"./update-scroll":22}],22:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var instances = require('./instances');

var upEvent = document.createEvent('Event')
  , downEvent = document.createEvent('Event')
  , leftEvent = document.createEvent('Event')
  , rightEvent = document.createEvent('Event')
  , yEvent = document.createEvent('Event')
  , xEvent = document.createEvent('Event')
  , xStartEvent = document.createEvent('Event')
  , xEndEvent = document.createEvent('Event')
  , yStartEvent = document.createEvent('Event')
  , yEndEvent = document.createEvent('Event')
  , lastTop
  , lastLeft;

upEvent.initEvent('ps-scroll-up', true, true);
downEvent.initEvent('ps-scroll-down', true, true);
leftEvent.initEvent('ps-scroll-left', true, true);
rightEvent.initEvent('ps-scroll-right', true, true);
yEvent.initEvent('ps-scroll-y', true, true);
xEvent.initEvent('ps-scroll-x', true, true);
xStartEvent.initEvent('ps-x-reach-start', true, true);
xEndEvent.initEvent('ps-x-reach-end', true, true);
yStartEvent.initEvent('ps-y-reach-start', true, true);
yEndEvent.initEvent('ps-y-reach-end', true, true);

module.exports = function (element, axis, value) {
  if (typeof element === 'undefined') {
    throw 'You must provide an element to the update-scroll function';
  }

  if (typeof axis === 'undefined') {
    throw 'You must provide an axis to the update-scroll function';
  }

  if (typeof value === 'undefined') {
    throw 'You must provide a value to the update-scroll function';
  }

  if (axis === 'top' && value <= 0) {
    element.scrollTop = 0;
    element.dispatchEvent(yStartEvent);
    return; // don't allow negative scroll
  }

  if (axis === 'left' && value <= 0) {
    element.scrollLeft = 0;
    element.dispatchEvent(xStartEvent);
    return; // don't allow negative scroll
  }

  var i = instances.get(element);

  if (axis === 'top' && value > i.contentHeight - i.containerHeight) {
    element.scrollTop = i.contentHeight - i.containerHeight;
    element.dispatchEvent(yEndEvent);
    return; // don't allow scroll past container
  }

  if (axis === 'left' && value > i.contentWidth - i.containerWidth) {
    element.scrollLeft = i.contentWidth - i.containerWidth;
    element.dispatchEvent(xEndEvent);
    return; // don't allow scroll past container
  }

  if (!lastTop) {
    lastTop = element.scrollTop;
  }

  if (!lastLeft) {
    lastLeft = element.scrollLeft;
  }

  if (axis === 'top' && value < lastTop) {
    element.dispatchEvent(upEvent);
  }

  if (axis === 'top' && value > lastTop) {
    element.dispatchEvent(downEvent);
  }

  if (axis === 'left' && value < lastLeft) {
    element.dispatchEvent(leftEvent);
  }

  if (axis === 'left' && value > lastLeft) {
    element.dispatchEvent(rightEvent);
  }

  if (axis === 'top') {
    element.scrollTop = lastTop = value;
    element.dispatchEvent(yEvent);
  }

  if (axis === 'left') {
    element.scrollLeft = lastLeft = value;
    element.dispatchEvent(xEvent);
  }

};

},{"./instances":20}],23:[function(require,module,exports){
/* Copyright (c) 2015 Hyunje Alex Jun and other contributors
 * Licensed under the MIT License
 */
'use strict';

var d = require('../lib/dom')
  , h = require('../lib/helper')
  , instances = require('./instances')
  , updateGeometry = require('./update-geometry');

module.exports = function (element) {
  var i = instances.get(element);

  if (!i) {
    return;
  }

  // Recalcuate negative scrollLeft adjustment
  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;

  // Recalculate rail margins
  d.css(i.scrollbarXRail, 'display', 'block');
  d.css(i.scrollbarYRail, 'display', 'block');
  i.railXMarginWidth = h.toInt(d.css(i.scrollbarXRail, 'marginLeft')) + h.toInt(d.css(i.scrollbarXRail, 'marginRight'));
  i.railYMarginHeight = h.toInt(d.css(i.scrollbarYRail, 'marginTop')) + h.toInt(d.css(i.scrollbarYRail, 'marginBottom'));

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  d.css(i.scrollbarXRail, 'display', 'none');
  d.css(i.scrollbarYRail, 'display', 'none');

  updateGeometry(element);

  d.css(i.scrollbarXRail, 'display', '');
  d.css(i.scrollbarYRail, 'display', '');
};

},{"../lib/dom":5,"../lib/helper":8,"./instances":20,"./update-geometry":21}],24:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],25:[function(require,module,exports){
var _ = cdb._;
var Model = cdb.core.Model;
var log = cdb.log;
var DashboardView = require('./dashboard-view');
var WidgetsCollection = require('./widgets/widgets-collection');
var WidgetModelFactory = require('./widgets/widget-model-factory');
var ListModel = require('./widgets/list/model');
var HistogramModel = require('./widgets/histogram/model');
var CategoryModel = require('./widgets/category/model');
var FormulaModel = require('./widgets/formula/model');
var RangeFilter = require('./windshaft/filters/range');
var CategoryFilter = require('./windshaft/filters/category');
var WindshaftConfig = require('./windshaft/config');
var WindshaftClient = require('./windshaft/client');
var WindshaftDashboard = require('./windshaft/dashboard');
var WindshaftPrivateDashboardConfig = require('./windshaft/private-dashboard-config');
var WindshaftPublicDashboardConfig = require('./windshaft/public-dashboard-config');

module.exports = function(selector, diJSON, visOpts) {
  var widgetModelFactory = new WidgetModelFactory({
    list: function(attrs, opts) {
      return new ListModel(attrs, opts);
    },
    formula: function(attrs, opts) {
      return new FormulaModel(attrs, opts);
    },
    histogram: function(attrs, opts, layerIndex) {
      opts.filter = new RangeFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      return new HistogramModel(attrs, opts);
    },
    'time-series': function(attrs, opts, layerIndex) {
      // change type because time-series because it's really a histogram (for the tiler at least)
      attrs.type = 'histogram';
      opts.filter = new RangeFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      var model = new HistogramModel(attrs, opts);

      // since we changed the type of we need some way to identify that it's intended for a time-series view later
      model.isForTimeSeries = true;

      return model;
    },
    aggregation: function(attrs, opts, layerIndex) {
      opts.filter = new CategoryFilter({
        widgetId: attrs.id,
        layerIndex: layerIndex
      });
      return new CategoryModel(attrs, opts);
    }
  });

  // TODO keep this collection in sync with layers individual widgets collections
  var widgets = new WidgetsCollection();

  var dashboardInfoModel = new Model({
    title: diJSON.title,
    description: diJSON.description,
    updatedAt: diJSON.updated_at,
    userName: diJSON.user.fullname,
    userAvatarURL: diJSON.user.avatar_url
  });
  var dashboardView = new DashboardView({
    el: document.querySelector(selector),
    widgets: widgets,
    dashboardInfoModel: dashboardInfoModel
  });

  var vis = cdb.createVis(dashboardView.$('#map'), diJSON.vizJSON, visOpts);

  var cartoDBLayerGroup;
  var interactiveLayers = [];
  vis.map.layers.each(function(layer) {
    var layerType = layer.get('type');
    var isLayerGroup = layerType === 'layergroup';

    if (isLayerGroup) {
      cartoDBLayerGroup = layer;
    }

    if (isLayerGroup || layerType === 'namedmap') {
      layer.layers.each(function(subLayer) {
        interactiveLayers.push(subLayer);
      });
    } else {
       if (layerType === 'torque') {
        interactiveLayers.push(layer);
       }
    }
  });

  // TODO: We can probably move this logic somewhere else
  var widgetModels = [];
  for (var id in diJSON.widgets) {
    var d = diJSON.widgets[id];
    var layer;

    // Find the Layer that the Widget should be created for.
    // a layerId has top-priority, otherwise it tries with a layerIndex, and even a subLayerIndex (if available)
    if (d.layerId) {
      layer = _.find(interactiveLayers, function(l) {
        return d.layerId === l.get('id');
      });
    } else if (Number.isInteger(d.layerIndex)) {
      layer = vis.map.layers.at(d.layerIndex);
      if (layer && Number.isInteger(d.subLayerIndex)) {
        layer = layer.layers.at(d.subLayerIndex);
      }
    }

    if (layer) {
      var layerIndex = interactiveLayers.indexOf(layer);
      var attrs = _.extend({
        id: id
      }, d);
      var widgetModel = widgetModelFactory.createModel(layer, layerIndex, attrs);
      widgetModels.push(widgetModel);
    } else {
      log.error('no layer found for widget ' + id + ':'  + JSON.stringify(d));
    }
  }
  widgets.reset(widgetModels);

  dashboardView.render();

  // TODO: Perhaps this "endpoint" could be part of the "datasource"?
  var endpoint = WindshaftConfig.MAPS_API_BASE_URL;
  var configGenerator = WindshaftPublicDashboardConfig;
  var datasource = diJSON.datasource;
  // TODO: We can use something else to differentiate types of "datasource"s
  if (datasource.template_name) {
    endpoint = [WindshaftConfig.MAPS_API_BASE_URL, 'named', datasource.template_name].join('/');
    configGenerator = WindshaftPrivateDashboardConfig;
  }

  var windshaftClient = new WindshaftClient({
    endpoint: endpoint,
    urlTemplate: datasource.maps_api_template,
    userName: datasource.user_name,
    statTag: datasource.stat_tag,
    forceCors: datasource.force_cors
  });

  var dashboard = new WindshaftDashboard({
    client: windshaftClient,
    configGenerator: configGenerator,
    statTag: datasource.stat_tag,
    //TODO: assuming here all viz.json has a layergroup and that may not be true
    layerGroup: cartoDBLayerGroup,
    layers: interactiveLayers,
    widgets: widgets,
    map: vis.map
  });

  // TODO: rethink this
  if (widgets.size() > 0) {
    setTimeout(function() {
      vis.mapView.invalidateSize();
    }, 0);
  }

  return dashboardView;
};

},{"./dashboard-view":31,"./widgets/category/model":45,"./widgets/formula/model":65,"./widgets/histogram/model":73,"./widgets/list/model":81,"./widgets/widget-model-factory":106,"./widgets/widgets-collection":112,"./windshaft/client":113,"./windshaft/config":114,"./windshaft/dashboard":116,"./windshaft/filters/category":119,"./windshaft/filters/range":121,"./windshaft/private-dashboard-config":122,"./windshaft/public-dashboard-config":123}],26:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var WidgetViewFactory = require('./widgets/widget-view-factory');
var TimeSeriesContentView = require('./widgets/time-series/content-view');
var TorqueTimeSeriesContentView = require('./widgets/time-series/torque-content-view');

module.exports = View.extend({

  className: 'CDB-Dashboard-belowMap',

  initialize: function(options) {
    this._widgetViewFactory = new WidgetViewFactory([
      {
        match: function(m) {
          // isForTimeSeries is set to true to distinguish from default type 'histogram'
          // This match needs to be done before the default time-series widget's match below to have presedence
          return m.isForTimeSeries && m.layer.get('type') === 'torque';
        },
        createContentView: function(m) {
          return new TorqueTimeSeriesContentView({
            model: m,
            rangeFilter: m.filter,
            torqueLayerModel: m.layer
          });
        },
        customizeWidgetAttrs: function(attrs) {
          attrs.className += ' CDB-Widget--timeSeries';
          return attrs;
        }
      }, {
        match: function(m) {
          // isForTimeSeries is set to true to distinguish from default type 'histogram'
          return m.isForTimeSeries;
        },
        createContentView: function(m) {
          return new TimeSeriesContentView({
            model: m,
            filter: m.filter
          });
        },
        customizeWidgetAttrs: function(attrs) {
          attrs.className += ' CDB-Widget--timeSeries';
          return attrs;
        }
      }
    ]);

    this._widgets = options.widgets;
    this._widgets.bind('add', this._maybeRenderWidgetView, this);
    this._widgets.bind('reset', this.render, this);
    this.add_related_model(this._widgets);
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    this._widgets.each(this._maybeRenderWidgetView, this);
    this.$el.toggle(!_.isEmpty(this._subviews));
    return this;
  },

  _maybeRenderWidgetView: function(widgetModel) {
    var view = this._widgetViewFactory.createWidgetView(widgetModel);
    if (view) {
      this.addView(view);
      this.$el.append(view.render().el);
    }
  }

});

},{"./widgets/time-series/content-view":90,"./widgets/time-series/torque-content-view":93,"./widgets/widget-view-factory":108}],27:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./dashboard-info-view.tpl');
var moment = require('moment');

var DashboardInfoView = View.extend({

  className: 'CDB-Dashboard-info',

  events: {
    'click .js-toggle-view-link': "_toggleView"
  },

  render: function() {
    this.$el.html(
      template({
        title: this.model.get('title'),
        description: this.model.get('description'),
        updatedAt: moment(this.model.get('updatedAt')).fromNow(),
        userName: this.model.get('userName'),
        userAvatarURL: this.model.get('userAvatarURL')
      })
    );

    return this;
  },

  _toggleView: function() {
    this.$el.toggleClass('is-active');
  }
});

module.exports = DashboardInfoView;

},{"./dashboard-info-view.tpl":28,"moment":2}],28:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Dashboard-infoHeader"> <div class="CDB-Dashboard-infoLogo"> <i class="CDB-Icon CDB-Icon-cartofante"></i> </div> <div class="CDB-Dashboard-infoActions"> <button class="CDB-Dashboard-infoActionsLink js-toggle-view-link"></button> </div> <div class="CDB-Dashboard-infoTexts"> <p class="CDB-Dashboard-infoUpdate">UPDATED '+
((__t=( updatedAt ))==null?'':_.escape(__t))+
'</p> <h1 class="CDB-Dashboard-infoTitle">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h1> <h2 class="CDB-Dashboard-infoDescription">'+
((__t=( description ))==null?'':_.escape(__t))+
'</h2> </div> </div> <div class="CDB-Dashboard-infoFooter"> <ul>  <li class="CDB-Dashboard-infoFooterItem"> <div class="CDB-Dashboard-infoMedia CDB-Dashboard-infoAvatar"> <img src="'+
((__t=( userAvatarURL ))==null?'':_.escape(__t))+
'" alt="avatar" class="inline-block"> </div> <p class="CDB-Dashboard-infoFooterTxt">'+
((__t=( userName ))==null?'':_.escape(__t))+
'</p> </li> </ul> </div>';
}
return __p;
};

},{"underscore":24}],29:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var Ps = require('perfect-scrollbar');
var View = cdb.core.View;
var Model = cdb.core.Model;
var CategoryContentView = require('./widgets/category/content_view');
var FormulaContentView = require('./widgets/formula/content_view');
var HistogramContentView = require('./widgets/histogram/content-view');
var ListContentView = require('./widgets/list/content_view');
var WidgetViewFactory = require('./widgets/widget-view-factory');
var template = require('./dashboard-sidebar.tpl');

module.exports = View.extend({

  className: 'CDB-Widget-canvas',

  initialize: function(options) {
    this._widgetViewFactory = new WidgetViewFactory([
      {
        type: 'formula',
        createContentView: function(m) {
          return new FormulaContentView({
            model: m
          });
        }
      }, {
        type: 'list',
        createContentView: function(m) {
          return new ListContentView({
            model: m
          });
        }
      }, {
        match: function(m) {
          return m.get('type') === 'histogram' && m.layer.get('type') !== 'torque';
        },
        createContentView: function(m) {
          return new HistogramContentView({
            dataModel: m,
            viewModel: new Model(),
            filter: m.filter
          });
        }
      }, {
        type: 'aggregation',
        createContentView: function(m) {
          return new CategoryContentView({
            model: m,
            filter: m.filter
          });
        }
      }
    ]);

    this._widgets = options.widgets;

    this._widgets.bind('add', this._maybeRenderWidgetView, this);
    this._widgets.bind('reset', this.render, this);
    this._widgets.bind('change:collapsed', this._onWidgetCollapsed, this);
    this.add_related_model(this._widgets);
  },

  render: function() {
    this._cleanScrollEvent();
    this.clearSubViews();

    this.$el.html(template());
    this._widgets.each(this._maybeRenderWidgetView, this);
    this.$el.toggle(!_.isEmpty(this._subviews));

    this._renderScroll();
    this._renderShadows();
    this._bindScroll();

    return this;
  },

  _$container: function() {
    return $(this._container());
  },

  _container: function() {
    return this.el.querySelector('.js-container');
  },

  _maybeRenderWidgetView: function(widgetModel) {
    var view = this._widgetViewFactory.createWidgetView(widgetModel);
    if (view) {
      this.addView(view);
      this._$container().append(view.render().el);
    }
  },

  _bindScroll: function() {
    this._$container()
      .on('ps-y-reach-start', _.bind(this._onScrollTop, this))
      .on('ps-y-reach-end', _.bind(this._onScrollBottom, this))
      .on('ps-scroll-y', _.bind(this._onScroll, this));
  },

  _renderScroll: function() {
    Ps.initialize(this._container(), {
      wheelSpeed: 2,
      wheelPropagation: true,
      minScrollbarLength: 20
    });
  },

  _onWidgetCollapsed: function() {
    Ps.update(this._container());
  },

  _renderShadows: function() {
    var self = this;
    this.$shadowTop = $('<div>').addClass("CDB-Widget-canvasShadow CDB-Widget-canvasShadow--top");
    this.$shadowBottom = $('<div>').addClass("CDB-Widget-canvasShadow CDB-Widget-canvasShadow--bottom is-visible");
    this.$el.append(this.$shadowTop);
    this.$el.append(this.$shadowBottom);
  },

  _onScrollTop: function() {
    this.$shadowTop.removeClass('is-visible');
  },

  _onScroll: function() {
    var $el = this._$container();
    var currentPos = $el.scrollTop();
    var max = $el.get(0).scrollHeight;
    var height = $el.outerHeight();
    var maxPos = max - height;
    this.$shadowTop.toggleClass('is-visible', currentPos > 0);
    this.$shadowBottom.toggleClass('is-visible', currentPos < maxPos);
  },

  _onScrollBottom: function() {
    this.$shadowBottom.removeClass('is-visible');
  },

  _cleanScrollEvent: function() {
    if (this._$container()) {
      this._$container().off('ps-scroll-y');
    }
  },

  clean: function() {
    this._cleanScrollEvent();
    View.prototype.clean.call(this);
  }

});

},{"./dashboard-sidebar.tpl":30,"./widgets/category/content_view":35,"./widgets/formula/content_view":64,"./widgets/histogram/content-view":69,"./widgets/list/content_view":76,"./widgets/widget-view-factory":108,"perfect-scrollbar":3}],30:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-canvasInner js-container"></div>';
}
return __p;
};

},{"underscore":24}],31:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./dashboard.tpl');
var DashboardBelowMapView = require('./dashboard-below-map-view');
var DashboardInfoView = require('./dashboard-info-view');
var DashboardSidebarView = require('./dashboard-sidebar-view');

/**
 * Dashboard is a wrapper around the map canvas, which contains widget views for the map contdxt
 * Widgets may be rendered in two areas, in the "sidebar" or "below-map".
 */
module.exports = View.extend({

  className: 'CDB-Dashboard-canvas',

  initialize: function(options) {
    this._widgets = options.widgets;
    this._dashboardInfoModel = options.dashboardInfoModel;

    // TODO parent context requires some markup to be present already, but NOT the other views
    this.el.classList.add(this.className);
    this.$el.html(template());
  },

  render: function() {
    this.clearSubViews();

    var view;
    view = new DashboardInfoView({
      model: this._dashboardInfoModel
    });
    this.addView(view);
    this.$el.append(view.render().el);

    view = new DashboardBelowMapView({
      widgets: this._widgets
    });
    this.addView(view);
    this.$('.js-map-wrapper').append(view.render().el);

    view = new DashboardSidebarView({
      widgets: this._widgets
    });
    this.addView(view);
    this.$el.append(view.render().el);

    return this;
  }
});

},{"./dashboard-below-map-view":26,"./dashboard-info-view":27,"./dashboard-sidebar-view":29,"./dashboard.tpl":32}],32:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Dashboard-mapWrapper CDB-Dashboard-mapWrapper--margin js-map-wrapper"> <div class="CDB-Map-canvas"> <div class="CDB-Map" id="map"></div> </div> </div>';
}
return __p;
};

},{"underscore":24}],33:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var d3 = cdb.d3;
var log = cdb.log;
var View = cdb.core.View;

/**
 * Animate between two values
 */
module.exports = View.extend({

  animateFromValues: function(from, to, className, template, opts) {
    var $el = this.$(className);
    var options = opts || {};
    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};
    var debounceWait = options.debounceWait || 500;

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  },

  animateFromCurrentValue: function(value, className, template, opts) {
    var $el = this.$(className);

    var options = opts || {};
    var debounceWait = options.debounceWait || 500;

    var to   = value;
    var from = +this.$(className).text();

    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  },

  animateValue: function(model, what, className, template, opts) {
    var $el = this.$(className);

    var options = opts || {};
    var debounceWait = options.debounceWait || 500;

    var to   = model.get(what);
    var from = model.previous(what) || 0;

    var formatter = options.formatter || d3.format('0,000');
    var templateData = options.templateData || {};

    var stepValue = function (i) {
      value = (_.isNaN(i) || i === undefined) ? (options.defaultValue || 0) : formatter(i);
      var data = _.extend({ value: value }, templateData);
      $el.text(template(data));
    };

    if (options.animationSpeed === 0) {
      stepValue(to);
      return;
    }

    stepValue(from);

    var animate = _.debounce(function() {
      $el.prop('counter', from).stop().animate({ counter: to }, {
        duration: options.animationSpeed || 500,
        easing: options.easingMethod || 'swing',
        step: stepValue
      });
    }, debounceWait);

    animate();
  }
});

},{}],34:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header js-header"></div> <div class="CDB-Widget-content CDB-Widget-content--noSidesMargin"> <div class="CDB-Widget-listWrapper js-content"></div> </div> <div class="CDB-Widget-footer js-footer"></div>';
}
return __p;
};

},{"underscore":24}],35:[function(require,module,exports){
var _ = cdb._;
var WidgetContent = require('../standard/widget_content_view');
var SearchTitleView = require('./title/search_title_view');
var CategoryOptionsView = require('./options/options_view');
var CategoryItemsView = require('./list/items_view');
var WidgetViewModel = require('../widget_content_model');
var CategoryStatsView = require('./stats/stats_view');
var CategoryPaginatorView = require('./paginator/paginator_view');
var SearchCategoryItemsView = require('./list/search_items_view');
var SearchCategoryPaginatorView = require('./paginator/search_paginator_view');
var template = require('./content_template.tpl');

/**
 * Content view for category widget
 *
 */

module.exports = WidgetContent.extend({

  _ITEMS_PER_PAGE: 6,

  initialize: function(opts) {
    this.viewModel = new WidgetViewModel();
    WidgetContent.prototype.initialize.call(this, arguments);
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(template());
    this._initViews();
    return this;
  },

  _initBinds: function() {
    this.model.bind('change:collapsed', function(mdl, isCollapsed) {
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
    }, this);
  },

  _initViews: function() {
    var searchTitle = new SearchTitleView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-header').append(searchTitle.render().el);
    this.addView(searchTitle);

    var stats = new CategoryStatsView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-header').append(stats.render().el);
    this.addView(stats);

    var options = new CategoryOptionsView({
      dataModel: this.model,
      viewModel: this.viewModel
    });
    this.$('.js-content').html(options.render().el);
    this.addView(options);

    var dataList = new CategoryItemsView({
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE
    });
    this.$('.js-content').append(dataList.render().el);
    this.addView(dataList);

    var pagination = new CategoryPaginatorView({
      $target: dataList.$el,
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE
    });
    this.$('.js-footer').append(pagination.render().el);
    this.addView(pagination);

    var searchList = new SearchCategoryItemsView({
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE,
      paginator: true
    });
    this.$('.js-content').append(searchList.render().el);
    this.addView(searchList);

    var searchPagination = new SearchCategoryPaginatorView({
      $target: searchList.$el,
      viewModel: this.viewModel,
      dataModel: this.model,
      itemsPerPage: this._ITEMS_PER_PAGE,
      paginator: true
    });
    this.$('.js-footer').append(searchPagination.render().el);
    this.addView(searchPagination);
  }

});

},{"../standard/widget_content_view":85,"../widget_content_model":110,"./content_template.tpl":34,"./list/items_view":42,"./list/search_items_view":44,"./options/options_view":53,"./paginator/paginator_view":55,"./paginator/search_paginator_view":57,"./stats/stats_view":60,"./title/search_title_view":62}],36:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button type="button" class="CDB-Widget-listItemInner CDB-Widget-listButton js-button '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( formattedValue ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState '+
((__t=( isAggregated ? 'CDB-Widget-progressState--pattern' : '' ))==null?'':_.escape(__t))+
'" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%; background-color: '+
((__t=( customColor ? color : '' ))==null?'':_.escape(__t))+
'"></div> </div> </button>';
}
return __p;
};

},{"underscore":24}],37:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-listItemInner '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( formattedValue ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState CDB-Widget-progressState--pattern '+
((__t=( isAggregated ? 'CDB-Widget-progressState--inactive' : '' ))==null?'':_.escape(__t))+
'" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%; background-color: '+
((__t=( customColor ? color : '' ))==null?'':_.escape(__t))+
'"></div> </div> </div>';
}
return __p;
};

},{"underscore":24}],38:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var formatter = cdb.core.format;
var clickableTemplate = require('./item_clickable_template.tpl');
var unclickableTemplate = require('./item_unclickable_template.tpl');

/**
 * Category list item view
 */
module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function(options) {
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    var value = this.model.get('value');
    var template = this.model.get('agg') || this.dataModel.isLocked() ?
      unclickableTemplate : clickableTemplate;

    this.$el.html(
      template({
        customColor: this.dataModel.isColorApplied(),
        isAggregated: this.model.get('agg'),
        name: this.model.get('name'),
        value: value,
        formattedValue: formatter.formatNumber(value),
        percentage: ((value / this.dataModel.get('max')) * 100),
        color: this.model.get('color'),
        isDisabled: !this.model.get('selected') ? 'is-disabled' : '',
        prefix: this.dataModel.get('prefix'),
        suffix: this.dataModel.get('suffix')
      })
    );

    return this;
  },

  _initBinds: function() {
    this.model.bind('change', this.render, this);
    this.dataModel.bind('change:search change:categoryColors', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _onItemClick: function() {
    this.trigger('itemClicked', this.model, this);
  }

});

},{"./item_clickable_template.tpl":36,"./item_unclickable_template.tpl":37}],39:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button type="button" class="CDB-Widget-listItemInner CDB-Widget-listItemInner--fullSpace CDB-Widget-listButton js-button '+
((__t=( isDisabled ? 'is-disabled' : '' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Widget-checkbox '+
((__t=( isDisabled ? '' : 'is-checked' ))==null?'':_.escape(__t))+
'"></span> <div class="u-lSpace--xl"> <div class="CDB-Widget-contentSpaced"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--bold CDB-Widget-textSmall--upper" title="'+
((__t=( name ))==null?'':_.escape(__t))+
'">'+
((__t=( name ))==null?'':_.escape(__t))+
'</p> <p class="CDB-Widget-textSmaller" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'">'+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'</p> </div> <div class="CDB-Widget-progressBar"> <div class="CDB-Widget-progressState" style="width: '+
((__t=( percentage ))==null?'':_.escape(__t))+
'%"></div> </div> </div> </button>';
}
return __p;
};

},{"underscore":24}],40:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var formatter = cdb.core.format;
var template = require('./search_item_clickable_template.tpl');

/**
 * Category search list view
 */
module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function(options) {
    // This data model comes from the original data in order to get
    // the max value and set properly the progress bar and add the
    // necessary suffix and prefix for the item.
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    var value = this.model.get('value');

    this.$el.html(
      template({
        name: this.model.get('name'),
        value: value,
        formattedValue: formatter.formatNumber(value),
        percentage: ((value / this.dataModel.get('max')) * 100),
        isDisabled: !this.model.get('selected'),
        prefix: this.dataModel.get('prefix'),
        suffix: this.dataModel.get('suffix')
      })
    );

    return this;
  },

  _initBinds: function() {
    this.model.bind('change:selected', this.render, this);
  },

  _onItemClick: function() {
    this.model.set('selected', !this.model.get('selected'));
  }

});

},{"./search_item_clickable_template.tpl":39}],41:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li>';
}
return __p;
};

},{"underscore":24}],42:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var CategoryItemView = require('./item/item_view');
var placeholder = require('./items_placeholder_template.tpl');

/**
 * Category list view
 */
module.exports = View.extend({

  options: {
    paginator: false,
    itemsPerPage: 6
  },

  className: 'CDB-Widget-list CDB-Widget-list--wrapped js-list',
  tagName: 'ul',

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var data = this.dataModel.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;

    if (isDataEmpty) {
      this._renderPlaceholder();
    } else {
      this._renderList();
    }
    return this;
  },

  _initBinds: function() {
    this.viewModel.bind('change:search', this.toggle, this);
    this.dataModel.bind('change:data change:searchData', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _renderPlaceholder: function() {
    // Change view classes
    this.$el
      .addClass('CDB-Widget-list--withBorders')
      .removeClass('CDB-Widget-list--wrapped');
    this.$el.append(placeholder());
  },

  _renderList: function() {
    // Change view classes
    this.$el.removeClass('CDB-Widget-list--withBorders');
    this.$el[ this.options.paginator ? 'addClass' : 'removeClass']('CDB-Widget-list--wrapped');

    var groupItem;
    var data = this.dataModel.getData();

    data.each(function(mdl, i) {
      if (i % this.options.itemsPerPage === 0) {
        groupItem = $('<div>').addClass('CDB-Widget-listGroup');
        this.$el.append(groupItem);
      }
      this._addItem(mdl, groupItem);
    }, this);
  },

  _addItem: function(mdl, $parent) {
    var v = new CategoryItemView({
      model: mdl,
      dataModel: this.dataModel
    });
    v.bind('itemClicked', this._setFilters, this);
    this.addView(v);
    $parent.append(v.render().el);
  },

  _setFilters: function(mdl) {
    var isSelected = mdl.get('selected');

    if (isSelected) {
      if (!this.dataModel.getRejectedCount() && !this.dataModel.getAcceptedCount() && this.dataModel.getCount() > 1) {
        var data = this.dataModel.getData();
        var rejects = [];
        // Make elements "unselected"
        data.map(function(m) {
          var name = m.get('name');
          if (name !== mdl.get('name')) {
            m.set('selected', false);
          }
        });
        this.dataModel.acceptFilters(mdl.get('name'));
      } else {
        mdl.set('selected', false);
        this.dataModel.rejectFilters(mdl.get('name'));
      }
    } else {
      mdl.set('selected', true);
      this.dataModel.acceptFilters(mdl.get('name'));
    }
  },

  toggle: function() {
    this[ !this.viewModel.isSearchEnabled() ? 'show' : 'hide']();
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  }

});

},{"./item/item_view":38,"./items_placeholder_template.tpl":41}],43:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<li class="CDB-Widget-listItem"> <h4 class="CDB-Widget-textBig CDB-Widget-textBig--bold">No results</h4> <p class="CDB-Widget-textSmall u-tSpace-xl">Your search "'+
((__t=( q ))==null?'':_.escape(__t))+
'" didn\'t match<br>with any value.</p> <p class="CDB-Widget-textSmall u-tSpace-xl">Try searching again.</p> </li>';
}
return __p;
};

},{"underscore":24}],44:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var CategoryItemsView = require('./items_view');
var WidgetSearchCategoryItemView = require('./item/search_item_view');
var placeholder = require('./search_items_no_results_template.tpl');

/**
 * Category list view
 */
module.exports = CategoryItemsView.extend({

  className: 'CDB-Widget-list is-hidden CDB-Widget-list--wrapped js-list',

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var data = this.dataModel.getSearchResult();
    var isDataEmpty = data.isEmpty() || data.size() === 0;

    if (isDataEmpty) {
      this._renderPlaceholder();
    } else {
      this._renderList();
    }
    return this;
  },

  _renderList: function() {
    this.$el.removeClass('CDB-Widget-list--withBorders CDB-Widget-list--noresults');
    this.$el.addClass('CDB-Widget-list--wrapped');

    var groupItem;
    var data = this.dataModel.getSearchResult();

    data.each(function(mdl, i) {
      if (i % this.options.itemsPerPage === 0) {
        groupItem = $('<div>').addClass('CDB-Widget-listGroup');
        this.$el.append(groupItem);
      }
      this._addItem(mdl, groupItem);
    }, this);
  },

  _renderPlaceholder: function() {
    // Change view classes
    this.$el
      .addClass('CDB-Widget-list--noresults')
      .removeClass('CDB-Widget-list--wrapped');

    this.$el.html(
      placeholder({
        q: this.dataModel.getSearchQuery()
      })
    );
  },

  _addItem: function(mdl, $parent) {
    var v = new WidgetSearchCategoryItemView({
      model: mdl,
      dataModel: this.dataModel
    });
    this.addView(v);
    $parent.append(v.render().el);
  },

  toggle: function() {
    this[ this.viewModel.isSearchEnabled() ? 'show' : 'hide']();
  }

});

},{"./item/search_item_view":40,"./items_view":42,"./search_items_no_results_template.tpl":43}],45:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;
var d3 = cdb.d3;
var CategoryColors = require('./models/category_colors');
var WidgetModel = require('../widget_model');
var WidgetSearchModel = require('./models/search_model');
var CategoryModelRange = require('./models/category_model_range');
var CategoriesCollection = require('./models/categories_collection');
var LockedCatsCollection = require('./models/locked_categories_collection');

/**
 *  Category widget model
 *
 *  - It has several internal models/collections
 *
 *  · search model: it manages category search results.
 *  · locked collection: it stores locked items.
 *  · filter model: it knows which items are accepted or rejected.
 *
 */

module.exports = WidgetModel.extend({

  url: function() {
    return this.get('url') + '?bbox=' + this.get('boundingBox') + '&own_filter=' + (this.get('locked') ? 1 : 0);
  },

  initialize: function(attrs, opts) {
    this._data = new CategoriesCollection();

    WidgetModel.prototype.initialize.call(this, attrs, opts);

    // Locked categories collection
    this.locked = new LockedCatsCollection();

    // Internal model for calculating total amount of values in the category
    this.rangeModel = new CategoryModelRange();

    // Colors class
    this.colors = new CategoryColors();

    // Search model
    this.search = new WidgetSearchModel({}, {
      locked: this.locked
    });
  },

  // Set any needed parameter when they have changed in this model
  _setInternalModels: function() {
    var url = this.get('url');

    this.search.set({
      url: url,
      boundingBox: this.get('boundingBox')
    });

    this.rangeModel.setUrl(url);
  },

  _onChangeBinds: function() {
    this._setInternalModels();

    this.rangeModel.bind('change:totalCount', function(mdl, value) {
      this.set('totalCount', value);
    }, this);

    this.bind('change:url', function(){
      if (this.get('sync') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:boundingBox', function() {
      // If a search is applied and bounding bounds has changed,
      // don't fetch new raw data
      if (this.get('bbox') && !this.isSearchApplied() && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:url change:boundingBox', function() {
      this.search.set({
        url: this.get('url'),
        boundingBox: this.get('boundingBox')
      });
    }, this);

    this.bind('change:collapsed', function(mdl, isCollapsed) {
      if (!isCollapsed) {
        if (mdl.changedAttributes(this._previousAttrs)) {
          this._fetch();
        }
      } else {
        this._previousAttrs = {
          url: this.get('url'),
          boundingBox: this.get('boundingBox')
        };
      }
    }, this);

    this.locked.bind('change add remove', function() {
      this.trigger('change:lockCollection', this.locked, this);
    }, this);

    this.search.bind('loading', function() {
      this.trigger("loading", this);
    }, this);
    this.search.bind('sync', function() {
      this.trigger("sync", this);
    }, this);
    this.search.bind('error', function(e) {
      if (!e || (e && e.statusText !== "abort")) {
        this.trigger("error", this);
      }
    }, this);
    this.search.bind('change:data', function() {
      this.trigger('change:searchData', this.search, this);
    }, this);
  },

  /*
   *  Helper methods for internal models/collections
   *
   */

  applyCategoryColors: function() {
    this.set('categoryColors', true);
    var colorsData = this._data.map(function(m){
      return [ m.get('name'), m.get('color') ];
    });
    this.trigger('applyCategoryColors', colorsData, this);
  },

  cancelCategoryColors: function() {
    this.set('categoryColors', false);
    this.trigger('cancelCategoryColors', this);
  },

  isColorApplied: function() {
    return this.get('categoryColors');
  },

  // Locked collection helper methods //

  getLockedSize: function() {
    return this.locked.size();
  },

  isLocked: function() {
    return this.get('locked');
  },

  canBeLocked: function() {
    return this.isLocked() ||
      this.getAcceptedCount() > 0;
  },

  canApplyLocked: function() {
    var acceptedCollection = this.filter.getAccepted();
    if (this.filter.getAccepted().size() !== this.locked.size()) {
      return true;
    }

    return acceptedCollection.find(function(m) {
      return !this.locked.isItemLocked(m.get('name'));
    }, this);
  },

  applyLocked: function() {
    var currentLocked = this.locked.getItemsName();
    if (!currentLocked.length) {
      this.unlockCategories();
      return false;
    }
    this.set('locked', true);
    this.filter.cleanFilter(false);
    this.filter.accept(currentLocked);
    this.filter.applyFilter();
    this.cleanSearch();
  },

  lockCategories: function() {
    this.set('locked', true);
    this._fetch();
  },

  unlockCategories: function() {
    this.set('locked', false);
    this.acceptAll();
  },

  // Search model helper methods //

  getSearchQuery: function() {
    return this.search.getSearchQuery();
  },

  setSearchQuery: function(q) {
    this.search.set('q', q);
  },

  isSearchValid: function() {
    return this.search.isValid();
  },

  getSearchResult: function() {
    return this.search.getData();
  },

  getSearchCount: function() {
    return this.search.getCount();
  },

  applySearch: function() {
    this.search.fetch();
  },

  isSearchApplied: function() {
    return this.search.isSearchApplied();
  },

  cleanSearch: function() {
    this.locked.resetItems([]);
    this.search.resetData();
  },

  setupSearch: function() {
    if (!this.isSearchApplied()) {
      var acceptedCats = this.filter.getAccepted().toJSON();
      this.locked.addItems(acceptedCats);
      this.search.setData(
        this._data.toJSON()
      );
    }
  },

  // Filter model helper methods //

  getRejectedCount: function() {
    return this.filter.rejectedCategories.size();
  },

  getAcceptedCount: function() {
    return this.filter.acceptedCategories.size();
  },

  acceptFilters: function(values) {
    this.filter.accept(values);
  },

  rejectFilters: function(values) {
    this.filter.reject(values);
  },

  rejectAll: function() {
    this.filter.rejectAll();
  },

  acceptAll: function() {
    this.filter.acceptAll();
  },

  isAllFiltersRejected: function() {
    return this.filter.get('rejectAll');
  },

  // Proper model helper methods //

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  getCount: function() {
    return this.get('categoriesCount');
  },

  refresh: function() {
    if (this.isSearchApplied()) {
      this.search.fetch();
    } else {
      this._fetch();
    }
  },

  // Data parser methods //

  _parseData: function(categories) {
    var newData = [];
    var _tmpArray = {};
    var acceptedCats = this.filter.getAccepted();

    // Update colors by data categories
    this.colors.updateData(
      _.uniq(
        _.union(
          _.pluck(categories, 'category'),
          _.pluck(acceptedCats, 'name')
        )
      )
    );

    _.each(categories, function(datum, i) {
      var category = datum.category;
      var isRejected = this.filter.isRejected(category);
      _tmpArray[category] = true;

      newData.push({
        selected: !isRejected,
        name: category,
        agg: datum.agg,
        value: datum.value,
        color: this.colors.getColorByCategory(category)
      });
    }, this);

    if (this.isLocked()) {
      // Add accepted items that are not present in the categories data
      acceptedCats.each(function(mdl, i) {
        var category = mdl.get('name').toString();
        if (!_tmpArray[category]) {
          newData.push({
            selected: true,
            color: this.colors.getColorByCategory(category),
            name: category,
            agg: false,
            value: 0
          });
        }
      }, this);
    }

    return {
      data: newData
    }
  },

  setCategories: function(d) {
    var attrs = this._parseData(d);
    this._data.reset(attrs.data);
    this.set(attrs);
    if (this.isColorApplied()) {
      this.applyCategoryColors();
    }
  },

  parse: function(d) {
    var categories = d.categories;
    var attrs = this._parseData(categories);

    _.extend(attrs, {
        nulls: d.nulls,
        min: d.min,
        max: d.max,
        count: d.count,
        categoriesCount: d.categoriesCount
      }
    );
    this._data.reset(attrs.data);
    if (this.isColorApplied()) {
      this.applyCategoryColors();
    }
    return attrs;
  },

  // Backbone toJson function override

  toJSON: function() {
    return {
      type: "aggregation",
      options: {
        column: this.get('column'),
        aggregation: this.get('aggregation'),
        aggregationColumn: this.get('aggregationColumn')
      }
    };
  }

});

},{"../widget_model":111,"./models/categories_collection":46,"./models/category_colors":47,"./models/category_model_range":49,"./models/locked_categories_collection":50,"./models/search_model":51}],46:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var CategoryItemModel = require('./category_item_model');

/**
 *  Data categories collection
 *
 *  - It basically sorts by (value, selected and "Other").
 */

module.exports = Backbone.Collection.extend({

  model: CategoryItemModel,

  comparator: function(a,b) {
    if (a.get('name') === 'Other') {
      return 1;
    } else if (b.get('name') === 'Other') {
      return -1;
    } else if (a.get('value') === b.get('value')) {
      return (a.get('selected') < b.get('selected')) ? 1 : -1;
    } else {
      return (a.get('value') < b.get('value')) ? 1 : -1;
    }
  }

});

},{"./category_item_model":48}],47:[function(require,module,exports){
var _ = cdb._;
// var colorbrewer = require('colorbrewer');
// var categoryColors = _.initial(colorbrewer.Accent[8]); // Color brewer colors
var categoryColors = ['#2CA095','#E5811B','#4A4DBA','#AD2BAD','#559030','#E1C221']; // Demo colors
var defaultColor = '#CCC';

/**
 *  Class to set categories to each color
 *  - Right now, there is a relation 1 color to 1 category.
 *  - If that category is not available in the new data, that
 *    color will be freed.
 *
 */

function CategoryColors() {
  this.colors = {};
  _.each(categoryColors, function(c) {
    this.colors[c] = null;
  }, this);
}

CategoryColors.prototype.updateData = function(d) {
  // Remove categories from colors where they are not present anymore
  _.each(this.colors, function(value, key) {
    if (!_.contains(d, value)) {
      this.colors[key] = null;
    } else {
      d = _.without(d, value);
    }
  }, this);

  // Set colors by new categories
  _.each(d, function(category) {
    var nextFreeColor = this.getNextAvailableColor();
    if (nextFreeColor) {
      this.colors[nextFreeColor] = category;
    }
  }, this);
};

CategoryColors.prototype.getNextAvailableColor = function() {
  for (var i in this.colors) {
    if (this.colors[i] === null) {
      return i;
    }
  }
  return null;
};

CategoryColors.prototype.getColorByCategory = function (category) {
  for (var i in this.colors) {
    if (this.colors[i] === category) {
      return i;
    }
  }
  return defaultColor;
};

CategoryColors.prototype.getCategoryByColor = function (color) {
  return this.colors[color];
};

module.exports = CategoryColors;

},{}],48:[function(require,module,exports){

var Model = cdb.core.Model;

/**
 *
 */

module.exports = Model.extend({

  defaults: {
    name: '',
    agg: false,
    value: 0
  }

});

},{}],49:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;

/**
 *  This model is used for getting the total amount of values
 *  from the category.
 *
 */

module.exports = Model.extend({

  defaults: {
    url: '',
    totalCount: 0
  },

  url: function() {
    return this.get('url');
  },

  initialize: function() {
    this.bind('change:url', function() {
      this.fetch();
    }, this);
  },

  setUrl: function(url) {
    this.set('url', url);
  },

  parse: function(d) {
    // Calculating the total amount of all categories with the sum of all
    // values from this model included the aggregated (Other)

    return {
      totalCount: _.reduce(
        _.pluck(d.categories, 'value'),
        function(memo, value) {
          return memo + value;
        },
        0
      )
    };
  }
});

},{}],50:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var CategoryItemModel = require('./category_item_model');

/**
 *  Locked categories collection
 *
 */

module.exports = Backbone.Collection.extend({

  model: CategoryItemModel,

  addItem: function(mdl) {
    if (!this.isItemLocked(mdl.get('name'))) {
      this.add(mdl);
    }
  },

  addItems: function(mdls) {
    _.each(mdls, function(m) {
      if (!this.isItemLocked(m.name)) {
        this.add(m);
      }
    }, this);
  },

  resetItems: function(mdls) {
    this.reset(mdls);
  },

  removeItem: function(mdl) {
    var lockedItem = this.isItemLocked(mdl.get('name'));
    if (lockedItem) {
      this.remove(lockedItem);
    }
  },

  removeItems: function() {
    this.reset([]);
  },

  isItemLocked: function(name) {
    return this.find(function(d) {
      return d.get('name') === name;
    });
  },

  getItemsName: function() {
    return this.pluck('name');
  }

});

},{"./category_item_model":48}],51:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var Model = cdb.core.Model;
var CategoriesCollection = require('./categories_collection');

/**
 * Category search model
 */
module.exports = Model.extend({

  defaults: {
    q: '',
    data: [],
    url: ''
  },

  url: function() {
    return this.get('url') + '/search?q=' + encodeURIComponent(this.get('q'));
  },

  initialize: function(attrs, opts) {
    // Locked collection will have the status
    // of the selected/locked items
    this.locked = opts.locked;
    this._data = new CategoriesCollection();
    this._initBinds();
  },

  _initBinds: function() {
    this._data.bind('change:selected', this._onChangeSelected, this);
    this.bind('change:boundingBox', function() {
      if (this.isSearchApplied()) {
        this.fetch();
      }
    }, this);
  },

  setData: function(data) {
    var categories = this._parseData(data);
    this._data.reset(categories);
    this.set('data', categories);
  },

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  getCount: function() {
    return this.getSize();
  },

  isValid: function() {
    var str = this.get('q');
    return !!(str||'');
  },

  isLocked: function() {},

  resetData: function() {
    this.setData([]);
    this.set('q', '');
  },

  getSearchQuery: function() {
    return this.get('q');
  },

  isSearchApplied: function() {
    return this.isValid() && this.getSize() > 0;
  },

  _onChangeSelected: function(mdl, isSelected) {
    this.locked[ isSelected ? 'addItem' : 'removeItem' ](mdl);
  },

  _parseData: function(categories) {
    var newData = [];
    _.each(categories, function(d) {
      if (!d.agg) {
        var category = (d.category || d.name).toString();
        var isLocked = this.locked.isItemLocked(category);
        newData.push({
          selected: isLocked,
          name: category,
          agg: d.agg,
          value: d.value
        });
      }
    }, this);

    return newData;
  },

  parse: function(r) {
    var categories = this._parseData(r.categories);
    this._data.reset(categories);
    return {
      data: categories
    };
  },

  fetch: function(opts) {
    this.trigger("loading", this);
    return Model.prototype.fetch.call(this, opts);
  },

  sync: function() {
    var self = arguments[1];
    if (this._xhr) {
      this._xhr.abort();
    }
    this._xhr = Model.prototype.sync.apply(this, arguments);
    this._xhr.always(function() {
      self._xhr = null;
    });
    return this._xhr;
  }

});

},{"./categories_collection":46}],52:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) {
__p+=' <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark CDB-Widget-textSmaller--upper">'+
((__t=( totalLocked ))==null?'':_.escape(__t))+
' selected</p> ';
 } else {
__p+=' <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark CDB-Widget-textSmaller--upper"> ';
 if (isLocked) {
__p+=' '+
((__t=( totalCats ))==null?'':_.escape(__t))+
' blocked <button class="CDB-Widget-link u-lSpace js-unlock">unlock</button> ';
 } else {
__p+=' '+
((__t=( rejectedCats === 0 && acceptedCats === 0 || acceptedCats >= totalCats ? "All selected" : acceptedCats + " selected" ))==null?'':_.escape(__t))+
' ';
 if (canBeLocked) {
__p+=' <button class="CDB-Widget-link u-lSpace js-lock">lock</button> ';
 }
__p+=' ';
 }
__p+=' </p> ';
 if (!isLocked) {
__p+=' <div class="CDB-Widget-filterButtons"> ';
 if (rejectedCats > 0 || acceptedCats > 0 || isAllRejected) {
__p+=' <button class="CDB-Widget-link CDB-Widget-filterButton js-all">all</button> ';
 }
__p+=' ';
 if (totalCats > rejectedCats && !isAllRejected) {
__p+=' <button class="CDB-Widget-link CDB-Widget-filterButton js-none">none</button> ';
 }
__p+=' </div> ';
 }
__p+=' ';
 }
__p+='';
}
return __p;
};

},{"underscore":24}],53:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var template = require('./options_template.tpl');

/**
 * Category filter view
 *
 */
module.exports = View.extend({

  className: 'CDB-Widget-filter CDB-Widget-contentSpaced CDB-Widget-contentSpaced--sideMargins',

  events: {
    'click .js-all': '_onSelectAll',
    'click .js-none': '_onUnselectAll',
    'click .js-lock': '_lockCategories',
    'click .js-unlock': '_unlockCategories'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this.viewModel = this.options.viewModel;
    this._initBinds();
  },

  render: function() {
    var totalCats = this.dataModel.getData().size();
    var rejectedCats = this.dataModel.getRejectedCount();
    var acceptedCats = this.dataModel.getAcceptedCount();

    this.$el.html(
      template({
        isLocked: this.dataModel.isLocked(),
        canBeLocked: this.dataModel.canBeLocked(),
        totalLocked: this.dataModel.getLockedSize(),
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        isSearchApplied: this.dataModel.isSearchApplied(),
        isAllRejected: this.dataModel.isAllFiltersRejected(),
        totalCats: totalCats,
        rejectedCats: rejectedCats,
        acceptedCats: acceptedCats
      })
    );
    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:data change:filter change:locked change:lockCollection', this.render, this);
    this.viewModel.bind('change:search', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _lockCategories: function() {
    this.dataModel.lockCategories();
  },

  _unlockCategories: function() {
    this.dataModel.unlockCategories();
  },

  _onUnselectAll: function() {
    this.dataModel.rejectAll();
  },

  _onSelectAll: function() {
    this.dataModel.acceptAll();
  }

});

},{"./options_template.tpl":52}],54:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-contentFlex"> <button class="u-rSpace--m CDB-Widget-buttonIcon CDB-Widget-textSmaller CDB-Widget-textSmaller--upper js-searchToggle"> <i class="CDB-Icon CDB-Icon--center CDB-Icon-lens u-rSpace"></i> <span class="u-iBlock"> search </span> </button> </div> ';
 if (showPaginator) {
__p+=' <div class="CDB-Widget-navDots js-dots"> ';
 for (var i = 0, l = pages; i < l; i++) {
__p+='<button class="CDB-Shape-dot CDB-Widget-dot--navigation js-page ';
 if (currentPage === i) {
__p+='is-selected';
 }
__p+='" data-page="'+
((__t=( i ))==null?'':_.escape(__t))+
'"></button>';
 }
__p+=' </div> ';
 }
__p+='';
}
return __p;
};

},{"underscore":24}],55:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var Model = cdb.core.Model;
var defaultTemplate = require('./paginator_template.tpl');

module.exports = View.extend({

  options: {
    itemsPerPage: 6,
    template: defaultTemplate,
    paginator: false
  },

  className: 'CDB-Widget-nav CDB-Widget-contentSpaced',

  events: {
    'click .js-searchToggle': '_onSearchClicked',
    'click .js-page': '_onDotClick'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this.viewModel = this.options.viewModel;
    this._$target = this.options.$target;
    this.model = new Model({
      page: 0
    });
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var pages = Math.ceil(this.dataModel.getSize() / this.options.itemsPerPage);
    var template = this.options.template;
    this.$el.html(
      template({
        showPaginator: this.options.paginator,
        currentPage: this.model.get('page'),
        pages: pages
      })
    );
    this._scrollToPage();

    return this;
  },

  _initBinds: function() {
    $(window).bind('resize.' + this.cid, _.bind(this._scrollToPage, this));
    this.model.bind('change:page', this.render, this);
    this.dataModel.bind('change:data change:searchData', function() {
      this._setPage();
      this.render();
    }, this);
    this.viewModel.bind('change:search', this.toggle, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  // If current page doesn't exist due to a data change, we should reset it
  _setPage: function() {
    var count = this.dataModel.getSize();
    var pages = Math.ceil(count / this._ITEMS_PER_PAGE);
    if (this.model.get('page') > (pages - 1)) {
      this.model.set({ page: 0 }, { silent :true });
    }
  },

  _onSearchClicked: function() {
    this.dataModel.setupSearch();
    this.viewModel.toggleSearch();
  },

  _scrollToPage: function() {
    var page = this.model.get('page');
    var pageWidth = this._$target.find('.CDB-Widget-listGroup:eq(0)').outerWidth();
    this._$target.css('margin-left', - (page * pageWidth));
  },

  _onDotClick: function(ev) {
    var page = $(ev.target).data('page');
    this.model.set('page', page);
  },

  toggle: function() {
    this[ this.viewModel.isSearchEnabled() ? 'hide' : 'show' ]();
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  clean: function() {
    $(window).unbind('resize.' + this.cid);
    View.prototype.clean.call(this);
  }

});

},{"./paginator_template.tpl":54}],56:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-contentFlex"> <button class="u-rSpace--m CDB-Widget-link js-searchToggle">cancel</button> </div> ';
 if (showPaginator) {
__p+=' <div class="CDB-Widget-navDots js-dots"> ';
 for (var i = 0, l = pages; i < l; i++) {
__p+='<button class="CDB-Shape-dot CDB-Widget-dot--navigation js-page ';
 if (currentPage === i) {
__p+='is-selected';
 }
__p+='" data-page="'+
((__t=( i ))==null?'':_.escape(__t))+
'"></button>';
 }
__p+=' </div> ';
 }
__p+='';
}
return __p;
};

},{"underscore":24}],57:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var Model = cdb.core.Model;
var PaginatorView = require('./paginator_view');
var searchTemplate = require('./search_paginator_template.tpl');

module.exports = PaginatorView.extend({

  className: 'CDB-Widget-nav is-hidden CDB-Widget-contentSpaced',

  render: function() {
    this.clearSubViews();
    this.$el.empty();
    var pages = Math.ceil(this.dataModel.getSearchCount() / this.options.itemsPerPage);
    this.$el.html(
      searchTemplate({
        showPaginator: true,
        currentPage: this.model.get('page'),
        pages: pages
      })
    );
    this._scrollToPage();

    return this;
  },

  _setPage: function() {
    var count = this.dataModel.getSearchCount();
    var pages = Math.ceil(count / this._ITEMS_PER_PAGE);
    if (this.model.get('page') > (pages - 1)) {
      this.model.set({ page: 0 }, { silent :true });
    }
  },

  toggle: function() {
    this[ !this.viewModel.isSearchEnabled() ? 'hide' : 'show' ]();
  },

  _onSearchClicked: function() {
    this.dataModel.cleanSearch();
    this.viewModel.toggleSearch();
  }

});

},{"./paginator_view":55,"./search_paginator_template.tpl":56}],58:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( value ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],59:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) {
__p+=' <dt class="CDB-Widget-infoItem"> ';
 if (isSearchApplied) {
__p+=' '+
((__t=( resultsCount ))==null?'':_.escape(__t))+
' found ';
 } else {
__p+=' &nbsp; ';
 }
__p+=' </dt> ';
 } else {
__p+=' <dt class="CDB-Widget-infoItem">'+
((__t=( nullsPer ))==null?'':_.escape(__t))+
'% null rows</dt> <dt class="CDB-Widget-infoItem"><span class="js-cats">'+
((__t=( catsPer ))==null?'':_.escape(__t))+
'</span>% in '+
((__t=( totalCats ))==null?'':_.escape(__t))+
' categor'+
((__t=( totalCats !== 1 ? 'ies' : 'y' ))==null?'':_.escape(__t))+
'</dt> ';
 }
__p+='';
}
return __p;
};

},{"underscore":24}],60:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var View = cdb.core.View;
var d3 = cdb.d3;
var formatter = cdb.core.format;
var template = require('./stats_template.tpl');
var animationTemplate = require('./cats_template.tpl');
var AnimateValues = require('../../animate_values');

/**
 * Category stats info view
 *
 */

module.exports = View.extend({

  className: 'CDB-Widget-info CDB-Widget-textSmaller CDB-Widget-textSmaller--upper',
  tagName: 'dl',

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.$el.html(
      template({
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        isSearchApplied: this.dataModel.isSearchApplied(),
        resultsCount: this.dataModel.getSearchCount(),
        totalCats: this._getCategoriesSize(),
        nullsPer: this._getNullPercentage(),
        catsPer: this._getCurrentCategoriesPercentage()
      })
    );

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateFromValues(this._getPreviousCategoriesPercentage(), this._getCurrentCategoriesPercentage(), '.js-cats',
      animationTemplate, { defaultValue: '-', animationSpeed: 700, formatter: formatter.formatValue }
    );

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:data change:locked change:search change:totalCount', this.render, this);
    this.viewModel.bind('change:search', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _getNullPercentage: function() {
    var nulls = this.dataModel.get('nulls');
    var total = this.dataModel.get('totalCount') || 0;
    return !nulls ? 0 : ((nulls/total) * 100).toFixed(2);
  },

  _getPreviousCategoriesPercentage: function() {
    var total = this.dataModel.previous('totalCount') || 0;
    var data = this.dataModel.getPreviousData();
    return this._getCategoriesPercentage(data, total);
  },

  _getCurrentCategoriesPercentage: function() {
    var total = this.dataModel.get('totalCount') || 0;
    var data = this.dataModel.getData().toJSON();
    return this._getCategoriesPercentage(data, total);
  },

  _getCategoriesPercentage: function(data, total) {
    if (!total) {
      return 0;
    }

    var currentTotal = data.reduce(function(memo, mdl) {
      return !mdl.agg ? ( memo + parseFloat(mdl.value)) : memo;
    }, 0);

    if (!currentTotal) {
      return 0;
    }

    return ((currentTotal / total) * 100).toFixed(2);
  },

  _getCategoriesSize: function() {
    return _.pluck(
      this.dataModel.getData().reject(function(mdl) {
        return mdl.get('agg');
      }), 'name').length;
  }
});

},{"../../animate_values":33,"./cats_template.tpl":58,"./stats_template.tpl":59}],61:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isSearchEnabled) {
__p+=' <form class="CDB-Widget-search js-form"> <i class="CDB-Icon CDB-Icon-lens CDB-Widget-searchLens"></i> <input type="text" class="CDB-Widget-textInput CDB-Widget-searchTextInput js-textInput" value="'+
((__t=( q ))==null?'':_.escape(__t))+
'" placeholder="Search by '+
((__t=( columnName ))==null?'':_.escape(__t))+
'"> ';
 if (canShowApply) {
__p+=' <button type="button" class="CDB-Widget-link CDB-Widget-searchApply js-applyLocked">apply</button> ';
 }
__p+=' </form> ';
 } else {
__p+=' <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-options CDB-Widget-contentSpaced"> <button class="CDB-Widget-buttonIcon CDB-Widget-buttonIcon--circle js-colors '+
((__t=( isColorApplied ? 'is-selected' : '' ))==null?'':_.escape(__t))+
' '+
((__t=( isColorApplied ? 'js-cancelColors' : 'js-applyColors' ))==null?'':_.escape(__t))+
'" data-tooltip="\n          '+
((__t=( isColorApplied ? 'Remove colors' : 'Apply colors' ))==null?'':_.escape(__t))+
'\n        "> <i class="CDB-Icon CDB-Icon-syringe CDB-Icon--top"></i> </button> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div> </div> ';
 }
__p+='';
}
return __p;
};

},{"underscore":24}],62:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var View = cdb.core.View;
var TooltipView = require('../../widget-tooltip-view');
var template = require('./search_title_template.tpl');

/**
 *  Show category title or search any category
 *  + another options for this widget, as in,
 *  colorize categories, lock defined categories...
 *
 */

module.exports = View.extend({

  events: {
    'keyup .js-textInput': '_onKeyupInput',
    'submit .js-form': '_onSubmitForm',
    'click .js-applyLocked': '_applyLocked',
    'click .js-applyColors': '_applyColors',
    'click .js-cancelColors': '_cancelColors',
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.viewModel = this.options.viewModel;
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(
      template({
        isCollapsed: this.dataModel.isCollapsed(),
        isColorApplied: this.dataModel.isColorApplied(),
        title: this.dataModel.get('title'),
        columnName: this.dataModel.get('column'),
        q: this.dataModel.getSearchQuery(),
        isLocked: this.dataModel.isLocked(),
        canBeLocked: this.dataModel.canBeLocked(),
        isSearchEnabled: this.viewModel.isSearchEnabled(),
        canShowApply: this.dataModel.canApplyLocked()
      })
    );
    this._initViews();
    return this;
  },

  _initBinds: function() {
    this.viewModel.bind('change:search', this._onSearchToggled, this);
    this.dataModel.bind('change:filter change:lockCollection change:categoryColors change:collapsed', this.render, this);
    this.add_related_model(this.dataModel);
    this.add_related_model(this.viewModel);
  },

  _initViews: function() {
    var collapseTooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(collapseTooltip.render().el);
    this.addView(collapseTooltip);

    var colorsTooltip = new TooltipView({
      target: this.$('.js-colors')
    });
    $('body').append(colorsTooltip.render().el);
    this.addView(colorsTooltip);
  },

  _onSearchToggled: function() {
    var isSearchEnabled = this.viewModel.isSearchEnabled();
    this[isSearchEnabled ? '_bindESC' : '_unbindESC']();
    this.render();
    if (isSearchEnabled) {
      this._focusOnInput();
    }
  },

  _onSubmitForm: function(ev) {
    if (ev) {
      ev.preventDefault();
    }
    var q = this.$('.js-textInput').val();
    if (this.dataModel.getSearchQuery() !== q) {
      this.dataModel.setSearchQuery(q);
      if (this.dataModel.isSearchValid()) {
        this.dataModel.applySearch();
      }
    }
  },

  _focusOnInput: function() {
    var self = this;
    setTimeout(function() {
      self.$('.js-textInput').focus();
    }, 0);
  },

  _onKeyupInput: _.debounce(
    function(ev) {
      var q = this.$('.js-textInput').val();
      if (ev.keyCode !== 13 && ev.keyCode !== 27 && q !== "") {
        this._onSubmitForm();
      }
    }, 250
  ),

  _bindESC: function() {
    $(document).bind("keyup." + this.cid, _.bind(this._onKeyUp, this));
  },

  _unbindESC: function() {
    $(document).unbind("keyup." + this.cid);
  },

  _onKeyUp: function(ev) {
    if (ev.keyCode === 27) {
      this._cancelSearch();
      return false;
    }
  },

  _applyLocked: function() {
    this.viewModel.toggleSearch();
    this.dataModel.applyLocked();
  },

  _applyColors: function() {
    this.dataModel.applyCategoryColors();
  },

  _cancelColors: function() {
    this.dataModel.cancelCategoryColors();
  },

  _cancelSearch: function() {
    this.dataModel.cleanSearch();
    this.viewModel.disableSearch();
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  },

  clean: function() {
    this._unbindESC();
    View.prototype.clean.call(this);
  }

});

},{"../../widget-tooltip-view":107,"./search_title_template.tpl":61}],63:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],64:[function(require,module,exports){
var _ = cdb._;
var formatter = cdb.core.format;
var d3 = cdb.d3;
var $ = cdb.$;
var WidgetContent = require('../standard/widget_content_view');
var WidgetViewModel = require('../widget_content_model');
var template = require('./template.tpl');
var TooltipView = require('../widget-tooltip-view');
var animationTemplate = require('./animation_template.tpl');
var AnimateValues = require('../animate_values.js');

/**
 * Default widget content view:
 */
module.exports = WidgetContent.extend({

  events: {
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.dataModel = this.model;
    this.viewModel = new WidgetViewModel();
    WidgetContent.prototype.initialize.call(this);
  },

  render: function() {
    this.clearSubViews();
    var value = this.dataModel.get('data');

    var format = function(value) {
      var formatter = d3.format('0,000');

      if (_.isNumber(value)) {
        return formatter(value.toFixed(2));
      }
      return 0;
    };

    var nulls = !_.isUndefined(this.dataModel.get('nulls')) && formatter.formatNumber(this.dataModel.get('nulls')) || '-';
    var isCollapsed = this.dataModel.isCollapsed();

    var prefix = this.dataModel.get('prefix');
    var suffix = this.dataModel.get('suffix');

    this.$el.html(
      template({
        title: this.dataModel.get('title'),
        operation: this.dataModel.get('operation'),
        value: value,
        nulls: nulls,
        prefix: prefix,
        suffix: suffix,
        isCollapsed: isCollapsed
      })
    );

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateValue(this.dataModel, 'data', '.js-value', animationTemplate, { animationSpeed: 700, formatter: format, templateData: { prefix: prefix, suffix: suffix }});

    this.$el.toggleClass('is-collapsed', !!isCollapsed);

    this._initViews();

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:collapsed', this.render, this);
    WidgetContent.prototype._initBinds.call(this);
  },

  _initViews: function() {
    var tooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(tooltip.render().el);
    this.addView(tooltip);
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  }

});

},{"../animate_values.js":33,"../standard/widget_content_view":85,"../widget-tooltip-view":107,"../widget_content_model":110,"./animation_template.tpl":63,"./template.tpl":66}],65:[function(require,module,exports){
var _ = cdb._;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  defaults: _.extend(
    {},
    WidgetModel.prototype.defaults,
    {
      data: '',
      suffix: '',
      prefix: ''
    }
  ),

  // TODO: The response format has probably changed
  parse: function(r) {
    return {
      data: r.result,
      nulls: r.nulls
    };
  },

  toJSON: function(d) {
    return {
      type: "formula",
      options: {
        column: this.get('column'),
        operation: this.get('operation')
      }
    };
  }

});

},{"../widget_model":111}],66:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <div class="CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-tag CDB-Widget-tag--'+
((__t=( operation ))==null?'':_.escape(__t))+
'"> <span class="CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( operation ))==null?'':_.escape(__t))+
'</span> </div> </div> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( nulls ))==null?'':_.escape(__t))+
' null rows</dt> </dl> </div> <div class="CDB-Widget-content"> ';
 if (value) {
__p+=' <h4 class="CDB-Widget-textBigger CDB-Widget-textBigger--maxWidth js-value" title="'+
((__t=( value ))==null?'':_.escape(__t))+
'"> '+
((__t=( prefix ))==null?'':_.escape(__t))+
''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
' </h4> ';
 } else {
__p+=' <div class="CDB-Widget-listItem--fake"></div> ';
 }
__p+=' </div>';
}
return __p;
};

},{"underscore":24}],67:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+=''+
((__t=( value ))==null?'':_.escape(__t))+
''+
((__t=( suffix ))==null?'':_.escape(__t))+
'';
}
return __p;
};

},{"underscore":24}],68:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var d3 = cdb.d3;
var formatter = cdb.core.format;
var Model = cdb.core.Model;
var View = cdb.core.View;

module.exports = View.extend({

  defaults: {
     // render the chart once the width is set as default, provide false value for this prop to disable this behavior
     // e.g. for "mini" histogram behavior
    showOnWidthChange: true,

    labelsMargin: 16, // px
    hasAxisTip: false,
    minimumBarHeight: 2,
    animationSpeed: 750,
    handleWidth: 6,
    handleHeight: 23,
    handleRadius: 3,
    divisionWidth: 80,
    animationBarDelay: function(d, i) {
      return Math.random() * (100 + (i * 10));
    },
    transitionType: 'elastic'
  },

  initialize: function() {
    if (!_.isNumber(this.options.height)) throw new Error('height is required');

    this.options = _.extend({}, this.defaults, this.options);

    _.bindAll(this, '_selectBars', '_adjustBrushHandles', '_onBrushMove', '_onBrushStart', '_onMouseMove', '_onMouseOut');

    // Use this special setup for each view instance ot have its own debounced listener
    // TODO in theory there's the possiblity that the callback is called before the view is rendered in the DOM,
    //  which would lead to the view not being visible until an explicit window resize.
    //  a wasAddedToDOM event would've been nice to have
    this._onWindowResize = _.debounce(this._resizeToParentElement.bind(this), 50);
    $(window).bind('resize', this._onWindowResize);

    // using tagName: 'svg' doesn't work,
    // and w/o class="" d3 won't instantiate properly
    this.setElement($('<svg class=""></svg>')[0]);

    this.canvas = d3.select(this.el)
    .attr('width', 0)
    .attr('height', this.options.height);

    this.canvas
    .append('g')
    .attr('class', 'CDB-WidgetCanvas');

    this._setupModel();
    this._setupBindings();
    this._setupDimensions();
    this._setupD3Bindings();

    this.hide(); // will be toggled on width change
  },

  render: function() {
    this._generateChart();
    this._generateChartContent();
    return this;
  },

  clean: function() {
    $(window).unbind('resize', this._onWindowResize);
    View.prototype.clean.call(this);
  },

  replaceData: function(data) {
    this.model.set({ data: data });
  },

  toggleLabels: function(show) {
    this.model.set('showLabels', show);
  },

  chartWidth: function() {
    var m = this.model.get('margin');

    // Get max because width might be negative initially
    return Math.max(0, this.model.get('width') - m.left - m.right);
  },

  chartHeight: function() {
    var m = this.model.get('margin');
    var labelsMargin = this.model.get('showLabels')
      ? this.defaults.labelsMargin
      : 0;
    return this.model.get('height') - m.top - m.bottom - labelsMargin;
  },

  _resizeToParentElement: function() {

    if (this.$el.parent()) {
      // Hide this view temporarily to get actual size of the parent container
      var wasHidden = this.isHidden();

      this.hide();

      var width = this.$el.parent().width() || 0;

      if (wasHidden) {
        this.hide();
      } else {
        this.show();
      }

      this.model.set('width', width);
    }
  },

  _onChangeLeftAxisTip: function() {
    this._updateAxisTip('left');
  },

  _onChangeRightAxisTip: function() {
    this._updateAxisTip('right');
  },

  _updateAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip  = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);
    var handle    = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);

    textLabel.data([this.model.get(className + '_axis_tip')]).text(function(d) {
      return formatter.formatNumber(d);
    });

    var width = textLabel.node().getBBox().width;
    rectLabel.attr('width', width + 4);

    var parts = /translate\(\s*([^\s,)]+), ([^\s,)]+)/.exec(handle.attr('transform'));
    var xPos = +parts[1] + 3;

    if ((xPos - width/2) < 0) {
      axisTip.attr('transform', 'translate(0, 52)');
      textLabel.attr('dx', -xPos);
      rectLabel.attr('x',  -xPos);
    } else if ((xPos + width/2 + 2) >= this.chartWidth()) {
      axisTip.attr('transform', 'translate(0, 52)');
      textLabel.attr('dx', this.chartWidth() - (xPos + width - 2));
      rectLabel.attr('x', this.chartWidth() - (xPos + width));
    } else {
      axisTip.attr('transform', 'translate(-' + (width/2) + ', 52)');
      rectLabel.attr('x', 0);
      textLabel.attr('dx', +2);
    }
  },

  _onChangeData: function() {
    if (this.model.previous('data').length != this.model.get('data').length) {
      this.reset();
    } else {
      this.refresh();
    }
  },

  _onChangeRange: function() {
    if (this.model.get('lo_index') === 0 && this.model.get('hi_index') === 0) {
      return;
    }
    this.trigger('range_updated', this.model.get('lo_index'), this.model.get('hi_index'));
  },

  _onChangeWidth: function() {
    var width = this.model.get('width');
    this.$el.width(width);
    this.chart.attr('width', width);
    if (this.options.showOnWidthChange && width > 0) {
      this.show();
    }
    this.reset();

    var loBarIndex = this.model.get('lo_index');
    var hiBarIndex = this.model.get('hi_index');
    this.selectRange(loBarIndex, hiBarIndex);
  },

  _onChangeHeight: function() {
    var height = this.model.get('height');

    this.$el.height(height);
    this.chart.attr('height', height);
    this.leftHandle.attr('height', height);
    this.rightHandle.attr('height', height);

    this.reset();
  },

  _onChangShowLabels: function() {
    this._axis.style('opacity', this.model.get('showLabels') ? 1 : 0);
  },

  _onChangePos: function() {
    var pos = this.model.get('pos');
    var margin = this.model.get('margin');

    var x = +pos.x;
    var y = +pos.y;

    this.chart
    .transition()
    .duration(150)
    .attr('transform', 'translate(' + (margin.left + x) + ', ' + (margin.top + y) + ')');
  },

  _onBrushStart: function() {
    var extent = this.brush.extent();
    var hiExtent = extent[1];
    var rightX = this.xScale(hiExtent) - this.options.handleWidth / 2;

    this.chart.classed('is-selectable', true);
  },

  _onChangeDragging: function() {
    this.chart.classed('is-dragging', this.model.get('dragging'));
    this._updateAxisTipOpacity('right');
    this._updateAxisTipOpacity('left');
  },

  _showAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip   = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);

    if (textLabel) {
      textLabel.transition().duration(200).attr('opacity',  1);
    }
    if (rectLabel) {
      rectLabel.transition().duration(200).attr('opacity',  1);
    }
  },

  _hideAxisTip: function(className) {
    var textLabel = this.chart.select('.CDB-Chart-axisTipText.CDB-Chart-axisTip-' + className);
    var axisTip   = this.chart.select('.CDB-Chart-axisTip.CDB-Chart-axisTip-' + className);
    var rectLabel = this.chart.select('.CDB-Chart-axisTipRect.CDB-Chart-axisTip-' + className);

    if (textLabel) {
      textLabel.transition().duration(200).attr('opacity',  0);
    }
    if (rectLabel) {
      rectLabel.transition().duration(200).attr('opacity',  0);
    }
  },

  _updateAxisTipOpacity: function(className) {
    if (this.model.get('dragging')) {
      this._showAxisTip(className);
    } else {
      this._hideAxisTip(className);
    }
  },

  _onBrushMove: function() {
    this.model.set({ dragging: true });
    this._selectBars();
    this._adjustBrushHandles();
  },

  _onMouseOut: function() {
    var bars = this.chart.selectAll('.CDB-Chart-bar');
    bars.classed('is-highlighted', false);
    this.trigger('hover', { value: null });
  },

  _onMouseMove: function() {
    var x = d3.event.offsetX;
    var y = d3.event.offsetY;

    var barIndex = Math.floor(x / this.barWidth);
    var data = this.model.get('data');

    if (data[barIndex] === undefined || data[barIndex] === null) {
      return;
    }

    var freq = data[barIndex].freq;
    var hoverProperties = {};

    var bar = this.chart.select('.CDB-Chart-bar:nth-child(' + (barIndex + 1) + ')');

    if (bar && bar.node() && !bar.classed('is-selected')) {

      var left = (barIndex * this.barWidth) + (this.barWidth/2);

      var top = this.yScale(freq);

      var h = this.chartHeight() - this.yScale(freq);

      if (h < this.options.minimumBarHeight && h > 0) {
        top = this.chartHeight() - this.options.minimumBarHeight;
      }

      if (!this._isDragging() && freq > 0) {
        var d = formatter.formatNumber(freq);
        hoverProperties = { top: top, left: left, data: d };
      } else {
        hoverProperties = null;
      }

    } else {
      hoverProperties = null;
    }

    this.trigger('hover', hoverProperties);

    this.chart.selectAll('.CDB-Chart-bar')
    .classed('is-highlighted', false);

    if (bar && bar.node()) {
      bar.classed('is-highlighted', true);
    }
  },

  reset: function() {
    this._removeChartContent();
    this._setupDimensions();
    this._calcBarWidth();
    this._generateChartContent();
    this._removeShadowBars();
    this._generateShadowBars();
  },

  refresh: function() {
    this._setupDimensions();
    this._removeAxis();
    this._generateAxis();
    this._updateChart();

    this._generateShadowBars();
    this.chart.select('.CDB-Chart-handles').moveToFront();
    this.chart.select('.Brush').moveToFront();
  },

  resetIndexes: function() {
    this.model.set({ lo_index: null, hi_index: null });
  },

  removeShadowBars: function() {
    this.model.set('show_shadow_bars', false);
  },

  _removeShadowBars: function() {
    this.chart.selectAll('.CDB-Chart-shadowBars').remove();
  },

  _removeBars: function() {
    this.chart.selectAll('.CDB-Chart-bars').remove();
  },

  _removeBrush: function() {
    this.chart.selectAll('.Brush').remove();
    this.chart.classed('is-selectable', false);
  },

  _removeLines: function() {
    this.chart.select('.CDB-Chart-lines').remove();
  },

  _removeChartContent: function() {
    this._removeBrush();
    this._removeHandles();
    this._removeBars();
    this._removeAxis();
    this._removeLines();
  },

  _generateChartContent: function() {
    this._generateAxis();
    this._generateLines();

    this._generateBars();
    this._generateHandles();
    this._setupBrush();
  },

  _generateLines: function() {
    this._generateHorizontalLines();

    if (this.options.type !== 'time') {
      this._generateVerticalLines();
    }
  },

  _generateVerticalLines: function() {
    var lines = this.chart.select('.CDB-Chart-lines');

    lines.append('g')
    .selectAll('.CDB-Chart-line')
    .data(this.verticalRange.slice(1, this.verticalRange.length - 1))
    .enter().append('svg:line')
    .attr('class', 'CDB-Chart-line')
    .attr('y1', 0)
    .attr('x1', function(d) { return d; })
    .attr('y2', this.chartHeight())
    .attr('x2', function(d) { return d; });
  },

  _generateHorizontalLines: function() {
    var lines = this.chart.append('g')
    .attr('class', 'CDB-Chart-lines');

    lines.append('g')
    .attr('class', 'y')
    .selectAll('.CDB-Chart-line')
    .data(this.horizontalRange)
    .enter().append('svg:line')
    .attr('class', 'CDB-Chart-line')
    .attr('x1', 0)
    .attr('y1', function(d) { return d; })
    .attr('x2', this.chartWidth())
    .attr('y2', function(d) { return d; });

    this.bottomLine = lines
    .append('line')
    .attr('class', 'CDB-Chart-line CDB-Chart-line--bottom')
    .attr('x1', 0)
    .attr('y1', this.chartHeight())
    .attr('x2', this.chartWidth() - 1)
    .attr('y2', this.chartHeight());
  },

   _setupD3Bindings: function() { // TODO: move to a helper

    d3.selection.prototype.moveToBack = function() {
      return this.each(function() {
        var firstChild = this.parentNode.firstChild;
        if (firstChild) {
          this.parentNode.insertBefore(this, firstChild);
        }
      });
    };

    d3.selection.prototype.moveToFront = function() {
      return this.each(function(){
        this.parentNode.appendChild(this);
      });
    };
  },

  _setupModel: function() {
    this.model = new Model({
      showLabels: true,
      data: this.options.data,
      height: this.options.height,
      display: true,
      show_shadow_bars: this.options.shadowData,
      margin: _.clone(this.options.margin),
      width: 0, // will be set on resize listener
      pos: { x: 0, y: 0 }
    });
  },

  _setupBindings: function() {
    this.model.bind('change:data', this._onChangeData, this);
    this.model.bind('change:display', this._onChangeDisplay, this);
    this.model.bind('change:dragging', this._onChangeDragging, this);
    this.model.bind('change:height', this._onChangeHeight, this);
    this.model.bind('change:left_axis_tip', this._onChangeLeftAxisTip, this);
    this.model.bind('change:lo_index change:hi_index', this._onChangeRange, this);
    this.model.bind('change:pos', this._onChangePos, this);
    this.model.bind('change:right_axis_tip', this._onChangeRightAxisTip, this);
    this.model.bind('change:showLabels', this._onChangShowLabels, this);
    this.model.bind('change:show_shadow_bars', this._onChangeShowShadowBars, this);
    this.model.bind('change:width', this._onChangeWidth, this);
  },

  _setupDimensions: function() {
    this._setupScales();
    this._setupRanges();
    this._onWindowResize();
  },

  _setupScales: function() {
    var data = this.model.get('data');

    this.xScale = d3.scale.linear().domain([0, 100]).range([0, this.chartWidth()]);
    this.yScale = d3.scale.linear().domain([0, d3.max(data, function(d) { return _.isEmpty(d) ? 0 : d.freq; } )]).range([this.chartHeight(), 0]);

    if (!data || !data.length) {
      return;
    }

    if (this.options.type === 'time') {
      this.xAxisScale = d3.time.scale().domain([data[0].start * 1000, data[data.length - 1].end * 1000]).nice().range([0, this.chartWidth()]);
    } else {
      this.xAxisScale = d3.scale.linear().range([data[0].start, data[data.length - 1].end]).domain([0, this.chartWidth()]);
    }
  },

  _setupRanges: function() {
    var n = Math.round(this.chartWidth() / this.options.divisionWidth);
    this.verticalRange = d3.range(0, this.chartWidth() + this.chartWidth() / n, this.chartWidth() / n);
    this.horizontalRange = d3.range(0, this.chartHeight() + this.chartHeight() / 2, this.chartHeight() / 2);
  },

  _calcBarWidth: function() {
    this.barWidth = this.chartWidth() / this.model.get('data').length;
  },

  _generateChart: function() {
    var margin = this.model.get('margin');

    this.chart = d3.select(this.el)
    .selectAll('.CDB-WidgetCanvas')
    .append('g')
    .attr('class', 'CDB-Chart')
    .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');

    this.chart.classed(this.options.className || '', true);
  },

  _onChangeShowShadowBars: function() {
    if (this.model.get('show_shadow_bars')) {
      this._generateShadowBars();
    } else {
      this._removeShadowBars();
    }
  },

  _onChangeDisplay: function() {
    if (this.model.get('display')) {
      this._show();
    } else {
      this._hide();
    }
  },

  hide: function() {
    this.model.set('display', false);
  },

  show: function() {
    this.model.set('display', true);
  },

  _hide: function() {
    this.$el.hide();
  },

  _show: function() {
    this.$el.show();
  },

  isHidden: function() {
    return !this.model.get('display');
  },

  _selectBars: function() {
    var self = this;
    var extent = this.brush.extent();
    var lo = extent[0];
    var hi = extent[1];


    this.model.set({ lo_index: this._getLoBarIndex(), hi_index: this._getHiBarIndex() });

    this.chart.selectAll('.CDB-Chart-bar').classed('is-selected', function(d, i) {
      var a = Math.floor(i * self.barWidth);
      var b = Math.floor(a + self.barWidth);
      var LO = Math.floor(self.xScale(lo));
      var HI = Math.floor(self.xScale(hi));
      var isIn = (a > LO && a < HI) || (b > LO && b < HI) || (a <= LO && b >= HI);
      return !isIn;
    });
  },

  _isDragging: function() {
    return this.model.get('dragging');
  },

  _move: function(pos) {
    this.model.set({ pos: pos });
  },

  expand: function(height) {
    this.canvas.attr('height', this.model.get('height') + height);
    this._move({ x: 0, y: height });
  },

  contract: function(height) {
    this.canvas.attr('height', height);
    this._move({ x: 0, y: 0 });
  },

  resizeHeight: function(height) {
    this.model.set('height', height);
  },

  removeSelection: function() {
    this.resetIndexes();
    this.chart.selectAll('.CDB-Chart-bar').classed('is-selected', false);
    this._removeBrush();
    this._setupBrush();
  },

  selectRange: function(loBarIndex, hiBarIndex) {
    if (!loBarIndex && !hiBarIndex) {
      return;
    }

    var loPosition = this._getBarPosition(loBarIndex);
    var hiPosition = this._getBarPosition(hiBarIndex);

    this._selectRange(loPosition, hiPosition);
  },

  _selectRange: function(loPosition, hiPosition) {
    this.chart.select('.Brush').transition()
    .duration(this.brush.empty() ? 0 : 150)
    .call(this.brush.extent([loPosition, hiPosition]))
    .call(this.brush.event);
  },

  _getLoBarIndex: function() {
    var extent = this.brush.extent();
    return Math.round(this.xScale(extent[0]) / this.barWidth);
  },

  _getHiBarIndex: function() {
    var extent = this.brush.extent();
    return Math.round(this.xScale(extent[1]) / this.barWidth);
  },

  _getBarIndex: function() {
    var x = d3.event.sourceEvent.offsetX;
    return Math.floor(x / this.barWidth);
  },

  _getBarPosition: function(index) {
    var data = this.model.get('data');
    return index * (100 / data.length);
  },

  _setupBrush: function() {
    var self = this;

    var xScale = this.xScale;
    var brush = this.brush = d3.svg.brush().x(this.xScale);

    function onBrushEnd() {
      var data = self.model.get('data');
      var loPosition, hiPosition;

      self.model.set({ dragging: false });

      if (brush.empty()) {
        self.chart.selectAll('.CDB-Chart-bar').classed('is-selected', false);
        d3.select(this).call(brush.extent([0, 0]));
      } else {

        var loBarIndex = self._getLoBarIndex();
        var hiBarIndex = self._getHiBarIndex();

        loPosition = self._getBarPosition(loBarIndex);
        hiPosition = self._getBarPosition(hiBarIndex);

        if (!d3.event.sourceEvent) {
          return;
        }

        if (loBarIndex === hiBarIndex) {
          if (hiBarIndex >= data.length) {
            loPosition = self._getBarPosition(loBarIndex - 1);
          } else {
            hiPosition = self._getBarPosition(hiBarIndex + 1);
          }
        }

        self._selectRange(loPosition, hiPosition);
        self.model.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
        self._adjustBrushHandles();
        self._selectBars();

        self.trigger('on_brush_end', self.model.get('lo_index'), self.model.get('hi_index'));
      }

      if (d3.event.sourceEvent && loPosition === undefined && hiPosition === undefined) {
        var barIndex = self._getBarIndex();

        loPosition = self._getBarPosition(barIndex);
        hiPosition = self._getBarPosition(barIndex + 1);

        self.model.set({ lo_index: barIndex, hi_index: barIndex + 1 });
        self._selectRange(loPosition, hiPosition);
        self.trigger('on_brush_end', self.model.get('lo_index'), self.model.get('hi_index'));
      }
    }

    var data = this.model.get('data');

    this.brush
    .on('brushstart', this._onBrushStart)
    .on('brush', this._onBrushMove)
    .on('brushend', onBrushEnd);

    this.chart.append('g')
    .attr('class', 'Brush')
    .call(this.brush)
    .selectAll('rect')
    .attr('y', 0)
    .attr('height', this.chartHeight())
    .on('mouseout', this._onMouseOut)
    .on('mousemove', this._onMouseMove);
  },

  _adjustBrushHandles: function() {
    var extent = this.brush.extent();

    var loExtent = extent[0];
    var hiExtent = extent[1];

    var leftX  = this.xScale(loExtent) - this.options.handleWidth / 2;
    var rightX = this.xScale(hiExtent) - this.options.handleWidth / 2;

    this.chart.select('.CDB-Chart-handle-left')
    .attr('transform', 'translate(' + leftX + ', 0)');

    this.chart.select('.CDB-Chart-handle-right')
    .attr('transform', 'translate(' + rightX + ', 0)');

    if (this.options.hasAxisTip) {
      this.model.set({
        left_axis_tip: this.xAxisScale(leftX + 3),
        right_axis_tip: this.xAxisScale(rightX + 3)
      });
    }
  },

  _generateAxisTip: function(className) {

    var handle = this.chart.select('.CDB-Chart-handle.CDB-Chart-handle-' + className);

    var axisTip = handle.selectAll("g")
    .data([''])
    .enter().append("g")
    .attr('class', 'CDB-Chart-axisTip CDB-Chart-axisTip-' + className)
    .attr("transform", function(d, i) { return "translate(0,52)"; });

    this.rectLabel = axisTip.append("rect")
    .attr('class', 'CDB-Chart-axisTipRect CDB-Chart-axisTip-' + className)
    .attr("height", 12)
    .attr("width", 10);

    this.textLabel = axisTip.append("text")
    .attr('class', 'CDB-Chart-axisTipText CDB-Chart-axisTip-' + className)
    .attr("dy", "11")
    .attr("dx", "0")
    .text(function(d) { return d; });
  },

  _generateHandle: function(className) {
    var opts = { width: this.options.handleWidth, height: this.options.handleHeight, radius: this.options.handleRadius };
    var yPos = (this.chartHeight() / 2) - (this.options.handleHeight / 2);

    var handle = this.chart.select('.CDB-Chart-handles')
    .append('g')
    .attr('class', 'CDB-Chart-handle CDB-Chart-handle-' + className);

    if (this.options.hasAxisTip) {
      this._generateAxisTip(className);
    }

    handle
    .append('line')
    .attr('class', 'CDB-Chart-handleLine')
    .attr('x1', 3)
    .attr('y1', -4)
    .attr('x2', 3)
    .attr('y2', this.chartHeight() + 4);

    if (this.options.hasHandles) {
      handle
      .append('rect')
      .attr('class', 'CDB-Chart-handleRect')
      .attr('transform', 'translate(0, ' + yPos + ')')
      .attr('width', opts.width)
      .attr('height', opts.height)
      .attr('rx', opts.radius)
      .attr('ry', opts.radius);

      var y = 21; // initial position of the first grip

      for (var i = 0; i < 3; i++) {
        handle
        .append('line')
        .attr('class', 'CDB-Chart-handleGrip')
        .attr('x1', 2)
        .attr('y1', y + i*3)
        .attr('x2', 4)
        .attr('y2', y + i*3);
      }
    }

    return handle;
  },

  _generateHandles: function() {
    this.chart.append('g').attr('class', 'CDB-Chart-handles');
    this.leftHandle  = this._generateHandle('left');
    this.rightHandle = this._generateHandle('right');
  },

  _generateHandleLine: function() {
    return this.chart.select('.CDB-Chart-handles').append('line')
    .attr('class', 'CDB-Chart-handleLine')
    .attr('x1', 0)
    .attr('y1', 0)
    .attr('x2', 0)
    .attr('y2', this.chartHeight());
  },

  _removeHandles: function() {
    this.chart.select('.CDB-Chart-handles').remove();
  },

  _removeAxis: function() {
    this.canvas.select('.CDB-Chart-axis').remove();
  },

  _generateAdjustAnchorMethod: function(ticks) {

    return function(d, i) {
      if (i === 0) {
        return 'start';
      } else if (i === (ticks.length - 1)) {
        return 'end';
      } else {
        return 'middle';
      }
    };
  },

  _generateAxis: function() {
    this._axis = this.options.type === 'time'
      ? this._generateTimeAxis()
      : this._generateNumericAxis();

    this._onChangShowLabels();
  },

  _generateNumericAxis: function() {
    var self = this;
    var adjustTextAnchor = this._generateAdjustAnchorMethod(this.verticalRange);

    var axis = this.chart.append('g')
    .attr('class', 'CDB-Chart-axis');

    axis
    .append('g')
    .selectAll('.Label')
    .data(this.verticalRange)
    .enter().append("text")
    .attr("x", function(d) { return d; })
    .attr("y", function(d) { return self.chartHeight() + 15; })
    .attr("text-anchor", adjustTextAnchor)
    .text(function(d) {
      return formatter.formatNumber(self.xAxisScale(d));
    });

    return axis;
  },

  _generateTimeAxis: function() {
    var adjustTextAnchor = this._generateAdjustAnchorMethod(this.xAxisScale.ticks());

    var xAxis = d3.svg.axis()
    .orient("bottom")
    .tickPadding(5)
    .innerTickSize(-this.chartHeight())
    .scale(this.xAxisScale)
    .orient('bottom');

    var axis = this.canvas.append('g')
    .attr("class", 'CDB-Chart-axis')
    .attr("transform", "translate(0," + (this.chartHeight() + 5) + ")")
    .call(xAxis);

    axis.selectAll('text').style('text-anchor', adjustTextAnchor);
    axis.moveToBack();

    return axis;
  },

  _updateChart: function() {
    var self = this;
    var data = this.model.get('data');

    var bars = this.chart.selectAll('.CDB-Chart-bar')
    .data(data);

    bars
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-bar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * self.barWidth) + ', 0 )';
    })
    .attr('y', self.chartHeight())
    .attr('height', 0)
    .attr('width', Math.max(0, this.barWidth - 1));

    bars
    .transition()
    .duration(200)
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return self.yScale(d.freq);
      }
    });

    bars
    .exit()
    .transition()
    .duration(200)
    .attr('height', function(d) {
      return 0;
    })
    .attr('y', function(d) {
      return self.chartHeight();
    });
  },

  _generateBars: function() {
    var self = this;
    var data = this.model.get('data');

    this._calcBarWidth();

    var bars = this.chart.append('g')
    .attr('transform', 'translate(0, 0)')
    .attr('class', 'CDB-Chart-bars')
    .selectAll('.CDB-Chart-bar')
    .data(data);

    bars
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-bar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * self.barWidth) + ', 0 )';
    })
    .attr('y', self.chartHeight())
    .attr('height', 0)
    .attr('width', Math.max(0, this.barWidth - 1));

    bars
    .transition()
    .ease(this.options.transitionType)
    .duration(this.options.animationSpeed)
    .delay(this.options.animationBarDelay)
    .transition()
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - self.yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return self.yScale(d.freq);
      }
    });
  },

  showShadowBars: function() {
    this.model.set('show_shadow_bars', true);
  },

  _generateShadowBars: function() {
    var data = this.options.shadowData;

    if (!data || !data.length || !this.model.get('show_shadow_bars')) {
      this._removeShadowBars();
      return;
    }

    this._removeShadowBars();

    var self = this;

    var yScale = d3.scale.linear().domain([0, d3.max(data, function(d) { return _.isEmpty(d) ? 0 : d.freq; } )]).range([this.chartHeight(), 0]);
    var barWidth = this.chartWidth() / data.length;

    var bars = this.chart.append('g')
    .attr('transform', 'translate(0, 0)')
    .attr('class', 'CDB-Chart-shadowBars')
    .selectAll('.CDB-Chart-shadowBar')
    .data(data)
    .enter()
    .append('rect')
    .attr('class', 'CDB-Chart-shadowBar')
    .attr('data', function(d) { return _.isEmpty(d) ? 0 :  d.freq; })
    .attr('transform', function(d, i) {
      return 'translate(' + (i * barWidth) + ', 0 )';
    })
    .attr('y', function(d) {
      if (_.isEmpty(d)) {
        return self.chartHeight();
      }

      var h = self.chartHeight() - yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        return self.chartHeight() - self.options.minimumBarHeight;
      } else {
        return yScale(d.freq);
      }
    })
    .attr('width', Math.max(0, barWidth - 1))
    .attr('height', function(d) {

      if (_.isEmpty(d)) {
        return 0;
      }

      var h = self.chartHeight() - yScale(d.freq);

      if (h < self.options.minimumBarHeight && h > 0) {
        h = self.options.minimumBarHeight;
      }
      return h;
    });

    // We need to explicitly move the lines of the grid behind the shadow bars
    this.chart.selectAll('.CDB-Chart-shadowBars').moveToBack();
    this.chart.selectAll('.CDB-Chart-lines').moveToBack();
  }
});

},{}],69:[function(require,module,exports){
var _ = cdb._;
var formatter = cdb.core.format;
var HistogramTitleView = require('./histogram_title_view');
var WidgetContent = require('../standard/widget_content_view');
var WidgetViewModel = require('../widget_content_model');
var HistogramChartView = require('./chart');
var placeholder = require('./placeholder.tpl');
var template = require('./content.tpl');
var AnimateValues = require('../animate_values.js');
var animationTemplate = require('./animation_template.tpl');

/**
 * Widget content view for a histogram
 */
module.exports = WidgetContent.extend({

  defaults: {
    chartHeight: 48 + 20 + 4
  },

  events: {
    'click .js-clear': '_clear',
    'click .js-zoom': '_zoom'
  },

  initialize: function() {
    this.model = this.options.dataModel;
    this.viewModel = new WidgetViewModel();
    this.lockedByUser = false;
    WidgetContent.prototype.initialize.call(this);
  },

  _initViews: function() {
    var titleView = new HistogramTitleView({
      viewModel: this.viewModel,
      dataModel: this.model
    });
    this.$('.js-title').html(titleView.render().el);
    this.addView(titleView);

    this._renderMiniChart();
    this._renderMainChart();
  },

  _initBinds: function() {
    this.model.once('change:data', this._onFirstLoad, this);
    this.model.bind('change:collapsed', function(mdl, isCollapsed) {
      this.$el.toggleClass('is-collapsed', !!isCollapsed);
    }, this);
  },

  _onFirstLoad: function() {
    this.render();
    this._storeBounds();

    this.model.bind('change', this._onChangeModel, this);
    this.model._fetch();
  },

  _storeBounds: function() {
    var data = this.model.getData();
    if (data && data.length > 0) {
      this.start = data[0].start;
      this.end = data[data.length - 1].end;
      this.binsCount = data.length;
      this.model.set({ start: this.start, end: this.end, bins: this.binsCount });
    }
  },

  _isZoomed: function() {
    return this.viewModel.get('zoomed');
  },

  _onChangeModel: function() {

    // When the histogram is zoomed, we don't need to rely
    // on the change url to update the histogram
    if (this.model.changed.url && this._isZoomed()) {
      return;
    }

    // if the action was initiated by the user
    // don't replace the stored data
    if (this.lockedByUser) {
      this.lockedByUser = false;
    } else {
      if (this._isZoomed()) {
        this.zoomedData = this.model.getData();
      } else {
        this.histogramChartView.showShadowBars();
        this.originalData = this.model.getData();
      }
        this.histogramChartView.replaceData(this.model.getData());
    }

    if (this.unsettingRange) {
      this._unsetRange();
    } else {
      if (this._isZoomed() && !this.lockZoomedData) {
        this.lockZoomedData = true;
        this.zoomedData = this.model.getData();
      }
    }

    this._updateStats();
  },

  render: function() {
    this.clearSubViews();

    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;

    this.$el.html(
      template({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? data.length : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    } else {
      this.originalData = this.model.getData();
      this._setupBindings();
      this._initViews();
    }

    return this;
  },

  _unsetRange: function() {
    this.unsettingRange = false;
    this.histogramChartView.replaceData(this.originalData);
    this.viewModel.set({ lo_index: null, hi_index: null });

    if (!this._isZoomed()) {
      this.histogramChartView.showShadowBars();
    }
  },

  _addPlaceholder: function() {
    this.$('.js-content').append(placeholder());
  },

  _renderMainChart: function() {
    this.histogramChartView = new HistogramChartView(({
      margin: { top: 4, right: 4, bottom: 4, left: 4 },
      hasShadowBards: true,
      hasHandles: true,
      hasAxisTip: true,
      width: this.canvasWidth,
      height: this.defaults.chartHeight,
      data: this.model.getData(),
      shadowData: this.model.getData()
    }));

    this.$('.js-content').append(this.histogramChartView.el);
    this.addView(this.histogramChartView);

    this.histogramChartView.bind('range_updated', this._onRangeUpdated, this);
    this.histogramChartView.bind('on_brush_end', this._onBrushEnd, this);
    this.histogramChartView.bind('hover', this._onValueHover, this);
    this.histogramChartView.render().show();

    this._updateStats();
  },

  _renderMiniChart: function() {
    this.miniHistogramChartView = new HistogramChartView(({
      className: 'CDB-Chart--mini',
      margin: { top: 0, right: 0, bottom: 4, left: 4 },
      height: 40,
      showOnWidthChange: false,
      data: this.model.getData()
    }));

    this.addView(this.miniHistogramChartView);
    this.$('.js-content').append(this.miniHistogramChartView.el);
    this.miniHistogramChartView.bind('on_brush_end', this._onMiniRangeUpdated, this);
    this.miniHistogramChartView.render();
  },

  _setupBindings: function() {
    this.viewModel.bind('change:zoomed', this._onChangeZoomed, this);
    this.viewModel.bind('change:zoom_enabled', this._onChangeZoomEnabled, this);
    this.viewModel.bind('change:filter_enabled', this._onChangeFilterEnabled, this);
    this.viewModel.bind('change:total', this._onChangeTotal, this);
    this.viewModel.bind('change:nulls', this._onChangeNulls, this);
    this.viewModel.bind('change:max',   this._onChangeMax, this);
    this.viewModel.bind('change:min',   this._onChangeMin, this);
    this.viewModel.bind('change:avg',   this._onChangeAvg, this);
  },

  _clearTooltip: function() {
    this.$(".js-tooltip").stop().hide();
  },

  _onValueHover: function(info) {
    var $tooltip = this.$(".js-tooltip");

    if (info && info.data) {
      var bottom = this.defaults.chartHeight + 3 - info.top;

      $tooltip.css({ bottom: bottom, left: info.left });
      $tooltip.text(info.data);
      $tooltip.css({ left: info.left - $tooltip.width()/2 });
      $tooltip.fadeIn(70);
    } else {
      this._clearTooltip();
    }
  },

  _onMiniRangeUpdated: function(loBarIndex, hiBarIndex) {
    this.lockedByUser = false;
    this.lockZoomedData = false;

    this._clearTooltip();
    this.histogramChartView.removeSelection();

    var data = this.originalData;

    if (loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
      this.filter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._updateStats();
    } else {
      console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this._getData();

    if (!data || !data.length) {
      return;
    }

    if (this._isZoomed()) {
      this.lockedByUser = true;
    }

    var properties = { filter_enabled: true, lo_index: loBarIndex, hi_index: hiBarIndex };

    if (!this.viewModel.get('zoomed')) {
      properties.zoom_enabled = true;
    }

    this.viewModel.set(properties);

    if (loBarIndex >= 0 && loBarIndex < data.length && (hiBarIndex - 1) >= 0 && (hiBarIndex - 1) < data.length) {
      this.filter.setRange(
        data[loBarIndex].start,
        data[hiBarIndex - 1].end
      );
      this._updateStats();
    } else {
      console.error('Error accessing array bounds', loBarIndex, hiBarIndex, data);
    }
  },

  _onRangeUpdated: function(loBarIndex, hiBarIndex) {

    var self = this;
    if (this.viewModel.get('zoomed')) {
      this.viewModel.set({ zoom_enabled: false, lo_index: loBarIndex, hi_index: hiBarIndex });
    } else {
      this.viewModel.set({ lo_index: loBarIndex, hi_index: hiBarIndex });
    }

    var updateStats = _.debounce(function() { self._updateStats(); }, 400);
    updateStats();
  },

  _getData: function() {
    var data = this.model.getData();

    if (this._isZoomed()) {
      data = this.zoomedData;
    }
    return data;
  },

  _onChangeFilterEnabled: function() {
    this.$(".js-filter").toggleClass('is-hidden', !this.viewModel.get('filter_enabled'));
  },

  _onChangeZoomEnabled: function() {
    this.$(".js-zoom").toggleClass('is-hidden', !this.viewModel.get('zoom_enabled'));
  },

  _changeHeaderValue: function(className, what, suffix) {
    if (this.viewModel.get(what) === undefined) {
      this.$(className).text('0 ' + suffix);
      return;
    }

    this._addTitleForValue(className, what, suffix);

    var animator = new AnimateValues({
      el: this.$el
    });

    animator.animateValue(this.viewModel, what, className, animationTemplate, {
      formatter: formatter.formatNumber,
      templateData: { suffix: " " + suffix }
    });
  },

  _onChangeNulls: function() {
    this._changeHeaderValue('.js-nulls', 'nulls', 'NULL ROWS');
  },

  _onChangeTotal: function() {
    this._changeHeaderValue('.js-val', 'total', 'SELECTED');
  },

  _onChangeMax: function() {
    this._changeHeaderValue('.js-max', 'max', 'MAX');
  },

  _onChangeMin: function() {
    this._changeHeaderValue('.js-min', 'min', 'MIN');
  },

  _onChangeAvg: function() {
    this._changeHeaderValue('.js-avg', 'avg', 'AVG');
  },

  _addTitleForValue: function(className, what, unit) {
    this.$(className).attr('title', this._formatNumberWithCommas(this.viewModel.get(what).toFixed(2)) + ' ' + unit);
  },

  _formatNumberWithCommas: function(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  },

  _updateStats: function() {
    var data = this.originalData;

    if (this._isZoomed()) {
      data = this.zoomedData;
    }

    var nulls = this.model.get('nulls');

    var min, max;

    if (data && data.length) {

      var loBarIndex = this.viewModel.get('lo_index') || 0;
      var hiBarIndex = this.viewModel.get('hi_index') || data.length;

      var sum = this._calcSum(data, loBarIndex, hiBarIndex);
      var avg = this._calcAvg(data, loBarIndex, hiBarIndex);

      if (loBarIndex >= 0 && loBarIndex < data.length) {
        min = data[loBarIndex].start;
      }

      if (hiBarIndex >= 0 && hiBarIndex - 1 < data.length) {
        max = data[hiBarIndex - 1].end;
      }

      this.viewModel.set({ total: sum, nulls: nulls, min: min, max: max, avg: avg });
    }
  },

  _calcAvg: function(data, start, end) {

    var selectedData = data.slice(start, end);

    var total = this._calcSum(data, start, end, total);

    if (!total) {
      return 0;
    }

    var area = _.reduce(selectedData, function(memo, d) {
      return (d.avg && d.freq) ? (d.avg * d.freq) + memo : memo;
    }, 0);

    return area / total;
  },

  _calcSum: function(data, start, end) {
    return _.reduce(data.slice(start, end), function(memo, d) {
      return d.freq + memo;
    }, 0);
  },

  _onChangeZoomed: function() {
    if (this.viewModel.get('zoomed')) {
      this._onZoomIn();
    } else {
      this._onZoomOut();
    }
  },

  _onZoomIn: function() {
    this._showMiniRange();
    this.histogramChartView.expand(20);

    this.histogramChartView.removeShadowBars();

    this.model.set({ start: null, end: null, bins: null, own_filter: 1 });
    this.model._fetch();
    this.lockedByUser = false;
  },

  _zoom: function() {
    this.lockedByUser = true;
    this.viewModel.set({ zoomed: true, zoom_enabled: false });
    this.histogramChartView.removeSelection();
  },

  _onZoomOut: function() {
    this.lockedByUser   = true;
    this.lockZoomedData = false;
    this.unsettingRange = true;

    this.model.set({ start: this.start, end: this.end, bins: this.binsCount, own_filter: null });

    this.viewModel.set({ zoom_enabled: false, filter_enabled: false, lo_index: null, hi_index: null });

    this.filter.unsetRange();

    this.histogramChartView.contract(this.defaults.chartHeight);
    this.histogramChartView.resetIndexes();

    this.miniHistogramChartView.hide();
  },

  _showMiniRange: function() {
    var data = this.model.getData();

    var loBarIndex = this.viewModel.get('lo_index');
    var hiBarIndex = this.viewModel.get('hi_index');

    this.miniHistogramChartView.selectRange(loBarIndex, hiBarIndex);
    this.miniHistogramChartView.show();
  },

  _clear: function() {
    this.histogramChartView.removeSelection();
    this.viewModel.set({ zoomed: false, zoom_enabled: false });
    this.viewModel.trigger('change:zoomed');
  }
});

},{"../animate_values.js":33,"../standard/widget_content_view":85,"../widget_content_model":110,"./animation_template.tpl":67,"./chart":68,"./content.tpl":70,"./histogram_title_view":72,"./placeholder.tpl":74}],70:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="js-title"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> </div> <dl class="CDB-Widget-info CDB-Widget-textSmaller CDB-Widget-textSmaller--upper"> <dt class="CDB-Widget-infoItem js-nulls">0 NULL ROWS</dt> <dt class="CDB-Widget-infoItem js-min">0 MIN</dt> <dt class="CDB-Widget-infoItem js-avg">0 AVG</dt> <dt class="CDB-Widget-infoItem js-max">0 MAX</dt> </dl> </div> <div class="CDB-Widget-content js-content"> <div class="CDB-Widget-tooltip js-tooltip"></div> <div class="CDB-Widget-filter CDB-Widget-contentSpaced js-filter is-hidden"> <p class="CDB-Widget-textSmaller CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--upper js-val"></p> <div class="CDB-Widget-filterButtons"> <button class="CDB-Widget-link CDB-Widget-filterButton js-zoom">zoom</button> <button class="CDB-Widget-link CDB-Widget-filterButton js-clear">clear</button> </div> </div> </div>';
}
return __p;
};

},{"underscore":24}],71:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> <div class="CDB-Widget-options CDB-Widget-contentSpaced"> <button class="CDB-Widget-buttonIcon CDB-Widget-buttonIcon--circle js-sizes '+
((__t=( isSizesApplied ? 'is-selected' : '' ))==null?'':_.escape(__t))+
' '+
((__t=( isSizesApplied ? 'js-cancelSizes' : 'js-applySizes' ))==null?'':_.escape(__t))+
'" data-tooltip="'+
((__t=( isSizesApplied ? 'Remove sizes' : 'Apply sizes' ))==null?'':_.escape(__t))+
'"> <i class="CDB-Icon CDB-Icon-syringe CDB-Icon--top"></i> </button> <button class="CDB-Shape-threePoints js-collapse" data-tooltip="'+
((__t=( isCollapsed ? 'Show' : 'Hide' ))==null?'':_.escape(__t))+
'"> <span class="CDB-Shape-threePointsItem"></span> </button> </div>';
}
return __p;
};

},{"underscore":24}],72:[function(require,module,exports){
var _ = cdb._;
var $ = cdb.$;
var View = cdb.core.View;
var TooltipView = require('../widget-tooltip-view');
var template = require('./histogram_title_template.tpl');

/**
 *  Show title + show if histogram sizes are applied or not
 *
 */

module.exports = View.extend({

  className: 'CDB-Widget-title CDB-Widget-contentSpaced',

  events: {
    'click .js-applySizes': '_applySizes',
    'click .js-cancelSizes': '_cancelSizes',
    'click .js-collapse': '_toggleCollapse'
  },

  initialize: function() {
    this.dataModel = this.options.dataModel;
    this._initBinds();
  },

  render: function() {
    this.$el.html(
      template({
        title: this.dataModel.get('title'),
        isSizesApplied: this.dataModel.get('histogramSizes'),
        isCollapsed: this.dataModel.isCollapsed()
      })
    );
    this._initViews();

    return this;
  },

  _initBinds: function() {
    this.dataModel.bind('change:histogramSizes change:collapsed', this.render, this);
    this.add_related_model(this.dataModel);
  },

  _initViews: function() {
    var sizesTooltip = new TooltipView({
      target: this.$('.js-sizes')
    });
    $('body').append(sizesTooltip.render().el);
    this.addView(sizesTooltip);

    var collapseTooltip = new TooltipView({
      target: this.$('.js-collapse')
    });
    $('body').append(collapseTooltip.render().el);
    this.addView(collapseTooltip);
  },

  _applySizes: function() {
    this.dataModel.set('histogramSizes', true);
  },

  _cancelSizes: function() {
    this.dataModel.set('histogramSizes', false);
  },

  _toggleCollapse: function() {
    this.dataModel.toggleCollapsed();
  }

});

},{"../widget-tooltip-view":107,"./histogram_title_template.tpl":71}],73:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  url: function() {
    var params = [];

    if (this.get('columnType')) {
      params.push('column_type=' + this.get('columnType'));
    }
    if (_.isNumber(this.get('start'))) {
      params.push('start=' + this.get('start'));
    }
    if (_.isNumber(this.get('end'))) {
      params.push('end=' + this.get('end'));
    }
    if (_.isNumber(this.get('bins'))) {
      params.push('bins=' + this.get('bins'));
    }
    if (_.isNumber(this.get('own_filter'))) {
      params.push('own_filter=' + this.get('own_filter'));
    }
    if (this.get('boundingBox') && this.get('submitBBox')) {
      params.push('bbox=' + this.get('boundingBox'));
    }

    var url = this.get('url');
    if (params.length > 0) {
        url += '?' + params.join('&');
    }
    return url;
  },

  initialize: function(attrs, opts) {
    WidgetModel.prototype.initialize.apply(this, arguments);
    this._data = new Backbone.Collection(this.get('data'));

    // BBox should only be included until after the first fetch, since we want to get the range of the full dataset
    this.once('change:data', function() {
      this.set('submitBBox', true);
    }, this);

    this.layer.bind('change:meta', this._onChangeLayerMeta, this);
  },

  getData: function() {
    return this._data.toJSON();
  },

  getSize: function() {
    return this._data.size();
  },

  parse: function(data) {
    var numberOfBins = data.bins_count;
    var width = data.bin_width;
    var nulls = data.nulls_count;
    var start = data.bins_start;

    var buckets = new Array(numberOfBins);

    _.each(data.bins, function(b) {
      buckets[b.bin] = b;
    });

    for (var i = 0; i < numberOfBins; i++) {
      buckets[i] = _.extend({
        bin: i,
        start: start + (i * width),
        end: start + ((i + 1) * width),
        freq: 0
      }, buckets[i]);
    }

    this._data.reset(buckets);

    return {
      data: buckets,
      nulls: data.nulls
    };
  },

  // set bins for the histograms
  // @bins should be an array with the format [{ start: ..., end: ..., freq: ..., min: ..., max:   }, ...]
  //    - start, end: are the bucket bounds
  //    - min, max: the min and the max value for all the points in that bucket
  //    - freq: count
  setBins: function(bins, options) {
    this._data.reset(bins, options);
    this.set('data', { bins: bins }, options);
    return this;
  },

  toJSON: function(d) {
    return {
      type: "histogram",
      options: {
        column: this.get('column'),
        bins: this.get('bins')
      }
    };
  },

  _onChangeLayerMeta: function() {
    this.filter.set('columnType', this.layer.get('meta').column_type);
  },

  _onChangeBinds: function() {
    WidgetModel.prototype._onChangeBinds.call(this);
    this.bind('change:histogramSizes', function(mdl, isSizesApplied, d) {
      if (isSizesApplied) {
        this.trigger('histogramSizes', this);
      }
    }, this);
  }
});

},{"../widget_model":111}],74:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-chart CDB-Widget-chart--fake"> ';
 for (var i = 0; i < 15; i++) {
__p+=' <li class="CDB-Widget-chartItem CDB-Widget-chartItem--'+
((__t=( _.sample(['small', 'medium', 'big'], 1)[0] ))==null?'':_.escape(__t))+
' Widget-chartItem--fake"></li> ';
 }
__p+=' </ul>';
}
return __p;
};

},{"underscore":24}],75:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title CDB-Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( itemsCount ))==null?'':_.escape(__t))+
' rows</dt> </dl> </div> <div class="CDB-Widget-content CDB-Widget-content--noSidesMargin"> <div class="CDB-Widget-listWrapper js-content"></div> </div> <div class="CDB-Widget-footer js-footer"></div>';
}
return __p;
};

},{"underscore":24}],76:[function(require,module,exports){
var _ = cdb._;
var format = cdb.core.format;
var WidgetContentView = require('../standard/widget_content_view');
var WidgetListItemsView = require('./items_view');
var WidgetListPaginatorView = require('./paginator_view');
var WidgetListEdgesView = require('./edges_view');
var template = require('./content_template.tpl');
var templatePlaceholder = require('./placeholder_template.tpl');

/**
 * Default widget content view:
 */
module.exports = WidgetContentView.extend({

  options: {
    showScroll: false
  },

  render: function() {
    this.clearSubViews();
    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
    this.$el.html(
      template({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? format.formatValue(data.length) : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    } else {
      this._initViews();
    }

    return this;
  },

  _initViews: function() {
    var count = this.model.getSize();

    // List view -> items view
    this._list = new WidgetListItemsView({
      model: this.model
    });
    this.$('.js-content').html(this._list.render().el);
    this.addView(this._list);

    var isScrollList = (this._list.$el.get(0).scrollHeight - this._list.$el.outerHeight()) > 0;

    if (isScrollList || this.options.showScroll) {
      // Paginator
      this._pagination = new WidgetListPaginatorView({
        $target: this._list.$el
      });
      this.$('.js-footer').append(this._pagination.render().el);
      this.addView(this._pagination);

      // Edges
      this._edges = new WidgetListEdgesView({
        $target: this._list.$el
      });
      this.$('.js-content').append(this._edges.render().el);
      this.addView(this._edges);
    }
  }

});

},{"../standard/widget_content_view":85,"./content_template.tpl":75,"./edges_view":77,"./items_view":80,"./paginator_view":82,"./placeholder_template.tpl":83}],77:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;

/**
 *  List edges view:
 *
 *  - It shows the borders and the shadows, if needed.
 */
module.exports = View.extend({

  _TEMPLATE: ' ' +
    '<div class="CDB-Widget-listEdge CDB-Widget-listEdge--top">'+
      '<div class="CDB-Widget-listEdgeShadow js-topShadow"></div>'+
      '<div class="CDB-Widget-listEdgeBorder"></div>'+
    '</div>'+
    '<div class="CDB-Widget-listEdge CDB-Widget-listEdge--bottom">'+
      '<div class="CDB-Widget-listEdgeShadow js-bottomShadow"></div>'+
      '<div class="CDB-Widget-listEdgeBorder"></div>'+
    '</div>',

  initialize: function() {
    this._$target = this.options.$target;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    var template = _.template(this._TEMPLATE);
    this.$el.html(template());
    this._checkScroll();
    return this;
  },

  _initBinds: function() {
    var self = this;
    this._$target.bind('scroll', function() {
      self._checkScroll();
    });
  },

  _unbindScroll: function() {
    this._$target.unbind('scroll');
  },

  _checkScroll: function() {
    var currentScroll = this._$target.scrollTop();
    var maxScroll = this._$target.get(0).scrollHeight - this._$target.outerHeight();
    this.$('.js-topShadow').toggle(currentScroll !== 0);
    this.$('.js-bottomShadow').toggle(currentScroll !== maxScroll);
  },

  clean: function() {
    this._unbindScroll();
    View.prototype.clean.call(this);
  }

});

},{}],78:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='';
 if (isClickable) {
__p+=' <button type="button" class="CDB-Widget-listItemInner CDB-Widget-listButton CDB-Widget-listButton--withBorder js-button"> ';
 } else {
__p+=' <div class="CDB-Widget-listItemInner CDB-Widget-listItemInner--withBorders"> ';
 }
__p+=' <div class="CDB-Widget-contentSpaced CDB-Widget-contentSpaced--topAligned CDB-Widget-contentSpaced--start"> <em class="CDB-Shape-dot CDB-Widget-listDot"></em> ';
 if (itemsCount > 0) {
__p+=' <div class="CDB-Widget-contentFull"> <p class="CDB-Widget-textSmall CDB-Widget-textSmall--upper CDB-Widget-textSmall--bold" title="'+
((__t=( items[0][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[0][1] ))==null?'':_.escape(__t))+
'</p> ';
 if (itemsCount > 2) {
__p+=' <dl class="CDB-Widget-inlineList"> ';
 for (var i = 1, l = itemsCount; i < l; i++) {
__p+=' <div class="CDB-Widget-inlineListItem CDB-Widget-textSmaller CDB-Widget-textSmaller--noEllip"> <dd class="CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark u-rSpace" title="'+
((__t=( items[i][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[i][1] ))==null?'':_.escape(__t))+
'</dd> <dt title="'+
((__t=( items[i][0] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[i][0] ))==null?'':_.escape(__t))+
'</dt> </div> ';
 }
__p+=' </dl> ';
 } else if (itemsCount === 2) {
__p+=' <dl class="CDB-Widget-textSmaller CDB-Widget-textSmaller--noEllip u-tSpace"> <dd class="CDB-Widget-textSmaller--bold CDB-Widget-textSmaller--dark u-rSpace" title="'+
((__t=( items[1][1] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[1][1] ))==null?'':_.escape(__t))+
'</dd> <dt title="'+
((__t=( items[1][0] ))==null?'':_.escape(__t))+
'">'+
((__t=( items[1][0] ))==null?'':_.escape(__t))+
'</dt> </dl> ';
 }
__p+=' </div> ';
 }
__p+=' </div> ';
 if (isClickable) {
__p+=' </div></button> ';
 } else {
__p+='  ';
 }
__p+='';
}
return __p;
};

},{"underscore":24}],79:[function(require,module,exports){
var _ = cdb._;
var format = cdb.core.format;
var View = cdb.core.View;
var template = require('./item_template.tpl');

module.exports = View.extend({

  tagName: 'li',
  className: 'CDB-Widget-listItem',

  events: {
    'click .js-button': '_onItemClick'
  },

  initialize: function() {
    this.viewModel = this.options.viewModel;
  },

  render: function() {
    var data = this.model.toJSON();
    var hasInteractivity = this._hasInteractivity(data);
    var items = this._sanitizeData(data);

    this.$el.html(
      template({
        items: items,
        isClickable: hasInteractivity,
        itemsCount: _.size(items)
      })
    );

    // If there is no cartodb_id defined, click event should
    // be disabled
    this[ hasInteractivity ? 'delegateEvents' : 'undelegateEvents' ]();
    return this;
  },

  // Remove cartodb_id, if exists
  // Replace titles if there are alternatives
  // Convert data object to array items
  _sanitizeData: function(data) {
    var hasInteractivity = this._hasInteractivity(data);
    var data = _.omit(data, function(value, key, object) {
      return key === 'cartodb_id';
    });

    var columnTitles = this.viewModel.get('columns_title');
    if (hasInteractivity && !_.isEmpty(columnTitles)) {
      columnTitles = _.rest(columnTitles, 1);
    }

    // Convert to pair items and check if there is a column title
    var arr = [];
    var i = 0;

    _.each(data, function(value, key) {
      var title = columnTitles && columnTitles[i] || key;
      arr.push([ title, format.formatValue(value) ]);
      ++i;
    });

    return arr;
  },

  _hasInteractivity: function(data) {
    return !_.isEmpty(
      _.filter(data, function(value, key){
        return key === 'cartodb_id'
      })
    )
  },

  _onItemClick: function() {
    this.trigger('itemClicked', this.model, this);
  }

});

},{"./item_template.tpl":78}],80:[function(require,module,exports){
var View = cdb.core.View;
var WidgetListItemView = require('./item_view');

module.exports = View.extend({

  className: 'CDB-Widget-list js-list',
  tagName: 'ul',

  events: {
    'scroll': '_checkScroll'
  },

  render: function() {
    this.clearSubViews();
    this._renderList();
    return this;
  },

  _renderList: function() {
    this.model.getData().each(this._addItem, this);
  },

  _addItem: function(mdl) {
    var v = new WidgetListItemView({
      model: mdl,
      viewModel: this.model
    });
    v.bind('itemClicked', function(){
      this.trigger('itemClicked', mdl, this);
    }, this);
    this.addView(v);
    this.$el.append(v.render().el);
  }

});

},{"./item_view":79}],81:[function(require,module,exports){
var Backbone = cdb.Backbone;
var WidgetModel = require('../widget_model');

module.exports = WidgetModel.extend({

  options: {
    page: 0,
    per_page: 100
  },

  initialize: function(attrs, opts) {
    this._data = new Backbone.Collection(this.get('data'));
    WidgetModel.prototype.initialize.call(this, attrs, opts);
  },

  getData: function() {
    return this._data;
  },

  getSize: function() {
    return this._data.size();
  },

  parse: function(data) {
    var rows = data.rows;
    this._data.reset(rows);
    return {
      data: rows
    };
  },

  toJSON: function() {
    return {
      type: "list",
      options: {
        columns: this.get('columns')
      }
    };
  }
});

},{"../widget_model":111}],82:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;

module.exports = View.extend({

  className: 'CDB-Widget-nav CDB-Widget-contentSpaced',

  _TEMPLATE: ' ' +
    '<span></span>' +
    '<div class="CDB-Widget-navArrows CDB-Widget-contentSpaced">'+
      '<button class="CDB-Shape-arrow CDB-Shape-arrow--up js-up"></button>'+
      '<button class="CDB-Shape-arrow CDB-Shape-arrow--down js-down"></button>'+
    '</div>',

  events: {
    'click .js-up': '_scrollUp',
    'click .js-down': '_scrollDown'
  },

  initialize: function() {
    if (!this.options.$target) {
      throw new Error('target should be defined in order to be able to paginate');
    }
    this._$target = this.options.$target;
    this._scrollHeight = this._$target.get(0).scrollHeight - this._$target.outerHeight();
    this._initBinds();
  },

  render: function() {
    var template = _.template(this._TEMPLATE);
    this.$el.html(template());
    this._checkScroll();
    return this;
  },

  _initBinds: function() {
    var self = this;
    this._$target.bind('scroll', function() {
      self._checkScroll();
    });
  },

  _unbindScroll: function() {
    this._$target.unbind('scroll');
  },

  _checkScroll: function() {
    var currentScroll = this._$target.scrollTop();
    this.$('.js-up').toggleClass('is-disabled', currentScroll === 0);
    this.$('.js-down').toggleClass('is-disabled', currentScroll >= this._scrollHeight);
  },

  _getEdgeVisibleItems: function() {
    var areaHeight = this._$target.outerHeight();
    var firstEl = null;
    var lastEl = null;
    var items = this._$target.children('.CDB-Widget-listItem');

    items.each(function(index, value) {
      var top = $(this).position().top;
      var height = $(this).outerHeight();

      if (top > -1 && firstEl === null){ //first entirely visible element
        firstEl = this;
      } else if ((top + height) > areaHeight && lastEl === null){
        lastEl = items[index-1];//the last entirely visible was the element before
      }
    });

    return [firstEl,lastEl];
  },

  _scrollDown: function() {
    var lastVisibleItem = this._getEdgeVisibleItems()[1];
    var currentScroll = this._$target.scrollTop();
    var $next = $(lastVisibleItem).next();
    if ($next.length) {
      var top = $next.position().top;
      var height = $next.outerHeight();
      var scrollPos = top + height - this._$target.outerHeight() + currentScroll;
      if (scrollPos > 0) {
        this._$target.scrollTop(scrollPos);
      }
    }
  },

  _scrollUp: function() {
    var firstVisibleItem = this._getEdgeVisibleItems()[0];
    var currentScroll = this._$target.scrollTop();
    var $prev = $(firstVisibleItem).prev();
    if ($prev.length) {
      var top = $prev.position().top;
      var scrollPos = currentScroll + top;
      this._$target.scrollTop(scrollPos);
    }
  },

  clean: function() {
    this._unbindScroll();
    View.prototype.clean.call(this);
  }

});

},{}],83:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-list CDB-Widget-list--withBorders"> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> <li class="CDB-Widget-listItem CDB-Widget-listItem--fake"></li> </ul>';
}
return __p;
};

},{"underscore":24}],84:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header"> <div class="CDB-Widget-title Widget-contentSpaced"> <h3 class="CDB-Widget-textBig" title="'+
((__t=( title ))==null?'':_.escape(__t))+
'">'+
((__t=( title ))==null?'':_.escape(__t))+
'</h3> </div> <dl class="CDB-Widget-info"> <dt class="CDB-Widget-infoItem CDB-Widget-textSmaller CDB-Widget-textSmaller--upper">'+
((__t=( itemsCount ))==null?'':_.escape(__t))+
' items</dt> </dl> </div> <div class="CDB-Widget-content js-content"></div>';
}
return __p;
};

},{"underscore":24}],85:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var log = cdb.log;
var View = cdb.core.View;
var d3 = cdb.d3;
var contentTemplate = require('./widget_content_template.tpl');
var placeholderTemplate = require('./widget_placeholder_template.tpl');

/**
 * Default widget content view:
 */
module.exports = View.extend({

  className: 'CDB-Widget-body',

  initialize: function() {
    this.filter = this.options.filter;
    this._initBinds();
  },

  render: function() {
    this.clearSubViews();
    var data = this.model.getData();
    var isDataEmpty = _.isEmpty(data) || _.size(data) === 0;
    this.$el.html(
      contentTemplate({
        title: this.model.get('title'),
        itemsCount: !isDataEmpty ? data.length : '-'
      })
    );

    if (isDataEmpty) {
      this._addPlaceholder();
    }

    return this;
  },

  _initBinds: function() {
    this.model.bind('change:data', this.render, this);
  },

  _addPlaceholder: function() {
    if (placeholderTemplate) {
      this.$('.js-content').append(placeholderTemplate());
    } else {
      log.info('Placeholder template doesn\'t exist');
    }
  }
});

},{"./widget_content_template.tpl":84,"./widget_placeholder_template.tpl":89}],86:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button class="CDB-Widget-button CDB-Widget-errorButton js-refresh"> <span class="CDB-Widget-textSmall CDB-Widget-textSmall--bold">REFRESH</span> </button>';
}
return __p;
};

},{"underscore":24}],87:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var template = require('./widget_error_template.tpl');

/**
 *  Default widget error view:
 *
 *  It will listen or not to dataModel changes when
 *  first load is done.
 */
module.exports = View.extend({

  className: 'CDB-Widget-error is-hidden',

  events: {
    'click .js-refresh': '_onRefreshClick'
  },

  initialize: function() {
    this._initBinds();
  },

  render: function() {
    this.$el.html(template());
    return this;
  },

  _initBinds: function() {
    this.model.bind('error', this.show, this);
    this.model.bind('loading', this.hide, this);
  },

  _onRefreshClick: function() {
    this.model.refresh();
  },

  show: function() {
    this.$el.removeClass('is-hidden');
  },

  hide: function() {
    this.$el.addClass('is-hidden');
  }

});

},{"./widget_error_template.tpl":86}],88:[function(require,module,exports){
var View = cdb.core.View;

/**
 *  Default widget loader view:
 *
 *  It will listen or not to dataModel changes when
 *  first load is done.
 */
module.exports = View.extend({

  className: 'CDB-Widget-loader',

  initialize: function() {
    this._initBinds();
  },

  _initBinds: function() {
    this.model.bind('loading', this.show, this);
    this.model.bind('sync error', this.hide, this);
  },

  show: function() {
    this.$el.addClass('is-visible');
  },

  hide: function() {
    var self = this;
    setTimeout(function() {
      self.$el.removeClass('is-visible');
    }, 500);
  }

});

},{}],89:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<ul class="CDB-Widget-list CDB-Widget-list--withBorders"> <li class="CDB-Widget-listItem CDB-Widget-listItem--withBorders CDB-Widget-listItem--fake"></li> </ul>';
}
return __p;
};

},{"underscore":24}],90:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var placeholderTemplate = require('./placeholder.tpl');
var HistogramView = require('./histogram-view');

/**
 * Widget content view for a time-series
 */
module.exports = View.extend({

  className: 'CDB-Widget-body CDB-Widget-body--timeSeries',

  initialize: function() {
    this.model.once('change:data', this._onFirstLoad, this);
    this.model.once('error', function() {
      alert('the tiler does not support non-torque layers just yet…');
    });
  },

  render: function() {
    this.clearSubViews();
    this.$el.html(''); // to remove placeholder if there is any

    if (this._isDataEmpty()) {
      this.$el.append(placeholderTemplate({
        hasTorqueLayer: false
      }));
    } else {
      this._appendView(new HistogramView(this.options));
    }

    return this;
  },

  _onFirstLoad: function() {
    this._storeBounds();
    this.model.once('change:data', this.render, this);
    this.model._fetch();
  },

  _storeBounds: function() {
    var data = this.model.getData();
    if (data && data.length > 0) {
      var start = data[0].start;
      var end = data[data.length - 1].end;
      this.model.set({ start: start, end: end, bins: data.length });
    }
  },

  _appendView: function(view) {
    this.addView(view);
    this.$el.append(view.render().el);
  },

  _isDataEmpty: function() {
    var data = this.model.getData();
    return _.isEmpty(data) || _.size(data) === 0;
  }
});

},{"./histogram-view":91,"./placeholder.tpl":92}],91:[function(require,module,exports){
var $ = cdb.$;
var View = cdb.core.View;
var HistogramChartView = require('../histogram/chart');

/**
 * Time-series histogram view.
 */
module.exports = View.extend({

  className: 'CDB-Widget-content CDB-Widget-content--timeSeries',

  defaults: {
    mobileThreshold: 960, // px; should match CSS media-query
    histogramChartHeight:
      48 + // inline bars height
      4 + // bottom margin
      16 + // labels
      4, // margins
    histogramChartMobileHeight:
      20 + // inline bars height (no bottom labels)
      4 // margins
  },

  initialize: function() {
    this.filter = this.options.filter;

    this.model.bind('change:data', this._onChangeData, this);
  },

  render: function() {
    this.clearSubViews();
    this._createHistogramView();
    return this;
  },

  _createHistogramView: function() {
    this._chartView = new HistogramChartView({
      type: 'time',
      animationSpeed: 100,
      margin: {
        top: 4,
        right: 4,
        bottom: 4,
        left: 4
      },
      hasHandles: true,
      animationBarDelay: function(d, i) {
        return (i * 3);
      },
      height: this.defaults.histogramChartHeight,
      data: this.model.getData()
    });
    this.addView(this._chartView);
    this.$el.append(this._chartView.render().el);
    this._chartView.show();

    this._chartView.bind('on_brush_end', this._onBrushEnd, this);
    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this.add_related_model(this._chartView.model);
  },

  _onChangeData: function() {
    if (this._chartView) {
      this._chartView.replaceData(this.model.getData());
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this.model.getData();
    this.filter.setRange(
      data[loBarIndex].start,
      data[hiBarIndex - 1].end
    );
  },

  _onChangeChartWidth: function() {
    var isMobileSize = $(window).width() < this.defaults.mobileThreshold;

    this._chartView.toggleLabels(!isMobileSize);

    var height = isMobileSize
      ? this.defaults.histogramChartMobileHeight
      : this.defaults.histogramChartHeight;
    this._chartView.model.set('height', height);
  }

});

},{"../histogram/chart":68}],92:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header CDB-Widget-header--timeSeries"> ';
 if (hasTorqueLayer) {
__p+=' <div class="CDB-Widget-timeSeriesFakeControl"></div> <div class="CDB-Widget-timeSeriesTimeInfo CDB-Widget-timeSeriesTimeInfo--fake"></div> ';
 }
__p+=' </div> <div class="CDB-Widget-content CDB-Widget-content--timeSeries"> <div class="CDB-Widget-timeSeriesFakeChart ';
 if (hasTorqueLayer) {
__p+='CDB-Widget-timeSeriesFakeChart--torque';
 }
__p+='"> ';
 for (var i = 0; i < 50; i++) {
__p+=' <div class="CDB-Widget-timeSeriesFakeChartItem" style="height: '+
((__t=( Math.floor(Math.random() * 100) ))==null?'':_.escape(__t))+
'%"></div> ';
 }
__p+=' </div> </div>';
}
return __p;
};

},{"underscore":24}],93:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var torqueTemplate = require('./torque-template.tpl');
var placeholderTemplate = require('./placeholder.tpl');
var TorqueHeaderView = require('./torque-header-view');
var TorqueHistogramView = require('./torque-histogram-view');

/**
 * Widget content view for a Torque time-series
 */
module.exports = View.extend({

  className: 'CDB-Widget-body CDB-Widget-body--timeSeries',

  initialize: function() {
    this._torqueLayerModel = this.options.torqueLayerModel;
    this.model.once('change:data', this.render, this);
  },

  render: function() {
    this.clearSubViews();

    if (this._isDataEmpty()) {
      this.$el.html(placeholderTemplate({
        hasTorqueLayer: true
      }));
    } else {
      this.$el.html(torqueTemplate());

      this._appendView(
        new TorqueHeaderView({
          el: this.$('.js-header'),
          model: this.model,
          torqueLayerModel: this._torqueLayerModel
        })
      );

      var view = new TorqueHistogramView(this.options);
      this._appendView(view);
      this.$el.append(view.el);
    }

    return this;
  },

  _appendView: function(view) {
    this.addView(view);
    view.render();
  },

  _isDataEmpty: function() {
    var data = this.model.getData();
    return _.isEmpty(data) || _.size(data) === 0;
  }
});

},{"./placeholder.tpl":92,"./torque-header-view":98,"./torque-histogram-view":99,"./torque-template.tpl":102}],94:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./torque-controls.tpl');

/**
 * Torque animation controls, to manage run state
 */
module.exports = View.extend({

  tagName: 'button',
  className: 'CDB-Widget-controlButton',

  events: {
    'click': '_onClick'
  },

  initialize: function() {
    this.model.bind('change:isRunning', this.render, this);
  },

  render: function() {
    this.$el.html(
      template({
        iconClass: 'CDB-Widget-controlButton-icon CDB-Widget-controlButton-icon--' + (
          this.model.get('isRunning')
            ? 'pause'
            : 'play')
      })
    );

    return this;
  },

  _onClick: function() {
    if (this.model.get('isRunning')) {
      this.model.pause();
    } else {
      this.model.play();
    }
  }
});

},{"./torque-controls.tpl":95}],95:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-controlButton-content"> <i class="'+
((__t=( iconClass ))==null?'':_.escape(__t))+
'"></i> </div>';
}
return __p;
};

},{"underscore":24}],96:[function(require,module,exports){
var View = cdb.core.View;
var d3 = cdb.d3;
var template = require('./torque-cumulative-render-info.tpl');

/**
 * View for to display info about the cumulative render data, e.g. the time range that's being displayed
 * this.model is expected to be a torqueLayer model
 */
module.exports = View.extend({

  initialize: function() {
    this._torqueLayerModel = this.options.torqueLayerModel;

    var data = this.model.get('data');
    this._scale = d3.time.scale()
      .domain([data[0].start * 1000, data[data.length - 1].end * 1000])
      .nice()
      .range([0, this.model.get('bins')]);

    // for format rules see https://github.com/mbostock/d3/wiki/Time-Formatting
    this._timeFormatter = d3.time.format('%H:%M');
    this._dateFormatter = d3.time.format('%x');
  },

  render: function() {
    var cumulativeRender = this._torqueLayerModel.get('cumulativeRender')

    this.$el.html(template({
      timeFormatter: this._timeFormatter,
      dateFormatter: this._dateFormatter,
      startDate: new Date(this._scale.invert(cumulativeRender.start)),
      endDate: new Date(this._scale.invert(cumulativeRender.end))
    }));

    return this;
  }
});

},{"./torque-cumulative-render-info.tpl":97}],97:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<p class="CDB-Widget-textBig CDB-Widget-text--secondary"> Selected from </p> <p class="CDB-Widget-textBig"> '+
((__t=( timeFormatter(startDate) ))==null?'':_.escape(__t))+
' '+
((__t=( dateFormatter(startDate) ))==null?'':_.escape(__t))+
' </p> <p class="CDB-Widget-textBig CDB-Widget-text--secondary"> to </p> <p class="CDB-Widget-textBig"> '+
((__t=( timeFormatter(endDate) ))==null?'':_.escape(__t))+
' '+
((__t=( dateFormatter(endDate) ))==null?'':_.escape(__t))+
' </p>';
}
return __p;
};

},{"underscore":24}],98:[function(require,module,exports){
var _ = cdb._;
var View = cdb.core.View;
var TorqueControlsView = require('./torque-controls-view');
var TorqueTimeInfoView = require('./torque-time-info-view');
var TorqueCumulativeRenderInfoView = require('./torque-cumulative-render-info-view');
var TorqueResetCumulativeRenderView = require('./torque-reset-cumulative-render-view');

/**
 * View for the header in the torque time-series view
 */
module.exports = View.extend({

  initialize: function() {
    this._torqueLayerModel = this.options.torqueLayerModel;
    this._torqueLayerModel.bind('change:cumulativeRender', this.render, this);
    this.add_related_model(this._torqueLayerModel);
  },

  render: function() {
    this.clearSubViews();

    if (this._torqueLayerModel.get('cumulativeRender')) {
      this.el.classList.add('CDB-Widget-contentSpaced');
      // TODO implement view for selected range of cumulativeRender + clear-button
      this._appendView(
        new TorqueCumulativeRenderInfoView({
          model: this.model,
          torqueLayerModel: this._torqueLayerModel
        })
      );
      this._appendView(
        new TorqueResetCumulativeRenderView({
          model: this._torqueLayerModel
        })
      );
    } else {
      this.el.classList.remove('CDB-Widget-contentSpaced');
      this._appendView(
        new TorqueControlsView({
          model: this._torqueLayerModel
        })
      );
      this._appendView(
        new TorqueTimeInfoView({
          model: this._torqueLayerModel
        })
      );
    }

    return this;
  },

  _appendView: function(view) {
    this.addView(view);
    this.$el.append(view.el);
    view.render();
  }
});

},{"./torque-controls-view":94,"./torque-cumulative-render-info-view":96,"./torque-reset-cumulative-render-view":100,"./torque-time-info-view":103}],99:[function(require,module,exports){
var $ = cdb.$;
var View = cdb.core.View;
var HistogramChartView = require('../histogram/chart');
var TorqueTimeSliderView = require('./torque-time-slider-view');

/**
 * Torque time-series histogram view.
 * Extends the common histogram chart view with time-control
 * this.model is a histogram model
 */
module.exports = View.extend({

  className: 'CDB-Widget-content CDB-Widget-content--timeSeries',

  // TODO could be calculated from element styles instead of duplicated numbers here?
  defaults: {
    mobileThreshold: 960, // px; should match CSS media-query
    histogramChartHeight:
      48 + // inline bars height
      4 + // bottom margin
      16 + // bottom labels
      4, // margins
    histogramChartMobileHeight:
      20 + // inline bars height (no bottom labels)
      4 // margins
  },

  initialize: function() {
    if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');
    if (!this.options.rangeFilter) throw new Error('rangeFilter is required');

    this._rangeFilter = this.options.rangeFilter;
    this._torqueLayerModel = this.options.torqueLayerModel;
    this._torqueLayerModel.bind('change:cumulativeRender', this._onChangeCumulativeRender, this);
    this.add_related_model(this._torqueLayerModel);

    this.model.bind('change:data', this._onChangeData, this);
  },

  render: function() {
    this.clearSubViews();
    this._createHistogramView();
    return this;
  },

  _createHistogramView: function() {
    this._chartView = new HistogramChartView({
      type: 'time',
      animationSpeed: 100,
      animationBarDelay: function(d, i) {
        return (i * 3);
      },
      margin: {
        top: 4,
        right: 4,
        bottom: 4,
        left: 4
      },
      hasHandles: true,
      height: this.defaults.histogramChartHeight,
      data: this.model.getData(),
      shadowData: this.model.getData()
    });

    this.addView(this._chartView);
    this.$el.append(this._chartView.render().el);
    this._chartView.show();

    this._chartView.bind('on_brush_end', this._onBrushEnd, this);
    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this.add_related_model(this._chartView.model);

    var timeSliderView = new TorqueTimeSliderView({
      model: this.model, // a histogram model
      chartView: this._chartView,
      torqueLayerModel: this._torqueLayerModel
    });
    this.addView(timeSliderView);
    timeSliderView.render();
  },

  _onChangeData: function() {
    if (this._chartView) {
      this._chartView.replaceData(this.model.getData());
    }
  },

  _onChangeCumulativeRender: function(m, val) {
    if (!val) {
      this._chartView.removeSelection();
    }
  },

  _onBrushEnd: function(loBarIndex, hiBarIndex) {
    var data = this.model.getData();
    this._rangeFilter.setRange(
      data[loBarIndex].start,
      data[hiBarIndex - 1].end
    );
    this._torqueLayerModel.setCumulativeRender(loBarIndex, hiBarIndex);
  },

  _onChangeChartWidth: function() {
    var isMobileSize = $(window).width() < this.defaults.mobileThreshold;

    this._chartView.toggleLabels(!isMobileSize);

    var height = isMobileSize
      ? this.defaults.histogramChartMobileHeight
      : this.defaults.histogramChartHeight;
    this._chartView.model.set('height', height);
  }

});

},{"../histogram/chart":68,"./torque-time-slider-view":105}],100:[function(require,module,exports){
var View = cdb.core.View;
var template = require('./torque-reset-cumulative-render.tpl');

/**
 * View to reset cumulative render.
 * this.model is expected to be a torqueLayer model
 */
module.exports = View.extend({

  className: 'CDB-Widget-filterButtons',
  events: {
    'click .js-clear': '_onClick'
  },

  render: function() {
    this.$el.html(template());
    return this;
  },

  _onClick: function() {
    this.model.resetCumulativeRender();
  }
});

},{"./torque-reset-cumulative-render.tpl":101}],101:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<button class="CDB-Widget-link CDB-Widget-filterButton js-clear">Clear selection</button>';
}
return __p;
};

},{"underscore":24}],102:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<div class="CDB-Widget-header CDB-Widget-header--timeSeries js-header"></div>';
}
return __p;
};

},{"underscore":24}],103:[function(require,module,exports){
var _ = cdb._;
var d3 = cdb.d3;
var View = cdb.core.View;
var template = require('./torque-time-info.tpl');

/**
 * View rendering the current step time
 *
 * Model is expected to be a torque layer model
 */
module.exports = View.extend({

  className: 'CDB-Widget-timeSeriesTimeInfo',

  initialize: function() {
    this.model.bind('change:step', this.render, this);

    // for format rules see https://github.com/mbostock/d3/wiki/Time-Formatting
    this._timeFormatter = d3.time.format('%H:%M');
    this._dateFormatter = d3.time.format('%x');
  },

  render: function() {
    var date = this.model.get('time');

    this.$el.html(
      isNaN(date && date.getTime())
        ? ''
        : template({
            time: this._timeFormatter(date),
            date: this._dateFormatter(date)
          })
    );

    return this;
  }
});

},{"./torque-time-info.tpl":104}],104:[function(require,module,exports){
var _ = require('underscore');
module.exports = function(obj){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
with(obj||{}){
__p+='<p class="CDB-Widget-textBig"> '+
((__t=( time ))==null?'':_.escape(__t))+
' </p> <p class="CDB-Widget-textBig CDB-Widget-text--secondary"> '+
((__t=( date ))==null?'':_.escape(__t))+
' </p>';
}
return __p;
};

},{"underscore":24}],105:[function(require,module,exports){
var d3 = cdb.d3;
var Model = cdb.core.Model;
var View = cdb.core.View;

/**
 * Time-slider, expected to be used in a histogram view
 */
module.exports = View.extend({

  defaults: {
    width: 4,
    height: 8
  },

  initialize: function() {
    if (!this.options.model) throw new Error('model is required');
    if (!this.options.chartView) throw new Error('chartView is required');
    if (!this.options.torqueLayerModel) throw new Error('torqeLayerModel is required');

    this._chartView = this.options.chartView;
    this._torqueLayerModel = this.options.torqueLayerModel;
    this.viewModel = new Model();

    this._torqueLayerModel.bind('change:step', this._onChangeStep, this);
    this._torqueLayerModel.bind('change:steps', this._onChangeSteps, this);
    this._torqueLayerModel.bind('change:stepsRange', this._onStepsRange, this);
    this._torqueLayerModel.bind('change:cumulativeRender', this._onChangeCumulativeRender, this);
    this.add_related_model(this._torqueLayerModel);

    this._chartView.model.bind('change:width', this._onChangeChartWidth, this);
    this._chartView.model.bind('change:height', this._onChangeChartHeight, this);
    this.add_related_model(this._chartView.model);

    this._updateXScale();
  },

  render: function() {
    // Make the render call idempotent; only create time slider once
    if (!this.timeSlider) {
      var dragBehavior = d3.behavior.drag()
        .on('dragstart', this._onDragStart.bind(this))
        .on('drag', this._onDrag.bind(this))
        .on('dragend', this._onDragEnd.bind(this));

      var d3el = this._chartView.canvas.append('rect');
      this.timeSlider = d3el
        .attr('class', 'CDB-TimeSlider')
        .attr('width', this.defaults.width)
        .attr('height', this._calcHeight())
        .attr('rx', 3)
        .attr('ry', 3)
        .data([{ x: 0, y: 0 }])
        .attr('transform', this._translateXY)
        .call(dragBehavior);
    }
    this.setElement(d3el.node());

    return this;
  },

  clean: function() {
    if (this.timeSlider) {
      this.timeSlider.remove();
    }
    View.prototype.clean.call(this);
  },

  _onDragStart: function() {
    var isRunning = this._torqueLayerModel.get('isRunning');
    if (isRunning) {
      this._torqueLayerModel.pause();
    }
    this.viewModel.set({
      isDragging: true,
      wasRunning: isRunning
    });
  },

  _onDrag: function(d, i) {
    var nextX = d.x + d3.event.dx;
    if (this._isWithinRange(nextX)) {
      d.x = nextX;
      this.timeSlider.attr('transform', this._translateXY);

      var step = Math.round(this._xScale.invert(d.x));
      this._torqueLayerModel.setStep(step);
    }
  },

  _onDragEnd: function() {
    this.viewModel.set('isDragging', false);
    if (this.viewModel.get('wasRunning')) {
      this._torqueLayerModel.play();
    }
  },

  _translateXY: function(d) {
    return 'translate(' + [d.x, d.y] + ')';
  },

  _isWithinRange: function(x) {
    return x >= 0 && x <= this._width();
  },

  _onChangeStep: function() {
    // Time slider might not be created when this method is first called
    if (this.timeSlider && !this.viewModel.get('isDragging')) {
      var data = this.timeSlider.data();
      var newX = this._xScale(this._torqueLayerModel.get('step'));
      if (!isNaN(newX)) {
        data[0].x = newX;
        this.timeSlider
          .data(data)
          .transition()
          .ease('linear')
          .attr('transform', this._translateXY);
      }
    }
  },

  _onChangeSteps: function() {
    this._updateXScale();
  },

  _onStepsRange: function() {
    var r = this._torqueLayerModel.get('stepsRange');
    if (r.start === 0 && r.end === this.model.get('bins')) {
      this._chartView.removeSelection();
    } else {
      this._chartView.selectRange(r.start, r.end);
    }
  },

  _onChangeCumulativeRender: function(m, val) {
    this.$el.toggle(!val);
  },

  _onChangeChartWidth: function() {
    this._updateXScale();
    this._onChangeStep();
  },

  _onChangeChartHeight: function() {
    this.timeSlider.attr('height', this._calcHeight());
  },

  _calcHeight: function() {
    return this._chartView.chartHeight() + this.defaults.height;
  },

  _updateXScale: function() {
    this._xScale = d3.scale.linear()
      .domain([0, this._torqueLayerModel.get('steps')])
      .range([0, this._width()]);
  },

  _width: function() {
    return this._chartView.model.get('width');
  }

});

},{}],106:[function(require,module,exports){
var _ = cdb._;

var WidgetModelFactory = function (types) {
  types = types || {};
  this.types = {};
  for (var type in types) {
    var createModel = types[type];
    this.addType(type, createModel);
  }
};

WidgetModelFactory.prototype.addType = function (type, createModel) {
  if (!_.isString(type)) new Error('type must be a string or a function');
  if (!_.isFunction(createModel)) new Error('createModel must be a function');
  this.types[type] = createModel;
};

WidgetModelFactory.prototype.createModel = function (layer, layerIndex, attrs) {
  if (!attrs.id) throw new Error('attrs.id is required');

  var createModel = this.types[attrs.type];
  if (createModel) {
    var opts = {
      layer: layer
    };
    return createModel(attrs, opts, layerIndex);
  } else {
    throw new Error('no model found for arguments ' + arguments);
  }
};

module.exports = WidgetModelFactory;

},{}],107:[function(require,module,exports){
var View = cdb.core.View;
var _ = cdb._;

/**
 * Standard widget tooltip view
 *
 */
module.exports = View.extend({

  className: 'CDB-Widget-tooltip',

  options: {
    attribute: 'data-tooltip',
    offsetX: 10,
    offsetY: -28
  },

  initialize: function(opts) {
    if (!opts.target) {
      throw new Error('target is not defined');
    }
    this._$target = this.options.target;
    this._initBinds();
  },

  render: function() {
    var value = this._$target.attr(this.options.attribute);
    this.$el.html(value);
    return this;
  },

  _initBinds: function() {
    this._$target.hover(
      _.bind(this.show, this),
      _.bind(this.hide, this)
    );
  },

  _setPosition: function() {
    var pos = this._$target.offset();
    var width = this.$el.outerWidth();

    this.$el.css({
      top: pos.top + this.options.offsetY,
      left: pos.left - (width/2) + this.options.offsetX
    });
  },

  show: function() {
    this.render();
    this._setPosition();
    View.prototype.show.call(this);
  },

  clean: function() {
    this._$target.off('mouseenter mouseleave');
    View.prototype.clean.call(this);
  }

});

},{}],108:[function(require,module,exports){
var _ = cdb._;
var WidgetView = require('./widget-view');

var WidgetViewFactory = function(defs) {
  this.defs = [];
  _.each(defs, function(def) {
    this.addType(def);
  }, this);
};

WidgetViewFactory.prototype.DEFAULT_CLASS_NAMES = 'CDB-Widget CDB-Widget--light';

WidgetViewFactory.prototype.addType = function(def) {
  if (!def.match) {
    if (def.type) {
      def.match = function(widget) {
        return widget.get('type') === this.type;
      };
    } else {
      new Error('def.type or def.match must be provided for createContentView to work');
    }
  }
  if (!_.isFunction(def.createContentView)) new Error('def.createContentView must be a function');
  this.defs.push(def);
};

/**
 * @returns {Object, undefined} Returns nothing if there is not matching view for the given model
 */
WidgetViewFactory.prototype.createWidgetView = function(widget) {
  var def = _.find(this.defs, function(def) {
    return def.match(widget);
  });

  if (def) {
    var attrs = {
      className: this.DEFAULT_CLASS_NAMES,
      model: widget,
      contentView: def.createContentView(widget)
    };

    return new WidgetView(
      _.isFunction(def.customizeWidgetAttrs)
        ? def.customizeWidgetAttrs(attrs)
        : attrs
    );
  }
};

module.exports = WidgetViewFactory;

},{"./widget-view":109}],109:[function(require,module,exports){
var View = cdb.core.View;
var WidgetLoaderView = require('./standard/widget_loader_view');
var WidgetErrorView = require('./standard/widget_error_view');

/**
 * Default widget view
 * The model is a expected to be widget model
 */
module.exports = View.extend({

  className: 'CDB-Widget CDB-Widget--light',

  options: {
    columns_title: [],
    sync: true
  },

  initialize: function() {
    this.model.layer.bind('change:visible', this._onChangeLayerVisible, this);
  },

  render: function() {
    this._loader = new WidgetLoaderView({
      model: this.model
    });
    this.$el.append(this._loader.render().el);
    this.addView(this._loader);

    this._error = new WidgetErrorView({
      model: this.model
    });
    this.$el.append(this._error.render().el);
    this.addView(this._error);

    var contentView = this.options.contentView;
    this.$el.append(contentView.render().el);
    this.addView(contentView);

    return this;
  },

  _onChangeLayerVisible: function(layer) {
    // !! to force a boolean value, so only a true value actually shows the view
    this.$el.toggle(!!layer.get('visible'));
  }
});

},{"./standard/widget_error_view":87,"./standard/widget_loader_view":88}],110:[function(require,module,exports){
var Model = cdb.core.Model;

/**
 *  View model, special for widgets with search and collapse
 *  functionalities
 *
 */

module.exports = Model.extend({

  defaults: {
    search: false
  },

  toggleSearch: function() {
    this.set('search', !this.get('search'));
  },

  enableSearch: function() {
    this.set('search', true);
  },

  disableSearch: function() {
    this.set('search', false);
  },

  isSearchEnabled: function() {
    return this.get('search');
  }

});

},{}],111:[function(require,module,exports){
var Model = cdb.core.Model;

/**
 * Default widget model
 */
module.exports = Model.extend({

  defaults: {
    url: '',
    data: [],
    columns: [],
    sync: true,
    bbox: true,
    collapsed: false
  },

  url: function() {
    return this.get('url') + '?bbox=' + this.get('boundingBox');
  },

  initialize: function(attrs, opts) {
    opts = opts || {};

    this.layer = opts.layer;
    this.filter = opts.filter; // optional/might be undefined

    this._initBinds();
  },

  _initBinds: function() {
    this.once('change:url', function() {
      var self = this;
      this._fetch(function() {
        self._onChangeBinds();
      });
    }, this);

    // Retrigger an event when the filter changes
    if (this.filter) {
      this.filter.bind('change', this._onFilterChanged, this);
    }
  },

  _onChangeBinds: function() {
    this.bind('change:url', function(){
      if (this.get('sync') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);
    this.bind('change:boundingBox', function() {
      if (this.get('bbox') && !this.isCollapsed()) {
        this._fetch();
      }
    }, this);

    this.bind('change:collapsed', function(mdl, isCollapsed) {
      if (!isCollapsed) {
        if (mdl.changedAttributes(this._previousAttrs)) {
          this._fetch();
        }
      } else {
        this._previousAttrs = {
          url: this.get('url'),
          boundingBox: this.get('boundingBox')
        };
      }
    }, this);
  },

  _fetch: function(callback) {
    var self = this;
    this.fetch({
      success: callback,
      error: function() {
        self.trigger('error');
      }
    });
  },

  refresh: function() {
    this._fetch();
  },

  isCollapsed: function() {
    return this.get('collapsed');
  },

  toggleCollapsed: function() {
    this.set('collapsed', !this.get('collapsed'));
  },

  _onFilterChanged: function(filter) {
    this.trigger('change:filter', this, filter);
  },

  getData: function() {
    return this.get('data');
  },

  getPreviousData: function() {
    return this.previous('data');
  },

  fetch: function(opts) {
    this.trigger("loading", this);
    return Model.prototype.fetch.call(this,opts);
  },

  toJSON: function() {
    throw new Error('toJSON should be defined for each widget');
  }
});

},{}],112:[function(require,module,exports){
var Backbone = cdb.Backbone;
var _ = cdb._;

/**
 *  Collection that controls widget models per layer
 *
 */
module.exports = Backbone.Collection.extend({

  initialize: function() {
    this._initBinds();
  },

  _initBinds: function() {
    // If a category model applies the category colors, rest should remove/disable
    // the category colors applied before.
    this.bind('change:categoryColors', function(m, isColorCategorized) {
      if (isColorCategorized) {
        this.each(function(mdl) {
          if (mdl !== m && mdl.get('categoryColors')) {
            mdl.set('categoryColors', false);
          }
        })
      }
    }, this);

    // If a histogram model applies the histogram sizes, rest should remove/disable
    // the sizes applied before.
    this.bind('change:histogramSizes', function(m, isSizesApplied) {
      if (isSizesApplied) {
        this.each(function(mdl) {
          if (mdl !== m && mdl.get('histogramSizes')) {
            mdl.set('histogramSizes', false);
          }
        })
      }
    }, this);
  }

});

},{}],113:[function(require,module,exports){
var $ = cdb.$;
var _ = cdb._;
var LZMA = cdb.LZMA;
var util = cdb.core.util;
var WindshaftDashboardInstance = require('./dashboard-instance');

var validatePresenceOfOptions = function(options, requiredOptions) {
  var missingOptions = _.filter(requiredOptions, function(option) {
    return !options[option];
  });
  if (missingOptions.length) {
    throw 'The following options are required: ' + missingOptions.join(', ');
  }
};

/**
 * Windshaft client. It provides a method to create instances of dashboards.
 * @param {object} options Options to set up the client
 */
WindshaftClient = function(options) {
  validatePresenceOfOptions(options, ['urlTemplate', 'userName', 'endpoint', 'statTag']);

  this.urlTemplate = options.urlTemplate;
  this.userName = options.userName;
  this.endpoint = options.endpoint;
  this.statTag = options.statTag;
  this.forceCors = options.forceCors || false;

  this.url = this.urlTemplate.replace('{user}', this.userName);
};

WindshaftClient.DEFAULT_COMPRESSION_LEVEL = 3;
WindshaftClient.MAX_GET_SIZE = 2033;

/**
 * Creates an instance of a map in Windshaft
 * @param {object} mapDefinition An object that responds to .toJSON with the definition of the map
 * @param  {function} callback A callback that will get the public or private map
 * @return {cdb.windshaft.DashboardInstance} The instance of the dashboard
 */
WindshaftClient.prototype.instantiateMap = function(options) {
  var mapDefinition = options.mapDefinition;
  var filters = options.filters;
  var successCallback = options.success;
  var errorCallback = options.error;
  var payload = JSON.stringify(mapDefinition);

  var options = {
    success: function(data) {
      if (data.errors) {
        errorCallback(data.errors[0]);
      } else {
        data.urlTemplate = this.urlTemplate;
        data.userName = this.userName;
        successCallback(new WindshaftDashboardInstance(data));
      }
    }.bind(this),
    error: function(xhr) {
      var err = { errors: ['Unknown error'] };
      try {
        err = JSON.parse(xhr.responseText);
      } catch(e) {}
      errorCallback(err.errors[0]);
    }
  };

  // TODO: Move this
  var params = [
    ["stat_tag", this.statTag].join("=")
  ];

  var filters = filters || {};
  if (Object.keys(filters).length) {
    params.push(["filters", encodeURIComponent(JSON.stringify(filters))].join('='));
  }

  if (this._usePOST(payload, params)) {
    this._post(payload, params, options);
  } else {
    this._get(payload, params, options);
  }
}

WindshaftClient.prototype._usePOST = function(payload, params) {
  if (util.isCORSSupported() && this.forceCors) {
    return true;
  }
  return payload.length >= this.constructor.MAX_GET_SIZE;
}

WindshaftClient.prototype._post = function(payload, params, options) {
  $.ajax({
    crossOrigin: true,
    method: 'POST',
    dataType: 'json',
    contentType: 'application/json',
    url: this._getURL(params),
    data: payload,
    success: options.success,
    error: options.error
  });
}

WindshaftClient.prototype._get = function(payload, params, options) {
  var compressFunction = this._getCompressor(payload);
  compressFunction(payload, this.constructor.DEFAULT_COMPRESSION_LEVEL, function(dataParameter) {
    params.push(dataParameter);
    $.ajax({
      url: this._getURL(params),
      method: 'GET',
      dataType: 'jsonp',
      jsonpCallback: this._jsonpCallbackName(payload),
      cache: true,
      success: options.success,
      error: options.error
    });
  }.bind(this));
}

WindshaftClient.prototype._getCompressor = function(payload) {
  if (payload.length < this.constructor.MAX_GET_SIZE) {
    return function(data, level, callback) {
      callback("config=" + encodeURIComponent(data));
    };
  }

  return function(data, level, callback) {
    data = JSON.stringify({ config: data });
    LZMA.compress(data, level, function(encoded) {
      callback("lzma=" + encodeURIComponent(util.array2hex(encoded)));
    });
  };
}


WindshaftClient.prototype._getURL = function(params) {
  return [this.url, this.endpoint].join('/') + '?' + params.join('&');
}

WindshaftClient.prototype._jsonpCallbackName = function(payload) {
  return '_cdbc_' + util.uniqueCallbackName(payload);
}

module.exports = WindshaftClient;

},{"./dashboard-instance":115}],114:[function(require,module,exports){
var config = {};
config.MAPS_API_BASE_URL = 'api/v1/map'

module.exports = config;

},{}],115:[function(require,module,exports){
var _ = cdb._;
var Model = cdb.core.Model;
var WindshaftConfig = require('./config');
var EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";

module.exports = Model.extend({

  TILE_EXTENSIONS_BY_LAYER_TYPE: {
    'mapnik': '.png',
    'torque': '.json.torque'
  },

  initialize: function() {

    // TODO: What params are really used?
    this.pngParams = ['map_key', 'api_key', 'cache_policy', 'updated_at'];
    this.gridParams = ['map_key', 'api_key', 'cache_policy', 'updated_at'];
  },

  isLoaded: function() {
    return !!this.get('layergroupid');
  },

  getBaseURL: function(subhost) {
    return [
      this._getHost(subhost),
      WindshaftConfig.MAPS_API_BASE_URL,
      this._getMapId(),
    ].join('/');
  },

  _getMapId: function() {
    return this.get('layergroupid');
  },

  _getHost: function(subhost) {
    var userName = this.get('userName');
    var protocol = this._useHTTPS() ? 'https' : 'http';
    var subhost = subhost ? subhost + '.' : '';
    var host = this.get('urlTemplate').replace('{user}', userName);
    var cdnHost = this.get('cdn_url') && this.get('cdn_url')[protocol];
    if (cdnHost) {
      host = [protocol, '://', subhost, cdnHost, '/', userName].join('');
    }

    return host;
  },

  _useHTTPS: function() {
    return this.get('urlTemplate').indexOf('https') === 0;
  },

  getTiles: function(layerType, params) {
    var grids = [];
    var tiles = [];

    var pngParams = this._encodeParams(params, this.pngParams);
    var gridParams = this._encodeParams(params, this.gridParams);
    var subdomains = ['0', '1', '2', '3'];

    if(this._useHTTPS()) {
      subdomains = [''];
    }

    layerType = layerType || 'mapnik';

    var layerIndexes = this._getLayerIndexesByType(layerType);
    if (layerIndexes.length) {
      var gridTemplate = '/{z}/{x}/{y}';

      for(var i = 0; i < subdomains.length; ++i) {
        var subdomain = subdomains[i];
        var tileURLTemplate = [
          this.getBaseURL(subdomain),
          '/',
          layerIndexes.join(','),
          '/{z}/{x}/{y}',
          this.TILE_EXTENSIONS_BY_LAYER_TYPE[layerType],
          (pngParams ? "?" + pngParams: '')
        ].join('');

        tiles.push(tileURLTemplate);

        // for mapnik layers add grid json too
        if (layerType === 'mapnik') {
          for(var layer = 0; layer < this.get('metadata').layers.length; ++layer) {
            var index = this._getLayerIndexByType(layer, "mapnik");
            if (index >= 0) {
              var gridURLTemplate = [
                this.getBaseURL(subdomain),
                "/",
                index,
                gridTemplate,
                ".grid.json",
                (gridParams ? "?" + gridParams: '')
              ].join("");
              grids[layer] = grids[layer] || [];
              grids[layer].push(gridURLTemplate);
            }
          }
        }
      }
    } else {
      // TODO: Clients of this method should decide what to render if no layers are present
      tiles = [EMPTY_GIF];
    }

    this.urls = {
      tiles: tiles,
      grids: grids
    };
    return this.urls;
  },

  getLayerMeta: function(layerIndex) {
    var layerMeta = {};
    var layers = this.get('metadata') && this.get('metadata').layers;
    if (layers && layers[layerIndex]) {
        layerMeta = layers[layerIndex].meta || {};
    }
    return layerMeta;
  },

  _encodeParams: function(params, included) {
    if(!params) return '';
    var url_params = [];
    included = included || _.keys(params);
    for(var i in included) {
      var k = included[i];
      var p = params[k];
      if(p) {
        if (_.isArray(p)) {
          for (var j = 0, len = p.length; j < len; j++) {
            url_params.push(k + "[]=" + encodeURIComponent(p[j]));
          }
        } else {
          var q = encodeURIComponent(p);
          q = q.replace(/%7Bx%7D/g,"{x}").replace(/%7By%7D/g,"{y}").replace(/%7Bz%7D/g,"{z}");
          url_params.push(k + "=" + q);
        }
      }
    }
    return url_params.join('&');
  },

  /**
   * Returns the index of a layer of a given type, as the tiler kwows it.
   *
   * @param {string|array} types - Type or types of layers
   */
  _getLayerIndexesByType: function(types) {
    var layers = this.get('metadata') && this.get('metadata').layers;

    if (!layers) {
      return;
    }
    var layerIndexes = [];
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var isValidType = false;
      if (types && types.length > 0) {
        isValidType = types.indexOf(layer.type) != -1;
      }
      if (isValidType) {
        layerIndexes.push(i);
      }
    }
    return layerIndexes;
  },

  /**
   * Returns the index of a layer of a given type, as the tiler kwows it.
   *
   * @param {integer} index - number of layer of the specified type
   * @param {string} layerType - type of the layers
   */
  _getLayerIndexByType: function(index, layerType) {
    var layers = this.get('metadata') && this.get('metadata').layers;

    if (!layers) {
      return index;
    }

    var tilerLayerIndex = {};
    var j = 0;
    for (var i = 0; i < layers.length; i++) {
      if (layers[i].type == layerType) {
        tilerLayerIndex[j] = i;
        j++;
      }
    }
    if (tilerLayerIndex[index] === undefined) {
      return -1;
    }
    return tilerLayerIndex[index];
  },

  getWidgetURL: function(options) {
    var widgetId = options.widgetId;
    var protocol = options.protocol;
    var url;
    var layers = this.get('metadata') && this.get('metadata').layers;

    _.each(layers, function(layer) {
      var widgets = layer.widgets;
      for (var id in widgets) {
        if (widgetId === id) {
          url = widgets[id].url[protocol];
          return;
        }
      }
    });

    return url;
  }
});

},{"./config":114}],116:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WindshaftFiltersCollection = require('./filters/collection');
var WindshaftFiltersBoundingBoxFilter = require('./filters/bounding_box');
var WindshaftDashboardInstance = require('./dashboard-instance');

var WindshaftDashboard = function(options) {
  BOUNDING_BOX_FILTER_WAIT = 500;

  this.layerGroup = options.layerGroup;
  this.layers = new Backbone.Collection(options.layers);
  this.widgets = options.widgets;
  this.map = options.map;
  this.client = options.client;
  this.statTag = options.statTag;
  this.configGenerator = options.configGenerator;

  this.instance = new WindshaftDashboardInstance();

  this.map.bind('change:center change:zoom', _.debounce(this._boundingBoxChanged, BOUNDING_BOX_FILTER_WAIT), this);

  this.layers.bind('change', this._layerChanged, this);
  this.widgets.bind('change:filter', this._filterChanged, this);

  this._createInstance();
};

WindshaftDashboard.prototype._createInstance = function(options) {
  var options = options || {};

  var dashboardConfig = this.configGenerator.generate({
    layers: this.layers.models,
    widgets: this.widgets
  });


  var filtersFromVisibleLayers = this.widgets.chain()
    .filter(function(w) { return w.layer.isVisible() })
    .map(function(w) { return w.filter })
    .compact() // not all widgets have filters
    .value();

  var filters = new WindshaftFiltersCollection(filtersFromVisibleLayers);

  this.client.instantiateMap({
    mapDefinition: dashboardConfig,
    filters: filters.toJSON(),
    success: function(dashboardInstance) {

      // Update the dashboard instance with the attributes of the new one
      this.instance.set(dashboardInstance.toJSON());

      // TODO: Set the URL of the attributes service once it's available
      this.layerGroup && this.layerGroup.set({
        baseURL: dashboardInstance.getBaseURL(),
        urls: dashboardInstance.getTiles('mapnik')
      });

      // update other kind of layers too
      this.layers.each(function(layer, layerIndex) {
        if (layer.get('type') === 'torque') {
          layer.set('meta', dashboardInstance.getLayerMeta(layerIndex));
          layer.set('urls', dashboardInstance.getTiles('torque'));
        }
      });

      this._updateWidgetURLs({
        layerId: options.layerId
      });

    }.bind(this),
    error: function(error) {
      console.log('Error creating dashboard instance: ' + error);
    }
  });

  return this.instance;
};

WindshaftDashboard.prototype._boundingBoxChanged = function() {
  if (this.instance.isLoaded()) {
    this._updateWidgetURLs();
  }
};

WindshaftDashboard.prototype._updateWidgetURLs = function(options) {
  options = options || {};
  var boundingBoxFilter = new WindshaftFiltersBoundingBoxFilter(this.map.getViewBounds());
  var boundingBox = boundingBoxFilter.toString();
  var layerId = options.layerId;

  this.widgets.each(function(widget) {
    var url = this.instance.getWidgetURL({
      widgetId: widget.get('id'),
      protocol: 'http'
    });

    var layerMeta = widget.layer.get('meta') || {};
    var extraAttrs = {};
    if (layerMeta.steps && layerMeta.column_type && _.isNumber(layerMeta.start) && _.isNumber(layerMeta.end)) {
      extraAttrs = {
        bins: layerMeta.steps,
        columnType: layerMeta.column_type,
        start: layerMeta.start  / 1000,
        end:  layerMeta.end / 1000
      };
    }

    widget.set(_.extend({
      'url': url,
      'boundingBox': boundingBox
    }, extraAttrs), {
      silent: layerId && layerId !== widget.layer.get('id')
    });
  }, this);
};

WindshaftDashboard.prototype._filterChanged = function(w) {
  this._createInstance({
    layerId: w.layer.get('id')
  });
};

WindshaftDashboard.prototype._layerChanged = function(layer) {
  var layerId = layer.get('id');
  this._createInstance({
    layerId: layerId
  });
};

module.exports = WindshaftDashboard;

},{"./dashboard-instance":115,"./filters/bounding_box":118,"./filters/collection":120}],117:[function(require,module,exports){
var Model = cdb.core.Model;

module.exports = Model.extend({

  isEmpty: function() {
    throw "Filters must implement the .isEmpty method";
  },

  toJSON: function() {
    throw "Filters must implement the .toJSON method";
  }
});

},{}],118:[function(require,module,exports){
var Model = cdb.core.Model;

module.exports = Model.extend({

  initialize: function(bounds) {
    this.setBounds(bounds);
  },

  setBounds: function(bounds) {
    this.set({
      west: bounds[0][1],
      south: bounds[0][0],
      east: bounds[1][1],
      north: bounds[1][0]
    });
  },

  toString: function() {
    return [
      this.get('west'),
      this.get('south'),
      this.get('east'),
      this.get('north')
    ].join(',');
  }
});

},{}],119:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;
var WindshaftFilterBase = require('./base');

/**
 *  Filter used by the category widget
 *
 */
module.exports = WindshaftFilterBase.extend({

  defaults: {
    rejectAll: false
  },

  initialize: function() {
    this.rejectedCategories = new Backbone.Collection();
    this.acceptedCategories = new Backbone.Collection();
    this._initBinds();
  },

  _initBinds: function() {
    this.rejectedCategories.bind('add remove', function() {
      this.set('rejectAll', false);
    }, this);
    this.acceptedCategories.bind('add remove', function() {
      this.set('rejectAll', false);
    }, this);
  },

  isEmpty: function() {
    return this.rejectedCategories.size() === 0 && this.acceptedCategories.size() === 0 && !this.get('rejectAll');
  },

  accept: function(values, applyFilter) {
    values = !_.isArray(values) ? [values] : values;
    var acceptedCount = this.acceptedCategories.size();

    _.each(values, function(value) {
      var d = { name: value };
      var rejectedMdls = this.rejectedCategories.where(d);
      var acceptedMdls = this.acceptedCategories.where(d);
      if (rejectedMdls.length > 0) {
        this.rejectedCategories.remove(rejectedMdls);
      }
      if (!acceptedMdls.length) {
        this.acceptedCategories.add(d);
      }
    }, this);

    if (applyFilter !== false) {
      this.applyFilter();
    }
  },

  acceptAll: function() {
    this.set('rejectAll', false);
    this.cleanFilter();
  },

  isAccepted: function(name) {
    return this.acceptedCategories.where({ name: name }).length > 0;
  },

  getAccepted: function() {
    return this.acceptedCategories;
  },

  reject: function(values, applyFilter) {
    values = !_.isArray(values) ? [values] : values;

    _.each(values, function(value) {
      var d = { name: value };
      var acceptedMdls = this.acceptedCategories.where(d);
      var rejectedMdls = this.rejectedCategories.where(d);
      if (acceptedMdls.length > 0) {
        this.acceptedCategories.remove(acceptedMdls);
      } else {
        if (!rejectedMdls.length) {
          this.rejectedCategories.add(d);
        }
      }
    }, this);

    if (applyFilter !== false) {
      this.applyFilter();
    }
  },

  isRejected: function(name) {
    var rejectCount = this.rejectedCategories.size();
    var acceptCount = this.acceptedCategories.size();
    if (this.rejectedCategories.where({ name: name }).length > 0) {
      return true;
    } else if (acceptCount > 0 && this.acceptedCategories.where({ name: name }).length === 0) {
      return true;
    } else if (this.get('rejectAll')) {
      return true;
    } else {
      return false;
    }
  },

  getRejected: function() {
    return this.rejectedCategories;
  },

  rejectAll: function() {
    this.set('rejectAll', true);
    this.cleanFilter();
  },

  cleanFilter: function(triggerChange) {
    this.acceptedCategories.reset();
    this.rejectedCategories.reset();
    if (triggerChange !== false) {
      this.applyFilter();
    }
  },

  applyFilter: function() {
    this.trigger('change', this);
  },

  toJSON: function() {
    var filter = {};
    var rejectCount = this.rejectedCategories.size();
    var acceptCount = this.acceptedCategories.size();
    var acceptedCats = { accept: _.pluck(this.acceptedCategories.toJSON(), 'name') };
    var rejectedCats = { reject: _.pluck(this.rejectedCategories.toJSON(), 'name') };

    if (this.get('rejectAll')) {
      filter = { accept: [] };
    } else if (acceptCount > 0) {
      filter = acceptedCats;
    } else if (rejectCount > 0 && acceptCount === 0) {
      filter = rejectedCats;
    }

    var json = {};
    json[this.get('widgetId')] = filter;

    return json;
  }
});

},{"./base":117}],120:[function(require,module,exports){
var _ = cdb._;
var Backbone = cdb.Backbone;

module.exports = Backbone.Collection.extend({

  toJSON: function() {
    var json = {};
    var activeFilters = this.getActiveFilters();
    if (activeFilters.length) {
      json.layers = [];
      _.each(activeFilters, function(filter) {
        if (!filter.isEmpty()) {
          var index = filter.get('layerIndex');
          if (json.layers[index]) {
            _.extend(json.layers[index],filter.toJSON());
          } else {
            json.layers[index] = filter.toJSON();
          }
        }
      });
      // fill the holes
      for (var i = 0; i < json.layers.length; ++i) {
        json.layers[i] = json.layers[i] || {};
      }
    }

    return json;
  },

  getActiveFilters: function() {
    return this.filter(function(filter) {
      return !filter.isEmpty();
    });
  }
});

},{}],121:[function(require,module,exports){
var _ = cdb._;
var WindshaftFilterBase = require('./base');

module.exports = WindshaftFilterBase.extend({

  isEmpty: function() {
    return _.isUndefined(this.get('min')) && _.isUndefined(this.get('max'));
  },

  setRange: function(min, max) {
    this.set({
      min: min,
      max: max
    });
  },

  unsetRange: function() {
    this.setRange(undefined, undefined);
  },

  toJSON: function() {
    var json = {};
    json[this.get('widgetId')] = {
      min: this.get('min'),
      max: this.get('max'),
      column_type: this.get('columnType')
    };

    return json;
  }
});

},{"./base":117}],122:[function(require,module,exports){
var _ = cdb._;
var WindshaftPrivateDashboardConfig = {};

WindshaftPrivateDashboardConfig.generate = function(options) {
  var layers = options.layers;
  var config = {};

  _.each(layers, function(layer, index){
    config['layer' + index] = layer.isVisible() ? 1 : 0;
  });

  // TODO: We should add the params
  // TODO: We should add the auth_token
  return config;
};

module.exports = WindshaftPrivateDashboardConfig;

},{}],123:[function(require,module,exports){
var _ = cdb._;
var WindshaftPublicDashboardConfig = {};

WindshaftPublicDashboardConfig.generate = function(options) {
  var layers = options.layers;
  var widgets = options.widgets;
  var config = { layers: [] };
  _.each(layers, function(layer) {
    if (layer.isVisible()) {
      var layerConfig = {
        type: layer.get('type').toLowerCase(),
        options: {
          sql: layer.get('sql'),
          cartocss: layer.get('cartocss'),
          cartocss_version: layer.get('cartocss_version'),
          interactivity: layer.getInteractiveColumnNames()
        }
      };
      if (layer.getInfowindowFieldNames().length) {
        layerConfig.options.attributes = {
          id: "cartodb_id",
          columns: layer.getInfowindowFieldNames()
        };
      }

      layerConfig.options.widgets = {};
      var layerId = layer.get('id');
      widgets.each(function(widget) {
        if (layerId === widget.layer.get('id')) {
          layerConfig.options.widgets[widget.get('id')] = widget.toJSON();
        }
      });
      config.layers.push(layerConfig);
    }
  });

  return config;
};

module.exports = WindshaftPublicDashboardConfig;

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvY2xhc3MuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9kb20uanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL2xpYi9ldmVudC1tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9saWIvZ3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbGliL2hlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2RlZmF1bHQtc2V0dGluZy5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL2NsaWNrLXJhaWwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL2RyYWctc2Nyb2xsYmFyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaGFuZGxlci9rZXlib2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvbW91c2Utd2hlZWwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL25hdGl2ZS1zY3JvbGwuanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9oYW5kbGVyL3NlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL2hhbmRsZXIvdG91Y2guanMiLCJub2RlX21vZHVsZXMvcGVyZmVjdC1zY3JvbGxiYXIvc3JjL2pzL3BsdWdpbi9pbml0aWFsaXplLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vaW5zdGFuY2VzLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vdXBkYXRlLWdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL3NyYy9qcy9wbHVnaW4vdXBkYXRlLXNjcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmZWN0LXNjcm9sbGJhci9zcmMvanMvcGx1Z2luL3VwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJzcmMvY3JlYXRlLWRhc2hib2FyZC5qcyIsInNyYy9kYXNoYm9hcmQtYmVsb3ctbWFwLXZpZXcuanMiLCJzcmMvZGFzaGJvYXJkLWluZm8tdmlldy5qcyIsInNyYy9kYXNoYm9hcmQtaW5mby12aWV3LnRwbCIsInNyYy9kYXNoYm9hcmQtc2lkZWJhci12aWV3LmpzIiwic3JjL2Rhc2hib2FyZC1zaWRlYmFyLnRwbCIsInNyYy9kYXNoYm9hcmQtdmlldy5qcyIsInNyYy9kYXNoYm9hcmQudHBsIiwic3JjL3dpZGdldHMvYW5pbWF0ZV92YWx1ZXMuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9jb250ZW50X3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2NvbnRlbnRfdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3QvaXRlbS9pdGVtX2NsaWNrYWJsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vaXRlbV91bmNsaWNrYWJsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vaXRlbV92aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtL3NlYXJjaF9pdGVtX2NsaWNrYWJsZV90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L2l0ZW0vc2VhcmNoX2l0ZW1fdmlldy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L2xpc3QvaXRlbXNfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9pdGVtc192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbGlzdC9zZWFyY2hfaXRlbXNfbm9fcmVzdWx0c190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9saXN0L3NlYXJjaF9pdGVtc192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWwuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9tb2RlbHMvY2F0ZWdvcmllc19jb2xsZWN0aW9uLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2NhdGVnb3J5X2NvbG9ycy5qcyIsInNyYy93aWRnZXRzL2NhdGVnb3J5L21vZGVscy9jYXRlZ29yeV9pdGVtX21vZGVsLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2NhdGVnb3J5X21vZGVsX3JhbmdlLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWxzL2xvY2tlZF9jYXRlZ29yaWVzX2NvbGxlY3Rpb24uanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9tb2RlbHMvc2VhcmNoX21vZGVsLmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvb3B0aW9ucy9vcHRpb25zX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L29wdGlvbnMvb3B0aW9uc192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvcGFnaW5hdG9yL3BhZ2luYXRvcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9wYWdpbmF0b3IvcGFnaW5hdG9yX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9wYWdpbmF0b3Ivc2VhcmNoX3BhZ2luYXRvcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9wYWdpbmF0b3Ivc2VhcmNoX3BhZ2luYXRvcl92aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvc3RhdHMvY2F0c190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9zdGF0cy9zdGF0c190ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9jYXRlZ29yeS9zdGF0cy9zdGF0c192aWV3LmpzIiwic3JjL3dpZGdldHMvY2F0ZWdvcnkvdGl0bGUvc2VhcmNoX3RpdGxlX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2NhdGVnb3J5L3RpdGxlL3NlYXJjaF90aXRsZV92aWV3LmpzIiwic3JjL3dpZGdldHMvZm9ybXVsYS9hbmltYXRpb25fdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvZm9ybXVsYS9jb250ZW50X3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9mb3JtdWxhL21vZGVsLmpzIiwic3JjL3dpZGdldHMvZm9ybXVsYS90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9jaGFydC5qcyIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9jb250ZW50LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vY29udGVudC50cGwiLCJzcmMvd2lkZ2V0cy9oaXN0b2dyYW0vaGlzdG9ncmFtX3RpdGxlX3RlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9oaXN0b2dyYW1fdGl0bGVfdmlldy5qcyIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9tb2RlbC5qcyIsInNyYy93aWRnZXRzL2hpc3RvZ3JhbS9wbGFjZWhvbGRlci50cGwiLCJzcmMvd2lkZ2V0cy9saXN0L2NvbnRlbnRfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvbGlzdC9jb250ZW50X3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L2VkZ2VzX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L2l0ZW1fdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvbGlzdC9pdGVtX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L2l0ZW1zX3ZpZXcuanMiLCJzcmMvd2lkZ2V0cy9saXN0L21vZGVsLmpzIiwic3JjL3dpZGdldHMvbGlzdC9wYWdpbmF0b3Jfdmlldy5qcyIsInNyYy93aWRnZXRzL2xpc3QvcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvc3RhbmRhcmQvd2lkZ2V0X2NvbnRlbnRfdGVtcGxhdGUudHBsIiwic3JjL3dpZGdldHMvc3RhbmRhcmQvd2lkZ2V0X2NvbnRlbnRfdmlldy5qcyIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9lcnJvcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy9zdGFuZGFyZC93aWRnZXRfZXJyb3Jfdmlldy5qcyIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9sb2FkZXJfdmlldy5qcyIsInNyYy93aWRnZXRzL3N0YW5kYXJkL3dpZGdldF9wbGFjZWhvbGRlcl90ZW1wbGF0ZS50cGwiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy9jb250ZW50LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy9oaXN0b2dyYW0tdmlldy5qcyIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3BsYWNlaG9sZGVyLnRwbCIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS1jb250ZW50LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtY29udHJvbHMtdmlldy5qcyIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS1jb250cm9scy50cGwiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtY3VtdWxhdGl2ZS1yZW5kZXItaW5mby12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWN1bXVsYXRpdmUtcmVuZGVyLWluZm8udHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWhlYWRlci12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWhpc3RvZ3JhbS12aWV3LmpzIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXJlc2V0LWN1bXVsYXRpdmUtcmVuZGVyLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy90aW1lLXNlcmllcy90b3JxdWUtcmVzZXQtY3VtdWxhdGl2ZS1yZW5kZXIudHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXRlbXBsYXRlLnRwbCIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS10aW1lLWluZm8tdmlldy5qcyIsInNyYy93aWRnZXRzL3RpbWUtc2VyaWVzL3RvcnF1ZS10aW1lLWluZm8udHBsIiwic3JjL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLXRpbWUtc2xpZGVyLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXQtbW9kZWwtZmFjdG9yeS5qcyIsInNyYy93aWRnZXRzL3dpZGdldC10b29sdGlwLXZpZXcuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXQtdmlldy1mYWN0b3J5LmpzIiwic3JjL3dpZGdldHMvd2lkZ2V0LXZpZXcuanMiLCJzcmMvd2lkZ2V0cy93aWRnZXRfY29udGVudF9tb2RlbC5qcyIsInNyYy93aWRnZXRzL3dpZGdldF9tb2RlbC5qcyIsInNyYy93aWRnZXRzL3dpZGdldHMtY29sbGVjdGlvbi5qcyIsInNyYy93aW5kc2hhZnQvY2xpZW50LmpzIiwic3JjL3dpbmRzaGFmdC9jb25maWcuanMiLCJzcmMvd2luZHNoYWZ0L2Rhc2hib2FyZC1pbnN0YW5jZS5qcyIsInNyYy93aW5kc2hhZnQvZGFzaGJvYXJkLmpzIiwic3JjL3dpbmRzaGFmdC9maWx0ZXJzL2Jhc2UuanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvYm91bmRpbmdfYm94LmpzIiwic3JjL3dpbmRzaGFmdC9maWx0ZXJzL2NhdGVnb3J5LmpzIiwic3JjL3dpbmRzaGFmdC9maWx0ZXJzL2NvbGxlY3Rpb24uanMiLCJzcmMvd2luZHNoYWZ0L2ZpbHRlcnMvcmFuZ2UuanMiLCJzcmMvd2luZHNoYWZ0L3ByaXZhdGUtZGFzaGJvYXJkLWNvbmZpZy5qcyIsInNyYy93aW5kc2hhZnQvcHVibGljLWRhc2hib2FyZC1jb25maWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZURhc2hib2FyZDogcmVxdWlyZSgnLi9zcmMvY3JlYXRlLWRhc2hib2FyZCcpXG59O1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjEwLjZcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc0FNb21lbnRPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fc3RyaWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3R6bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc1VUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3BmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbG9jYWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKCkge1xuICAgIH1cblxuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdIHx8IG5ldyBMb2NhbGUoKTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdldF9zZXRfX3NldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdW5pdDtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodW5pdCBpbiB1bml0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHVuaXQsIHVuaXRzW3VuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW3VuaXRzXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbiAoc3RoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMzI1XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RoID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RoKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1ttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIG91dCBvZiBoZXJlIVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5cbiAgICB2YXIgZnJvbV9zdHJpbmdfX2lzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZHsyfS1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC8oVHwgKVxcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZnJvbV9zdHJpbmdfX2lzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbNl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gKG1hdGNoWzZdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaChtYXRjaE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gJ1onO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IGxvY2FsX19jcmVhdGVMb2NhbChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssICdkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgdmFyIHdlZWsxSmFuID0gNiArIGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3REYXlPZldlZWtPZlllYXIsIGphblggPSBjcmVhdGVVVENEYXRlKHllYXIsIDAsIDEgKyB3ZWVrMUphbiksIGQgPSBqYW5YLmdldFVUQ0RheSgpLCBkYXlPZlllYXI7XG4gICAgICAgIGlmIChkIDwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgICAgIGQgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHdlZWtkYXkgPSB3ZWVrZGF5ICE9IG51bGwgPyAxICogd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyB3ZWVrMUphbiArIDcgKiAod2VlayAtIDEpIC0gZCArIHdlZWtkYXk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCBkb3csIGRveSkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCAxKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IGRvdykge1xuICAgICAgICAgICAgICAgICAgICArK3dlZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xuXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoT2Zmc2V0KSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2lzRFNUU2hpZnRlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIHZhciBjcmVhdGVfX2lzb1JlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGNyZWF0ZV9faXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChmb3JtYXRzICYmIGZvcm1hdHNbZm9ybWF0XSB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRNcyA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzIDwgK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgaW5wdXRNcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpICYmIHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyksXG4gICAgICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0LFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiArdGhpcy5fZCAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkX19pc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgMCwgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IGxvY2FsZS5fb3JkaW5hbFBhcnNlIDogbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gdGhpcy5fd2Vla2RheXNQYXJzZSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGxvY2FsX19jcmVhdGVMb2NhbChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm90b3R5cGVfX3Byb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgID0gY2xvbmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kaWZmICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgPSBmb3JtYXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICA9IHRvO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9Ob3cgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgPSBpbnZhbGlkQXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgPSBpc0JldHdlZW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgID0gbG9jYWxlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICA9IHN0YXJ0T2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICA9IHRvT2JqZWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9EYXRlICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICA9IHRvU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udW5peCAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG5cbiAgICAvLyBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4gICAgLy8gV2VlayBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuICAgIC8vIFF1YXJ0ZXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuICAgIC8vIE1vbnRoXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuICAgIC8vIFdlZWtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWsgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2VlayAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuICAgIC8vIERheVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXkgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4gICAgLy8gSG91clxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91ciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4gICAgLy8gTWludXRlXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbiAgICAvLyBTZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuICAgIC8vIE1pbGxpc2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbiAgICAvLyBPZmZzZXRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUU2hpZnRlZCAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE3NzknLCBnZXRTZXRab25lKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLl9jYWxlbmRhciAgICAgICA9IGRlZmF1bHRDYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5fbG9uZ0RhdGVGb3JtYXQgPSBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9pbnZhbGlkRGF0ZSAgICA9IGRlZmF1bHRJbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWwgICAgICAgID0gZGVmYXVsdE9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWxQYXJzZSAgID0gZGVmYXVsdE9yZGluYWxQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9yZWxhdGl2ZVRpbWUgICA9IGRlZmF1bHRSZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICA9IGxvY2FsZV9zZXRfX3NldDtcblxuICAgIC8vIE1vbnRoXG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRocyAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydCA9IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1BhcnNlICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcblxuICAgIC8vIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWsgPSBkZWZhdWx0TG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzICAgICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pbiAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0ID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21lcmlkaWVtUGFyc2UgPSBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fZ2V0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgY291bnQsIHNldHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzJywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0JywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3QgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgID09PSAxICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA9PT0gMSAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPT09IDEgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgID09PSAxICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTAuNic7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlVW5peDtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c01pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9qcy9tYWluJyk7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9sZEFkZChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgdmFyIGNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPCAwKSB7XG4gICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gIH1cbiAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gb2xkUmVtb3ZlKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICB2YXIgY2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIHZhciBpZHggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgaWYgKGlkeCA+PSAwKSB7XG4gICAgY2xhc3Nlcy5zcGxpY2UoaWR4LCAxKTtcbiAgfVxuICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xufVxuXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgb2xkQWRkKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gIH1cbn07XG5cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBvbGRSZW1vdmUoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0cy5saXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbGVtZW50LmNsYXNzTGlzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gIH1cbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSB7fTtcblxuRE9NLmUgPSBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuRE9NLmFwcGVuZFRvID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcbiAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcblxuZnVuY3Rpb24gY3NzR2V0KGVsZW1lbnQsIHN0eWxlTmFtZSkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbc3R5bGVOYW1lXTtcbn1cblxuZnVuY3Rpb24gY3NzU2V0KGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgc3R5bGVWYWx1ZSA9IHN0eWxlVmFsdWUudG9TdHJpbmcoKSArICdweCc7XG4gIH1cbiAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNzc011bHRpU2V0KGVsZW1lbnQsIG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gdmFsLnRvU3RyaW5nKCkgKyAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW2tleV0gPSB2YWw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbkRPTS5jc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QsIHN0eWxlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZU5hbWVPck9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBtdWx0aXBsZSBzZXQgd2l0aCBvYmplY3RcbiAgICByZXR1cm4gY3NzTXVsdGlTZXQoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjc3NHZXQoZWxlbWVudCwgc3R5bGVOYW1lT3JPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3NzU2V0KGVsZW1lbnQsIHN0eWxlTmFtZU9yT2JqZWN0LCBzdHlsZVZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbkRPTS5tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5tYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMocXVlcnkpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC5tYXRjaGVzU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzU2VsZWN0b3IocXVlcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvcihxdWVyeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yKHF1ZXJ5KTtcbiAgICB9XG4gIH1cbn07XG5cbkRPTS5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQucmVtb3ZlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuRE9NLnF1ZXJ5Q2hpbGRyZW4gPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBET00ubWF0Y2hlcyhjaGlsZCwgc2VsZWN0b3IpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5ldmVudHMgPSB7fTtcbn07XG5cbkV2ZW50RWxlbWVudC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLmV2ZW50c1tldmVudE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgfVxuICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbGVtZW50LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIHZhciBpc0hhbmRsZXJQcm92aWRlZCA9ICh0eXBlb2YgaGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGhkbHIpIHtcbiAgICBpZiAoaXNIYW5kbGVyUHJvdmlkZWQgJiYgaGRsciAhPT0gaGFuZGxlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGRsciwgZmFsc2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgdGhpcyk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmV2ZW50cykge1xuICAgIHRoaXMudW5iaW5kKG5hbWUpO1xuICB9XG59O1xuXG52YXIgRXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZXZlbnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50RWxlbWVudC5lbGVtZW50ID09PSBlbGVtZW50O1xuICB9KVswXTtcbiAgaWYgKHR5cGVvZiBlZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlZSA9IG5ldyBFdmVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgdGhpcy5ldmVudEVsZW1lbnRzLnB1c2goZWUpO1xuICB9XG4gIHJldHVybiBlZTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCkuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpLnVuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ldmVudEVsZW1lbnRzW2ldLnVuYmluZEFsbCgpO1xuICB9XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIHZhciBlZSA9IHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgb25jZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGVlLnVuYmluZChldmVudE5hbWUsIG9uY2VIYW5kbGVyKTtcbiAgICBoYW5kbGVyKGUpO1xuICB9O1xuICBlZS5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudE1hbmFnZXI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gczQoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHM0KCkgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgK1xuICAgICAgICAgICBzNCgpICsgJy0nICsgczQoKSArIHM0KCkgKyBzNCgpO1xuICB9O1xufSkoKTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNscyA9IHJlcXVpcmUoJy4vY2xhc3MnKVxuICAsIGQgPSByZXF1aXJlKCcuL2RvbScpO1xuXG5leHBvcnRzLnRvSW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKSB8fCAwO1xufTtcblxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5jbG9uZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAob3JpZ2luYWwsIHNvdXJjZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZShvcmlnaW5hbCk7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICByZXN1bHRba2V5XSA9IHRoaXMuY2xvbmUoc291cmNlW2tleV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLmlzRWRpdGFibGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGQubWF0Y2hlcyhlbCwgXCJpbnB1dCxbY29udGVudGVkaXRhYmxlXVwiKSB8fFxuICAgICAgICAgZC5tYXRjaGVzKGVsLCBcInNlbGVjdCxbY29udGVudGVkaXRhYmxlXVwiKSB8fFxuICAgICAgICAgZC5tYXRjaGVzKGVsLCBcInRleHRhcmVhLFtjb250ZW50ZWRpdGFibGVdXCIpIHx8XG4gICAgICAgICBkLm1hdGNoZXMoZWwsIFwiYnV0dG9uLFtjb250ZW50ZWRpdGFibGVdXCIpO1xufTtcblxuZXhwb3J0cy5yZW1vdmVQc0NsYXNzZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgY2xzTGlzdCA9IGNscy5saXN0KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gY2xzTGlzdFtpXTtcbiAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ3BzLScpID09PSAwKSB7XG4gICAgICBjbHMucmVtb3ZlKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLm91dGVyV2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gdGhpcy50b0ludChkLmNzcyhlbGVtZW50LCAnd2lkdGgnKSkgK1xuICAgICAgICAgdGhpcy50b0ludChkLmNzcyhlbGVtZW50LCAncGFkZGluZ0xlZnQnKSkgK1xuICAgICAgICAgdGhpcy50b0ludChkLmNzcyhlbGVtZW50LCAncGFkZGluZ1JpZ2h0JykpICtcbiAgICAgICAgIHRoaXMudG9JbnQoZC5jc3MoZWxlbWVudCwgJ2JvcmRlckxlZnRXaWR0aCcpKSArXG4gICAgICAgICB0aGlzLnRvSW50KGQuY3NzKGVsZW1lbnQsICdib3JkZXJSaWdodFdpZHRoJykpO1xufTtcblxuZXhwb3J0cy5zdGFydFNjcm9sbGluZyA9IGZ1bmN0aW9uIChlbGVtZW50LCBheGlzKSB7XG4gIGNscy5hZGQoZWxlbWVudCwgJ3BzLWluLXNjcm9sbGluZycpO1xuICBpZiAodHlwZW9mIGF4aXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2xzLmFkZChlbGVtZW50LCAncHMtJyArIGF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGNscy5hZGQoZWxlbWVudCwgJ3BzLXgnKTtcbiAgICBjbHMuYWRkKGVsZW1lbnQsICdwcy15Jyk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc3RvcFNjcm9sbGluZyA9IGZ1bmN0aW9uIChlbGVtZW50LCBheGlzKSB7XG4gIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLWluLXNjcm9sbGluZycpO1xuICBpZiAodHlwZW9mIGF4aXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2xzLnJlbW92ZShlbGVtZW50LCAncHMtJyArIGF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGNscy5yZW1vdmUoZWxlbWVudCwgJ3BzLXgnKTtcbiAgICBjbHMucmVtb3ZlKGVsZW1lbnQsICdwcy15Jyk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZW52ID0ge1xuICBpc1dlYktpdDogJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgc3VwcG9ydHNUb3VjaDogKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFxuICBzdXBwb3J0c0llUG9pbnRlcjogd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICE9PSBudWxsXG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVzdHJveSA9IHJlcXVpcmUoJy4vcGx1Z2luL2Rlc3Ryb3knKVxuICAsIGluaXRpYWxpemUgPSByZXF1aXJlKCcuL3BsdWdpbi9pbml0aWFsaXplJylcbiAgLCB1cGRhdGUgPSByZXF1aXJlKCcuL3BsdWdpbi91cGRhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gIHVwZGF0ZTogdXBkYXRlLFxuICBkZXN0cm95OiBkZXN0cm95XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IDAsXG4gIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IDAsXG4gIHN0b3BQcm9wYWdhdGlvbk9uQ2xpY2s6IHRydWUsXG4gIHN1cHByZXNzU2Nyb2xsWDogZmFsc2UsXG4gIHN1cHByZXNzU2Nyb2xsWTogZmFsc2UsXG4gIHN3aXBlUHJvcGFnYXRpb246IHRydWUsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IGZhbHNlLFxuICB1c2VLZXlib2FyZDogdHJ1ZSxcbiAgdXNlU2VsZWN0aW9uU2Nyb2xsOiBmYWxzZSxcbiAgd2hlZWxQcm9wYWdhdGlvbjogZmFsc2UsXG4gIHdoZWVsU3BlZWQ6IDFcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkID0gcmVxdWlyZSgnLi4vbGliL2RvbScpXG4gICwgaCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXInKVxuICAsIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuXG4gIGlmICghaSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGkuZXZlbnQudW5iaW5kQWxsKCk7XG4gIGQucmVtb3ZlKGkuc2Nyb2xsYmFyWCk7XG4gIGQucmVtb3ZlKGkuc2Nyb2xsYmFyWSk7XG4gIGQucmVtb3ZlKGkuc2Nyb2xsYmFyWFJhaWwpO1xuICBkLnJlbW92ZShpLnNjcm9sbGJhcllSYWlsKTtcbiAgaC5yZW1vdmVQc0NsYXNzZXMoZWxlbWVudCk7XG5cbiAgaW5zdGFuY2VzLnJlbW92ZShlbGVtZW50KTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBiaW5kQ2xpY2tSYWlsSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIGZ1bmN0aW9uIHBhZ2VPZmZzZXQoZWwpIHtcbiAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgdmFyIHN0b3BQcm9wYWdhdGlvbiA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uLmJpbmQ7XG5cbiAgaWYgKGkuc2V0dGluZ3Muc3RvcFByb3BhZ2F0aW9uT25DbGljaykge1xuICAgIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclksICdjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XG4gIH1cbiAgaS5ldmVudC5iaW5kKGkuc2Nyb2xsYmFyWVJhaWwsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhhbGZPZlNjcm9sbGJhckxlbmd0aCA9IGgudG9JbnQoaS5zY3JvbGxiYXJZSGVpZ2h0IC8gMik7XG4gICAgdmFyIHBvc2l0aW9uVG9wID0gaS5yYWlsWVJhdGlvICogKGUucGFnZVkgLSB3aW5kb3cuc2Nyb2xsWSAtIHBhZ2VPZmZzZXQoaS5zY3JvbGxiYXJZUmFpbCkudG9wIC0gaGFsZk9mU2Nyb2xsYmFyTGVuZ3RoKTtcbiAgICB2YXIgbWF4UG9zaXRpb25Ub3AgPSBpLnJhaWxZUmF0aW8gKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCk7XG4gICAgdmFyIHBvc2l0aW9uUmF0aW8gPSBwb3NpdGlvblRvcCAvIG1heFBvc2l0aW9uVG9wO1xuXG4gICAgaWYgKHBvc2l0aW9uUmF0aW8gPCAwKSB7XG4gICAgICBwb3NpdGlvblJhdGlvID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uUmF0aW8gPiAxKSB7XG4gICAgICBwb3NpdGlvblJhdGlvID0gMTtcbiAgICB9XG5cbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgKiBwb3NpdGlvblJhdGlvKTtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuXG4gIGlmIChpLnNldHRpbmdzLnN0b3BQcm9wYWdhdGlvbk9uQ2xpY2spIHtcbiAgICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYLCAnY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xuICB9XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclhSYWlsLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBoYWxmT2ZTY3JvbGxiYXJMZW5ndGggPSBoLnRvSW50KGkuc2Nyb2xsYmFyWFdpZHRoIC8gMik7XG4gICAgdmFyIHBvc2l0aW9uTGVmdCA9IGkucmFpbFhSYXRpbyAqIChlLnBhZ2VYIC0gd2luZG93LnNjcm9sbFggLSBwYWdlT2Zmc2V0KGkuc2Nyb2xsYmFyWFJhaWwpLmxlZnQgLSBoYWxmT2ZTY3JvbGxiYXJMZW5ndGgpO1xuICAgIHZhciBtYXhQb3NpdGlvbkxlZnQgPSBpLnJhaWxYUmF0aW8gKiAoaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpO1xuICAgIHZhciBwb3NpdGlvblJhdGlvID0gcG9zaXRpb25MZWZ0IC8gbWF4UG9zaXRpb25MZWZ0O1xuXG4gICAgaWYgKHBvc2l0aW9uUmF0aW8gPCAwKSB7XG4gICAgICBwb3NpdGlvblJhdGlvID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uUmF0aW8gPiAxKSB7XG4gICAgICBwb3NpdGlvblJhdGlvID0gMTtcbiAgICB9XG5cbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCAoKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkgKiBwb3NpdGlvblJhdGlvKSAtIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50KTtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZENsaWNrUmFpbEhhbmRsZXIoZWxlbWVudCwgaSk7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5JylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGJpbmRNb3VzZVNjcm9sbFhIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgdmFyIGN1cnJlbnRMZWZ0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQYWdlWCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsTGVmdChkZWx0YVgpIHtcbiAgICB2YXIgbmV3TGVmdCA9IGN1cnJlbnRMZWZ0ICsgKGRlbHRhWCAqIGkucmFpbFhSYXRpbyk7XG4gICAgdmFyIG1heExlZnQgPSBpLnNjcm9sbGJhclhSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyAoaS5yYWlsWFJhdGlvICogKGkucmFpbFhXaWR0aCAtIGkuc2Nyb2xsYmFyWFdpZHRoKSk7XG5cbiAgICBpZiAobmV3TGVmdCA8IDApIHtcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSAwO1xuICAgIH0gZWxzZSBpZiAobmV3TGVmdCA+IG1heExlZnQpIHtcbiAgICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBtYXhMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpLnNjcm9sbGJhclhMZWZ0ID0gbmV3TGVmdDtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGgudG9JbnQoaS5zY3JvbGxiYXJYTGVmdCAqIChpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpIC8gKGkuY29udGFpbmVyV2lkdGggLSAoaS5yYWlsWFJhdGlvICogaS5zY3JvbGxiYXJYV2lkdGgpKSkgLSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudDtcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBzY3JvbGxMZWZ0KTtcbiAgfVxuXG4gIHZhciBtb3VzZU1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB1cGRhdGVTY3JvbGxMZWZ0KGUucGFnZVggLSBjdXJyZW50UGFnZVgpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBoLnN0b3BTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcbiAgICBpLmV2ZW50LnVuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgfTtcblxuICBpLmV2ZW50LmJpbmQoaS5zY3JvbGxiYXJYLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBjdXJyZW50UGFnZVggPSBlLnBhZ2VYO1xuICAgIGN1cnJlbnRMZWZ0ID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclgsICdsZWZ0JykpICogaS5yYWlsWFJhdGlvO1xuICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcblxuICAgIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICBpLmV2ZW50Lm9uY2UoaS5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsWUhhbmRsZXIoZWxlbWVudCwgaSkge1xuICB2YXIgY3VycmVudFRvcCA9IG51bGw7XG4gIHZhciBjdXJyZW50UGFnZVkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFRvcChkZWx0YVkpIHtcbiAgICB2YXIgbmV3VG9wID0gY3VycmVudFRvcCArIChkZWx0YVkgKiBpLnJhaWxZUmF0aW8pO1xuICAgIHZhciBtYXhUb3AgPSBpLnNjcm9sbGJhcllSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIChpLnJhaWxZUmF0aW8gKiAoaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodCkpO1xuXG4gICAgaWYgKG5ld1RvcCA8IDApIHtcbiAgICAgIGkuc2Nyb2xsYmFyWVRvcCA9IDA7XG4gICAgfSBlbHNlIGlmIChuZXdUb3AgPiBtYXhUb3ApIHtcbiAgICAgIGkuc2Nyb2xsYmFyWVRvcCA9IG1heFRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaS5zY3JvbGxiYXJZVG9wID0gbmV3VG9wO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxUb3AgPSBoLnRvSW50KGkuc2Nyb2xsYmFyWVRvcCAqIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgLyAoaS5jb250YWluZXJIZWlnaHQgLSAoaS5yYWlsWVJhdGlvICogaS5zY3JvbGxiYXJZSGVpZ2h0KSkpO1xuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgc2Nyb2xsVG9wKTtcbiAgfVxuXG4gIHZhciBtb3VzZU1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB1cGRhdGVTY3JvbGxUb3AoZS5wYWdlWSAtIGN1cnJlbnRQYWdlWSk7XG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGguc3RvcFNjcm9sbGluZyhlbGVtZW50LCAneScpO1xuICAgIGkuZXZlbnQudW5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICB9O1xuXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclksICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGN1cnJlbnRQYWdlWSA9IGUucGFnZVk7XG4gICAgY3VycmVudFRvcCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZLCAndG9wJykpICogaS5yYWlsWVJhdGlvO1xuICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcblxuICAgIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICBpLmV2ZW50Lm9uY2UoaS5vd25lckRvY3VtZW50LCAnbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgaSA9IGluc3RhbmNlcy5nZXQoZWxlbWVudCk7XG4gIGJpbmRNb3VzZVNjcm9sbFhIYW5kbGVyKGVsZW1lbnQsIGkpO1xuICBiaW5kTW91c2VTY3JvbGxZSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBiaW5kS2V5Ym9hcmRIYW5kbGVyKGVsZW1lbnQsIGkpIHtcbiAgdmFyIGhvdmVyZWQgPSBmYWxzZTtcbiAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgIGhvdmVyZWQgPSB0cnVlO1xuICB9KTtcbiAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgIGhvdmVyZWQgPSBmYWxzZTtcbiAgfSk7XG5cbiAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgaWYgKGRlbHRhWCA9PT0gMCkge1xuICAgICAgaWYgKCFpLnNjcm9sbGJhcllBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChzY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgfHwgKHNjcm9sbFRvcCA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCAmJiBkZWx0YVkgPCAwKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBpZiAoZGVsdGFZID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgfHwgKHNjcm9sbExlZnQgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoICYmIGRlbHRhWCA+IDApKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGkuZXZlbnQuYmluZChpLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQgJiYgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaG92ZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBpLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgLy8gZ28gZGVlcGVyIGlmIGVsZW1lbnQgaXMgYSB3ZWJjb21wb25lbnRcbiAgICAgIHdoaWxlIChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGguaXNFZGl0YWJsZShhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhWCA9IDA7XG4gICAgdmFyIGRlbHRhWSA9IDA7XG5cbiAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICBjYXNlIDM3OiAvLyBsZWZ0XG4gICAgICBkZWx0YVggPSAtMzA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM4OiAvLyB1cFxuICAgICAgZGVsdGFZID0gMzA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM5OiAvLyByaWdodFxuICAgICAgZGVsdGFYID0gMzA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQwOiAvLyBkb3duXG4gICAgICBkZWx0YVkgPSAtMzA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDMzOiAvLyBwYWdlIHVwXG4gICAgICBkZWx0YVkgPSA5MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzI6IC8vIHNwYWNlIGJhclxuICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgZGVsdGFZID0gOTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YVkgPSAtOTA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM0OiAvLyBwYWdlIGRvd25cbiAgICAgIGRlbHRhWSA9IC05MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzU6IC8vIGVuZFxuICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICBkZWx0YVkgPSAtaS5jb250ZW50SGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGFZID0gLWkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzNjogLy8gaG9tZVxuICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICBkZWx0YVkgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhWSA9IGkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gZGVsdGFZKTtcbiAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgKyBkZWx0YVgpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGVsZW1lbnQpO1xuXG4gICAgc2hvdWxkUHJldmVudCA9IHNob3VsZFByZXZlbnREZWZhdWx0KGRlbHRhWCwgZGVsdGFZKTtcbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kS2V5Ym9hcmRIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5JylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGJpbmRNb3VzZVdoZWVsSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgaWYgKGRlbHRhWCA9PT0gMCkge1xuICAgICAgaWYgKCFpLnNjcm9sbGJhcllBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChzY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgfHwgKHNjcm9sbFRvcCA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCAmJiBkZWx0YVkgPCAwKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBpZiAoZGVsdGFZID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgfHwgKHNjcm9sbExlZnQgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoICYmIGRlbHRhWCA+IDApKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbHRhRnJvbUV2ZW50KGUpIHtcbiAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVg7XG4gICAgdmFyIGRlbHRhWSA9IC0xICogZS5kZWx0YVk7XG5cbiAgICBpZiAodHlwZW9mIGRlbHRhWCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZGVsdGFZID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBPUyBYIFNhZmFyaVxuICAgICAgZGVsdGFYID0gLTEgKiBlLndoZWVsRGVsdGFYIC8gNjtcbiAgICAgIGRlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyA2O1xuICAgIH1cblxuICAgIGlmIChlLmRlbHRhTW9kZSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkge1xuICAgICAgLy8gRmlyZWZveCBpbiBkZWx0YU1vZGUgMTogTGluZSBzY3JvbGxpbmdcbiAgICAgIGRlbHRhWCAqPSAxMDtcbiAgICAgIGRlbHRhWSAqPSAxMDtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGFYICE9PSBkZWx0YVggJiYgZGVsdGFZICE9PSBkZWx0YVkvKiBOYU4gY2hlY2tzICovKSB7XG4gICAgICAvLyBJRSBpbiBzb21lIG1vdXNlIGRyaXZlcnNcbiAgICAgIGRlbHRhWCA9IDA7XG4gICAgICBkZWx0YVkgPSBlLndoZWVsRGVsdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtkZWx0YVgsIGRlbHRhWV07XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCZUNvbnN1bWVkQnlUZXh0YXJlYShkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBob3ZlcmVkVGV4dGFyZWEgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhOmhvdmVyJyk7XG4gICAgaWYgKGhvdmVyZWRUZXh0YXJlYSkge1xuICAgICAgdmFyIG1heFNjcm9sbFRvcCA9IGhvdmVyZWRUZXh0YXJlYS5zY3JvbGxIZWlnaHQgLSBob3ZlcmVkVGV4dGFyZWEuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKG1heFNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgaWYgKCEoaG92ZXJlZFRleHRhcmVhLnNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSAmJlxuICAgICAgICAgICAgIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsVG9wID09PSBtYXhTY3JvbGxUb3AgJiYgZGVsdGFZIDwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1heFNjcm9sbExlZnQgPSBob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsTGVmdCAtIGhvdmVyZWRUZXh0YXJlYS5jbGllbnRXaWR0aDtcbiAgICAgIGlmIChtYXhTY3JvbGxMZWZ0ID4gMCkge1xuICAgICAgICBpZiAoIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsTGVmdCA9PT0gMCAmJiBkZWx0YVggPCAwKSAmJlxuICAgICAgICAgICAgIShob3ZlcmVkVGV4dGFyZWEuc2Nyb2xsTGVmdCA9PT0gbWF4U2Nyb2xsTGVmdCAmJiBkZWx0YVggPiAwKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNld2hlZWxIYW5kbGVyKGUpIHtcbiAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHF1aWNrIGZpeCBmb3IgdGhlIHNlbGVjdCBwcm9ibGVtIGluIEZGIGFuZCBJRS5cbiAgICAvLyBJZiB0aGVyZSBjb21lcyBhbiBlZmZlY3RpdmUgd2F5IHRvIGRlYWwgd2l0aCB0aGUgcHJvYmxlbSxcbiAgICAvLyB0aGlzIGxpbmVzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgIGlmICghaC5lbnYuaXNXZWJLaXQgJiYgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzZWxlY3Q6Zm9jdXMnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IGdldERlbHRhRnJvbUV2ZW50KGUpO1xuXG4gICAgdmFyIGRlbHRhWCA9IGRlbHRhWzBdO1xuICAgIHZhciBkZWx0YVkgPSBkZWx0YVsxXTtcblxuICAgIGlmIChzaG91bGRCZUNvbnN1bWVkQnlUZXh0YXJlYShkZWx0YVgsIGRlbHRhWSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKCFpLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMpIHtcbiAgICAgIC8vIGRlbHRhWCB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYW5kIGRlbHRhWSB3aWxsXG4gICAgICAvLyBvbmx5IGJlIHVzZWQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZyAtIHRoaXMgaXMgdGhlIGRlZmF1bHRcbiAgICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSAoZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XG4gICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgKyAoZGVsdGFYICogaS5zZXR0aW5ncy53aGVlbFNwZWVkKSk7XG4gICAgfSBlbHNlIGlmIChpLnNjcm9sbGJhcllBY3RpdmUgJiYgIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xuICAgICAgLy8gb25seSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgYWN0aXZlIGFuZCB1c2VCb3RoV2hlZWxBeGVzIG9wdGlvbiBpc1xuICAgICAgLy8gYWN0aXZlLCBzbyBsZXQncyBzY3JvbGwgdmVydGljYWwgYmFyIHVzaW5nIGJvdGggbW91c2Ugd2hlZWwgYXhlc1xuICAgICAgaWYgKGRlbHRhWSkge1xuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wIC0gKGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICd0b3AnLCBlbGVtZW50LnNjcm9sbFRvcCArIChkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQpKTtcbiAgICAgIH1cbiAgICAgIHNob3VsZFByZXZlbnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaS5zY3JvbGxiYXJYQWN0aXZlICYmICFpLnNjcm9sbGJhcllBY3RpdmUpIHtcbiAgICAgIC8vIHVzZUJvdGhXaGVlbEF4ZXMgYW5kIG9ubHkgaG9yaXpvbnRhbCBiYXIgaXMgYWN0aXZlLCBzbyB1c2UgYm90aFxuICAgICAgLy8gd2hlZWwgYXhlcyBmb3IgaG9yaXpvbnRhbCBiYXJcbiAgICAgIGlmIChkZWx0YVgpIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0ICsgKGRlbHRhWCAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0IC0gKGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZCkpO1xuICAgICAgfVxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gKHNob3VsZFByZXZlbnQgfHwgc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpKTtcbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5vbndoZWVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lm9ubW91c2V3aGVlbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnbW91c2V3aGVlbCcsIG1vdXNld2hlZWxIYW5kbGVyKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZE1vdXNlV2hlZWxIYW5kbGVyKGVsZW1lbnQsIGkpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4uL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuLi91cGRhdGUtZ2VvbWV0cnknKTtcblxuZnVuY3Rpb24gYmluZE5hdGl2ZVNjcm9sbEhhbmRsZXIoZWxlbWVudCwgaSkge1xuICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kTmF0aXZlU2Nyb2xsSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi4vaW5zdGFuY2VzJylcbiAgLCB1cGRhdGVHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS1nZW9tZXRyeScpXG4gICwgdXBkYXRlU2Nyb2xsID0gcmVxdWlyZSgnLi4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBiaW5kU2VsZWN0aW9uSGFuZGxlcihlbGVtZW50LCBpKSB7XG4gIGZ1bmN0aW9uIGdldFJhbmdlTm9kZSgpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSA6XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldFNlbGVjdGlvbiA/IGRvY3VtZW50LmdldFNlbGVjdGlvbigpIDogJyc7XG4gICAgaWYgKHNlbGVjdGlvbi50b1N0cmluZygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG4gIH1cblxuICB2YXIgc2Nyb2xsaW5nTG9vcCA9IG51bGw7XG4gIHZhciBzY3JvbGxEaWZmID0ge3RvcDogMCwgbGVmdDogMH07XG4gIGZ1bmN0aW9uIHN0YXJ0U2Nyb2xsaW5nKCkge1xuICAgIGlmICghc2Nyb2xsaW5nTG9vcCkge1xuICAgICAgc2Nyb2xsaW5nTG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxpbmdMb29wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ3RvcCcsIGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsRGlmZi50b3ApO1xuICAgICAgICB1cGRhdGVTY3JvbGwoZWxlbWVudCwgJ2xlZnQnLCBlbGVtZW50LnNjcm9sbExlZnQgKyBzY3JvbGxEaWZmLmxlZnQpO1xuICAgICAgICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbiAgICAgIH0sIDUwKTsgLy8gZXZlcnkgLjEgc2VjXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0b3BTY3JvbGxpbmcoKSB7XG4gICAgaWYgKHNjcm9sbGluZ0xvb3ApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2Nyb2xsaW5nTG9vcCk7XG4gICAgICBzY3JvbGxpbmdMb29wID0gbnVsbDtcbiAgICB9XG4gICAgaC5zdG9wU2Nyb2xsaW5nKGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWxlbWVudC5jb250YWlucyhnZXRSYW5nZU5vZGUoKSkpIHtcbiAgICAgIGlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICBzdG9wU2Nyb2xsaW5nKCk7XG4gICAgfVxuICB9KTtcbiAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHN0b3BTY3JvbGxpbmcoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGkuZXZlbnQuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IHt4OiBlLnBhZ2VYLCB5OiBlLnBhZ2VZfTtcbiAgICAgIHZhciBjb250YWluZXJHZW9tZXRyeSA9IHtcbiAgICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgICByaWdodDogZWxlbWVudC5vZmZzZXRMZWZ0ICsgZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICAgICAgYm90dG9tOiBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICBpZiAobW91c2VQb3NpdGlvbi54IDwgY29udGFpbmVyR2VvbWV0cnkubGVmdCArIDMpIHtcbiAgICAgICAgc2Nyb2xsRGlmZi5sZWZ0ID0gLTU7XG4gICAgICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcbiAgICAgIH0gZWxzZSBpZiAobW91c2VQb3NpdGlvbi54ID4gY29udGFpbmVyR2VvbWV0cnkucmlnaHQgLSAzKSB7XG4gICAgICAgIHNjcm9sbERpZmYubGVmdCA9IDU7XG4gICAgICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbERpZmYubGVmdCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3VzZVBvc2l0aW9uLnkgPCBjb250YWluZXJHZW9tZXRyeS50b3AgKyAzKSB7XG4gICAgICAgIGlmIChjb250YWluZXJHZW9tZXRyeS50b3AgKyAzIC0gbW91c2VQb3NpdGlvbi55IDwgNSkge1xuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gLTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsRGlmZi50b3AgPSAtMjA7XG4gICAgICAgIH1cbiAgICAgICAgaC5zdGFydFNjcm9sbGluZyhlbGVtZW50LCAneScpO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZVBvc2l0aW9uLnkgPiBjb250YWluZXJHZW9tZXRyeS5ib3R0b20gLSAzKSB7XG4gICAgICAgIGlmIChtb3VzZVBvc2l0aW9uLnkgLSBjb250YWluZXJHZW9tZXRyeS5ib3R0b20gKyAzIDwgNSkge1xuICAgICAgICAgIHNjcm9sbERpZmYudG9wID0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxEaWZmLnRvcCA9IDIwO1xuICAgICAgICB9XG4gICAgICAgIGguc3RhcnRTY3JvbGxpbmcoZWxlbWVudCwgJ3knKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbERpZmYudG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbERpZmYudG9wID09PSAwICYmIHNjcm9sbERpZmYubGVmdCA9PT0gMCkge1xuICAgICAgICBzdG9wU2Nyb2xsaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFNjcm9sbGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuICBiaW5kU2VsZWN0aW9uSGFuZGxlcihlbGVtZW50LCBpKTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnN0YW5jZXMgPSByZXF1aXJlKCcuLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vdXBkYXRlLWdlb21ldHJ5JylcbiAgLCB1cGRhdGVTY3JvbGwgPSByZXF1aXJlKCcuLi91cGRhdGUtc2Nyb2xsJyk7XG5cbmZ1bmN0aW9uIGJpbmRUb3VjaEhhbmRsZXIoZWxlbWVudCwgaSwgc3VwcG9ydHNUb3VjaCwgc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgdmFyIG1hZ25pdHVkZVggPSBNYXRoLmFicyhkZWx0YVgpO1xuICAgIHZhciBtYWduaXR1ZGVZID0gTWF0aC5hYnMoZGVsdGFZKTtcblxuICAgIGlmIChtYWduaXR1ZGVZID4gbWFnbml0dWRlWCkge1xuICAgICAgLy8gdXNlciBpcyBwZXJoYXBzIHRyeWluZyB0byBzd2lwZSB1cC9kb3duIHRoZSBwYWdlXG5cbiAgICAgIGlmICgoKGRlbHRhWSA8IDApICYmIChzY3JvbGxUb3AgPT09IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSkgfHxcbiAgICAgICAgICAoKGRlbHRhWSA+IDApICYmIChzY3JvbGxUb3AgPT09IDApKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Muc3dpcGVQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hZ25pdHVkZVggPiBtYWduaXR1ZGVZKSB7XG4gICAgICAvLyB1c2VyIGlzIHBlcmhhcHMgdHJ5aW5nIHRvIHN3aXBlIGxlZnQvcmlnaHQgYWNyb3NzIHRoZSBwYWdlXG5cbiAgICAgIGlmICgoKGRlbHRhWCA8IDApICYmIChzY3JvbGxMZWZ0ID09PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpKSB8fFxuICAgICAgICAgICgoZGVsdGFYID4gMCkgJiYgKHNjcm9sbExlZnQgPT09IDApKSkge1xuICAgICAgICByZXR1cm4gIWkuc2V0dGluZ3Muc3dpcGVQcm9wYWdhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VG91Y2hNb3ZlKGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSkge1xuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgZWxlbWVudC5zY3JvbGxUb3AgLSBkaWZmZXJlbmNlWSk7XG4gICAgdXBkYXRlU2Nyb2xsKGVsZW1lbnQsICdsZWZ0JywgZWxlbWVudC5zY3JvbGxMZWZ0IC0gZGlmZmVyZW5jZVgpO1xuXG4gICAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG4gIH1cblxuICB2YXIgc3RhcnRPZmZzZXQgPSB7fTtcbiAgdmFyIHN0YXJ0VGltZSA9IDA7XG4gIHZhciBzcGVlZCA9IHt9O1xuICB2YXIgZWFzaW5nTG9vcCA9IG51bGw7XG4gIHZhciBpbkdsb2JhbFRvdWNoID0gZmFsc2U7XG4gIHZhciBpbkxvY2FsVG91Y2ggPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnbG9iYWxUb3VjaFN0YXJ0KCkge1xuICAgIGluR2xvYmFsVG91Y2ggPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGdsb2JhbFRvdWNoRW5kKCkge1xuICAgIGluR2xvYmFsVG91Y2ggPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRvdWNoKGUpIHtcbiAgICBpZiAoZS50YXJnZXRUb3VjaGVzKSB7XG4gICAgICByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYXliZSBJRSBwb2ludGVyXG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkSGFuZGxlKGUpIHtcbiAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZS5wb2ludGVyVHlwZSAmJiBlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hTdGFydChlKSB7XG4gICAgaWYgKHNob3VsZEhhbmRsZShlKSkge1xuICAgICAgaW5Mb2NhbFRvdWNoID0gdHJ1ZTtcblxuICAgICAgdmFyIHRvdWNoID0gZ2V0VG91Y2goZSk7XG5cbiAgICAgIHN0YXJ0T2Zmc2V0LnBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgICBzdGFydE9mZnNldC5wYWdlWSA9IHRvdWNoLnBhZ2VZO1xuXG4gICAgICBzdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICBpZiAoZWFzaW5nTG9vcCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgICAgfVxuXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaE1vdmUoZSkge1xuICAgIGlmICghaW5HbG9iYWxUb3VjaCAmJiBpbkxvY2FsVG91Y2ggJiYgc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaChlKTtcblxuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB7cGFnZVg6IHRvdWNoLnBhZ2VYLCBwYWdlWTogdG91Y2gucGFnZVl9O1xuXG4gICAgICB2YXIgZGlmZmVyZW5jZVggPSBjdXJyZW50T2Zmc2V0LnBhZ2VYIC0gc3RhcnRPZmZzZXQucGFnZVg7XG4gICAgICB2YXIgZGlmZmVyZW5jZVkgPSBjdXJyZW50T2Zmc2V0LnBhZ2VZIC0gc3RhcnRPZmZzZXQucGFnZVk7XG5cbiAgICAgIGFwcGx5VG91Y2hNb3ZlKGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSk7XG4gICAgICBzdGFydE9mZnNldCA9IGN1cnJlbnRPZmZzZXQ7XG5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgIHZhciB0aW1lR2FwID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBpZiAodGltZUdhcCA+IDApIHtcbiAgICAgICAgc3BlZWQueCA9IGRpZmZlcmVuY2VYIC8gdGltZUdhcDtcbiAgICAgICAgc3BlZWQueSA9IGRpZmZlcmVuY2VZIC8gdGltZUdhcDtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRQcmV2ZW50RGVmYXVsdChkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hFbmQoKSB7XG4gICAgaWYgKCFpbkdsb2JhbFRvdWNoICYmIGluTG9jYWxUb3VjaCkge1xuICAgICAgaW5Mb2NhbFRvdWNoID0gZmFsc2U7XG5cbiAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICBlYXNpbmdMb29wID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluc3RhbmNlcy5nZXQoZWxlbWVudCkpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNYXRoLmFicyhzcGVlZC54KSA8IDAuMDEgJiYgTWF0aC5hYnMoc3BlZWQueSkgPCAwLjAxKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcHBseVRvdWNoTW92ZShzcGVlZC54ICogMzAsIHNwZWVkLnkgKiAzMCk7XG5cbiAgICAgICAgc3BlZWQueCAqPSAwLjg7XG4gICAgICAgIHNwZWVkLnkgKj0gMC44O1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0c1RvdWNoKSB7XG4gICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3RvdWNoc3RhcnQnLCBnbG9iYWxUb3VjaFN0YXJ0KTtcbiAgICBpLmV2ZW50LmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBnbG9iYWxUb3VjaEVuZCk7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCk7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaG1vdmUnLCB0b3VjaE1vdmUpO1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gIH1cblxuICBpZiAoc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ3BvaW50ZXJkb3duJywgZ2xvYmFsVG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQod2luZG93LCAncG9pbnRlcnVwJywgZ2xvYmFsVG91Y2hFbmQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVyZG93bicsIHRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVybW92ZScsIHRvdWNoTW92ZSk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJ1cCcsIHRvdWNoRW5kKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgaS5ldmVudC5iaW5kKHdpbmRvdywgJ01TUG9pbnRlckRvd24nLCBnbG9iYWxUb3VjaFN0YXJ0KTtcbiAgICAgIGkuZXZlbnQuYmluZCh3aW5kb3csICdNU1BvaW50ZXJVcCcsIGdsb2JhbFRvdWNoRW5kKTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnTVNQb2ludGVyRG93bicsIHRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJNb3ZlJywgdG91Y2hNb3ZlKTtcbiAgICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnTVNQb2ludGVyVXAnLCB0b3VjaEVuZCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN1cHBvcnRzVG91Y2gsIHN1cHBvcnRzSWVQb2ludGVyKSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcbiAgYmluZFRvdWNoSGFuZGxlcihlbGVtZW50LCBpLCBzdXBwb3J0c1RvdWNoLCBzdXBwb3J0c0llUG9pbnRlcik7XG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xzID0gcmVxdWlyZSgnLi4vbGliL2NsYXNzJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZUdlb21ldHJ5ID0gcmVxdWlyZSgnLi91cGRhdGUtZ2VvbWV0cnknKTtcblxuLy8gSGFuZGxlcnNcbnZhciBjbGlja1JhaWxIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL2NsaWNrLXJhaWwnKVxuICAsIGRyYWdTY3JvbGxiYXJIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWctc2Nyb2xsYmFyJylcbiAgLCBrZXlib2FyZEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIva2V5Ym9hcmQnKVxuICAsIG1vdXNlV2hlZWxIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL21vdXNlLXdoZWVsJylcbiAgLCBuYXRpdmVTY3JvbGxIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL25hdGl2ZS1zY3JvbGwnKVxuICAsIHNlbGVjdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvc2VsZWN0aW9uJylcbiAgLCB0b3VjaEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXIvdG91Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgdXNlclNldHRpbmdzKSB7XG4gIHVzZXJTZXR0aW5ncyA9IHR5cGVvZiB1c2VyU2V0dGluZ3MgPT09ICdvYmplY3QnID8gdXNlclNldHRpbmdzIDoge307XG5cbiAgY2xzLmFkZChlbGVtZW50LCAncHMtY29udGFpbmVyJyk7XG5cbiAgLy8gQ3JlYXRlIGEgcGx1Z2luIGluc3RhbmNlLlxuICB2YXIgaSA9IGluc3RhbmNlcy5hZGQoZWxlbWVudCk7XG5cbiAgaS5zZXR0aW5ncyA9IGguZXh0ZW5kKGkuc2V0dGluZ3MsIHVzZXJTZXR0aW5ncyk7XG5cbiAgY2xpY2tSYWlsSGFuZGxlcihlbGVtZW50KTtcbiAgZHJhZ1Njcm9sbGJhckhhbmRsZXIoZWxlbWVudCk7XG4gIG1vdXNlV2hlZWxIYW5kbGVyKGVsZW1lbnQpO1xuICBuYXRpdmVTY3JvbGxIYW5kbGVyKGVsZW1lbnQpO1xuXG4gIGlmIChpLnNldHRpbmdzLnVzZVNlbGVjdGlvblNjcm9sbCkge1xuICAgIHNlbGVjdGlvbkhhbmRsZXIoZWxlbWVudCk7XG4gIH1cblxuICBpZiAoaC5lbnYuc3VwcG9ydHNUb3VjaCB8fCBoLmVudi5zdXBwb3J0c0llUG9pbnRlcikge1xuICAgIHRvdWNoSGFuZGxlcihlbGVtZW50LCBoLmVudi5zdXBwb3J0c1RvdWNoLCBoLmVudi5zdXBwb3J0c0llUG9pbnRlcik7XG4gIH1cbiAgaWYgKGkuc2V0dGluZ3MudXNlS2V5Ym9hcmQpIHtcbiAgICBrZXlib2FyZEhhbmRsZXIoZWxlbWVudCk7XG4gIH1cblxuICB1cGRhdGVHZW9tZXRyeShlbGVtZW50KTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkID0gcmVxdWlyZSgnLi4vbGliL2RvbScpXG4gICwgZGVmYXVsdFNldHRpbmdzID0gcmVxdWlyZSgnLi9kZWZhdWx0LXNldHRpbmcnKVxuICAsIEV2ZW50TWFuYWdlciA9IHJlcXVpcmUoJy4uL2xpYi9ldmVudC1tYW5hZ2VyJylcbiAgLCBndWlkID0gcmVxdWlyZSgnLi4vbGliL2d1aWQnKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJyk7XG5cbnZhciBpbnN0YW5jZXMgPSB7fTtcblxuZnVuY3Rpb24gSW5zdGFuY2UoZWxlbWVudCkge1xuICB2YXIgaSA9IHRoaXM7XG5cbiAgaS5zZXR0aW5ncyA9IGguY2xvbmUoZGVmYXVsdFNldHRpbmdzKTtcbiAgaS5jb250YWluZXJXaWR0aCA9IG51bGw7XG4gIGkuY29udGFpbmVySGVpZ2h0ID0gbnVsbDtcbiAgaS5jb250ZW50V2lkdGggPSBudWxsO1xuICBpLmNvbnRlbnRIZWlnaHQgPSBudWxsO1xuXG4gIGkuaXNSdGwgPSBkLmNzcyhlbGVtZW50LCAnZGlyZWN0aW9uJykgPT09IFwicnRsXCI7XG4gIGkuaXNOZWdhdGl2ZVNjcm9sbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSAtMTtcbiAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbExlZnQgPCAwO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IG9yaWdpbmFsU2Nyb2xsTGVmdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xuICBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IGkuaXNOZWdhdGl2ZVNjcm9sbCA/IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50LmNsaWVudFdpZHRoIDogMDtcbiAgaS5ldmVudCA9IG5ldyBFdmVudE1hbmFnZXIoKTtcbiAgaS5vd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXG4gIGkuc2Nyb2xsYmFyWFJhaWwgPSBkLmFwcGVuZFRvKGQuZSgnZGl2JywgJ3BzLXNjcm9sbGJhci14LXJhaWwnKSwgZWxlbWVudCk7XG4gIGkuc2Nyb2xsYmFyWCA9IGQuYXBwZW5kVG8oZC5lKCdkaXYnLCAncHMtc2Nyb2xsYmFyLXgnKSwgaS5zY3JvbGxiYXJYUmFpbCk7XG4gIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWFdpZHRoID0gbnVsbDtcbiAgaS5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XG4gIGkuc2Nyb2xsYmFyWEJvdHRvbSA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvdHRvbScpKTtcbiAgaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9IGkuc2Nyb2xsYmFyWEJvdHRvbSA9PT0gaS5zY3JvbGxiYXJYQm90dG9tOyAvLyAhaXNOYU5cbiAgaS5zY3JvbGxiYXJYVG9wID0gaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA/IG51bGwgOiBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsICd0b3AnKSk7XG4gIGkucmFpbEJvcmRlclhXaWR0aCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvcmRlckxlZnRXaWR0aCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2JvcmRlclJpZ2h0V2lkdGgnKSk7XG4gIC8vIFNldCByYWlsIHRvIGRpc3BsYXk6YmxvY2sgdG8gY2FsY3VsYXRlIG1hcmdpbnNcbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgaS5yYWlsWE1hcmdpbldpZHRoID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luTGVmdCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ21hcmdpblJpZ2h0JykpO1xuICBkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnZGlzcGxheScsICcnKTtcbiAgaS5yYWlsWFdpZHRoID0gbnVsbDtcbiAgaS5yYWlsWFJhdGlvID0gbnVsbDtcblxuICBpLnNjcm9sbGJhcllSYWlsID0gZC5hcHBlbmRUbyhkLmUoJ2RpdicsICdwcy1zY3JvbGxiYXIteS1yYWlsJyksIGVsZW1lbnQpO1xuICBpLnNjcm9sbGJhclkgPSBkLmFwcGVuZFRvKGQuZSgnZGl2JywgJ3BzLXNjcm9sbGJhci15JyksIGkuc2Nyb2xsYmFyWVJhaWwpO1xuICBpLnNjcm9sbGJhcllBY3RpdmUgPSBudWxsO1xuICBpLnNjcm9sbGJhcllIZWlnaHQgPSBudWxsO1xuICBpLnNjcm9sbGJhcllUb3AgPSBudWxsO1xuICBpLnNjcm9sbGJhcllSaWdodCA9IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ3JpZ2h0JykpO1xuICBpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPSBpLnNjcm9sbGJhcllSaWdodCA9PT0gaS5zY3JvbGxiYXJZUmlnaHQ7IC8vICFpc05hTlxuICBpLnNjcm9sbGJhcllMZWZ0ID0gaS5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID8gbnVsbCA6IGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2xlZnQnKSk7XG4gIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGggPSBpLmlzUnRsID8gaC5vdXRlcldpZHRoKGkuc2Nyb2xsYmFyWSkgOiBudWxsO1xuICBpLnJhaWxCb3JkZXJZV2lkdGggPSBoLnRvSW50KGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdib3JkZXJUb3BXaWR0aCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2JvcmRlckJvdHRvbVdpZHRoJykpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICdibG9jaycpO1xuICBpLnJhaWxZTWFyZ2luSGVpZ2h0ID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luVG9wJykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luQm90dG9tJykpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICcnKTtcbiAgaS5yYWlsWUhlaWdodCA9IG51bGw7XG4gIGkucmFpbFlSYXRpbyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldElkKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRhdGFzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBzLWlkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YXNldC5wc0lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldElkKGVsZW1lbnQsIGlkKSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5kYXRhc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXBzLWlkJywgaWQpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuZGF0YXNldC5wc0lkID0gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlSWQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQuZGF0YXNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wcy1pZCcpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQucHNJZDtcbiAgfVxufVxuXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBuZXdJZCA9IGd1aWQoKTtcbiAgc2V0SWQoZWxlbWVudCwgbmV3SWQpO1xuICBpbnN0YW5jZXNbbmV3SWRdID0gbmV3IEluc3RhbmNlKGVsZW1lbnQpO1xuICByZXR1cm4gaW5zdGFuY2VzW25ld0lkXTtcbn07XG5cbmV4cG9ydHMucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tnZXRJZChlbGVtZW50KV07XG4gIHJlbW92ZUlkKGVsZW1lbnQpO1xufTtcblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2dldElkKGVsZW1lbnQpXTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUgSHl1bmplIEFsZXggSnVuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbHMgPSByZXF1aXJlKCcuLi9saWIvY2xhc3MnKVxuICAsIGQgPSByZXF1aXJlKCcuLi9saWIvZG9tJylcbiAgLCBoID0gcmVxdWlyZSgnLi4vbGliL2hlbHBlcicpXG4gICwgaW5zdGFuY2VzID0gcmVxdWlyZSgnLi9pbnN0YW5jZXMnKVxuICAsIHVwZGF0ZVNjcm9sbCA9IHJlcXVpcmUoJy4vdXBkYXRlLXNjcm9sbCcpO1xuXG5mdW5jdGlvbiBnZXRUaHVtYlNpemUoaSwgdGh1bWJTaXplKSB7XG4gIGlmIChpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCkge1xuICAgIHRodW1iU2l6ZSA9IE1hdGgubWF4KHRodW1iU2l6ZSwgaS5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGgpO1xuICB9XG4gIGlmIChpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCkge1xuICAgIHRodW1iU2l6ZSA9IE1hdGgubWluKHRodW1iU2l6ZSwgaS5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGgpO1xuICB9XG4gIHJldHVybiB0aHVtYlNpemU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNzcyhlbGVtZW50LCBpKSB7XG4gIHZhciB4UmFpbE9mZnNldCA9IHt3aWR0aDogaS5yYWlsWFdpZHRofTtcbiAgaWYgKGkuaXNSdGwpIHtcbiAgICB4UmFpbE9mZnNldC5sZWZ0ID0gaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBlbGVtZW50LnNjcm9sbExlZnQgKyBpLmNvbnRhaW5lcldpZHRoIC0gaS5jb250ZW50V2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgeFJhaWxPZmZzZXQubGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgfVxuICBpZiAoaS5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSkge1xuICAgIHhSYWlsT2Zmc2V0LmJvdHRvbSA9IGkuc2Nyb2xsYmFyWEJvdHRvbSAtIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LnRvcCA9IGkuc2Nyb2xsYmFyWFRvcCArIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWFJhaWwsIHhSYWlsT2Zmc2V0KTtcblxuICB2YXIgeVJhaWxPZmZzZXQgPSB7dG9wOiBlbGVtZW50LnNjcm9sbFRvcCwgaGVpZ2h0OiBpLnJhaWxZSGVpZ2h0fTtcbiAgaWYgKGkuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCkge1xuICAgIGlmIChpLmlzUnRsKSB7XG4gICAgICB5UmFpbE9mZnNldC5yaWdodCA9IGkuY29udGVudFdpZHRoIC0gKGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0KSAtIGkuc2Nyb2xsYmFyWVJpZ2h0IC0gaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPSBpLnNjcm9sbGJhcllSaWdodCAtIGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGkuaXNSdGwpIHtcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGkuY29udGFpbmVyV2lkdGggKiAyIC0gaS5jb250ZW50V2lkdGggLSBpLnNjcm9sbGJhcllMZWZ0IC0gaS5zY3JvbGxiYXJZT3V0ZXJXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgeVJhaWxPZmZzZXQubGVmdCA9IGkuc2Nyb2xsYmFyWUxlZnQgKyBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgfVxuICB9XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsIHlSYWlsT2Zmc2V0KTtcblxuICBkLmNzcyhpLnNjcm9sbGJhclgsIHtsZWZ0OiBpLnNjcm9sbGJhclhMZWZ0LCB3aWR0aDogaS5zY3JvbGxiYXJYV2lkdGggLSBpLnJhaWxCb3JkZXJYV2lkdGh9KTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZLCB7dG9wOiBpLnNjcm9sbGJhcllUb3AsIGhlaWdodDogaS5zY3JvbGxiYXJZSGVpZ2h0IC0gaS5yYWlsQm9yZGVyWVdpZHRofSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuXG4gIGkuY29udGFpbmVyV2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICBpLmNvbnRhaW5lckhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICBpLmNvbnRlbnRXaWR0aCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gIGkuY29udGVudEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuXG4gIHZhciBleGlzdGluZ1JhaWxzO1xuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJYUmFpbCkpIHtcbiAgICBleGlzdGluZ1JhaWxzID0gZC5xdWVyeUNoaWxkcmVuKGVsZW1lbnQsICcucHMtc2Nyb2xsYmFyLXgtcmFpbCcpO1xuICAgIGlmIChleGlzdGluZ1JhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4aXN0aW5nUmFpbHMuZm9yRWFjaChmdW5jdGlvbiAocmFpbCkge1xuICAgICAgICBkLnJlbW92ZShyYWlsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkLmFwcGVuZFRvKGkuc2Nyb2xsYmFyWFJhaWwsIGVsZW1lbnQpO1xuICB9XG4gIGlmICghZWxlbWVudC5jb250YWlucyhpLnNjcm9sbGJhcllSYWlsKSkge1xuICAgIGV4aXN0aW5nUmFpbHMgPSBkLnF1ZXJ5Q2hpbGRyZW4oZWxlbWVudCwgJy5wcy1zY3JvbGxiYXIteS1yYWlsJyk7XG4gICAgaWYgKGV4aXN0aW5nUmFpbHMubGVuZ3RoID4gMCkge1xuICAgICAgZXhpc3RpbmdSYWlscy5mb3JFYWNoKGZ1bmN0aW9uIChyYWlsKSB7XG4gICAgICAgIGQucmVtb3ZlKHJhaWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGQuYXBwZW5kVG8oaS5zY3JvbGxiYXJZUmFpbCwgZWxlbWVudCk7XG4gIH1cblxuICBpZiAoIWkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGkuY29udGFpbmVyV2lkdGggKyBpLnNldHRpbmdzLnNjcm9sbFhNYXJnaW5PZmZzZXQgPCBpLmNvbnRlbnRXaWR0aCkge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWFdpZHRoID0gaS5jb250YWluZXJXaWR0aCAtIGkucmFpbFhNYXJnaW5XaWR0aDtcbiAgICBpLnJhaWxYUmF0aW8gPSBpLmNvbnRhaW5lcldpZHRoIC8gaS5yYWlsWFdpZHRoO1xuICAgIGkuc2Nyb2xsYmFyWFdpZHRoID0gZ2V0VGh1bWJTaXplKGksIGgudG9JbnQoaS5yYWlsWFdpZHRoICogaS5jb250YWluZXJXaWR0aCAvIGkuY29udGVudFdpZHRoKSk7XG4gICAgaS5zY3JvbGxiYXJYTGVmdCA9IGgudG9JbnQoKGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgZWxlbWVudC5zY3JvbGxMZWZ0KSAqIChpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCkgLyAoaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoKSk7XG4gIH0gZWxzZSB7XG4gICAgaS5zY3JvbGxiYXJYQWN0aXZlID0gZmFsc2U7XG4gICAgaS5zY3JvbGxiYXJYV2lkdGggPSAwO1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSAwO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IDA7XG4gIH1cblxuICBpZiAoIWkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxZICYmIGkuY29udGFpbmVySGVpZ2h0ICsgaS5zZXR0aW5ncy5zY3JvbGxZTWFyZ2luT2Zmc2V0IDwgaS5jb250ZW50SGVpZ2h0KSB7XG4gICAgaS5zY3JvbGxiYXJZQWN0aXZlID0gdHJ1ZTtcbiAgICBpLnJhaWxZSGVpZ2h0ID0gaS5jb250YWluZXJIZWlnaHQgLSBpLnJhaWxZTWFyZ2luSGVpZ2h0O1xuICAgIGkucmFpbFlSYXRpbyA9IGkuY29udGFpbmVySGVpZ2h0IC8gaS5yYWlsWUhlaWdodDtcbiAgICBpLnNjcm9sbGJhcllIZWlnaHQgPSBnZXRUaHVtYlNpemUoaSwgaC50b0ludChpLnJhaWxZSGVpZ2h0ICogaS5jb250YWluZXJIZWlnaHQgLyBpLmNvbnRlbnRIZWlnaHQpKTtcbiAgICBpLnNjcm9sbGJhcllUb3AgPSBoLnRvSW50KGVsZW1lbnQuc2Nyb2xsVG9wICogKGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpIC8gKGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSk7XG4gIH0gZWxzZSB7XG4gICAgaS5zY3JvbGxiYXJZQWN0aXZlID0gZmFsc2U7XG4gICAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gMDtcbiAgICBpLnNjcm9sbGJhcllUb3AgPSAwO1xuICAgIHVwZGF0ZVNjcm9sbChlbGVtZW50LCAndG9wJywgMCk7XG4gIH1cblxuICBpZiAoaS5zY3JvbGxiYXJYTGVmdCA+PSBpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aCkge1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSBpLnJhaWxYV2lkdGggLSBpLnNjcm9sbGJhclhXaWR0aDtcbiAgfVxuICBpZiAoaS5zY3JvbGxiYXJZVG9wID49IGkucmFpbFlIZWlnaHQgLSBpLnNjcm9sbGJhcllIZWlnaHQpIHtcbiAgICBpLnNjcm9sbGJhcllUb3AgPSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0O1xuICB9XG5cbiAgdXBkYXRlQ3NzKGVsZW1lbnQsIGkpO1xuXG4gIGNsc1tpLnNjcm9sbGJhclhBY3RpdmUgPyAnYWRkJyA6ICdyZW1vdmUnXShlbGVtZW50LCAncHMtYWN0aXZlLXgnKTtcbiAgY2xzW2kuc2Nyb2xsYmFyWUFjdGl2ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGVsZW1lbnQsICdwcy1hY3RpdmUteScpO1xufTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSBIeXVuamUgQWxleCBKdW4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluc3RhbmNlcyA9IHJlcXVpcmUoJy4vaW5zdGFuY2VzJyk7XG5cbnZhciB1cEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCBkb3duRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIGxlZnRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgcmlnaHRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gICwgeUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCB4RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHhTdGFydEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCB4RW5kRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIHlTdGFydEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JylcbiAgLCB5RW5kRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAsIGxhc3RUb3BcbiAgLCBsYXN0TGVmdDtcblxudXBFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC11cCcsIHRydWUsIHRydWUpO1xuZG93bkV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLWRvd24nLCB0cnVlLCB0cnVlKTtcbmxlZnRFdmVudC5pbml0RXZlbnQoJ3BzLXNjcm9sbC1sZWZ0JywgdHJ1ZSwgdHJ1ZSk7XG5yaWdodEV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLXJpZ2h0JywgdHJ1ZSwgdHJ1ZSk7XG55RXZlbnQuaW5pdEV2ZW50KCdwcy1zY3JvbGwteScsIHRydWUsIHRydWUpO1xueEV2ZW50LmluaXRFdmVudCgncHMtc2Nyb2xsLXgnLCB0cnVlLCB0cnVlKTtcbnhTdGFydEV2ZW50LmluaXRFdmVudCgncHMteC1yZWFjaC1zdGFydCcsIHRydWUsIHRydWUpO1xueEVuZEV2ZW50LmluaXRFdmVudCgncHMteC1yZWFjaC1lbmQnLCB0cnVlLCB0cnVlKTtcbnlTdGFydEV2ZW50LmluaXRFdmVudCgncHMteS1yZWFjaC1zdGFydCcsIHRydWUsIHRydWUpO1xueUVuZEV2ZW50LmluaXRFdmVudCgncHMteS1yZWFjaC1lbmQnLCB0cnVlLCB0cnVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXhpcywgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGFuIGVsZW1lbnQgdG8gdGhlIHVwZGF0ZS1zY3JvbGwgZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBheGlzID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGFuIGF4aXMgdG8gdGhlIHVwZGF0ZS1zY3JvbGwgZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhIHZhbHVlIHRvIHRoZSB1cGRhdGUtc2Nyb2xsIGZ1bmN0aW9uJztcbiAgfVxuXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA8PSAwKSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh5U3RhcnRFdmVudCk7XG4gICAgcmV0dXJuOyAvLyBkb24ndCBhbGxvdyBuZWdhdGl2ZSBzY3JvbGxcbiAgfVxuXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPD0gMCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IDA7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHhTdGFydEV2ZW50KTtcbiAgICByZXR1cm47IC8vIGRvbid0IGFsbG93IG5lZ2F0aXZlIHNjcm9sbFxuICB9XG5cbiAgdmFyIGkgPSBpbnN0YW5jZXMuZ2V0KGVsZW1lbnQpO1xuXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA+IGkuY29udGVudEhlaWdodCAtIGkuY29udGFpbmVySGVpZ2h0KSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodDtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeUVuZEV2ZW50KTtcbiAgICByZXR1cm47IC8vIGRvbid0IGFsbG93IHNjcm9sbCBwYXN0IGNvbnRhaW5lclxuICB9XG5cbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA+IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aDtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeEVuZEV2ZW50KTtcbiAgICByZXR1cm47IC8vIGRvbid0IGFsbG93IHNjcm9sbCBwYXN0IGNvbnRhaW5lclxuICB9XG5cbiAgaWYgKCFsYXN0VG9wKSB7XG4gICAgbGFzdFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgaWYgKCFsYXN0TGVmdCkge1xuICAgIGxhc3RMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICd0b3AnICYmIHZhbHVlIDwgbGFzdFRvcCkge1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudCh1cEV2ZW50KTtcbiAgfVxuXG4gIGlmIChheGlzID09PSAndG9wJyAmJiB2YWx1ZSA+IGxhc3RUb3ApIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZG93bkV2ZW50KTtcbiAgfVxuXG4gIGlmIChheGlzID09PSAnbGVmdCcgJiYgdmFsdWUgPCBsYXN0TGVmdCkge1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChsZWZ0RXZlbnQpO1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICdsZWZ0JyAmJiB2YWx1ZSA+IGxhc3RMZWZ0KSB7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHJpZ2h0RXZlbnQpO1xuICB9XG5cbiAgaWYgKGF4aXMgPT09ICd0b3AnKSB7XG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSBsYXN0VG9wID0gdmFsdWU7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHlFdmVudCk7XG4gIH1cblxuICBpZiAoYXhpcyA9PT0gJ2xlZnQnKSB7XG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gbGFzdExlZnQgPSB2YWx1ZTtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoeEV2ZW50KTtcbiAgfVxuXG59O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1IEh5dW5qZSBBbGV4IEp1biBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCA9IHJlcXVpcmUoJy4uL2xpYi9kb20nKVxuICAsIGggPSByZXF1aXJlKCcuLi9saWIvaGVscGVyJylcbiAgLCBpbnN0YW5jZXMgPSByZXF1aXJlKCcuL2luc3RhbmNlcycpXG4gICwgdXBkYXRlR2VvbWV0cnkgPSByZXF1aXJlKCcuL3VwZGF0ZS1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBpID0gaW5zdGFuY2VzLmdldChlbGVtZW50KTtcblxuICBpZiAoIWkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZWNhbGN1YXRlIG5lZ2F0aXZlIHNjcm9sbExlZnQgYWRqdXN0bWVudFxuICBpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IGkuaXNOZWdhdGl2ZVNjcm9sbCA/IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50LmNsaWVudFdpZHRoIDogMDtcblxuICAvLyBSZWNhbGN1bGF0ZSByYWlsIG1hcmdpbnNcbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgZC5jc3MoaS5zY3JvbGxiYXJZUmFpbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgaS5yYWlsWE1hcmdpbldpZHRoID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhclhSYWlsLCAnbWFyZ2luTGVmdCcpKSArIGgudG9JbnQoZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ21hcmdpblJpZ2h0JykpO1xuICBpLnJhaWxZTWFyZ2luSGVpZ2h0ID0gaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luVG9wJykpICsgaC50b0ludChkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnbWFyZ2luQm90dG9tJykpO1xuXG4gIC8vIEhpZGUgc2Nyb2xsYmFycyBub3QgdG8gYWZmZWN0IHNjcm9sbFdpZHRoIGFuZCBzY3JvbGxIZWlnaHRcbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICBkLmNzcyhpLnNjcm9sbGJhcllSYWlsLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgdXBkYXRlR2VvbWV0cnkoZWxlbWVudCk7XG5cbiAgZC5jc3MoaS5zY3JvbGxiYXJYUmFpbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIGQuY3NzKGkuc2Nyb2xsYmFyWVJhaWwsICdkaXNwbGF5JywgJycpO1xufTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIGxvZyA9IGNkYi5sb2c7XG52YXIgRGFzaGJvYXJkVmlldyA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLXZpZXcnKTtcbnZhciBXaWRnZXRzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vd2lkZ2V0cy93aWRnZXRzLWNvbGxlY3Rpb24nKTtcbnZhciBXaWRnZXRNb2RlbEZhY3RvcnkgPSByZXF1aXJlKCcuL3dpZGdldHMvd2lkZ2V0LW1vZGVsLWZhY3RvcnknKTtcbnZhciBMaXN0TW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvbGlzdC9tb2RlbCcpO1xudmFyIEhpc3RvZ3JhbU1vZGVsID0gcmVxdWlyZSgnLi93aWRnZXRzL2hpc3RvZ3JhbS9tb2RlbCcpO1xudmFyIENhdGVnb3J5TW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvY2F0ZWdvcnkvbW9kZWwnKTtcbnZhciBGb3JtdWxhTW9kZWwgPSByZXF1aXJlKCcuL3dpZGdldHMvZm9ybXVsYS9tb2RlbCcpO1xudmFyIFJhbmdlRmlsdGVyID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvZmlsdGVycy9yYW5nZScpO1xudmFyIENhdGVnb3J5RmlsdGVyID0gcmVxdWlyZSgnLi93aW5kc2hhZnQvZmlsdGVycy9jYXRlZ29yeScpO1xudmFyIFdpbmRzaGFmdENvbmZpZyA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L2NvbmZpZycpO1xudmFyIFdpbmRzaGFmdENsaWVudCA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L2NsaWVudCcpO1xudmFyIFdpbmRzaGFmdERhc2hib2FyZCA9IHJlcXVpcmUoJy4vd2luZHNoYWZ0L2Rhc2hib2FyZCcpO1xudmFyIFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWcgPSByZXF1aXJlKCcuL3dpbmRzaGFmdC9wcml2YXRlLWRhc2hib2FyZC1jb25maWcnKTtcbnZhciBXaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWcgPSByZXF1aXJlKCcuL3dpbmRzaGFmdC9wdWJsaWMtZGFzaGJvYXJkLWNvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBkaUpTT04sIHZpc09wdHMpIHtcbiAgdmFyIHdpZGdldE1vZGVsRmFjdG9yeSA9IG5ldyBXaWRnZXRNb2RlbEZhY3Rvcnkoe1xuICAgIGxpc3Q6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IExpc3RNb2RlbChhdHRycywgb3B0cyk7XG4gICAgfSxcbiAgICBmb3JtdWxhOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgICAgcmV0dXJuIG5ldyBGb3JtdWxhTW9kZWwoYXR0cnMsIG9wdHMpO1xuICAgIH0sXG4gICAgaGlzdG9ncmFtOiBmdW5jdGlvbihhdHRycywgb3B0cywgbGF5ZXJJbmRleCkge1xuICAgICAgb3B0cy5maWx0ZXIgPSBuZXcgUmFuZ2VGaWx0ZXIoe1xuICAgICAgICB3aWRnZXRJZDogYXR0cnMuaWQsXG4gICAgICAgIGxheWVySW5kZXg6IGxheWVySW5kZXhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBIaXN0b2dyYW1Nb2RlbChhdHRycywgb3B0cyk7XG4gICAgfSxcbiAgICAndGltZS1zZXJpZXMnOiBmdW5jdGlvbihhdHRycywgb3B0cywgbGF5ZXJJbmRleCkge1xuICAgICAgLy8gY2hhbmdlIHR5cGUgYmVjYXVzZSB0aW1lLXNlcmllcyBiZWNhdXNlIGl0J3MgcmVhbGx5IGEgaGlzdG9ncmFtIChmb3IgdGhlIHRpbGVyIGF0IGxlYXN0KVxuICAgICAgYXR0cnMudHlwZSA9ICdoaXN0b2dyYW0nO1xuICAgICAgb3B0cy5maWx0ZXIgPSBuZXcgUmFuZ2VGaWx0ZXIoe1xuICAgICAgICB3aWRnZXRJZDogYXR0cnMuaWQsXG4gICAgICAgIGxheWVySW5kZXg6IGxheWVySW5kZXhcbiAgICAgIH0pO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IEhpc3RvZ3JhbU1vZGVsKGF0dHJzLCBvcHRzKTtcblxuICAgICAgLy8gc2luY2Ugd2UgY2hhbmdlZCB0aGUgdHlwZSBvZiB3ZSBuZWVkIHNvbWUgd2F5IHRvIGlkZW50aWZ5IHRoYXQgaXQncyBpbnRlbmRlZCBmb3IgYSB0aW1lLXNlcmllcyB2aWV3IGxhdGVyXG4gICAgICBtb2RlbC5pc0ZvclRpbWVTZXJpZXMgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICBhZ2dyZWdhdGlvbjogZnVuY3Rpb24oYXR0cnMsIG9wdHMsIGxheWVySW5kZXgpIHtcbiAgICAgIG9wdHMuZmlsdGVyID0gbmV3IENhdGVnb3J5RmlsdGVyKHtcbiAgICAgICAgd2lkZ2V0SWQ6IGF0dHJzLmlkLFxuICAgICAgICBsYXllckluZGV4OiBsYXllckluZGV4XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlNb2RlbChhdHRycywgb3B0cyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPIGtlZXAgdGhpcyBjb2xsZWN0aW9uIGluIHN5bmMgd2l0aCBsYXllcnMgaW5kaXZpZHVhbCB3aWRnZXRzIGNvbGxlY3Rpb25zXG4gIHZhciB3aWRnZXRzID0gbmV3IFdpZGdldHNDb2xsZWN0aW9uKCk7XG5cbiAgdmFyIGRhc2hib2FyZEluZm9Nb2RlbCA9IG5ldyBNb2RlbCh7XG4gICAgdGl0bGU6IGRpSlNPTi50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogZGlKU09OLmRlc2NyaXB0aW9uLFxuICAgIHVwZGF0ZWRBdDogZGlKU09OLnVwZGF0ZWRfYXQsXG4gICAgdXNlck5hbWU6IGRpSlNPTi51c2VyLmZ1bGxuYW1lLFxuICAgIHVzZXJBdmF0YXJVUkw6IGRpSlNPTi51c2VyLmF2YXRhcl91cmxcbiAgfSk7XG4gIHZhciBkYXNoYm9hcmRWaWV3ID0gbmV3IERhc2hib2FyZFZpZXcoe1xuICAgIGVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgICB3aWRnZXRzOiB3aWRnZXRzLFxuICAgIGRhc2hib2FyZEluZm9Nb2RlbDogZGFzaGJvYXJkSW5mb01vZGVsXG4gIH0pO1xuXG4gIHZhciB2aXMgPSBjZGIuY3JlYXRlVmlzKGRhc2hib2FyZFZpZXcuJCgnI21hcCcpLCBkaUpTT04udml6SlNPTiwgdmlzT3B0cyk7XG5cbiAgdmFyIGNhcnRvREJMYXllckdyb3VwO1xuICB2YXIgaW50ZXJhY3RpdmVMYXllcnMgPSBbXTtcbiAgdmlzLm1hcC5sYXllcnMuZWFjaChmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBsYXllclR5cGUgPSBsYXllci5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgaXNMYXllckdyb3VwID0gbGF5ZXJUeXBlID09PSAnbGF5ZXJncm91cCc7XG5cbiAgICBpZiAoaXNMYXllckdyb3VwKSB7XG4gICAgICBjYXJ0b0RCTGF5ZXJHcm91cCA9IGxheWVyO1xuICAgIH1cblxuICAgIGlmIChpc0xheWVyR3JvdXAgfHwgbGF5ZXJUeXBlID09PSAnbmFtZWRtYXAnKSB7XG4gICAgICBsYXllci5sYXllcnMuZWFjaChmdW5jdGlvbihzdWJMYXllcikge1xuICAgICAgICBpbnRlcmFjdGl2ZUxheWVycy5wdXNoKHN1YkxheWVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgaWYgKGxheWVyVHlwZSA9PT0gJ3RvcnF1ZScpIHtcbiAgICAgICAgaW50ZXJhY3RpdmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IG1vdmUgdGhpcyBsb2dpYyBzb21ld2hlcmUgZWxzZVxuICB2YXIgd2lkZ2V0TW9kZWxzID0gW107XG4gIGZvciAodmFyIGlkIGluIGRpSlNPTi53aWRnZXRzKSB7XG4gICAgdmFyIGQgPSBkaUpTT04ud2lkZ2V0c1tpZF07XG4gICAgdmFyIGxheWVyO1xuXG4gICAgLy8gRmluZCB0aGUgTGF5ZXIgdGhhdCB0aGUgV2lkZ2V0IHNob3VsZCBiZSBjcmVhdGVkIGZvci5cbiAgICAvLyBhIGxheWVySWQgaGFzIHRvcC1wcmlvcml0eSwgb3RoZXJ3aXNlIGl0IHRyaWVzIHdpdGggYSBsYXllckluZGV4LCBhbmQgZXZlbiBhIHN1YkxheWVySW5kZXggKGlmIGF2YWlsYWJsZSlcbiAgICBpZiAoZC5sYXllcklkKSB7XG4gICAgICBsYXllciA9IF8uZmluZChpbnRlcmFjdGl2ZUxheWVycywgZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4gZC5sYXllcklkID09PSBsLmdldCgnaWQnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihkLmxheWVySW5kZXgpKSB7XG4gICAgICBsYXllciA9IHZpcy5tYXAubGF5ZXJzLmF0KGQubGF5ZXJJbmRleCk7XG4gICAgICBpZiAobGF5ZXIgJiYgTnVtYmVyLmlzSW50ZWdlcihkLnN1YkxheWVySW5kZXgpKSB7XG4gICAgICAgIGxheWVyID0gbGF5ZXIubGF5ZXJzLmF0KGQuc3ViTGF5ZXJJbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxheWVyKSB7XG4gICAgICB2YXIgbGF5ZXJJbmRleCA9IGludGVyYWN0aXZlTGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe1xuICAgICAgICBpZDogaWRcbiAgICAgIH0sIGQpO1xuICAgICAgdmFyIHdpZGdldE1vZGVsID0gd2lkZ2V0TW9kZWxGYWN0b3J5LmNyZWF0ZU1vZGVsKGxheWVyLCBsYXllckluZGV4LCBhdHRycyk7XG4gICAgICB3aWRnZXRNb2RlbHMucHVzaCh3aWRnZXRNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5lcnJvcignbm8gbGF5ZXIgZm91bmQgZm9yIHdpZGdldCAnICsgaWQgKyAnOicgICsgSlNPTi5zdHJpbmdpZnkoZCkpO1xuICAgIH1cbiAgfVxuICB3aWRnZXRzLnJlc2V0KHdpZGdldE1vZGVscyk7XG5cbiAgZGFzaGJvYXJkVmlldy5yZW5kZXIoKTtcblxuICAvLyBUT0RPOiBQZXJoYXBzIHRoaXMgXCJlbmRwb2ludFwiIGNvdWxkIGJlIHBhcnQgb2YgdGhlIFwiZGF0YXNvdXJjZVwiP1xuICB2YXIgZW5kcG9pbnQgPSBXaW5kc2hhZnRDb25maWcuTUFQU19BUElfQkFTRV9VUkw7XG4gIHZhciBjb25maWdHZW5lcmF0b3IgPSBXaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWc7XG4gIHZhciBkYXRhc291cmNlID0gZGlKU09OLmRhdGFzb3VyY2U7XG4gIC8vIFRPRE86IFdlIGNhbiB1c2Ugc29tZXRoaW5nIGVsc2UgdG8gZGlmZmVyZW50aWF0ZSB0eXBlcyBvZiBcImRhdGFzb3VyY2VcInNcbiAgaWYgKGRhdGFzb3VyY2UudGVtcGxhdGVfbmFtZSkge1xuICAgIGVuZHBvaW50ID0gW1dpbmRzaGFmdENvbmZpZy5NQVBTX0FQSV9CQVNFX1VSTCwgJ25hbWVkJywgZGF0YXNvdXJjZS50ZW1wbGF0ZV9uYW1lXS5qb2luKCcvJyk7XG4gICAgY29uZmlnR2VuZXJhdG9yID0gV2luZHNoYWZ0UHJpdmF0ZURhc2hib2FyZENvbmZpZztcbiAgfVxuXG4gIHZhciB3aW5kc2hhZnRDbGllbnQgPSBuZXcgV2luZHNoYWZ0Q2xpZW50KHtcbiAgICBlbmRwb2ludDogZW5kcG9pbnQsXG4gICAgdXJsVGVtcGxhdGU6IGRhdGFzb3VyY2UubWFwc19hcGlfdGVtcGxhdGUsXG4gICAgdXNlck5hbWU6IGRhdGFzb3VyY2UudXNlcl9uYW1lLFxuICAgIHN0YXRUYWc6IGRhdGFzb3VyY2Uuc3RhdF90YWcsXG4gICAgZm9yY2VDb3JzOiBkYXRhc291cmNlLmZvcmNlX2NvcnNcbiAgfSk7XG5cbiAgdmFyIGRhc2hib2FyZCA9IG5ldyBXaW5kc2hhZnREYXNoYm9hcmQoe1xuICAgIGNsaWVudDogd2luZHNoYWZ0Q2xpZW50LFxuICAgIGNvbmZpZ0dlbmVyYXRvcjogY29uZmlnR2VuZXJhdG9yLFxuICAgIHN0YXRUYWc6IGRhdGFzb3VyY2Uuc3RhdF90YWcsXG4gICAgLy9UT0RPOiBhc3N1bWluZyBoZXJlIGFsbCB2aXouanNvbiBoYXMgYSBsYXllcmdyb3VwIGFuZCB0aGF0IG1heSBub3QgYmUgdHJ1ZVxuICAgIGxheWVyR3JvdXA6IGNhcnRvREJMYXllckdyb3VwLFxuICAgIGxheWVyczogaW50ZXJhY3RpdmVMYXllcnMsXG4gICAgd2lkZ2V0czogd2lkZ2V0cyxcbiAgICBtYXA6IHZpcy5tYXBcbiAgfSk7XG5cbiAgLy8gVE9ETzogcmV0aGluayB0aGlzXG4gIGlmICh3aWRnZXRzLnNpemUoKSA+IDApIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdmlzLm1hcFZpZXcuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIHJldHVybiBkYXNoYm9hcmRWaWV3O1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgV2lkZ2V0Vmlld0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dpZGdldHMvd2lkZ2V0LXZpZXctZmFjdG9yeScpO1xudmFyIFRpbWVTZXJpZXNDb250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy90aW1lLXNlcmllcy9jb250ZW50LXZpZXcnKTtcbnZhciBUb3JxdWVUaW1lU2VyaWVzQ29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvdGltZS1zZXJpZXMvdG9ycXVlLWNvbnRlbnQtdmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItRGFzaGJvYXJkLWJlbG93TWFwJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fd2lkZ2V0Vmlld0ZhY3RvcnkgPSBuZXcgV2lkZ2V0Vmlld0ZhY3RvcnkoW1xuICAgICAge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24obSkge1xuICAgICAgICAgIC8vIGlzRm9yVGltZVNlcmllcyBpcyBzZXQgdG8gdHJ1ZSB0byBkaXN0aW5ndWlzaCBmcm9tIGRlZmF1bHQgdHlwZSAnaGlzdG9ncmFtJ1xuICAgICAgICAgIC8vIFRoaXMgbWF0Y2ggbmVlZHMgdG8gYmUgZG9uZSBiZWZvcmUgdGhlIGRlZmF1bHQgdGltZS1zZXJpZXMgd2lkZ2V0J3MgbWF0Y2ggYmVsb3cgdG8gaGF2ZSBwcmVzZWRlbmNlXG4gICAgICAgICAgcmV0dXJuIG0uaXNGb3JUaW1lU2VyaWVzICYmIG0ubGF5ZXIuZ2V0KCd0eXBlJykgPT09ICd0b3JxdWUnO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVG9ycXVlVGltZVNlcmllc0NvbnRlbnRWaWV3KHtcbiAgICAgICAgICAgIG1vZGVsOiBtLFxuICAgICAgICAgICAgcmFuZ2VGaWx0ZXI6IG0uZmlsdGVyLFxuICAgICAgICAgICAgdG9ycXVlTGF5ZXJNb2RlbDogbS5sYXllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjdXN0b21pemVXaWRnZXRBdHRyczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICBhdHRycy5jbGFzc05hbWUgKz0gJyBDREItV2lkZ2V0LS10aW1lU2VyaWVzJztcbiAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAvLyBpc0ZvclRpbWVTZXJpZXMgaXMgc2V0IHRvIHRydWUgdG8gZGlzdGluZ3Vpc2ggZnJvbSBkZWZhdWx0IHR5cGUgJ2hpc3RvZ3JhbSdcbiAgICAgICAgICByZXR1cm4gbS5pc0ZvclRpbWVTZXJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNvbnRlbnRWaWV3OiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUaW1lU2VyaWVzQ29udGVudFZpZXcoe1xuICAgICAgICAgICAgbW9kZWw6IG0sXG4gICAgICAgICAgICBmaWx0ZXI6IG0uZmlsdGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbWl6ZVdpZGdldEF0dHJzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgIGF0dHJzLmNsYXNzTmFtZSArPSAnIENEQi1XaWRnZXQtLXRpbWVTZXJpZXMnO1xuICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0pO1xuXG4gICAgdGhpcy5fd2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcbiAgICB0aGlzLl93aWRnZXRzLmJpbmQoJ2FkZCcsIHRoaXMuX21heWJlUmVuZGVyV2lkZ2V0VmlldywgdGhpcyk7XG4gICAgdGhpcy5fd2lkZ2V0cy5iaW5kKCdyZXNldCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX3dpZGdldHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICB0aGlzLl93aWRnZXRzLmVhY2godGhpcy5fbWF5YmVSZW5kZXJXaWRnZXRWaWV3LCB0aGlzKTtcbiAgICB0aGlzLiRlbC50b2dnbGUoIV8uaXNFbXB0eSh0aGlzLl9zdWJ2aWV3cykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9tYXliZVJlbmRlcldpZGdldFZpZXc6IGZ1bmN0aW9uKHdpZGdldE1vZGVsKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLl93aWRnZXRWaWV3RmFjdG9yeS5jcmVhdGVXaWRnZXRWaWV3KHdpZGdldE1vZGVsKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLWluZm8tdmlldy50cGwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxudmFyIERhc2hib2FyZEluZm9WaWV3ID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1EYXNoYm9hcmQtaW5mbycsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy10b2dnbGUtdmlldy1saW5rJzogXCJfdG9nZ2xlVmlld1wiXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICB0aXRsZTogdGhpcy5tb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLm1vZGVsLmdldCgnZGVzY3JpcHRpb24nKSxcbiAgICAgICAgdXBkYXRlZEF0OiBtb21lbnQodGhpcy5tb2RlbC5nZXQoJ3VwZGF0ZWRBdCcpKS5mcm9tTm93KCksXG4gICAgICAgIHVzZXJOYW1lOiB0aGlzLm1vZGVsLmdldCgndXNlck5hbWUnKSxcbiAgICAgICAgdXNlckF2YXRhclVSTDogdGhpcy5tb2RlbC5nZXQoJ3VzZXJBdmF0YXJVUkwnKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3RvZ2dsZVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnRvZ2dsZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGFzaGJvYXJkSW5mb1ZpZXc7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9IZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0xvZ29cIj4gPGkgY2xhc3M9XCJDREItSWNvbiBDREItSWNvbi1jYXJ0b2ZhbnRlXCI+PC9pPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0FjdGlvbnNcIj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0FjdGlvbnNMaW5rIGpzLXRvZ2dsZS12aWV3LWxpbmtcIj48L2J1dHRvbj4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9UZXh0c1wiPiA8cCBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb1VwZGF0ZVwiPlVQREFURUQgJytcbigoX190PSggdXBkYXRlZEF0ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPGgxIGNsYXNzPVwiQ0RCLURhc2hib2FyZC1pbmZvVGl0bGVcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gxPiA8aDIgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9EZXNjcmlwdGlvblwiPicrXG4oKF9fdD0oIGRlc2NyaXB0aW9uICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDI+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0Zvb3RlclwiPiA8dWw+ICA8bGkgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9Gb290ZXJJdGVtXCI+IDxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLWluZm9NZWRpYSBDREItRGFzaGJvYXJkLWluZm9BdmF0YXJcIj4gPGltZyBzcmM9XCInK1xuKChfX3Q9KCB1c2VyQXZhdGFyVVJMICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIGFsdD1cImF2YXRhclwiIGNsYXNzPVwiaW5saW5lLWJsb2NrXCI+IDwvZGl2PiA8cCBjbGFzcz1cIkNEQi1EYXNoYm9hcmQtaW5mb0Zvb3RlclR4dFwiPicrXG4oKF9fdD0oIHVzZXJOYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPC9saT4gPC91bD4gPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciAkID0gY2RiLiQ7XG52YXIgUHMgPSByZXF1aXJlKCdwZXJmZWN0LXNjcm9sbGJhcicpO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgQ2F0ZWdvcnlDb250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9jYXRlZ29yeS9jb250ZW50X3ZpZXcnKTtcbnZhciBGb3JtdWxhQ29udGVudFZpZXcgPSByZXF1aXJlKCcuL3dpZGdldHMvZm9ybXVsYS9jb250ZW50X3ZpZXcnKTtcbnZhciBIaXN0b2dyYW1Db250ZW50VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0cy9oaXN0b2dyYW0vY29udGVudC12aWV3Jyk7XG52YXIgTGlzdENvbnRlbnRWaWV3ID0gcmVxdWlyZSgnLi93aWRnZXRzL2xpc3QvY29udGVudF92aWV3Jyk7XG52YXIgV2lkZ2V0Vmlld0ZhY3RvcnkgPSByZXF1aXJlKCcuL3dpZGdldHMvd2lkZ2V0LXZpZXctZmFjdG9yeScpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtc2lkZWJhci50cGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1jYW52YXMnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl93aWRnZXRWaWV3RmFjdG9yeSA9IG5ldyBXaWRnZXRWaWV3RmFjdG9yeShbXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZvcm11bGFDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgY3JlYXRlQ29udGVudFZpZXc6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExpc3RDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZ2V0KCd0eXBlJykgPT09ICdoaXN0b2dyYW0nICYmIG0ubGF5ZXIuZ2V0KCd0eXBlJykgIT09ICd0b3JxdWUnO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9ncmFtQ29udGVudFZpZXcoe1xuICAgICAgICAgICAgZGF0YU1vZGVsOiBtLFxuICAgICAgICAgICAgdmlld01vZGVsOiBuZXcgTW9kZWwoKSxcbiAgICAgICAgICAgIGZpbHRlcjogbS5maWx0ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiAnYWdncmVnYXRpb24nLFxuICAgICAgICBjcmVhdGVDb250ZW50VmlldzogZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBtb2RlbDogbSxcbiAgICAgICAgICAgIGZpbHRlcjogbS5maWx0ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0pO1xuXG4gICAgdGhpcy5fd2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcblxuICAgIHRoaXMuX3dpZGdldHMuYmluZCgnYWRkJywgdGhpcy5fbWF5YmVSZW5kZXJXaWRnZXRWaWV3LCB0aGlzKTtcbiAgICB0aGlzLl93aWRnZXRzLmJpbmQoJ3Jlc2V0JywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuX3dpZGdldHMuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMuX29uV2lkZ2V0Q29sbGFwc2VkLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX3dpZGdldHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYW5TY3JvbGxFdmVudCgpO1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuXG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl93aWRnZXRzLmVhY2godGhpcy5fbWF5YmVSZW5kZXJXaWRnZXRWaWV3LCB0aGlzKTtcbiAgICB0aGlzLiRlbC50b2dnbGUoIV8uaXNFbXB0eSh0aGlzLl9zdWJ2aWV3cykpO1xuXG4gICAgdGhpcy5fcmVuZGVyU2Nyb2xsKCk7XG4gICAgdGhpcy5fcmVuZGVyU2hhZG93cygpO1xuICAgIHRoaXMuX2JpbmRTY3JvbGwoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF8kY29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJCh0aGlzLl9jb250YWluZXIoKSk7XG4gIH0sXG5cbiAgX2NvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmpzLWNvbnRhaW5lcicpO1xuICB9LFxuXG4gIF9tYXliZVJlbmRlcldpZGdldFZpZXc6IGZ1bmN0aW9uKHdpZGdldE1vZGVsKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLl93aWRnZXRWaWV3RmFjdG9yeS5jcmVhdGVXaWRnZXRWaWV3KHdpZGdldE1vZGVsKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy5hZGRWaWV3KHZpZXcpO1xuICAgICAgdGhpcy5fJGNvbnRhaW5lcigpLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcbiAgICB9XG4gIH0sXG5cbiAgX2JpbmRTY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuXyRjb250YWluZXIoKVxuICAgICAgLm9uKCdwcy15LXJlYWNoLXN0YXJ0JywgXy5iaW5kKHRoaXMuX29uU2Nyb2xsVG9wLCB0aGlzKSlcbiAgICAgIC5vbigncHMteS1yZWFjaC1lbmQnLCBfLmJpbmQodGhpcy5fb25TY3JvbGxCb3R0b20sIHRoaXMpKVxuICAgICAgLm9uKCdwcy1zY3JvbGwteScsIF8uYmluZCh0aGlzLl9vblNjcm9sbCwgdGhpcykpO1xuICB9LFxuXG4gIF9yZW5kZXJTY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgIFBzLmluaXRpYWxpemUodGhpcy5fY29udGFpbmVyKCksIHtcbiAgICAgIHdoZWVsU3BlZWQ6IDIsXG4gICAgICB3aGVlbFByb3BhZ2F0aW9uOiB0cnVlLFxuICAgICAgbWluU2Nyb2xsYmFyTGVuZ3RoOiAyMFxuICAgIH0pO1xuICB9LFxuXG4gIF9vbldpZGdldENvbGxhcHNlZDogZnVuY3Rpb24oKSB7XG4gICAgUHMudXBkYXRlKHRoaXMuX2NvbnRhaW5lcigpKTtcbiAgfSxcblxuICBfcmVuZGVyU2hhZG93czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuJHNoYWRvd1RvcCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoXCJDREItV2lkZ2V0LWNhbnZhc1NoYWRvdyBDREItV2lkZ2V0LWNhbnZhc1NoYWRvdy0tdG9wXCIpO1xuICAgIHRoaXMuJHNoYWRvd0JvdHRvbSA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoXCJDREItV2lkZ2V0LWNhbnZhc1NoYWRvdyBDREItV2lkZ2V0LWNhbnZhc1NoYWRvdy0tYm90dG9tIGlzLXZpc2libGVcIik7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuJHNoYWRvd1RvcCk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuJHNoYWRvd0JvdHRvbSk7XG4gIH0sXG5cbiAgX29uU2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRzaGFkb3dUb3AucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgfSxcblxuICBfb25TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgIHZhciAkZWwgPSB0aGlzLl8kY29udGFpbmVyKCk7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAkZWwuc2Nyb2xsVG9wKCk7XG4gICAgdmFyIG1heCA9ICRlbC5nZXQoMCkuc2Nyb2xsSGVpZ2h0O1xuICAgIHZhciBoZWlnaHQgPSAkZWwub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgbWF4UG9zID0gbWF4IC0gaGVpZ2h0O1xuICAgIHRoaXMuJHNoYWRvd1RvcC50b2dnbGVDbGFzcygnaXMtdmlzaWJsZScsIGN1cnJlbnRQb3MgPiAwKTtcbiAgICB0aGlzLiRzaGFkb3dCb3R0b20udG9nZ2xlQ2xhc3MoJ2lzLXZpc2libGUnLCBjdXJyZW50UG9zIDwgbWF4UG9zKTtcbiAgfSxcblxuICBfb25TY3JvbGxCb3R0b206IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJHNoYWRvd0JvdHRvbS5yZW1vdmVDbGFzcygnaXMtdmlzaWJsZScpO1xuICB9LFxuXG4gIF9jbGVhblNjcm9sbEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fJGNvbnRhaW5lcigpKSB7XG4gICAgICB0aGlzLl8kY29udGFpbmVyKCkub2ZmKCdwcy1zY3JvbGwteScpO1xuICAgIH1cbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2xlYW5TY3JvbGxFdmVudCgpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNhbnZhc0lubmVyIGpzLWNvbnRhaW5lclwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLnRwbCcpO1xudmFyIERhc2hib2FyZEJlbG93TWFwVmlldyA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLWJlbG93LW1hcC12aWV3Jyk7XG52YXIgRGFzaGJvYXJkSW5mb1ZpZXcgPSByZXF1aXJlKCcuL2Rhc2hib2FyZC1pbmZvLXZpZXcnKTtcbnZhciBEYXNoYm9hcmRTaWRlYmFyVmlldyA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkLXNpZGViYXItdmlldycpO1xuXG4vKipcbiAqIERhc2hib2FyZCBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBtYXAgY2FudmFzLCB3aGljaCBjb250YWlucyB3aWRnZXQgdmlld3MgZm9yIHRoZSBtYXAgY29udGR4dFxuICogV2lkZ2V0cyBtYXkgYmUgcmVuZGVyZWQgaW4gdHdvIGFyZWFzLCBpbiB0aGUgXCJzaWRlYmFyXCIgb3IgXCJiZWxvdy1tYXBcIi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLURhc2hib2FyZC1jYW52YXMnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl93aWRnZXRzID0gb3B0aW9ucy53aWRnZXRzO1xuICAgIHRoaXMuX2Rhc2hib2FyZEluZm9Nb2RlbCA9IG9wdGlvbnMuZGFzaGJvYXJkSW5mb01vZGVsO1xuXG4gICAgLy8gVE9ETyBwYXJlbnQgY29udGV4dCByZXF1aXJlcyBzb21lIG1hcmt1cCB0byBiZSBwcmVzZW50IGFscmVhZHksIGJ1dCBOT1QgdGhlIG90aGVyIHZpZXdzXG4gICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKTtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG5cbiAgICB2YXIgdmlldztcbiAgICB2aWV3ID0gbmV3IERhc2hib2FyZEluZm9WaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLl9kYXNoYm9hcmRJbmZvTW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuXG4gICAgdmlldyA9IG5ldyBEYXNoYm9hcmRCZWxvd01hcFZpZXcoe1xuICAgICAgd2lkZ2V0czogdGhpcy5fd2lkZ2V0c1xuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICB0aGlzLiQoJy5qcy1tYXAtd3JhcHBlcicpLmFwcGVuZCh2aWV3LnJlbmRlcigpLmVsKTtcblxuICAgIHZpZXcgPSBuZXcgRGFzaGJvYXJkU2lkZWJhclZpZXcoe1xuICAgICAgd2lkZ2V0czogdGhpcy5fd2lkZ2V0c1xuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodmlldy5yZW5kZXIoKS5lbCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItRGFzaGJvYXJkLW1hcFdyYXBwZXIgQ0RCLURhc2hib2FyZC1tYXBXcmFwcGVyLS1tYXJnaW4ganMtbWFwLXdyYXBwZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1NYXAtY2FudmFzXCI+IDxkaXYgY2xhc3M9XCJDREItTWFwXCIgaWQ9XCJtYXBcIj48L2Rpdj4gPC9kaXY+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGxvZyA9IGNkYi5sb2c7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG5cbi8qKlxuICogQW5pbWF0ZSBiZXR3ZWVuIHR3byB2YWx1ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgYW5pbWF0ZUZyb21WYWx1ZXM6IGZ1bmN0aW9uKGZyb20sIHRvLCBjbGFzc05hbWUsIHRlbXBsYXRlLCBvcHRzKSB7XG4gICAgdmFyICRlbCA9IHRoaXMuJChjbGFzc05hbWUpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgZDMuZm9ybWF0KCcwLDAwMCcpO1xuICAgIHZhciB0ZW1wbGF0ZURhdGEgPSBvcHRpb25zLnRlbXBsYXRlRGF0YSB8fCB7fTtcbiAgICB2YXIgZGVib3VuY2VXYWl0ID0gb3B0aW9ucy5kZWJvdW5jZVdhaXQgfHwgNTAwO1xuXG4gICAgdmFyIHN0ZXBWYWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZSA9IChfLmlzTmFOKGkpIHx8IGkgPT09IHVuZGVmaW5lZCkgPyAob3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgMCkgOiBmb3JtYXR0ZXIoaSk7XG4gICAgICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHsgdmFsdWU6IHZhbHVlIH0sIHRlbXBsYXRlRGF0YSk7XG4gICAgICAkZWwudGV4dCh0ZW1wbGF0ZShkYXRhKSk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvblNwZWVkID09PSAwKSB7XG4gICAgICBzdGVwVmFsdWUodG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0ZXBWYWx1ZShmcm9tKTtcblxuICAgIHZhciBhbmltYXRlID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICRlbC5wcm9wKCdjb3VudGVyJywgZnJvbSkuc3RvcCgpLmFuaW1hdGUoeyBjb3VudGVyOiB0byB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblNwZWVkIHx8IDUwMCxcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZ01ldGhvZCB8fCAnc3dpbmcnLFxuICAgICAgICBzdGVwOiBzdGVwVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIGRlYm91bmNlV2FpdCk7XG5cbiAgICBhbmltYXRlKCk7XG4gIH0sXG5cbiAgYW5pbWF0ZUZyb21DdXJyZW50VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBjbGFzc05hbWUsIHRlbXBsYXRlLCBvcHRzKSB7XG4gICAgdmFyICRlbCA9IHRoaXMuJChjbGFzc05hbWUpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBkZWJvdW5jZVdhaXQgPSBvcHRpb25zLmRlYm91bmNlV2FpdCB8fCA1MDA7XG5cbiAgICB2YXIgdG8gICA9IHZhbHVlO1xuICAgIHZhciBmcm9tID0gK3RoaXMuJChjbGFzc05hbWUpLnRleHQoKTtcblxuICAgIHZhciBmb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBkMy5mb3JtYXQoJzAsMDAwJyk7XG4gICAgdmFyIHRlbXBsYXRlRGF0YSA9IG9wdGlvbnMudGVtcGxhdGVEYXRhIHx8IHt9O1xuXG4gICAgdmFyIHN0ZXBWYWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZSA9IChfLmlzTmFOKGkpIHx8IGkgPT09IHVuZGVmaW5lZCkgPyAob3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgMCkgOiBmb3JtYXR0ZXIoaSk7XG4gICAgICB2YXIgZGF0YSA9IF8uZXh0ZW5kKHsgdmFsdWU6IHZhbHVlIH0sIHRlbXBsYXRlRGF0YSk7XG4gICAgICAkZWwudGV4dCh0ZW1wbGF0ZShkYXRhKSk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvblNwZWVkID09PSAwKSB7XG4gICAgICBzdGVwVmFsdWUodG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0ZXBWYWx1ZShmcm9tKTtcblxuICAgIHZhciBhbmltYXRlID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICRlbC5wcm9wKCdjb3VudGVyJywgZnJvbSkuc3RvcCgpLmFuaW1hdGUoeyBjb3VudGVyOiB0byB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblNwZWVkIHx8IDUwMCxcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZ01ldGhvZCB8fCAnc3dpbmcnLFxuICAgICAgICBzdGVwOiBzdGVwVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIGRlYm91bmNlV2FpdCk7XG5cbiAgICBhbmltYXRlKCk7XG4gIH0sXG5cbiAgYW5pbWF0ZVZhbHVlOiBmdW5jdGlvbihtb2RlbCwgd2hhdCwgY2xhc3NOYW1lLCB0ZW1wbGF0ZSwgb3B0cykge1xuICAgIHZhciAkZWwgPSB0aGlzLiQoY2xhc3NOYW1lKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZGVib3VuY2VXYWl0ID0gb3B0aW9ucy5kZWJvdW5jZVdhaXQgfHwgNTAwO1xuXG4gICAgdmFyIHRvICAgPSBtb2RlbC5nZXQod2hhdCk7XG4gICAgdmFyIGZyb20gPSBtb2RlbC5wcmV2aW91cyh3aGF0KSB8fCAwO1xuXG4gICAgdmFyIGZvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IGQzLmZvcm1hdCgnMCwwMDAnKTtcbiAgICB2YXIgdGVtcGxhdGVEYXRhID0gb3B0aW9ucy50ZW1wbGF0ZURhdGEgfHwge307XG5cbiAgICB2YXIgc3RlcFZhbHVlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhbHVlID0gKF8uaXNOYU4oaSkgfHwgaSA9PT0gdW5kZWZpbmVkKSA/IChvcHRpb25zLmRlZmF1bHRWYWx1ZSB8fCAwKSA6IGZvcm1hdHRlcihpKTtcbiAgICAgIHZhciBkYXRhID0gXy5leHRlbmQoeyB2YWx1ZTogdmFsdWUgfSwgdGVtcGxhdGVEYXRhKTtcbiAgICAgICRlbC50ZXh0KHRlbXBsYXRlKGRhdGEpKTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uU3BlZWQgPT09IDApIHtcbiAgICAgIHN0ZXBWYWx1ZSh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RlcFZhbHVlKGZyb20pO1xuXG4gICAgdmFyIGFuaW1hdGUgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgJGVsLnByb3AoJ2NvdW50ZXInLCBmcm9tKS5zdG9wKCkuYW5pbWF0ZSh7IGNvdW50ZXI6IHRvIH0sIHtcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uU3BlZWQgfHwgNTAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nTWV0aG9kIHx8ICdzd2luZycsXG4gICAgICAgIHN0ZXA6IHN0ZXBWYWx1ZVxuICAgICAgfSk7XG4gICAgfSwgZGVib3VuY2VXYWl0KTtcblxuICAgIGFuaW1hdGUoKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWhlYWRlciBqcy1oZWFkZXJcIj48L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudCBDREItV2lkZ2V0LWNvbnRlbnQtLW5vU2lkZXNNYXJnaW5cIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdFdyYXBwZXIganMtY29udGVudFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtZm9vdGVyIGpzLWZvb3RlclwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgV2lkZ2V0Q29udGVudCA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBTZWFyY2hUaXRsZVZpZXcgPSByZXF1aXJlKCcuL3RpdGxlL3NlYXJjaF90aXRsZV92aWV3Jyk7XG52YXIgQ2F0ZWdvcnlPcHRpb25zVmlldyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9vcHRpb25zX3ZpZXcnKTtcbnZhciBDYXRlZ29yeUl0ZW1zVmlldyA9IHJlcXVpcmUoJy4vbGlzdC9pdGVtc192aWV3Jyk7XG52YXIgV2lkZ2V0Vmlld01vZGVsID0gcmVxdWlyZSgnLi4vd2lkZ2V0X2NvbnRlbnRfbW9kZWwnKTtcbnZhciBDYXRlZ29yeVN0YXRzVmlldyA9IHJlcXVpcmUoJy4vc3RhdHMvc3RhdHNfdmlldycpO1xudmFyIENhdGVnb3J5UGFnaW5hdG9yVmlldyA9IHJlcXVpcmUoJy4vcGFnaW5hdG9yL3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgU2VhcmNoQ2F0ZWdvcnlJdGVtc1ZpZXcgPSByZXF1aXJlKCcuL2xpc3Qvc2VhcmNoX2l0ZW1zX3ZpZXcnKTtcbnZhciBTZWFyY2hDYXRlZ29yeVBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvci9zZWFyY2hfcGFnaW5hdG9yX3ZpZXcnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY29udGVudF90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDb250ZW50IHZpZXcgZm9yIGNhdGVnb3J5IHdpZGdldFxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldENvbnRlbnQuZXh0ZW5kKHtcblxuICBfSVRFTVNfUEVSX1BBR0U6IDYsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFdpZGdldFZpZXdNb2RlbCgpO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpjb2xsYXBzZWQnLCBmdW5jdGlvbihtZGwsIGlzQ29sbGFwc2VkKSB7XG4gICAgICB0aGlzLiRlbC50b2dnbGVDbGFzcygnaXMtY29sbGFwc2VkJywgISFpc0NvbGxhcHNlZCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2luaXRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlYXJjaFRpdGxlID0gbmV3IFNlYXJjaFRpdGxlVmlldyh7XG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtaGVhZGVyJykuYXBwZW5kKHNlYXJjaFRpdGxlLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2VhcmNoVGl0bGUpO1xuXG4gICAgdmFyIHN0YXRzID0gbmV3IENhdGVnb3J5U3RhdHNWaWV3KHtcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1oZWFkZXInKS5hcHBlbmQoc3RhdHMucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhzdGF0cyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG5ldyBDYXRlZ29yeU9wdGlvbnNWaWV3KHtcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWxcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuaHRtbChvcHRpb25zLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcob3B0aW9ucyk7XG5cbiAgICB2YXIgZGF0YUxpc3QgPSBuZXcgQ2F0ZWdvcnlJdGVtc1ZpZXcoe1xuICAgICAgdmlld01vZGVsOiB0aGlzLnZpZXdNb2RlbCxcbiAgICAgIGRhdGFNb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIGl0ZW1zUGVyUGFnZTogdGhpcy5fSVRFTVNfUEVSX1BBR0VcbiAgICB9KTtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKGRhdGFMaXN0LnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoZGF0YUxpc3QpO1xuXG4gICAgdmFyIHBhZ2luYXRpb24gPSBuZXcgQ2F0ZWdvcnlQYWdpbmF0b3JWaWV3KHtcbiAgICAgICR0YXJnZXQ6IGRhdGFMaXN0LiRlbCxcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBpdGVtc1BlclBhZ2U6IHRoaXMuX0lURU1TX1BFUl9QQUdFXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtZm9vdGVyJykuYXBwZW5kKHBhZ2luYXRpb24ucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhwYWdpbmF0aW9uKTtcblxuICAgIHZhciBzZWFyY2hMaXN0ID0gbmV3IFNlYXJjaENhdGVnb3J5SXRlbXNWaWV3KHtcbiAgICAgIHZpZXdNb2RlbDogdGhpcy52aWV3TW9kZWwsXG4gICAgICBkYXRhTW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICBpdGVtc1BlclBhZ2U6IHRoaXMuX0lURU1TX1BFUl9QQUdFLFxuICAgICAgcGFnaW5hdG9yOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZChzZWFyY2hMaXN0LnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2VhcmNoTGlzdCk7XG5cbiAgICB2YXIgc2VhcmNoUGFnaW5hdGlvbiA9IG5ldyBTZWFyY2hDYXRlZ29yeVBhZ2luYXRvclZpZXcoe1xuICAgICAgJHRhcmdldDogc2VhcmNoTGlzdC4kZWwsXG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgaXRlbXNQZXJQYWdlOiB0aGlzLl9JVEVNU19QRVJfUEFHRSxcbiAgICAgIHBhZ2luYXRvcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuJCgnLmpzLWZvb3RlcicpLmFwcGVuZChzZWFyY2hQYWdpbmF0aW9uLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2VhcmNoUGFnaW5hdGlvbik7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0SXRlbUlubmVyIENEQi1XaWRnZXQtbGlzdEJ1dHRvbiBqcy1idXR0b24gJytcbigoX190PSggaXNEaXNhYmxlZCA/ICdpcy1kaXNhYmxlZCcgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIENEQi1XaWRnZXQtdGV4dFNtYWxsLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsLS11cHBlclwiIHRpdGxlPVwiJytcbigoX190PSggbmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBuYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCBwcmVmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggZm9ybWF0dGVkVmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggc3VmZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXByb2dyZXNzQmFyXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUgJytcbigoX190PSggaXNBZ2dyZWdhdGVkID8gJ0NEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZS0tcGF0dGVybicgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBzdHlsZT1cIndpZHRoOiAnK1xuKChfX3Q9KCBwZXJjZW50YWdlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyU7IGJhY2tncm91bmQtY29sb3I6ICcrXG4oKF9fdD0oIGN1c3RvbUNvbG9yID8gY29sb3IgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj48L2Rpdj4gPC9kaXY+IDwvYnV0dG9uPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciAnK1xuKChfX3Q9KCBpc0Rpc2FibGVkID8gJ2lzLWRpc2FibGVkJyA6ICcnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGwgQ0RCLVdpZGdldC10ZXh0U21hbGwtLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGwtLXVwcGVyXCIgdGl0bGU9XCInK1xuKChfX3Q9KCBuYW1lICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXJcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIHByZWZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBmb3JtYXR0ZWRWYWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBzdWZmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9wPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtcHJvZ3Jlc3NCYXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZSBDREItV2lkZ2V0LXByb2dyZXNzU3RhdGUtLXBhdHRlcm4gJytcbigoX190PSggaXNBZ2dyZWdhdGVkID8gJ0NEQi1XaWRnZXQtcHJvZ3Jlc3NTdGF0ZS0taW5hY3RpdmUnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCIgc3R5bGU9XCJ3aWR0aDogJytcbigoX190PSggcGVyY2VudGFnZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclOyBiYWNrZ3JvdW5kLWNvbG9yOiAnK1xuKChfX3Q9KCBjdXN0b21Db2xvciA/IGNvbG9yIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBjbGlja2FibGVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaXRlbV9jbGlja2FibGVfdGVtcGxhdGUudHBsJyk7XG52YXIgdW5jbGlja2FibGVUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaXRlbV91bmNsaWNrYWJsZV90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDYXRlZ29yeSBsaXN0IGl0ZW0gdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICB0YWdOYW1lOiAnbGknLFxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWxpc3RJdGVtJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLWJ1dHRvbic6ICdfb25JdGVtQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwuZ2V0KCd2YWx1ZScpO1xuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMubW9kZWwuZ2V0KCdhZ2cnKSB8fMKgdGhpcy5kYXRhTW9kZWwuaXNMb2NrZWQoKSA/XG4gICAgICB1bmNsaWNrYWJsZVRlbXBsYXRlIDogY2xpY2thYmxlVGVtcGxhdGU7XG5cbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICBjdXN0b21Db2xvcjogdGhpcy5kYXRhTW9kZWwuaXNDb2xvckFwcGxpZWQoKSxcbiAgICAgICAgaXNBZ2dyZWdhdGVkOiB0aGlzLm1vZGVsLmdldCgnYWdnJyksXG4gICAgICAgIG5hbWU6IHRoaXMubW9kZWwuZ2V0KCduYW1lJyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlci5mb3JtYXROdW1iZXIodmFsdWUpLFxuICAgICAgICBwZXJjZW50YWdlOiAoKHZhbHVlIC8gdGhpcy5kYXRhTW9kZWwuZ2V0KCdtYXgnKSkgKiAxMDApLFxuICAgICAgICBjb2xvcjogdGhpcy5tb2RlbC5nZXQoJ2NvbG9yJyksXG4gICAgICAgIGlzRGlzYWJsZWQ6ICF0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWQnKSA/ICdpcy1kaXNhYmxlZCcgOiAnJyxcbiAgICAgICAgcHJlZml4OiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3ByZWZpeCcpLFxuICAgICAgICBzdWZmaXg6IHRoaXMuZGF0YU1vZGVsLmdldCgnc3VmZml4JylcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpzZWFyY2ggY2hhbmdlOmNhdGVnb3J5Q29sb3JzJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICB9LFxuXG4gIF9vbkl0ZW1DbGljazogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdpdGVtQ2xpY2tlZCcsIHRoaXMubW9kZWwsIHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciBDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXItLWZ1bGxTcGFjZSBDREItV2lkZ2V0LWxpc3RCdXR0b24ganMtYnV0dG9uICcrXG4oKF9fdD0oIGlzRGlzYWJsZWQgPyAnaXMtZGlzYWJsZWQnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVdpZGdldC1jaGVja2JveCAnK1xuKChfX3Q9KCBpc0Rpc2FibGVkID8gJycgOiAnaXMtY2hlY2tlZCcgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9zcGFuPiA8ZGl2IGNsYXNzPVwidS1sU3BhY2UtLXhsXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCBDREItV2lkZ2V0LXRleHRTbWFsbC0tYm9sZCBDREItV2lkZ2V0LXRleHRTbWFsbC0tdXBwZXJcIiB0aXRsZT1cIicrXG4oKF9fdD0oIG5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggbmFtZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlclwiIHRpdGxlPVwiJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggcHJlZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHN1ZmZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3A+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1wcm9ncmVzc0JhclwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1wcm9ncmVzc1N0YXRlXCIgc3R5bGU9XCJ3aWR0aDogJytcbigoX190PSggcGVyY2VudGFnZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclXCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gPC9idXR0b24+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgZm9ybWF0dGVyID0gY2RiLmNvcmUuZm9ybWF0O1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9zZWFyY2hfaXRlbV9jbGlja2FibGVfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgc2VhcmNoIGxpc3Qgdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICB0YWdOYW1lOiAnbGknLFxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWxpc3RJdGVtJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLWJ1dHRvbic6ICdfb25JdGVtQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vIFRoaXMgZGF0YSBtb2RlbCBjb21lcyBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIGluIG9yZGVyIHRvIGdldFxuICAgIC8vIHRoZSBtYXggdmFsdWUgYW5kIHNldCBwcm9wZXJseSB0aGUgcHJvZ3Jlc3MgYmFyIGFuZCBhZGQgdGhlXG4gICAgLy8gbmVjZXNzYXJ5IHN1ZmZpeCBhbmQgcHJlZml4IGZvciB0aGUgaXRlbS5cbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmdldCgndmFsdWUnKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubW9kZWwuZ2V0KCduYW1lJyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZvcm1hdHRlci5mb3JtYXROdW1iZXIodmFsdWUpLFxuICAgICAgICBwZXJjZW50YWdlOiAoKHZhbHVlIC8gdGhpcy5kYXRhTW9kZWwuZ2V0KCdtYXgnKSkgKiAxMDApLFxuICAgICAgICBpc0Rpc2FibGVkOiAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJyksXG4gICAgICAgIHByZWZpeDogdGhpcy5kYXRhTW9kZWwuZ2V0KCdwcmVmaXgnKSxcbiAgICAgICAgc3VmZml4OiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3N1ZmZpeCcpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpzZWxlY3RlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgfSxcblxuICBfb25JdGVtQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdzZWxlY3RlZCcsICF0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWQnKSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgQ2F0ZWdvcnlJdGVtVmlldyA9IHJlcXVpcmUoJy4vaXRlbS9pdGVtX3ZpZXcnKTtcbnZhciBwbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vaXRlbXNfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgbGlzdCB2aWV3XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBwYWdpbmF0b3I6IGZhbHNlLFxuICAgIGl0ZW1zUGVyUGFnZTogNlxuICB9LFxuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbGlzdCBDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQganMtbGlzdCcsXG4gIHRhZ05hbWU6ICd1bCcsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmVtcHR5KCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcblxuICAgIGlmIChpc0RhdGFFbXB0eSkge1xuICAgICAgdGhpcy5fcmVuZGVyUGxhY2Vob2xkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyTGlzdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy50b2dnbGUsIHRoaXMpO1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhIGNoYW5nZTpzZWFyY2hEYXRhJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICB9LFxuXG4gIF9yZW5kZXJQbGFjZWhvbGRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhbmdlIHZpZXcgY2xhc3Nlc1xuICAgIHRoaXMuJGVsXG4gICAgICAuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdC0td2l0aEJvcmRlcnMnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcbiAgICB0aGlzLiRlbC5hcHBlbmQocGxhY2Vob2xkZXIoKSk7XG4gIH0sXG5cbiAgX3JlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIC8vIENoYW5nZSB2aWV3IGNsYXNzZXNcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnQ0RCLVdpZGdldC1saXN0LS13aXRoQm9yZGVycycpO1xuICAgIHRoaXMuJGVsWyB0aGlzLm9wdGlvbnMucGFnaW5hdG9yID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcblxuICAgIHZhciBncm91cEl0ZW07XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCk7XG5cbiAgICBkYXRhLmVhY2goZnVuY3Rpb24obWRsLCBpKSB7XG4gICAgICBpZiAoaSAlIHRoaXMub3B0aW9ucy5pdGVtc1BlclBhZ2UgPT09IDApIHtcbiAgICAgICAgZ3JvdXBJdGVtID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnQ0RCLVdpZGdldC1saXN0R3JvdXAnKTtcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKGdyb3VwSXRlbSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRJdGVtKG1kbCwgZ3JvdXBJdGVtKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfYWRkSXRlbTogZnVuY3Rpb24obWRsLCAkcGFyZW50KSB7XG4gICAgdmFyIHYgPSBuZXcgQ2F0ZWdvcnlJdGVtVmlldyh7XG4gICAgICBtb2RlbDogbWRsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLmRhdGFNb2RlbFxuICAgIH0pO1xuICAgIHYuYmluZCgnaXRlbUNsaWNrZWQnLCB0aGlzLl9zZXRGaWx0ZXJzLCB0aGlzKTtcbiAgICB0aGlzLmFkZFZpZXcodik7XG4gICAgJHBhcmVudC5hcHBlbmQodi5yZW5kZXIoKS5lbCk7XG4gIH0sXG5cbiAgX3NldEZpbHRlcnM6IGZ1bmN0aW9uKG1kbCkge1xuICAgIHZhciBpc1NlbGVjdGVkID0gbWRsLmdldCgnc2VsZWN0ZWQnKTtcblxuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YU1vZGVsLmdldFJlamVjdGVkQ291bnQoKSAmJiAhdGhpcy5kYXRhTW9kZWwuZ2V0QWNjZXB0ZWRDb3VudCgpICYmIHRoaXMuZGF0YU1vZGVsLmdldENvdW50KCkgPiAxKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgcmVqZWN0cyA9IFtdO1xuICAgICAgICAvLyBNYWtlIGVsZW1lbnRzIFwidW5zZWxlY3RlZFwiXG4gICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG0uZ2V0KCduYW1lJyk7XG4gICAgICAgICAgaWYgKG5hbWUgIT09IG1kbC5nZXQoJ25hbWUnKSkge1xuICAgICAgICAgICAgbS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmFjY2VwdEZpbHRlcnMobWRsLmdldCgnbmFtZScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1kbC5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZWplY3RGaWx0ZXJzKG1kbC5nZXQoJ25hbWUnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1kbC5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICB0aGlzLmRhdGFNb2RlbC5hY2NlcHRGaWx0ZXJzKG1kbC5nZXQoJ25hbWUnKSk7XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sgIXRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdpcy1oaWRkZW4nKTtcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5hZGRDbGFzcygnaXMtaGlkZGVuJyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1cIj4gPGg0IGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnIENEQi1XaWRnZXQtdGV4dEJpZy0tYm9sZFwiPk5vIHJlc3VsdHM8L2g0PiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIHUtdFNwYWNlLXhsXCI+WW91ciBzZWFyY2ggXCInK1xuKChfX3Q9KCBxICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIGRpZG5cXCd0IG1hdGNoPGJyPndpdGggYW55IHZhbHVlLjwvcD4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCB1LXRTcGFjZS14bFwiPlRyeSBzZWFyY2hpbmcgYWdhaW4uPC9wPiA8L2xpPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIENhdGVnb3J5SXRlbXNWaWV3ID0gcmVxdWlyZSgnLi9pdGVtc192aWV3Jyk7XG52YXIgV2lkZ2V0U2VhcmNoQ2F0ZWdvcnlJdGVtVmlldyA9IHJlcXVpcmUoJy4vaXRlbS9zZWFyY2hfaXRlbV92aWV3Jyk7XG52YXIgcGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL3NlYXJjaF9pdGVtc19ub19yZXN1bHRzX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIENhdGVnb3J5IGxpc3Qgdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5SXRlbXNWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0IGlzLWhpZGRlbiBDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQganMtbGlzdCcsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoUmVzdWx0KCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gZGF0YS5pc0VtcHR5KCkgfHwgZGF0YS5zaXplKCkgPT09IDA7XG5cbiAgICBpZiAoaXNEYXRhRW1wdHkpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBsYWNlaG9sZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckxpc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3JlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdpdGhCb3JkZXJzIENEQi1XaWRnZXQtbGlzdC0tbm9yZXN1bHRzJyk7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdC0td3JhcHBlZCcpO1xuXG4gICAgdmFyIGdyb3VwSXRlbTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaFJlc3VsdCgpO1xuXG4gICAgZGF0YS5lYWNoKGZ1bmN0aW9uKG1kbCwgaSkge1xuICAgICAgaWYgKGkgJSB0aGlzLm9wdGlvbnMuaXRlbXNQZXJQYWdlID09PSAwKSB7XG4gICAgICAgIGdyb3VwSXRlbSA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ0NEQi1XaWRnZXQtbGlzdEdyb3VwJyk7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZChncm91cEl0ZW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkSXRlbShtZGwsIGdyb3VwSXRlbSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX3JlbmRlclBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFuZ2UgdmlldyBjbGFzc2VzXG4gICAgdGhpcy4kZWxcbiAgICAgIC5hZGRDbGFzcygnQ0RCLVdpZGdldC1saXN0LS1ub3Jlc3VsdHMnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdDREItV2lkZ2V0LWxpc3QtLXdyYXBwZWQnKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICBwbGFjZWhvbGRlcih7XG4gICAgICAgIHE6IHRoaXMuZGF0YU1vZGVsLmdldFNlYXJjaFF1ZXJ5KClcbiAgICAgIH0pXG4gICAgKTtcbiAgfSxcblxuICBfYWRkSXRlbTogZnVuY3Rpb24obWRsLCAkcGFyZW50KSB7XG4gICAgdmFyIHYgPSBuZXcgV2lkZ2V0U2VhcmNoQ2F0ZWdvcnlJdGVtVmlldyh7XG4gICAgICBtb2RlbDogbWRsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLmRhdGFNb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh2KTtcbiAgICAkcGFyZW50LmFwcGVuZCh2LnJlbmRlcigpLmVsKTtcbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbIHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIGQzID0gY2RiLmQzO1xudmFyIENhdGVnb3J5Q29sb3JzID0gcmVxdWlyZSgnLi9tb2RlbHMvY2F0ZWdvcnlfY29sb3JzJyk7XG52YXIgV2lkZ2V0TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfbW9kZWwnKTtcbnZhciBXaWRnZXRTZWFyY2hNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWxzL3NlYXJjaF9tb2RlbCcpO1xudmFyIENhdGVnb3J5TW9kZWxSYW5nZSA9IHJlcXVpcmUoJy4vbW9kZWxzL2NhdGVnb3J5X21vZGVsX3JhbmdlJyk7XG52YXIgQ2F0ZWdvcmllc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL21vZGVscy9jYXRlZ29yaWVzX2NvbGxlY3Rpb24nKTtcbnZhciBMb2NrZWRDYXRzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vbW9kZWxzL2xvY2tlZF9jYXRlZ29yaWVzX2NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiAgQ2F0ZWdvcnkgd2lkZ2V0IG1vZGVsXG4gKlxuICogIC0gSXQgaGFzIHNldmVyYWwgaW50ZXJuYWwgbW9kZWxzL2NvbGxlY3Rpb25zXG4gKlxuICogIMK3IHNlYXJjaCBtb2RlbDogaXQgbWFuYWdlcyBjYXRlZ29yeSBzZWFyY2ggcmVzdWx0cy5cbiAqICDCtyBsb2NrZWQgY29sbGVjdGlvbjogaXQgc3RvcmVzIGxvY2tlZCBpdGVtcy5cbiAqICDCtyBmaWx0ZXIgbW9kZWw6IGl0IGtub3dzIHdoaWNoIGl0ZW1zIGFyZSBhY2NlcHRlZCBvciByZWplY3RlZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRNb2RlbC5leHRlbmQoe1xuXG4gIHVybDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd1cmwnKSArICc/YmJveD0nICsgdGhpcy5nZXQoJ2JvdW5kaW5nQm94JykgKyAnJm93bl9maWx0ZXI9JyArICh0aGlzLmdldCgnbG9ja2VkJykgPyAxIDogMCk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICB0aGlzLl9kYXRhID0gbmV3IENhdGVnb3JpZXNDb2xsZWN0aW9uKCk7XG5cbiAgICBXaWRnZXRNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGF0dHJzLCBvcHRzKTtcblxuICAgIC8vIExvY2tlZCBjYXRlZ29yaWVzIGNvbGxlY3Rpb25cbiAgICB0aGlzLmxvY2tlZCA9IG5ldyBMb2NrZWRDYXRzQ29sbGVjdGlvbigpO1xuXG4gICAgLy8gSW50ZXJuYWwgbW9kZWwgZm9yIGNhbGN1bGF0aW5nIHRvdGFsIGFtb3VudCBvZiB2YWx1ZXMgaW4gdGhlIGNhdGVnb3J5XG4gICAgdGhpcy5yYW5nZU1vZGVsID0gbmV3IENhdGVnb3J5TW9kZWxSYW5nZSgpO1xuXG4gICAgLy8gQ29sb3JzIGNsYXNzXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgQ2F0ZWdvcnlDb2xvcnMoKTtcblxuICAgIC8vIFNlYXJjaCBtb2RlbFxuICAgIHRoaXMuc2VhcmNoID0gbmV3IFdpZGdldFNlYXJjaE1vZGVsKHt9LCB7XG4gICAgICBsb2NrZWQ6IHRoaXMubG9ja2VkXG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gU2V0IGFueSBuZWVkZWQgcGFyYW1ldGVyIHdoZW4gdGhleSBoYXZlIGNoYW5nZWQgaW4gdGhpcyBtb2RlbFxuICBfc2V0SW50ZXJuYWxNb2RlbHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cmwgPSB0aGlzLmdldCgndXJsJyk7XG5cbiAgICB0aGlzLnNlYXJjaC5zZXQoe1xuICAgICAgdXJsOiB1cmwsXG4gICAgICBib3VuZGluZ0JveDogdGhpcy5nZXQoJ2JvdW5kaW5nQm94JylcbiAgICB9KTtcblxuICAgIHRoaXMucmFuZ2VNb2RlbC5zZXRVcmwodXJsKTtcbiAgfSxcblxuICBfb25DaGFuZ2VCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0SW50ZXJuYWxNb2RlbHMoKTtcblxuICAgIHRoaXMucmFuZ2VNb2RlbC5iaW5kKCdjaGFuZ2U6dG90YWxDb3VudCcsIGZ1bmN0aW9uKG1kbCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0KCd0b3RhbENvdW50JywgdmFsdWUpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6dXJsJywgZnVuY3Rpb24oKXtcbiAgICAgIGlmICh0aGlzLmdldCgnc3luYycpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOmJvdW5kaW5nQm94JywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiBhIHNlYXJjaCBpcyBhcHBsaWVkIGFuZCBib3VuZGluZyBib3VuZHMgaGFzIGNoYW5nZWQsXG4gICAgICAvLyBkb24ndCBmZXRjaCBuZXcgcmF3IGRhdGFcbiAgICAgIGlmICh0aGlzLmdldCgnYmJveCcpICYmICF0aGlzLmlzU2VhcmNoQXBwbGllZCgpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOnVybCBjaGFuZ2U6Ym91bmRpbmdCb3gnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VhcmNoLnNldCh7XG4gICAgICAgIHVybDogdGhpcy5nZXQoJ3VybCcpLFxuICAgICAgICBib3VuZGluZ0JveDogdGhpcy5nZXQoJ2JvdW5kaW5nQm94JylcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6Y29sbGFwc2VkJywgZnVuY3Rpb24obWRsLCBpc0NvbGxhcHNlZCkge1xuICAgICAgaWYgKCFpc0NvbGxhcHNlZCkge1xuICAgICAgICBpZiAobWRsLmNoYW5nZWRBdHRyaWJ1dGVzKHRoaXMuX3ByZXZpb3VzQXR0cnMpKSB7XG4gICAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRycyA9IHtcbiAgICAgICAgICB1cmw6IHRoaXMuZ2V0KCd1cmwnKSxcbiAgICAgICAgICBib3VuZGluZ0JveDogdGhpcy5nZXQoJ2JvdW5kaW5nQm94JylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMubG9ja2VkLmJpbmQoJ2NoYW5nZSBhZGQgcmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpsb2NrQ29sbGVjdGlvbicsIHRoaXMubG9ja2VkLCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuc2VhcmNoLmJpbmQoJ2xvYWRpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIiwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5zZWFyY2guYmluZCgnc3luYycsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKFwic3luY1wiLCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLnNlYXJjaC5iaW5kKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZSB8fCAoZSAmJiBlLnN0YXR1c1RleHQgIT09IFwiYWJvcnRcIikpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZXJyb3JcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5zZWFyY2guYmluZCgnY2hhbmdlOmRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnNlYXJjaERhdGEnLCB0aGlzLnNlYXJjaCwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLypcbiAgICogIEhlbHBlciBtZXRob2RzIGZvciBpbnRlcm5hbCBtb2RlbHMvY29sbGVjdGlvbnNcbiAgICpcbiAgICovXG5cbiAgYXBwbHlDYXRlZ29yeUNvbG9yczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ2NhdGVnb3J5Q29sb3JzJywgdHJ1ZSk7XG4gICAgdmFyIGNvbG9yc0RhdGEgPSB0aGlzLl9kYXRhLm1hcChmdW5jdGlvbihtKXtcbiAgICAgIHJldHVybiBbIG0uZ2V0KCduYW1lJyksIG0uZ2V0KCdjb2xvcicpIF07XG4gICAgfSk7XG4gICAgdGhpcy50cmlnZ2VyKCdhcHBseUNhdGVnb3J5Q29sb3JzJywgY29sb3JzRGF0YSwgdGhpcyk7XG4gIH0sXG5cbiAgY2FuY2VsQ2F0ZWdvcnlDb2xvcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdjYXRlZ29yeUNvbG9ycycsIGZhbHNlKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbENhdGVnb3J5Q29sb3JzJywgdGhpcyk7XG4gIH0sXG5cbiAgaXNDb2xvckFwcGxpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnY2F0ZWdvcnlDb2xvcnMnKTtcbiAgfSxcblxuICAvLyBMb2NrZWQgY29sbGVjdGlvbiBoZWxwZXIgbWV0aG9kcyAvL1xuXG4gIGdldExvY2tlZFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2tlZC5zaXplKCk7XG4gIH0sXG5cbiAgaXNMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnbG9ja2VkJyk7XG4gIH0sXG5cbiAgY2FuQmVMb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9ja2VkKCkgfHxcbiAgICAgIHRoaXMuZ2V0QWNjZXB0ZWRDb3VudCgpID4gMDtcbiAgfSxcblxuICBjYW5BcHBseUxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFjY2VwdGVkQ29sbGVjdGlvbiA9IHRoaXMuZmlsdGVyLmdldEFjY2VwdGVkKCk7XG4gICAgaWYgKHRoaXMuZmlsdGVyLmdldEFjY2VwdGVkKCkuc2l6ZSgpICE9PSB0aGlzLmxvY2tlZC5zaXplKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZENvbGxlY3Rpb24uZmluZChmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gIXRoaXMubG9ja2VkLmlzSXRlbUxvY2tlZChtLmdldCgnbmFtZScpKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBhcHBseUxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRMb2NrZWQgPSB0aGlzLmxvY2tlZC5nZXRJdGVtc05hbWUoKTtcbiAgICBpZiAoIWN1cnJlbnRMb2NrZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVubG9ja0NhdGVnb3JpZXMoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zZXQoJ2xvY2tlZCcsIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyLmNsZWFuRmlsdGVyKGZhbHNlKTtcbiAgICB0aGlzLmZpbHRlci5hY2NlcHQoY3VycmVudExvY2tlZCk7XG4gICAgdGhpcy5maWx0ZXIuYXBwbHlGaWx0ZXIoKTtcbiAgICB0aGlzLmNsZWFuU2VhcmNoKCk7XG4gIH0sXG5cbiAgbG9ja0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdsb2NrZWQnLCB0cnVlKTtcbiAgICB0aGlzLl9mZXRjaCgpO1xuICB9LFxuXG4gIHVubG9ja0NhdGVnb3JpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdsb2NrZWQnLCBmYWxzZSk7XG4gICAgdGhpcy5hY2NlcHRBbGwoKTtcbiAgfSxcblxuICAvLyBTZWFyY2ggbW9kZWwgaGVscGVyIG1ldGhvZHMgLy9cblxuICBnZXRTZWFyY2hRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmdldFNlYXJjaFF1ZXJ5KCk7XG4gIH0sXG5cbiAgc2V0U2VhcmNoUXVlcnk6IGZ1bmN0aW9uKHEpIHtcbiAgICB0aGlzLnNlYXJjaC5zZXQoJ3EnLCBxKTtcbiAgfSxcblxuICBpc1NlYXJjaFZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2guaXNWYWxpZCgpO1xuICB9LFxuXG4gIGdldFNlYXJjaFJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmdldERhdGEoKTtcbiAgfSxcblxuICBnZXRTZWFyY2hDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoLmdldENvdW50KCk7XG4gIH0sXG5cbiAgYXBwbHlTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VhcmNoLmZldGNoKCk7XG4gIH0sXG5cbiAgaXNTZWFyY2hBcHBsaWVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2guaXNTZWFyY2hBcHBsaWVkKCk7XG4gIH0sXG5cbiAgY2xlYW5TZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubG9ja2VkLnJlc2V0SXRlbXMoW10pO1xuICAgIHRoaXMuc2VhcmNoLnJlc2V0RGF0YSgpO1xuICB9LFxuXG4gIHNldHVwU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWFyY2hBcHBsaWVkKCkpIHtcbiAgICAgIHZhciBhY2NlcHRlZENhdHMgPSB0aGlzLmZpbHRlci5nZXRBY2NlcHRlZCgpLnRvSlNPTigpO1xuICAgICAgdGhpcy5sb2NrZWQuYWRkSXRlbXMoYWNjZXB0ZWRDYXRzKTtcbiAgICAgIHRoaXMuc2VhcmNoLnNldERhdGEoXG4gICAgICAgIHRoaXMuX2RhdGEudG9KU09OKClcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEZpbHRlciBtb2RlbCBoZWxwZXIgbWV0aG9kcyAvL1xuXG4gIGdldFJlamVjdGVkQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci5yZWplY3RlZENhdGVnb3JpZXMuc2l6ZSgpO1xuICB9LFxuXG4gIGdldEFjY2VwdGVkQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci5hY2NlcHRlZENhdGVnb3JpZXMuc2l6ZSgpO1xuICB9LFxuXG4gIGFjY2VwdEZpbHRlcnM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHRoaXMuZmlsdGVyLmFjY2VwdCh2YWx1ZXMpO1xuICB9LFxuXG4gIHJlamVjdEZpbHRlcnM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHRoaXMuZmlsdGVyLnJlamVjdCh2YWx1ZXMpO1xuICB9LFxuXG4gIHJlamVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXIucmVqZWN0QWxsKCk7XG4gIH0sXG5cbiAgYWNjZXB0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlci5hY2NlcHRBbGwoKTtcbiAgfSxcblxuICBpc0FsbEZpbHRlcnNSZWplY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyLmdldCgncmVqZWN0QWxsJyk7XG4gIH0sXG5cbiAgLy8gUHJvcGVyIG1vZGVsIGhlbHBlciBtZXRob2RzIC8vXG5cbiAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH0sXG5cbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZSgpO1xuICB9LFxuXG4gIGdldENvdW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NhdGVnb3JpZXNDb3VudCcpO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzU2VhcmNoQXBwbGllZCgpKSB7XG4gICAgICB0aGlzLnNlYXJjaC5mZXRjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mZXRjaCgpO1xuICAgIH1cbiAgfSxcblxuICAvLyBEYXRhIHBhcnNlciBtZXRob2RzIC8vXG5cbiAgX3BhcnNlRGF0YTogZnVuY3Rpb24oY2F0ZWdvcmllcykge1xuICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgdmFyIF90bXBBcnJheSA9IHt9O1xuICAgIHZhciBhY2NlcHRlZENhdHMgPSB0aGlzLmZpbHRlci5nZXRBY2NlcHRlZCgpO1xuXG4gICAgLy8gVXBkYXRlIGNvbG9ycyBieSBkYXRhIGNhdGVnb3JpZXNcbiAgICB0aGlzLmNvbG9ycy51cGRhdGVEYXRhKFxuICAgICAgXy51bmlxKFxuICAgICAgICBfLnVuaW9uKFxuICAgICAgICAgIF8ucGx1Y2soY2F0ZWdvcmllcywgJ2NhdGVnb3J5JyksXG4gICAgICAgICAgXy5wbHVjayhhY2NlcHRlZENhdHMsICduYW1lJylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBfLmVhY2goY2F0ZWdvcmllcywgZnVuY3Rpb24oZGF0dW0sIGkpIHtcbiAgICAgIHZhciBjYXRlZ29yeSA9IGRhdHVtLmNhdGVnb3J5O1xuICAgICAgdmFyIGlzUmVqZWN0ZWQgPSB0aGlzLmZpbHRlci5pc1JlamVjdGVkKGNhdGVnb3J5KTtcbiAgICAgIF90bXBBcnJheVtjYXRlZ29yeV0gPSB0cnVlO1xuXG4gICAgICBuZXdEYXRhLnB1c2goe1xuICAgICAgICBzZWxlY3RlZDogIWlzUmVqZWN0ZWQsXG4gICAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgICBhZ2c6IGRhdHVtLmFnZyxcbiAgICAgICAgdmFsdWU6IGRhdHVtLnZhbHVlLFxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcnMuZ2V0Q29sb3JCeUNhdGVnb3J5KGNhdGVnb3J5KVxuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICAvLyBBZGQgYWNjZXB0ZWQgaXRlbXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGNhdGVnb3JpZXMgZGF0YVxuICAgICAgYWNjZXB0ZWRDYXRzLmVhY2goZnVuY3Rpb24obWRsLCBpKSB7XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IG1kbC5nZXQoJ25hbWUnKS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIV90bXBBcnJheVtjYXRlZ29yeV0pIHtcbiAgICAgICAgICBuZXdEYXRhLnB1c2goe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcnMuZ2V0Q29sb3JCeUNhdGVnb3J5KGNhdGVnb3J5KSxcbiAgICAgICAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgICAgICAgYWdnOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXdEYXRhXG4gICAgfVxuICB9LFxuXG4gIHNldENhdGVnb3JpZXM6IGZ1bmN0aW9uKGQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9wYXJzZURhdGEoZCk7XG4gICAgdGhpcy5fZGF0YS5yZXNldChhdHRycy5kYXRhKTtcbiAgICB0aGlzLnNldChhdHRycyk7XG4gICAgaWYgKHRoaXMuaXNDb2xvckFwcGxpZWQoKSkge1xuICAgICAgdGhpcy5hcHBseUNhdGVnb3J5Q29sb3JzKCk7XG4gICAgfVxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkKSB7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSBkLmNhdGVnb3JpZXM7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fcGFyc2VEYXRhKGNhdGVnb3JpZXMpO1xuXG4gICAgXy5leHRlbmQoYXR0cnMsIHtcbiAgICAgICAgbnVsbHM6IGQubnVsbHMsXG4gICAgICAgIG1pbjogZC5taW4sXG4gICAgICAgIG1heDogZC5tYXgsXG4gICAgICAgIGNvdW50OiBkLmNvdW50LFxuICAgICAgICBjYXRlZ29yaWVzQ291bnQ6IGQuY2F0ZWdvcmllc0NvdW50XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLl9kYXRhLnJlc2V0KGF0dHJzLmRhdGEpO1xuICAgIGlmICh0aGlzLmlzQ29sb3JBcHBsaWVkKCkpIHtcbiAgICAgIHRoaXMuYXBwbHlDYXRlZ29yeUNvbG9ycygpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH0sXG5cbiAgLy8gQmFja2JvbmUgdG9Kc29uIGZ1bmN0aW9uIG92ZXJyaWRlXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhZ2dyZWdhdGlvblwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2x1bW46IHRoaXMuZ2V0KCdjb2x1bW4nKSxcbiAgICAgICAgYWdncmVnYXRpb246IHRoaXMuZ2V0KCdhZ2dyZWdhdGlvbicpLFxuICAgICAgICBhZ2dyZWdhdGlvbkNvbHVtbjogdGhpcy5nZXQoJ2FnZ3JlZ2F0aW9uQ29sdW1uJylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBDYXRlZ29yeUl0ZW1Nb2RlbCA9IHJlcXVpcmUoJy4vY2F0ZWdvcnlfaXRlbV9tb2RlbCcpO1xuXG4vKipcbiAqICBEYXRhIGNhdGVnb3JpZXMgY29sbGVjdGlvblxuICpcbiAqICAtIEl0IGJhc2ljYWxseSBzb3J0cyBieSAodmFsdWUsIHNlbGVjdGVkIGFuZCBcIk90aGVyXCIpLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIG1vZGVsOiBDYXRlZ29yeUl0ZW1Nb2RlbCxcblxuICBjb21wYXJhdG9yOiBmdW5jdGlvbihhLGIpIHtcbiAgICBpZiAoYS5nZXQoJ25hbWUnKSA9PT0gJ090aGVyJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChiLmdldCgnbmFtZScpID09PSAnT3RoZXInKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhLmdldCgndmFsdWUnKSA9PT0gYi5nZXQoJ3ZhbHVlJykpIHtcbiAgICAgIHJldHVybiAoYS5nZXQoJ3NlbGVjdGVkJykgPCBiLmdldCgnc2VsZWN0ZWQnKSkgPyAxIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYS5nZXQoJ3ZhbHVlJykgPCBiLmdldCgndmFsdWUnKSkgPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbi8vIHZhciBjb2xvcmJyZXdlciA9IHJlcXVpcmUoJ2NvbG9yYnJld2VyJyk7XG4vLyB2YXIgY2F0ZWdvcnlDb2xvcnMgPSBfLmluaXRpYWwoY29sb3JicmV3ZXIuQWNjZW50WzhdKTsgLy8gQ29sb3IgYnJld2VyIGNvbG9yc1xudmFyIGNhdGVnb3J5Q29sb3JzID0gWycjMkNBMDk1JywnI0U1ODExQicsJyM0QTREQkEnLCcjQUQyQkFEJywnIzU1OTAzMCcsJyNFMUMyMjEnXTsgLy8gRGVtbyBjb2xvcnNcbnZhciBkZWZhdWx0Q29sb3IgPSAnI0NDQyc7XG5cbi8qKlxuICogIENsYXNzIHRvIHNldCBjYXRlZ29yaWVzIHRvIGVhY2ggY29sb3JcbiAqICAtIFJpZ2h0IG5vdywgdGhlcmUgaXMgYSByZWxhdGlvbiAxIGNvbG9yIHRvIDEgY2F0ZWdvcnkuXG4gKiAgLSBJZiB0aGF0IGNhdGVnb3J5IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIG5ldyBkYXRhLCB0aGF0XG4gKiAgICBjb2xvciB3aWxsIGJlIGZyZWVkLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBDYXRlZ29yeUNvbG9ycygpIHtcbiAgdGhpcy5jb2xvcnMgPSB7fTtcbiAgXy5lYWNoKGNhdGVnb3J5Q29sb3JzLCBmdW5jdGlvbihjKSB7XG4gICAgdGhpcy5jb2xvcnNbY10gPSBudWxsO1xuICB9LCB0aGlzKTtcbn1cblxuQ2F0ZWdvcnlDb2xvcnMucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbihkKSB7XG4gIC8vIFJlbW92ZSBjYXRlZ29yaWVzIGZyb20gY29sb3JzIHdoZXJlIHRoZXkgYXJlIG5vdCBwcmVzZW50IGFueW1vcmVcbiAgXy5lYWNoKHRoaXMuY29sb3JzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgaWYgKCFfLmNvbnRhaW5zKGQsIHZhbHVlKSkge1xuICAgICAgdGhpcy5jb2xvcnNba2V5XSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBfLndpdGhvdXQoZCwgdmFsdWUpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgLy8gU2V0IGNvbG9ycyBieSBuZXcgY2F0ZWdvcmllc1xuICBfLmVhY2goZCwgZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICB2YXIgbmV4dEZyZWVDb2xvciA9IHRoaXMuZ2V0TmV4dEF2YWlsYWJsZUNvbG9yKCk7XG4gICAgaWYgKG5leHRGcmVlQ29sb3IpIHtcbiAgICAgIHRoaXMuY29sb3JzW25leHRGcmVlQ29sb3JdID0gY2F0ZWdvcnk7XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbkNhdGVnb3J5Q29sb3JzLnByb3RvdHlwZS5nZXROZXh0QXZhaWxhYmxlQ29sb3IgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbG9ycykge1xuICAgIGlmICh0aGlzLmNvbG9yc1tpXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuQ2F0ZWdvcnlDb2xvcnMucHJvdG90eXBlLmdldENvbG9yQnlDYXRlZ29yeSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICBmb3IgKHZhciBpIGluIHRoaXMuY29sb3JzKSB7XG4gICAgaWYgKHRoaXMuY29sb3JzW2ldID09PSBjYXRlZ29yeSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0Q29sb3I7XG59O1xuXG5DYXRlZ29yeUNvbG9ycy5wcm90b3R5cGUuZ2V0Q2F0ZWdvcnlCeUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHJldHVybiB0aGlzLmNvbG9yc1tjb2xvcl07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5Q29sb3JzO1xuIiwiXG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIG5hbWU6ICcnLFxuICAgIGFnZzogZmFsc2UsXG4gICAgdmFsdWU6IDBcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKiAgVGhpcyBtb2RlbCBpcyB1c2VkIGZvciBnZXR0aW5nIHRoZSB0b3RhbCBhbW91bnQgb2YgdmFsdWVzXG4gKiAgZnJvbSB0aGUgY2F0ZWdvcnkuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHVybDogJycsXG4gICAgdG90YWxDb3VudDogMFxuICB9LFxuXG4gIHVybDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCd1cmwnKTtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTp1cmwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmV0Y2goKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBzZXRVcmw6IGZ1bmN0aW9uKHVybCkge1xuICAgIHRoaXMuc2V0KCd1cmwnLCB1cmwpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkKSB7XG4gICAgLy8gQ2FsY3VsYXRpbmcgdGhlIHRvdGFsIGFtb3VudCBvZiBhbGwgY2F0ZWdvcmllcyB3aXRoIHRoZSBzdW0gb2YgYWxsXG4gICAgLy8gdmFsdWVzIGZyb20gdGhpcyBtb2RlbCBpbmNsdWRlZCB0aGUgYWdncmVnYXRlZCAoT3RoZXIpXG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxDb3VudDogXy5yZWR1Y2UoXG4gICAgICAgIF8ucGx1Y2soZC5jYXRlZ29yaWVzLCAndmFsdWUnKSxcbiAgICAgICAgZnVuY3Rpb24obWVtbywgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbWVtbyArIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAwXG4gICAgICApXG4gICAgfTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIENhdGVnb3J5SXRlbU1vZGVsID0gcmVxdWlyZSgnLi9jYXRlZ29yeV9pdGVtX21vZGVsJyk7XG5cbi8qKlxuICogIExvY2tlZCBjYXRlZ29yaWVzIGNvbGxlY3Rpb25cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgbW9kZWw6IENhdGVnb3J5SXRlbU1vZGVsLFxuXG4gIGFkZEl0ZW06IGZ1bmN0aW9uKG1kbCkge1xuICAgIGlmICghdGhpcy5pc0l0ZW1Mb2NrZWQobWRsLmdldCgnbmFtZScpKSkge1xuICAgICAgdGhpcy5hZGQobWRsKTtcbiAgICB9XG4gIH0sXG5cbiAgYWRkSXRlbXM6IGZ1bmN0aW9uKG1kbHMpIHtcbiAgICBfLmVhY2gobWRscywgZnVuY3Rpb24obSkge1xuICAgICAgaWYgKCF0aGlzLmlzSXRlbUxvY2tlZChtLm5hbWUpKSB7XG4gICAgICAgIHRoaXMuYWRkKG0pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIHJlc2V0SXRlbXM6IGZ1bmN0aW9uKG1kbHMpIHtcbiAgICB0aGlzLnJlc2V0KG1kbHMpO1xuICB9LFxuXG4gIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKG1kbCkge1xuICAgIHZhciBsb2NrZWRJdGVtID0gdGhpcy5pc0l0ZW1Mb2NrZWQobWRsLmdldCgnbmFtZScpKTtcbiAgICBpZiAobG9ja2VkSXRlbSkge1xuICAgICAgdGhpcy5yZW1vdmUobG9ja2VkSXRlbSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0KFtdKTtcbiAgfSxcblxuICBpc0l0ZW1Mb2NrZWQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLmdldCgnbmFtZScpID09PSBuYW1lO1xuICAgIH0pO1xuICB9LFxuXG4gIGdldEl0ZW1zTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1Y2soJ25hbWUnKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBDYXRlZ29yaWVzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllc19jb2xsZWN0aW9uJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgc2VhcmNoIG1vZGVsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHE6ICcnLFxuICAgIGRhdGE6IFtdLFxuICAgIHVybDogJydcbiAgfSxcblxuICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndXJsJykgKyAnL3NlYXJjaD9xPScgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5nZXQoJ3EnKSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdHMpIHtcbiAgICAvLyBMb2NrZWQgY29sbGVjdGlvbiB3aWxsIGhhdmUgdGhlIHN0YXR1c1xuICAgIC8vIG9mIHRoZSBzZWxlY3RlZC9sb2NrZWQgaXRlbXNcbiAgICB0aGlzLmxvY2tlZCA9IG9wdHMubG9ja2VkO1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgQ2F0ZWdvcmllc0NvbGxlY3Rpb24oKTtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kYXRhLmJpbmQoJ2NoYW5nZTpzZWxlY3RlZCcsIHRoaXMuX29uQ2hhbmdlU2VsZWN0ZWQsIHRoaXMpO1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOmJvdW5kaW5nQm94JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1NlYXJjaEFwcGxpZWQoKSkge1xuICAgICAgICB0aGlzLmZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5fcGFyc2VEYXRhKGRhdGEpO1xuICAgIHRoaXMuX2RhdGEucmVzZXQoY2F0ZWdvcmllcyk7XG4gICAgdGhpcy5zZXQoJ2RhdGEnLCBjYXRlZ29yaWVzKTtcbiAgfSxcblxuICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICBnZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zaXplKCk7XG4gIH0sXG5cbiAgZ2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNpemUoKTtcbiAgfSxcblxuICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5nZXQoJ3EnKTtcbiAgICByZXR1cm4gISEoc3RyfHwnJyk7XG4gIH0sXG5cbiAgaXNMb2NrZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgcmVzZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldERhdGEoW10pO1xuICAgIHRoaXMuc2V0KCdxJywgJycpO1xuICB9LFxuXG4gIGdldFNlYXJjaFF1ZXJ5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3EnKTtcbiAgfSxcblxuICBpc1NlYXJjaEFwcGxpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSAmJiB0aGlzLmdldFNpemUoKSA+IDA7XG4gIH0sXG5cbiAgX29uQ2hhbmdlU2VsZWN0ZWQ6IGZ1bmN0aW9uKG1kbCwgaXNTZWxlY3RlZCkge1xuICAgIHRoaXMubG9ja2VkWyBpc1NlbGVjdGVkID8gJ2FkZEl0ZW0nIDogJ3JlbW92ZUl0ZW0nIF0obWRsKTtcbiAgfSxcblxuICBfcGFyc2VEYXRhOiBmdW5jdGlvbihjYXRlZ29yaWVzKSB7XG4gICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICBfLmVhY2goY2F0ZWdvcmllcywgZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKCFkLmFnZykge1xuICAgICAgICB2YXIgY2F0ZWdvcnkgPSAoZC5jYXRlZ29yeSB8fCBkLm5hbWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBpc0xvY2tlZCA9IHRoaXMubG9ja2VkLmlzSXRlbUxvY2tlZChjYXRlZ29yeSk7XG4gICAgICAgIG5ld0RhdGEucHVzaCh7XG4gICAgICAgICAgc2VsZWN0ZWQ6IGlzTG9ja2VkLFxuICAgICAgICAgIG5hbWU6IGNhdGVnb3J5LFxuICAgICAgICAgIGFnZzogZC5hZ2csXG4gICAgICAgICAgdmFsdWU6IGQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24ocikge1xuICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5fcGFyc2VEYXRhKHIuY2F0ZWdvcmllcyk7XG4gICAgdGhpcy5fZGF0YS5yZXNldChjYXRlZ29yaWVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY2F0ZWdvcmllc1xuICAgIH07XG4gIH0sXG5cbiAgZmV0Y2g6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB0aGlzLnRyaWdnZXIoXCJsb2FkaW5nXCIsIHRoaXMpO1xuICAgIHJldHVybiBNb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBvcHRzKTtcbiAgfSxcblxuICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5feGhyKSB7XG4gICAgICB0aGlzLl94aHIuYWJvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5feGhyID0gTW9kZWwucHJvdG90eXBlLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLl94aHIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5feGhyID0gbnVsbDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5feGhyO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnO1xuIGlmIChpc1NlYXJjaEVuYWJsZWQpIHsgXG5fX3ArPScgPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tZGFyayBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIHRvdGFsTG9ja2VkICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBzZWxlY3RlZDwvcD4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tYm9sZCBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1kYXJrIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyXCI+ICc7XG4gaWYgKGlzTG9ja2VkKSB7IFxuX19wKz0nICcrXG4oKF9fdD0oIHRvdGFsQ2F0cyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgYmxvY2tlZCA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIHUtbFNwYWNlIGpzLXVubG9ja1wiPnVubG9jazwvYnV0dG9uPiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nICcrXG4oKF9fdD0oIHJlamVjdGVkQ2F0cyA9PT0gMCAmJiBhY2NlcHRlZENhdHMgPT09IDAgfHwgYWNjZXB0ZWRDYXRzID49IHRvdGFsQ2F0cyA/IFwiQWxsIHNlbGVjdGVkXCIgOiBhY2NlcHRlZENhdHMgKyBcIiBzZWxlY3RlZFwiICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyAnO1xuIGlmIChjYW5CZUxvY2tlZCkgeyBcbl9fcCs9JyA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIHUtbFNwYWNlIGpzLWxvY2tcIj5sb2NrPC9idXR0b24+ICc7XG4gfVxuX19wKz0nICc7XG4gfVxuX19wKz0nIDwvcD4gJztcbiBpZiAoIWlzTG9ja2VkKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWZpbHRlckJ1dHRvbnNcIj4gJztcbiBpZiAocmVqZWN0ZWRDYXRzID4gMCB8fMKgYWNjZXB0ZWRDYXRzID4gMCB8fMKgaXNBbGxSZWplY3RlZCkgeyBcbl9fcCs9JyA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1saW5rIENEQi1XaWRnZXQtZmlsdGVyQnV0dG9uIGpzLWFsbFwiPmFsbDwvYnV0dG9uPiAnO1xuIH0gXG5fX3ArPScgJztcbiBpZiAodG90YWxDYXRzID4gcmVqZWN0ZWRDYXRzICYmICFpc0FsbFJlamVjdGVkKSB7IFxuX19wKz0nIDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWxpbmsgQ0RCLVdpZGdldC1maWx0ZXJCdXR0b24ganMtbm9uZVwiPm5vbmU8L2J1dHRvbj4gJztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScgJztcbiB9IFxuX19wKz0nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vb3B0aW9uc190ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiBDYXRlZ29yeSBmaWx0ZXIgdmlld1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1maWx0ZXIgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkIENEQi1XaWRnZXQtY29udGVudFNwYWNlZC0tc2lkZU1hcmdpbnMnLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtYWxsJzogJ19vblNlbGVjdEFsbCcsXG4gICAgJ2NsaWNrIC5qcy1ub25lJzogJ19vblVuc2VsZWN0QWxsJyxcbiAgICAnY2xpY2sgLmpzLWxvY2snOiAnX2xvY2tDYXRlZ29yaWVzJyxcbiAgICAnY2xpY2sgLmpzLXVubG9jayc6ICdfdW5sb2NrQ2F0ZWdvcmllcydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMub3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsQ2F0cyA9IHRoaXMuZGF0YU1vZGVsLmdldERhdGEoKS5zaXplKCk7XG4gICAgdmFyIHJlamVjdGVkQ2F0cyA9IHRoaXMuZGF0YU1vZGVsLmdldFJlamVjdGVkQ291bnQoKTtcbiAgICB2YXIgYWNjZXB0ZWRDYXRzID0gdGhpcy5kYXRhTW9kZWwuZ2V0QWNjZXB0ZWRDb3VudCgpO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaXNMb2NrZWQ6IHRoaXMuZGF0YU1vZGVsLmlzTG9ja2VkKCksXG4gICAgICAgIGNhbkJlTG9ja2VkOiB0aGlzLmRhdGFNb2RlbC5jYW5CZUxvY2tlZCgpLFxuICAgICAgICB0b3RhbExvY2tlZDogdGhpcy5kYXRhTW9kZWwuZ2V0TG9ja2VkU2l6ZSgpLFxuICAgICAgICBpc1NlYXJjaEVuYWJsZWQ6IHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpLFxuICAgICAgICBpc1NlYXJjaEFwcGxpZWQ6IHRoaXMuZGF0YU1vZGVsLmlzU2VhcmNoQXBwbGllZCgpLFxuICAgICAgICBpc0FsbFJlamVjdGVkOiB0aGlzLmRhdGFNb2RlbC5pc0FsbEZpbHRlcnNSZWplY3RlZCgpLFxuICAgICAgICB0b3RhbENhdHM6IHRvdGFsQ2F0cyxcbiAgICAgICAgcmVqZWN0ZWRDYXRzOiByZWplY3RlZENhdHMsXG4gICAgICAgIGFjY2VwdGVkQ2F0czogYWNjZXB0ZWRDYXRzXG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmRhdGEgY2hhbmdlOmZpbHRlciBjaGFuZ2U6bG9ja2VkIGNoYW5nZTpsb2NrQ29sbGVjdGlvbicsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5kYXRhTW9kZWwpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy52aWV3TW9kZWwpO1xuICB9LFxuXG4gIF9sb2NrQ2F0ZWdvcmllczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwubG9ja0NhdGVnb3JpZXMoKTtcbiAgfSxcblxuICBfdW5sb2NrQ2F0ZWdvcmllczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwudW5sb2NrQ2F0ZWdvcmllcygpO1xuICB9LFxuXG4gIF9vblVuc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5yZWplY3RBbGwoKTtcbiAgfSxcblxuICBfb25TZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmFjY2VwdEFsbCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50RmxleFwiPiA8YnV0dG9uIGNsYXNzPVwidS1yU3BhY2UtLW0gQ0RCLVdpZGdldC1idXR0b25JY29uIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXIganMtc2VhcmNoVG9nZ2xlXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tLWNlbnRlciBDREItSWNvbi1sZW5zIHUtclNwYWNlXCI+PC9pPiA8c3BhbiBjbGFzcz1cInUtaUJsb2NrXCI+IHNlYXJjaCA8L3NwYW4+IDwvYnV0dG9uPiA8L2Rpdj4gJztcbiBpZiAoc2hvd1BhZ2luYXRvcikgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1uYXZEb3RzIGpzLWRvdHNcIj4gJztcbiBmb3IgKHZhciBpID0gMCwgbCA9IHBhZ2VzOyBpIDwgbDsgaSsrKSB7IFxuX19wKz0nPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS1kb3QgQ0RCLVdpZGdldC1kb3QtLW5hdmlnYXRpb24ganMtcGFnZSAnO1xuIGlmIChjdXJyZW50UGFnZSA9PT0gaSkgeyBcbl9fcCs9J2lzLXNlbGVjdGVkJztcbiB9IFxuX19wKz0nXCIgZGF0YS1wYWdlPVwiJytcbigoX190PSggaSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj48L2J1dHRvbj4nO1xuIH0gXG5fX3ArPScgPC9kaXY+ICc7XG4gfSBcbl9fcCs9Jyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgZGVmYXVsdFRlbXBsYXRlID0gcmVxdWlyZSgnLi9wYWdpbmF0b3JfdGVtcGxhdGUudHBsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBpdGVtc1BlclBhZ2U6IDYsXG4gICAgdGVtcGxhdGU6IGRlZmF1bHRUZW1wbGF0ZSxcbiAgICBwYWdpbmF0b3I6IGZhbHNlXG4gIH0sXG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1uYXYgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkJyxcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmpzLXNlYXJjaFRvZ2dsZSc6ICdfb25TZWFyY2hDbGlja2VkJyxcbiAgICAnY2xpY2sgLmpzLXBhZ2UnOiAnX29uRG90Q2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm9wdGlvbnMuZGF0YU1vZGVsO1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgICB0aGlzLl8kdGFyZ2V0ID0gdGhpcy5vcHRpb25zLiR0YXJnZXQ7XG4gICAgdGhpcy5tb2RlbCA9IG5ldyBNb2RlbCh7XG4gICAgICBwYWdlOiAwXG4gICAgfSk7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgIHZhciBwYWdlcyA9IE1hdGguY2VpbCh0aGlzLmRhdGFNb2RlbC5nZXRTaXplKCkgLyB0aGlzLm9wdGlvbnMuaXRlbXNQZXJQYWdlKTtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGU7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgc2hvd1BhZ2luYXRvcjogdGhpcy5vcHRpb25zLnBhZ2luYXRvcixcbiAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMubW9kZWwuZ2V0KCdwYWdlJyksXG4gICAgICAgIHBhZ2VzOiBwYWdlc1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuX3Njcm9sbFRvUGFnZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZS4nICsgdGhpcy5jaWQsIF8uYmluZCh0aGlzLl9zY3JvbGxUb1BhZ2UsIHRoaXMpKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpwYWdlJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuZGF0YU1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhIGNoYW5nZTpzZWFyY2hEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zZXRQYWdlKCk7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTpzZWFyY2gnLCB0aGlzLnRvZ2dsZSwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLmRhdGFNb2RlbCk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLnZpZXdNb2RlbCk7XG4gIH0sXG5cbiAgLy8gSWYgY3VycmVudCBwYWdlIGRvZXNuJ3QgZXhpc3QgZHVlIHRvIGEgZGF0YSBjaGFuZ2UsIHdlIHNob3VsZCByZXNldCBpdFxuICBfc2V0UGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5kYXRhTW9kZWwuZ2V0U2l6ZSgpO1xuICAgIHZhciBwYWdlcyA9IE1hdGguY2VpbChjb3VudCAvIHRoaXMuX0lURU1TX1BFUl9QQUdFKTtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3BhZ2UnKSA+IChwYWdlcyAtIDEpKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCh7IHBhZ2U6IDAgfSwgeyBzaWxlbnQgOnRydWUgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9vblNlYXJjaENsaWNrZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLnNldHVwU2VhcmNoKCk7XG4gICAgdGhpcy52aWV3TW9kZWwudG9nZ2xlU2VhcmNoKCk7XG4gIH0sXG5cbiAgX3Njcm9sbFRvUGFnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLm1vZGVsLmdldCgncGFnZScpO1xuICAgIHZhciBwYWdlV2lkdGggPSB0aGlzLl8kdGFyZ2V0LmZpbmQoJy5DREItV2lkZ2V0LWxpc3RHcm91cDplcSgwKScpLm91dGVyV2lkdGgoKTtcbiAgICB0aGlzLl8kdGFyZ2V0LmNzcygnbWFyZ2luLWxlZnQnLCAtIChwYWdlICogcGFnZVdpZHRoKSk7XG4gIH0sXG5cbiAgX29uRG90Q2xpY2s6IGZ1bmN0aW9uKGV2KSB7XG4gICAgdmFyIHBhZ2UgPSAkKGV2LnRhcmdldCkuZGF0YSgncGFnZScpO1xuICAgIHRoaXMubW9kZWwuc2V0KCdwYWdlJywgcGFnZSk7XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzWyB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSA/ICdoaWRlJyA6ICdzaG93JyBdKCk7XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdpcy1oaWRkZW4nKTtcbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgJCh3aW5kb3cpLnVuYmluZCgncmVzaXplLicgKyB0aGlzLmNpZCk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudEZsZXhcIj4gPGJ1dHRvbiBjbGFzcz1cInUtclNwYWNlLS1tIENEQi1XaWRnZXQtbGluayBqcy1zZWFyY2hUb2dnbGVcIj5jYW5jZWw8L2J1dHRvbj4gPC9kaXY+ICc7XG4gaWYgKHNob3dQYWdpbmF0b3IpIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbmF2RG90cyBqcy1kb3RzXCI+ICc7XG4gZm9yICh2YXIgaSA9IDAsIGwgPSBwYWdlczsgaSA8IGw7IGkrKykgeyBcbl9fcCs9JzxidXR0b24gY2xhc3M9XCJDREItU2hhcGUtZG90IENEQi1XaWRnZXQtZG90LS1uYXZpZ2F0aW9uIGpzLXBhZ2UgJztcbiBpZiAoY3VycmVudFBhZ2UgPT09IGkpIHsgXG5fX3ArPSdpcy1zZWxlY3RlZCc7XG4gfSBcbl9fcCs9J1wiIGRhdGEtcGFnZT1cIicrXG4oKF9fdD0oIGkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9idXR0b24+JztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIFBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgc2VhcmNoVGVtcGxhdGUgPSByZXF1aXJlKCcuL3NlYXJjaF9wYWdpbmF0b3JfdGVtcGxhdGUudHBsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnaW5hdG9yVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbmF2IGlzLWhpZGRlbiBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQnLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICB2YXIgcGFnZXMgPSBNYXRoLmNlaWwodGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoQ291bnQoKSAvIHRoaXMub3B0aW9ucy5pdGVtc1BlclBhZ2UpO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICBzZWFyY2hUZW1wbGF0ZSh7XG4gICAgICAgIHNob3dQYWdpbmF0b3I6IHRydWUsXG4gICAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLm1vZGVsLmdldCgncGFnZScpLFxuICAgICAgICBwYWdlczogcGFnZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl9zY3JvbGxUb1BhZ2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZXRQYWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSB0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hDb3VudCgpO1xuICAgIHZhciBwYWdlcyA9IE1hdGguY2VpbChjb3VudCAvIHRoaXMuX0lURU1TX1BFUl9QQUdFKTtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3BhZ2UnKSA+IChwYWdlcyAtIDEpKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCh7IHBhZ2U6IDAgfSwgeyBzaWxlbnQgOnRydWUgfSk7XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sgIXRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpID8gJ2hpZGUnIDogJ3Nob3cnIF0oKTtcbiAgfSxcblxuICBfb25TZWFyY2hDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5jbGVhblNlYXJjaCgpO1xuICAgIHRoaXMudmlld01vZGVsLnRvZ2dsZVNlYXJjaCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jyc7XG4gaWYgKGlzU2VhcmNoRW5hYmxlZCkgeyBcbl9fcCs9JyA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtXCI+ICc7XG4gaWYgKGlzU2VhcmNoQXBwbGllZCkgeyBcbl9fcCs9JyAnK1xuKChfX3Q9KCByZXN1bHRzQ291bnQgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIGZvdW5kICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgJm5ic3A7ICc7XG4gfSBcbl9fcCs9JyA8L2R0PiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nIDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW1cIj4nK1xuKChfX3Q9KCBudWxsc1BlciApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbiclIG51bGwgcm93czwvZHQ+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW1cIj48c3BhbiBjbGFzcz1cImpzLWNhdHNcIj4nK1xuKChfX3Q9KCBjYXRzUGVyICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvc3Bhbj4lIGluICcrXG4oKF9fdD0oIHRvdGFsQ2F0cyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgY2F0ZWdvcicrXG4oKF9fdD0oIHRvdGFsQ2F0cyAhPT0gMSA/ICdpZXMnIDogJ3knICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZHQ+ICc7XG4gfSBcbl9fcCs9Jyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vc3RhdHNfdGVtcGxhdGUudHBsJyk7XG52YXIgYW5pbWF0aW9uVGVtcGxhdGUgPSByZXF1aXJlKCcuL2NhdHNfdGVtcGxhdGUudHBsJyk7XG52YXIgQW5pbWF0ZVZhbHVlcyA9IHJlcXVpcmUoJy4uLy4uL2FuaW1hdGVfdmFsdWVzJyk7XG5cbi8qKlxuICogQ2F0ZWdvcnkgc3RhdHMgaW5mbyB2aWV3XG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtaW5mbyBDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLXVwcGVyJyxcbiAgdGFnTmFtZTogJ2RsJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMub3B0aW9ucy52aWV3TW9kZWw7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm9wdGlvbnMuZGF0YU1vZGVsO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaXNTZWFyY2hFbmFibGVkOiB0aGlzLnZpZXdNb2RlbC5pc1NlYXJjaEVuYWJsZWQoKSxcbiAgICAgICAgaXNTZWFyY2hBcHBsaWVkOiB0aGlzLmRhdGFNb2RlbC5pc1NlYXJjaEFwcGxpZWQoKSxcbiAgICAgICAgcmVzdWx0c0NvdW50OiB0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hDb3VudCgpLFxuICAgICAgICB0b3RhbENhdHM6IHRoaXMuX2dldENhdGVnb3JpZXNTaXplKCksXG4gICAgICAgIG51bGxzUGVyOiB0aGlzLl9nZXROdWxsUGVyY2VudGFnZSgpLFxuICAgICAgICBjYXRzUGVyOiB0aGlzLl9nZXRDdXJyZW50Q2F0ZWdvcmllc1BlcmNlbnRhZ2UoKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdGVWYWx1ZXMoe1xuICAgICAgZWw6IHRoaXMuJGVsXG4gICAgfSk7XG5cbiAgICBhbmltYXRvci5hbmltYXRlRnJvbVZhbHVlcyh0aGlzLl9nZXRQcmV2aW91c0NhdGVnb3JpZXNQZXJjZW50YWdlKCksIHRoaXMuX2dldEN1cnJlbnRDYXRlZ29yaWVzUGVyY2VudGFnZSgpLCAnLmpzLWNhdHMnLFxuICAgICAgYW5pbWF0aW9uVGVtcGxhdGUsIHsgZGVmYXVsdFZhbHVlOiAnLScsIGFuaW1hdGlvblNwZWVkOiA3MDAsIGZvcm1hdHRlcjogZm9ybWF0dGVyLmZvcm1hdFZhbHVlIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX2luaXRCaW5kczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYmluZCgnY2hhbmdlOmRhdGEgY2hhbmdlOmxvY2tlZCBjaGFuZ2U6c2VhcmNoIGNoYW5nZTp0b3RhbENvdW50JywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTpzZWFyY2gnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLmRhdGFNb2RlbCk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLnZpZXdNb2RlbCk7XG4gIH0sXG5cbiAgX2dldE51bGxQZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVsbHMgPSB0aGlzLmRhdGFNb2RlbC5nZXQoJ251bGxzJyk7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCd0b3RhbENvdW50JykgfHwgMDtcbiAgICByZXR1cm4gIW51bGxzID8gMCA6ICgobnVsbHMvdG90YWwpICogMTAwKS50b0ZpeGVkKDIpO1xuICB9LFxuXG4gIF9nZXRQcmV2aW91c0NhdGVnb3JpZXNQZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG90YWwgPSB0aGlzLmRhdGFNb2RlbC5wcmV2aW91cygndG90YWxDb3VudCcpIHx8IDA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXRQcmV2aW91c0RhdGEoKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2F0ZWdvcmllc1BlcmNlbnRhZ2UoZGF0YSwgdG90YWwpO1xuICB9LFxuXG4gIF9nZXRDdXJyZW50Q2F0ZWdvcmllc1BlcmNlbnRhZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbCA9IHRoaXMuZGF0YU1vZGVsLmdldCgndG90YWxDb3VudCcpIHx8IDA7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCkudG9KU09OKCk7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhdGVnb3JpZXNQZXJjZW50YWdlKGRhdGEsIHRvdGFsKTtcbiAgfSxcblxuICBfZ2V0Q2F0ZWdvcmllc1BlcmNlbnRhZ2U6IGZ1bmN0aW9uKGRhdGEsIHRvdGFsKSB7XG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUb3RhbCA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIG1kbCkge1xuICAgICAgcmV0dXJuICFtZGwuYWdnID8gKCBtZW1vICsgcGFyc2VGbG9hdChtZGwudmFsdWUpKSA6IG1lbW87XG4gICAgfSwgMCk7XG5cbiAgICBpZiAoIWN1cnJlbnRUb3RhbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuICgoY3VycmVudFRvdGFsIC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpO1xuICB9LFxuXG4gIF9nZXRDYXRlZ29yaWVzU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8ucGx1Y2soXG4gICAgICB0aGlzLmRhdGFNb2RlbC5nZXREYXRhKCkucmVqZWN0KGZ1bmN0aW9uKG1kbCkge1xuICAgICAgICByZXR1cm4gbWRsLmdldCgnYWdnJyk7XG4gICAgICB9KSwgJ25hbWUnKS5sZW5ndGg7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPScnO1xuIGlmIChpc1NlYXJjaEVuYWJsZWQpIHsgXG5fX3ArPScgPGZvcm0gY2xhc3M9XCJDREItV2lkZ2V0LXNlYXJjaCBqcy1mb3JtXCI+IDxpIGNsYXNzPVwiQ0RCLUljb24gQ0RCLUljb24tbGVucyBDREItV2lkZ2V0LXNlYXJjaExlbnNcIj48L2k+IDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0SW5wdXQgQ0RCLVdpZGdldC1zZWFyY2hUZXh0SW5wdXQganMtdGV4dElucHV0XCIgdmFsdWU9XCInK1xuKChfX3Q9KCBxICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIGJ5ICcrXG4oKF9fdD0oIGNvbHVtbk5hbWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+ICc7XG4gaWYgKGNhblNob3dBcHBseSkgeyBcbl9fcCs9JyA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayBDREItV2lkZ2V0LXNlYXJjaEFwcGx5IGpzLWFwcGx5TG9ja2VkXCI+YXBwbHk8L2J1dHRvbj4gJztcbiB9IFxuX19wKz0nIDwvZm9ybT4gJztcbiB9IGVsc2UgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aXRsZSBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gzPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1vcHRpb25zIENEQi1XaWRnZXQtY29udGVudFNwYWNlZFwiPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVdpZGdldC1idXR0b25JY29uIENEQi1XaWRnZXQtYnV0dG9uSWNvbi0tY2lyY2xlIGpzLWNvbG9ycyAnK1xuKChfX3Q9KCBpc0NvbG9yQXBwbGllZCA/ICdpcy1zZWxlY3RlZCcgOiAnJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgJytcbigoX190PSggaXNDb2xvckFwcGxpZWQgPyAnanMtY2FuY2VsQ29sb3JzJyA6ICdqcy1hcHBseUNvbG9ycycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCIgZGF0YS10b29sdGlwPVwiXFxuICAgICAgICAgICcrXG4oKF9fdD0oIGlzQ29sb3JBcHBsaWVkID8gJ1JlbW92ZSBjb2xvcnMnIDogJ0FwcGx5IGNvbG9ycycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXFxuICAgICAgICBcIj4gPGkgY2xhc3M9XCJDREItSWNvbiBDREItSWNvbi1zeXJpbmdlIENEQi1JY29uLS10b3BcIj48L2k+IDwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzIGpzLWNvbGxhcHNlXCIgZGF0YS10b29sdGlwPVwiJytcbigoX190PSggaXNDb2xsYXBzZWQgPyAnU2hvdycgOiAnSGlkZScgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzSXRlbVwiPjwvc3Bhbj4gPC9idXR0b24+IDwvZGl2PiA8L2Rpdj4gJztcbiB9IFxuX19wKz0nJztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciAkID0gY2RiLiQ7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgVG9vbHRpcFZpZXcgPSByZXF1aXJlKCcuLi8uLi93aWRnZXQtdG9vbHRpcC12aWV3Jyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3NlYXJjaF90aXRsZV90ZW1wbGF0ZS50cGwnKTtcblxuLyoqXG4gKiAgU2hvdyBjYXRlZ29yeSB0aXRsZSBvciBzZWFyY2ggYW55IGNhdGVnb3J5XG4gKiAgKyBhbm90aGVyIG9wdGlvbnMgZm9yIHRoaXMgd2lkZ2V0LCBhcyBpbixcbiAqICBjb2xvcml6ZSBjYXRlZ29yaWVzLCBsb2NrIGRlZmluZWQgY2F0ZWdvcmllcy4uLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAna2V5dXAgLmpzLXRleHRJbnB1dCc6ICdfb25LZXl1cElucHV0JyxcbiAgICAnc3VibWl0IC5qcy1mb3JtJzogJ19vblN1Ym1pdEZvcm0nLFxuICAgICdjbGljayAuanMtYXBwbHlMb2NrZWQnOiAnX2FwcGx5TG9ja2VkJyxcbiAgICAnY2xpY2sgLmpzLWFwcGx5Q29sb3JzJzogJ19hcHBseUNvbG9ycycsXG4gICAgJ2NsaWNrIC5qcy1jYW5jZWxDb2xvcnMnOiAnX2NhbmNlbENvbG9ycycsXG4gICAgJ2NsaWNrIC5qcy1jb2xsYXBzZSc6ICdfdG9nZ2xlQ29sbGFwc2UnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm9wdGlvbnMudmlld01vZGVsO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIGlzQ29sbGFwc2VkOiB0aGlzLmRhdGFNb2RlbC5pc0NvbGxhcHNlZCgpLFxuICAgICAgICBpc0NvbG9yQXBwbGllZDogdGhpcy5kYXRhTW9kZWwuaXNDb2xvckFwcGxpZWQoKSxcbiAgICAgICAgdGl0bGU6IHRoaXMuZGF0YU1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgY29sdW1uTmFtZTogdGhpcy5kYXRhTW9kZWwuZ2V0KCdjb2x1bW4nKSxcbiAgICAgICAgcTogdGhpcy5kYXRhTW9kZWwuZ2V0U2VhcmNoUXVlcnkoKSxcbiAgICAgICAgaXNMb2NrZWQ6IHRoaXMuZGF0YU1vZGVsLmlzTG9ja2VkKCksXG4gICAgICAgIGNhbkJlTG9ja2VkOiB0aGlzLmRhdGFNb2RlbC5jYW5CZUxvY2tlZCgpLFxuICAgICAgICBpc1NlYXJjaEVuYWJsZWQ6IHRoaXMudmlld01vZGVsLmlzU2VhcmNoRW5hYmxlZCgpLFxuICAgICAgICBjYW5TaG93QXBwbHk6IHRoaXMuZGF0YU1vZGVsLmNhbkFwcGx5TG9ja2VkKClcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6c2VhcmNoJywgdGhpcy5fb25TZWFyY2hUb2dnbGVkLCB0aGlzKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6ZmlsdGVyIGNoYW5nZTpsb2NrQ29sbGVjdGlvbiBjaGFuZ2U6Y2F0ZWdvcnlDb2xvcnMgY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMudmlld01vZGVsKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29sbGFwc2VUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtY29sbGFwc2UnKVxuICAgIH0pO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoY29sbGFwc2VUb29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoY29sbGFwc2VUb29sdGlwKTtcblxuICAgIHZhciBjb2xvcnNUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtY29sb3JzJylcbiAgICB9KTtcbiAgICAkKCdib2R5JykuYXBwZW5kKGNvbG9yc1Rvb2x0aXAucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhjb2xvcnNUb29sdGlwKTtcbiAgfSxcblxuICBfb25TZWFyY2hUb2dnbGVkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNTZWFyY2hFbmFibGVkID0gdGhpcy52aWV3TW9kZWwuaXNTZWFyY2hFbmFibGVkKCk7XG4gICAgdGhpc1tpc1NlYXJjaEVuYWJsZWQgPyAnX2JpbmRFU0MnIDogJ191bmJpbmRFU0MnXSgpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgaWYgKGlzU2VhcmNoRW5hYmxlZCkge1xuICAgICAgdGhpcy5fZm9jdXNPbklucHV0KCk7XG4gICAgfVxuICB9LFxuXG4gIF9vblN1Ym1pdEZvcm06IGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB2YXIgcSA9IHRoaXMuJCgnLmpzLXRleHRJbnB1dCcpLnZhbCgpO1xuICAgIGlmICh0aGlzLmRhdGFNb2RlbC5nZXRTZWFyY2hRdWVyeSgpICE9PSBxKSB7XG4gICAgICB0aGlzLmRhdGFNb2RlbC5zZXRTZWFyY2hRdWVyeShxKTtcbiAgICAgIGlmICh0aGlzLmRhdGFNb2RlbC5pc1NlYXJjaFZhbGlkKCkpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlTZWFyY2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2ZvY3VzT25JbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLiQoJy5qcy10ZXh0SW5wdXQnKS5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9LFxuXG4gIF9vbktleXVwSW5wdXQ6IF8uZGVib3VuY2UoXG4gICAgZnVuY3Rpb24oZXYpIHtcbiAgICAgIHZhciBxID0gdGhpcy4kKCcuanMtdGV4dElucHV0JykudmFsKCk7XG4gICAgICBpZiAoZXYua2V5Q29kZSAhPT0gMTMgJiYgZXYua2V5Q29kZSAhPT0gMjcgJiYgcSAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLl9vblN1Ym1pdEZvcm0oKTtcbiAgICAgIH1cbiAgICB9LCAyNTBcbiAgKSxcblxuICBfYmluZEVTQzogZnVuY3Rpb24oKSB7XG4gICAgJChkb2N1bWVudCkuYmluZChcImtleXVwLlwiICsgdGhpcy5jaWQsIF8uYmluZCh0aGlzLl9vbktleVVwLCB0aGlzKSk7XG4gIH0sXG5cbiAgX3VuYmluZEVTQzogZnVuY3Rpb24oKSB7XG4gICAgJChkb2N1bWVudCkudW5iaW5kKFwia2V5dXAuXCIgKyB0aGlzLmNpZCk7XG4gIH0sXG5cbiAgX29uS2V5VXA6IGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICB0aGlzLl9jYW5jZWxTZWFyY2goKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgX2FwcGx5TG9ja2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC50b2dnbGVTZWFyY2goKTtcbiAgICB0aGlzLmRhdGFNb2RlbC5hcHBseUxvY2tlZCgpO1xuICB9LFxuXG4gIF9hcHBseUNvbG9yczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlDYXRlZ29yeUNvbG9ycygpO1xuICB9LFxuXG4gIF9jYW5jZWxDb2xvcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLmNhbmNlbENhdGVnb3J5Q29sb3JzKCk7XG4gIH0sXG5cbiAgX2NhbmNlbFNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwuY2xlYW5TZWFyY2goKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5kaXNhYmxlU2VhcmNoKCk7XG4gIH0sXG5cbiAgX3RvZ2dsZUNvbGxhcHNlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC50b2dnbGVDb2xsYXBzZWQoKTtcbiAgfSxcblxuICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5iaW5kRVNDKCk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJytcbigoX190PSggcHJlZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHZhbHVlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJycrXG4oKF9fdD0oIHN1ZmZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBkMyA9IGNkYi5kMztcbnZhciAkID0gY2RiLiQ7XG52YXIgV2lkZ2V0Q29udGVudCA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBXaWRnZXRWaWV3TW9kZWwgPSByZXF1aXJlKCcuLi93aWRnZXRfY29udGVudF9tb2RlbCcpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZS50cGwnKTtcbnZhciBUb29sdGlwVmlldyA9IHJlcXVpcmUoJy4uL3dpZGdldC10b29sdGlwLXZpZXcnKTtcbnZhciBhbmltYXRpb25UZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCcpO1xudmFyIEFuaW1hdGVWYWx1ZXMgPSByZXF1aXJlKCcuLi9hbmltYXRlX3ZhbHVlcy5qcycpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IGNvbnRlbnQgdmlldzpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRDb250ZW50LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1jb2xsYXBzZSc6ICdfdG9nZ2xlQ29sbGFwc2UnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHRoaXMudmlld01vZGVsID0gbmV3IFdpZGdldFZpZXdNb2RlbCgpO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZGF0YU1vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZDMuZm9ybWF0KCcwLDAwMCcpO1xuXG4gICAgICBpZiAoXy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcih2YWx1ZS50b0ZpeGVkKDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICB2YXIgbnVsbHMgPSAhXy5pc1VuZGVmaW5lZCh0aGlzLmRhdGFNb2RlbC5nZXQoJ251bGxzJykpICYmIGZvcm1hdHRlci5mb3JtYXROdW1iZXIodGhpcy5kYXRhTW9kZWwuZ2V0KCdudWxscycpKSB8fMKgJy0nO1xuICAgIHZhciBpc0NvbGxhcHNlZCA9IHRoaXMuZGF0YU1vZGVsLmlzQ29sbGFwc2VkKCk7XG5cbiAgICB2YXIgcHJlZml4ID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCdwcmVmaXgnKTtcbiAgICB2YXIgc3VmZml4ID0gdGhpcy5kYXRhTW9kZWwuZ2V0KCdzdWZmaXgnKTtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIG9wZXJhdGlvbjogdGhpcy5kYXRhTW9kZWwuZ2V0KCdvcGVyYXRpb24nKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBudWxsczogbnVsbHMsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICAgICAgaXNDb2xsYXBzZWQ6IGlzQ29sbGFwc2VkXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0ZVZhbHVlcyh7XG4gICAgICBlbDogdGhpcy4kZWxcbiAgICB9KTtcblxuICAgIGFuaW1hdG9yLmFuaW1hdGVWYWx1ZSh0aGlzLmRhdGFNb2RlbCwgJ2RhdGEnLCAnLmpzLXZhbHVlJywgYW5pbWF0aW9uVGVtcGxhdGUsIHsgYW5pbWF0aW9uU3BlZWQ6IDcwMCwgZm9ybWF0dGVyOiBmb3JtYXQsIHRlbXBsYXRlRGF0YTogeyBwcmVmaXg6IHByZWZpeCwgc3VmZml4OiBzdWZmaXggfX0pO1xuXG4gICAgdGhpcy4kZWwudG9nZ2xlQ2xhc3MoJ2lzLWNvbGxhcHNlZCcsICEhaXNDb2xsYXBzZWQpO1xuXG4gICAgdGhpcy5faW5pdFZpZXdzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6Y29sbGFwc2VkJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLl9pbml0QmluZHMuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9vbHRpcCA9IG5ldyBUb29sdGlwVmlldyh7XG4gICAgICB0YXJnZXQ6IHRoaXMuJCgnLmpzLWNvbGxhcHNlJylcbiAgICB9KTtcbiAgICAkKCdib2R5JykuYXBwZW5kKHRvb2x0aXAucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0b29sdGlwKTtcbiAgfSxcblxuICBfdG9nZ2xlQ29sbGFwc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsLnRvZ2dsZUNvbGxhcHNlZCgpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBXaWRnZXRNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9tb2RlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IF8uZXh0ZW5kKFxuICAgIHt9LFxuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5kZWZhdWx0cyxcbiAgICB7XG4gICAgICBkYXRhOiAnJyxcbiAgICAgIHN1ZmZpeDogJycsXG4gICAgICBwcmVmaXg6ICcnXG4gICAgfVxuICApLFxuXG4gIC8vIFRPRE86IFRoZSByZXNwb25zZSBmb3JtYXQgaGFzIHByb2JhYmx5IGNoYW5nZWRcbiAgcGFyc2U6IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogci5yZXN1bHQsXG4gICAgICBudWxsczogci5udWxsc1xuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9ybXVsYVwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2x1bW46IHRoaXMuZ2V0KCdjb2x1bW4nKSxcbiAgICAgICAgb3BlcmF0aW9uOiB0aGlzLmdldCgnb3BlcmF0aW9uJylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGFnIENEQi1XaWRnZXQtdGFnLS0nK1xuKChfX3Q9KCBvcGVyYXRpb24gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIG9wZXJhdGlvbiApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L3NwYW4+IDwvZGl2PiA8L2Rpdj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50cyBqcy1jb2xsYXBzZVwiIGRhdGEtdG9vbHRpcD1cIicrXG4oKF9fdD0oIGlzQ29sbGFwc2VkID8gJ1Nob3cnIDogJ0hpZGUnICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPiA8c3BhbiBjbGFzcz1cIkNEQi1TaGFwZS10aHJlZVBvaW50c0l0ZW1cIj48L3NwYW4+IDwvYnV0dG9uPiA8L2Rpdj4gPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvXCI+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIG51bGxzICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBudWxsIHJvd3M8L2R0PiA8L2RsPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudFwiPiAnO1xuIGlmICh2YWx1ZSkgeyBcbl9fcCs9JyA8aDQgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdnZXIgQ0RCLVdpZGdldC10ZXh0QmlnZ2VyLS1tYXhXaWR0aCBqcy12YWx1ZVwiIHRpdGxlPVwiJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+ICcrXG4oKF9fdD0oIHByZWZpeCApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCB2YWx1ZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicnK1xuKChfX3Q9KCBzdWZmaXggKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIDwvaDQ+ICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0tLWZha2VcIj48L2Rpdj4gJztcbiB9IFxuX19wKz0nIDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nJytcbigoX190PSggdmFsdWUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJytcbigoX190PSggc3VmZml4ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyc7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIGQzID0gY2RiLmQzO1xudmFyIGZvcm1hdHRlciA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgICAvLyByZW5kZXIgdGhlIGNoYXJ0IG9uY2UgdGhlIHdpZHRoIGlzIHNldCBhcyBkZWZhdWx0LCBwcm92aWRlIGZhbHNlIHZhbHVlIGZvciB0aGlzIHByb3AgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW9yXG4gICAgIC8vIGUuZy4gZm9yIFwibWluaVwiIGhpc3RvZ3JhbSBiZWhhdmlvclxuICAgIHNob3dPbldpZHRoQ2hhbmdlOiB0cnVlLFxuXG4gICAgbGFiZWxzTWFyZ2luOiAxNiwgLy8gcHhcbiAgICBoYXNBeGlzVGlwOiBmYWxzZSxcbiAgICBtaW5pbXVtQmFySGVpZ2h0OiAyLFxuICAgIGFuaW1hdGlvblNwZWVkOiA3NTAsXG4gICAgaGFuZGxlV2lkdGg6IDYsXG4gICAgaGFuZGxlSGVpZ2h0OiAyMyxcbiAgICBoYW5kbGVSYWRpdXM6IDMsXG4gICAgZGl2aXNpb25XaWR0aDogODAsXG4gICAgYW5pbWF0aW9uQmFyRGVsYXk6IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKDEwMCArIChpICogMTApKTtcbiAgICB9LFxuICAgIHRyYW5zaXRpb25UeXBlOiAnZWxhc3RpYydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIodGhpcy5vcHRpb25zLmhlaWdodCkpIHRocm93IG5ldyBFcnJvcignaGVpZ2h0IGlzIHJlcXVpcmVkJyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgdGhpcy5vcHRpb25zKTtcblxuICAgIF8uYmluZEFsbCh0aGlzLCAnX3NlbGVjdEJhcnMnLCAnX2FkanVzdEJydXNoSGFuZGxlcycsICdfb25CcnVzaE1vdmUnLCAnX29uQnJ1c2hTdGFydCcsICdfb25Nb3VzZU1vdmUnLCAnX29uTW91c2VPdXQnKTtcblxuICAgIC8vIFVzZSB0aGlzIHNwZWNpYWwgc2V0dXAgZm9yIGVhY2ggdmlldyBpbnN0YW5jZSBvdCBoYXZlIGl0cyBvd24gZGVib3VuY2VkIGxpc3RlbmVyXG4gICAgLy8gVE9ETyBpbiB0aGVvcnkgdGhlcmUncyB0aGUgcG9zc2libGl0eSB0aGF0IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYmVmb3JlIHRoZSB2aWV3IGlzIHJlbmRlcmVkIGluIHRoZSBET00sXG4gICAgLy8gIHdoaWNoIHdvdWxkIGxlYWQgdG8gdGhlIHZpZXcgbm90IGJlaW5nIHZpc2libGUgdW50aWwgYW4gZXhwbGljaXQgd2luZG93IHJlc2l6ZS5cbiAgICAvLyAgYSB3YXNBZGRlZFRvRE9NIGV2ZW50IHdvdWxkJ3ZlIGJlZW4gbmljZSB0byBoYXZlXG4gICAgdGhpcy5fb25XaW5kb3dSZXNpemUgPSBfLmRlYm91bmNlKHRoaXMuX3Jlc2l6ZVRvUGFyZW50RWxlbWVudC5iaW5kKHRoaXMpLCA1MCk7XG4gICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKTtcblxuICAgIC8vIHVzaW5nIHRhZ05hbWU6ICdzdmcnIGRvZXNuJ3Qgd29yayxcbiAgICAvLyBhbmQgdy9vIGNsYXNzPVwiXCIgZDMgd29uJ3QgaW5zdGFudGlhdGUgcHJvcGVybHlcbiAgICB0aGlzLnNldEVsZW1lbnQoJCgnPHN2ZyBjbGFzcz1cIlwiPjwvc3ZnPicpWzBdKTtcblxuICAgIHRoaXMuY2FudmFzID0gZDMuc2VsZWN0KHRoaXMuZWwpXG4gICAgLmF0dHIoJ3dpZHRoJywgMClcbiAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5vcHRpb25zLmhlaWdodCk7XG5cbiAgICB0aGlzLmNhbnZhc1xuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItV2lkZ2V0Q2FudmFzJyk7XG5cbiAgICB0aGlzLl9zZXR1cE1vZGVsKCk7XG4gICAgdGhpcy5fc2V0dXBCaW5kaW5ncygpO1xuICAgIHRoaXMuX3NldHVwRGltZW5zaW9ucygpO1xuICAgIHRoaXMuX3NldHVwRDNCaW5kaW5ncygpO1xuXG4gICAgdGhpcy5oaWRlKCk7IC8vIHdpbGwgYmUgdG9nZ2xlZCBvbiB3aWR0aCBjaGFuZ2VcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dlbmVyYXRlQ2hhcnQoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUNoYXJ0Q29udGVudCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAkKHdpbmRvdykudW5iaW5kKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfSxcblxuICByZXBsYWNlRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMubW9kZWwuc2V0KHsgZGF0YTogZGF0YSB9KTtcbiAgfSxcblxuICB0b2dnbGVMYWJlbHM6IGZ1bmN0aW9uKHNob3cpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2hvd0xhYmVscycsIHNob3cpO1xuICB9LFxuXG4gIGNoYXJ0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdGhpcy5tb2RlbC5nZXQoJ21hcmdpbicpO1xuXG4gICAgLy8gR2V0IG1heCBiZWNhdXNlIHdpZHRoIG1pZ2h0IGJlIG5lZ2F0aXZlIGluaXRpYWxseVxuICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLm1vZGVsLmdldCgnd2lkdGgnKSAtIG0ubGVmdCAtIG0ucmlnaHQpO1xuICB9LFxuXG4gIGNoYXJ0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHRoaXMubW9kZWwuZ2V0KCdtYXJnaW4nKTtcbiAgICB2YXIgbGFiZWxzTWFyZ2luID0gdGhpcy5tb2RlbC5nZXQoJ3Nob3dMYWJlbHMnKVxuICAgICAgPyB0aGlzLmRlZmF1bHRzLmxhYmVsc01hcmdpblxuICAgICAgOiAwO1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldCgnaGVpZ2h0JykgLSBtLnRvcCAtIG0uYm90dG9tIC0gbGFiZWxzTWFyZ2luO1xuICB9LFxuXG4gIF9yZXNpemVUb1BhcmVudEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHRoaXMuJGVsLnBhcmVudCgpKSB7XG4gICAgICAvLyBIaWRlIHRoaXMgdmlldyB0ZW1wb3JhcmlseSB0byBnZXQgYWN0dWFsIHNpemUgb2YgdGhlIHBhcmVudCBjb250YWluZXJcbiAgICAgIHZhciB3YXNIaWRkZW4gPSB0aGlzLmlzSGlkZGVuKCk7XG5cbiAgICAgIHRoaXMuaGlkZSgpO1xuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbC5wYXJlbnQoKS53aWR0aCgpIHx8IDA7XG5cbiAgICAgIGlmICh3YXNIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlbC5zZXQoJ3dpZHRoJywgd2lkdGgpO1xuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VMZWZ0QXhpc1RpcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQXhpc1RpcCgnbGVmdCcpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVJpZ2h0QXhpc1RpcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQXhpc1RpcCgncmlnaHQnKTtcbiAgfSxcblxuICBfdXBkYXRlQXhpc1RpcDogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIHRleHRMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBUZXh0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBheGlzVGlwICA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXAuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG4gICAgdmFyIHJlY3RMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBSZWN0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBoYW5kbGUgICAgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGUuQ0RCLUNoYXJ0LWhhbmRsZS0nICsgY2xhc3NOYW1lKTtcblxuICAgIHRleHRMYWJlbC5kYXRhKFt0aGlzLm1vZGVsLmdldChjbGFzc05hbWUgKyAnX2F4aXNfdGlwJyldKS50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKGQpO1xuICAgIH0pO1xuXG4gICAgdmFyIHdpZHRoID0gdGV4dExhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgcmVjdExhYmVsLmF0dHIoJ3dpZHRoJywgd2lkdGggKyA0KTtcblxuICAgIHZhciBwYXJ0cyA9IC90cmFuc2xhdGVcXChcXHMqKFteXFxzLCldKyksIChbXlxccywpXSspLy5leGVjKGhhbmRsZS5hdHRyKCd0cmFuc2Zvcm0nKSk7XG4gICAgdmFyIHhQb3MgPSArcGFydHNbMV0gKyAzO1xuXG4gICAgaWYgKCh4UG9zIC0gd2lkdGgvMikgPCAwKSB7XG4gICAgICBheGlzVGlwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgNTIpJyk7XG4gICAgICB0ZXh0TGFiZWwuYXR0cignZHgnLCAteFBvcyk7XG4gICAgICByZWN0TGFiZWwuYXR0cigneCcsICAteFBvcyk7XG4gICAgfSBlbHNlIGlmICgoeFBvcyArIHdpZHRoLzIgKyAyKSA+PSB0aGlzLmNoYXJ0V2lkdGgoKSkge1xuICAgICAgYXhpc1RpcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDUyKScpO1xuICAgICAgdGV4dExhYmVsLmF0dHIoJ2R4JywgdGhpcy5jaGFydFdpZHRoKCkgLSAoeFBvcyArIHdpZHRoIC0gMikpO1xuICAgICAgcmVjdExhYmVsLmF0dHIoJ3gnLCB0aGlzLmNoYXJ0V2lkdGgoKSAtICh4UG9zICsgd2lkdGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1RpcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC0nICsgKHdpZHRoLzIpICsgJywgNTIpJyk7XG4gICAgICByZWN0TGFiZWwuYXR0cigneCcsIDApO1xuICAgICAgdGV4dExhYmVsLmF0dHIoJ2R4JywgKzIpO1xuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5wcmV2aW91cygnZGF0YScpLmxlbmd0aCAhPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlUmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbG9faW5kZXgnKSA9PT0gMCAmJiB0aGlzLm1vZGVsLmdldCgnaGlfaW5kZXgnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoJ3JhbmdlX3VwZGF0ZWQnLCB0aGlzLm1vZGVsLmdldCgnbG9faW5kZXgnKSwgdGhpcy5tb2RlbC5nZXQoJ2hpX2luZGV4JykpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLm1vZGVsLmdldCgnd2lkdGgnKTtcbiAgICB0aGlzLiRlbC53aWR0aCh3aWR0aCk7XG4gICAgdGhpcy5jaGFydC5hdHRyKCd3aWR0aCcsIHdpZHRoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dPbldpZHRoQ2hhbmdlICYmIHdpZHRoID4gMCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIHZhciBsb0JhckluZGV4ID0gdGhpcy5tb2RlbC5nZXQoJ2xvX2luZGV4Jyk7XG4gICAgdmFyIGhpQmFySW5kZXggPSB0aGlzLm1vZGVsLmdldCgnaGlfaW5kZXgnKTtcbiAgICB0aGlzLnNlbGVjdFJhbmdlKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMubW9kZWwuZ2V0KCdoZWlnaHQnKTtcblxuICAgIHRoaXMuJGVsLmhlaWdodChoZWlnaHQpO1xuICAgIHRoaXMuY2hhcnQuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB0aGlzLmxlZnRIYW5kbGUuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB0aGlzLnJpZ2h0SGFuZGxlLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH0sXG5cbiAgX29uQ2hhbmdTaG93TGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9heGlzLnN0eWxlKCdvcGFjaXR5JywgdGhpcy5tb2RlbC5nZXQoJ3Nob3dMYWJlbHMnKSA/IDEgOiAwKTtcbiAgfSxcblxuICBfb25DaGFuZ2VQb3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3MgPSB0aGlzLm1vZGVsLmdldCgncG9zJyk7XG4gICAgdmFyIG1hcmdpbiA9IHRoaXMubW9kZWwuZ2V0KCdtYXJnaW4nKTtcblxuICAgIHZhciB4ID0gK3Bvcy54O1xuICAgIHZhciB5ID0gK3Bvcy55O1xuXG4gICAgdGhpcy5jaGFydFxuICAgIC50cmFuc2l0aW9uKClcbiAgICAuZHVyYXRpb24oMTUwKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAobWFyZ2luLmxlZnQgKyB4KSArICcsICcgKyAobWFyZ2luLnRvcCArIHkpICsgJyknKTtcbiAgfSxcblxuICBfb25CcnVzaFN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcbiAgICB2YXIgaGlFeHRlbnQgPSBleHRlbnRbMV07XG4gICAgdmFyIHJpZ2h0WCA9IHRoaXMueFNjYWxlKGhpRXh0ZW50KSAtIHRoaXMub3B0aW9ucy5oYW5kbGVXaWR0aCAvIDI7XG5cbiAgICB0aGlzLmNoYXJ0LmNsYXNzZWQoJ2lzLXNlbGVjdGFibGUnLCB0cnVlKTtcbiAgfSxcblxuICBfb25DaGFuZ2VEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5jbGFzc2VkKCdpcy1kcmFnZ2luZycsIHRoaXMubW9kZWwuZ2V0KCdkcmFnZ2luZycpKTtcbiAgICB0aGlzLl91cGRhdGVBeGlzVGlwT3BhY2l0eSgncmlnaHQnKTtcbiAgICB0aGlzLl91cGRhdGVBeGlzVGlwT3BhY2l0eSgnbGVmdCcpO1xuICB9LFxuXG4gIF9zaG93QXhpc1RpcDogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIHRleHRMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBUZXh0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciBheGlzVGlwICAgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwLkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuICAgIHZhciByZWN0TGFiZWwgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1heGlzVGlwUmVjdC5DREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKTtcblxuICAgIGlmICh0ZXh0TGFiZWwpIHtcbiAgICAgIHRleHRMYWJlbC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjAwKS5hdHRyKCdvcGFjaXR5JywgIDEpO1xuICAgIH1cbiAgICBpZiAocmVjdExhYmVsKSB7XG4gICAgICByZWN0TGFiZWwudHJhbnNpdGlvbigpLmR1cmF0aW9uKDIwMCkuYXR0cignb3BhY2l0eScsICAxKTtcbiAgICB9XG4gIH0sXG5cbiAgX2hpZGVBeGlzVGlwOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB2YXIgdGV4dExhYmVsID0gdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtYXhpc1RpcFRleHQuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG4gICAgdmFyIGF4aXNUaXAgICA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXAuQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSk7XG4gICAgdmFyIHJlY3RMYWJlbCA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXNUaXBSZWN0LkNEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpO1xuXG4gICAgaWYgKHRleHRMYWJlbCkge1xuICAgICAgdGV4dExhYmVsLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyMDApLmF0dHIoJ29wYWNpdHknLCAgMCk7XG4gICAgfVxuICAgIGlmIChyZWN0TGFiZWwpIHtcbiAgICAgIHJlY3RMYWJlbC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjAwKS5hdHRyKCdvcGFjaXR5JywgIDApO1xuICAgIH1cbiAgfSxcblxuICBfdXBkYXRlQXhpc1RpcE9wYWNpdHk6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnZHJhZ2dpbmcnKSkge1xuICAgICAgdGhpcy5fc2hvd0F4aXNUaXAoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGlkZUF4aXNUaXAoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQnJ1c2hNb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCh7IGRyYWdnaW5nOiB0cnVlIH0pO1xuICAgIHRoaXMuX3NlbGVjdEJhcnMoKTtcbiAgICB0aGlzLl9hZGp1c3RCcnVzaEhhbmRsZXMoKTtcbiAgfSxcblxuICBfb25Nb3VzZU91dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhcnMgPSB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKTtcbiAgICBiYXJzLmNsYXNzZWQoJ2lzLWhpZ2hsaWdodGVkJywgZmFsc2UpO1xuICAgIHRoaXMudHJpZ2dlcignaG92ZXInLCB7IHZhbHVlOiBudWxsIH0pO1xuICB9LFxuXG4gIF9vbk1vdXNlTW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSBkMy5ldmVudC5vZmZzZXRYO1xuICAgIHZhciB5ID0gZDMuZXZlbnQub2Zmc2V0WTtcblxuICAgIHZhciBiYXJJbmRleCA9IE1hdGguZmxvb3IoeCAvIHRoaXMuYmFyV2lkdGgpO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgIGlmIChkYXRhW2JhckluZGV4XSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFbYmFySW5kZXhdID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyZXEgPSBkYXRhW2JhckluZGV4XS5mcmVxO1xuICAgIHZhciBob3ZlclByb3BlcnRpZXMgPSB7fTtcblxuICAgIHZhciBiYXIgPSB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1iYXI6bnRoLWNoaWxkKCcgKyAoYmFySW5kZXggKyAxKSArICcpJyk7XG5cbiAgICBpZiAoYmFyICYmIGJhci5ub2RlKCkgJiYgIWJhci5jbGFzc2VkKCdpcy1zZWxlY3RlZCcpKSB7XG5cbiAgICAgIHZhciBsZWZ0ID0gKGJhckluZGV4ICogdGhpcy5iYXJXaWR0aCkgKyAodGhpcy5iYXJXaWR0aC8yKTtcblxuICAgICAgdmFyIHRvcCA9IHRoaXMueVNjYWxlKGZyZXEpO1xuXG4gICAgICB2YXIgaCA9IHRoaXMuY2hhcnRIZWlnaHQoKSAtIHRoaXMueVNjYWxlKGZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHRoaXMub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIHRvcCA9IHRoaXMuY2hhcnRIZWlnaHQoKSAtIHRoaXMub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzRHJhZ2dpbmcoKSAmJiBmcmVxID4gMCkge1xuICAgICAgICB2YXIgZCA9IGZvcm1hdHRlci5mb3JtYXROdW1iZXIoZnJlcSk7XG4gICAgICAgIGhvdmVyUHJvcGVydGllcyA9IHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIGRhdGE6IGQgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvdmVyUHJvcGVydGllcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaG92ZXJQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2hvdmVyJywgaG92ZXJQcm9wZXJ0aWVzKTtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpXG4gICAgLmNsYXNzZWQoJ2lzLWhpZ2hsaWdodGVkJywgZmFsc2UpO1xuXG4gICAgaWYgKGJhciAmJiBiYXIubm9kZSgpKSB7XG4gICAgICBiYXIuY2xhc3NlZCgnaXMtaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JlbW92ZUNoYXJ0Q29udGVudCgpO1xuICAgIHRoaXMuX3NldHVwRGltZW5zaW9ucygpO1xuICAgIHRoaXMuX2NhbGNCYXJXaWR0aCgpO1xuICAgIHRoaXMuX2dlbmVyYXRlQ2hhcnRDb250ZW50KCk7XG4gICAgdGhpcy5fcmVtb3ZlU2hhZG93QmFycygpO1xuICAgIHRoaXMuX2dlbmVyYXRlU2hhZG93QmFycygpO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldHVwRGltZW5zaW9ucygpO1xuICAgIHRoaXMuX3JlbW92ZUF4aXMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUF4aXMoKTtcbiAgICB0aGlzLl91cGRhdGVDaGFydCgpO1xuXG4gICAgdGhpcy5fZ2VuZXJhdGVTaGFkb3dCYXJzKCk7XG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtaGFuZGxlcycpLm1vdmVUb0Zyb250KCk7XG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5CcnVzaCcpLm1vdmVUb0Zyb250KCk7XG4gIH0sXG5cbiAgcmVzZXRJbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCh7IGxvX2luZGV4OiBudWxsLCBoaV9pbmRleDogbnVsbCB9KTtcbiAgfSxcblxuICByZW1vdmVTaGFkb3dCYXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2hvd19zaGFkb3dfYmFycycsIGZhbHNlKTtcbiAgfSxcblxuICBfcmVtb3ZlU2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtc2hhZG93QmFycycpLnJlbW92ZSgpO1xuICB9LFxuXG4gIF9yZW1vdmVCYXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXJzJykucmVtb3ZlKCk7XG4gIH0sXG5cbiAgX3JlbW92ZUJydXNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkJydXNoJykucmVtb3ZlKCk7XG4gICAgdGhpcy5jaGFydC5jbGFzc2VkKCdpcy1zZWxlY3RhYmxlJywgZmFsc2UpO1xuICB9LFxuXG4gIF9yZW1vdmVMaW5lczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtbGluZXMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfcmVtb3ZlQ2hhcnRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCgpO1xuICAgIHRoaXMuX3JlbW92ZUhhbmRsZXMoKTtcbiAgICB0aGlzLl9yZW1vdmVCYXJzKCk7XG4gICAgdGhpcy5fcmVtb3ZlQXhpcygpO1xuICAgIHRoaXMuX3JlbW92ZUxpbmVzKCk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQ2hhcnRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUF4aXMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUxpbmVzKCk7XG5cbiAgICB0aGlzLl9nZW5lcmF0ZUJhcnMoKTtcbiAgICB0aGlzLl9nZW5lcmF0ZUhhbmRsZXMoKTtcbiAgICB0aGlzLl9zZXR1cEJydXNoKCk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2dlbmVyYXRlSG9yaXpvbnRhbExpbmVzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVWZXJ0aWNhbExpbmVzKCk7XG4gICAgfVxuICB9LFxuXG4gIF9nZW5lcmF0ZVZlcnRpY2FsTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsaW5lcyA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWxpbmVzJyk7XG5cbiAgICBsaW5lcy5hcHBlbmQoJ2cnKVxuICAgIC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtbGluZScpXG4gICAgLmRhdGEodGhpcy52ZXJ0aWNhbFJhbmdlLnNsaWNlKDEsIHRoaXMudmVydGljYWxSYW5nZS5sZW5ndGggLSAxKSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWxpbmUnKVxuICAgIC5hdHRyKCd5MScsIDApXG4gICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAuYXR0cigneTInLCB0aGlzLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlSG9yaXpvbnRhbExpbmVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGluZXMgPSB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1saW5lcycpO1xuXG4gICAgbGluZXMuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAneScpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1DaGFydC1saW5lJylcbiAgICAuZGF0YSh0aGlzLmhvcml6b250YWxSYW5nZSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWxpbmUnKVxuICAgIC5hdHRyKCd4MScsIDApXG4gICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAuYXR0cigneDInLCB0aGlzLmNoYXJ0V2lkdGgoKSlcbiAgICAuYXR0cigneTInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTtcblxuICAgIHRoaXMuYm90dG9tTGluZSA9IGxpbmVzXG4gICAgLmFwcGVuZCgnbGluZScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1saW5lIENEQi1DaGFydC1saW5lLS1ib3R0b20nKVxuICAgIC5hdHRyKCd4MScsIDApXG4gICAgLmF0dHIoJ3kxJywgdGhpcy5jaGFydEhlaWdodCgpKVxuICAgIC5hdHRyKCd4MicsIHRoaXMuY2hhcnRXaWR0aCgpIC0gMSlcbiAgICAuYXR0cigneTInLCB0aGlzLmNoYXJ0SGVpZ2h0KCkpO1xuICB9LFxuXG4gICBfc2V0dXBEM0JpbmRpbmdzOiBmdW5jdGlvbigpIHsgLy8gVE9ETzogbW92ZSB0byBhIGhlbHBlclxuXG4gICAgZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5tb3ZlVG9CYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLm1vdmVUb0Zyb250ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG5cbiAgX3NldHVwTW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe1xuICAgICAgc2hvd0xhYmVsczogdHJ1ZSxcbiAgICAgIGRhdGE6IHRoaXMub3B0aW9ucy5kYXRhLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuaGVpZ2h0LFxuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIHNob3dfc2hhZG93X2JhcnM6IHRoaXMub3B0aW9ucy5zaGFkb3dEYXRhLFxuICAgICAgbWFyZ2luOiBfLmNsb25lKHRoaXMub3B0aW9ucy5tYXJnaW4pLFxuICAgICAgd2lkdGg6IDAsIC8vIHdpbGwgYmUgc2V0IG9uIHJlc2l6ZSBsaXN0ZW5lclxuICAgICAgcG9zOiB7IHg6IDAsIHk6IDAgfVxuICAgIH0pO1xuICB9LFxuXG4gIF9zZXR1cEJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25DaGFuZ2VEYXRhLCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkaXNwbGF5JywgdGhpcy5fb25DaGFuZ2VEaXNwbGF5LCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkcmFnZ2luZycsIHRoaXMuX29uQ2hhbmdlRHJhZ2dpbmcsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmhlaWdodCcsIHRoaXMuX29uQ2hhbmdlSGVpZ2h0LCB0aGlzKTtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpsZWZ0X2F4aXNfdGlwJywgdGhpcy5fb25DaGFuZ2VMZWZ0QXhpc1RpcCwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6bG9faW5kZXggY2hhbmdlOmhpX2luZGV4JywgdGhpcy5fb25DaGFuZ2VSYW5nZSwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6cG9zJywgdGhpcy5fb25DaGFuZ2VQb3MsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnJpZ2h0X2F4aXNfdGlwJywgdGhpcy5fb25DaGFuZ2VSaWdodEF4aXNUaXAsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnNob3dMYWJlbHMnLCB0aGlzLl9vbkNoYW5nU2hvd0xhYmVscywgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5iaW5kKCdjaGFuZ2U6c2hvd19zaGFkb3dfYmFycycsIHRoaXMuX29uQ2hhbmdlU2hvd1NoYWRvd0JhcnMsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOndpZHRoJywgdGhpcy5fb25DaGFuZ2VXaWR0aCwgdGhpcyk7XG4gIH0sXG5cbiAgX3NldHVwRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0dXBTY2FsZXMoKTtcbiAgICB0aGlzLl9zZXR1cFJhbmdlcygpO1xuICAgIHRoaXMuX29uV2luZG93UmVzaXplKCk7XG4gIH0sXG5cbiAgX3NldHVwU2NhbGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICB0aGlzLnhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbMCwgMTAwXSkucmFuZ2UoWzAsIHRoaXMuY2hhcnRXaWR0aCgpXSk7XG4gICAgdGhpcy55U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzAsIGQzLm1heChkYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBfLmlzRW1wdHkoZCkgPyAwIDogZC5mcmVxOyB9ICldKS5yYW5nZShbdGhpcy5jaGFydEhlaWdodCgpLCAwXSk7XG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSAndGltZScpIHtcbiAgICAgIHRoaXMueEF4aXNTY2FsZSA9IGQzLnRpbWUuc2NhbGUoKS5kb21haW4oW2RhdGFbMF0uc3RhcnQgKiAxMDAwLCBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZW5kICogMTAwMF0pLm5pY2UoKS5yYW5nZShbMCwgdGhpcy5jaGFydFdpZHRoKCldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54QXhpc1NjYWxlID0gZDMuc2NhbGUubGluZWFyKCkucmFuZ2UoW2RhdGFbMF0uc3RhcnQsIGRhdGFbZGF0YS5sZW5ndGggLSAxXS5lbmRdKS5kb21haW4oWzAsIHRoaXMuY2hhcnRXaWR0aCgpXSk7XG4gICAgfVxuICB9LFxuXG4gIF9zZXR1cFJhbmdlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBNYXRoLnJvdW5kKHRoaXMuY2hhcnRXaWR0aCgpIC8gdGhpcy5vcHRpb25zLmRpdmlzaW9uV2lkdGgpO1xuICAgIHRoaXMudmVydGljYWxSYW5nZSA9IGQzLnJhbmdlKDAsIHRoaXMuY2hhcnRXaWR0aCgpICsgdGhpcy5jaGFydFdpZHRoKCkgLyBuLCB0aGlzLmNoYXJ0V2lkdGgoKSAvIG4pO1xuICAgIHRoaXMuaG9yaXpvbnRhbFJhbmdlID0gZDMucmFuZ2UoMCwgdGhpcy5jaGFydEhlaWdodCgpICsgdGhpcy5jaGFydEhlaWdodCgpIC8gMiwgdGhpcy5jaGFydEhlaWdodCgpIC8gMik7XG4gIH0sXG5cbiAgX2NhbGNCYXJXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYXJXaWR0aCA9IHRoaXMuY2hhcnRXaWR0aCgpIC8gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKS5sZW5ndGg7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJnaW4gPSB0aGlzLm1vZGVsLmdldCgnbWFyZ2luJyk7XG5cbiAgICB0aGlzLmNoYXJ0ID0gZDMuc2VsZWN0KHRoaXMuZWwpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1XaWRnZXRDYW52YXMnKVxuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsICcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgIHRoaXMuY2hhcnQuY2xhc3NlZCh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnLCB0cnVlKTtcbiAgfSxcblxuICBfb25DaGFuZ2VTaG93U2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdzaG93X3NoYWRvd19iYXJzJykpIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlU2hhZG93QmFycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3dCYXJzKCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNoYW5nZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnZGlzcGxheScpKSB7XG4gICAgICB0aGlzLl9zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ2Rpc3BsYXknLCBmYWxzZSk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ2Rpc3BsYXknLCB0cnVlKTtcbiAgfSxcblxuICBfaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaGlkZSgpO1xuICB9LFxuXG4gIF9zaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5zaG93KCk7XG4gIH0sXG5cbiAgaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5tb2RlbC5nZXQoJ2Rpc3BsYXknKTtcbiAgfSxcblxuICBfc2VsZWN0QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmJydXNoLmV4dGVudCgpO1xuICAgIHZhciBsbyA9IGV4dGVudFswXTtcbiAgICB2YXIgaGkgPSBleHRlbnRbMV07XG5cblxuICAgIHRoaXMubW9kZWwuc2V0KHsgbG9faW5kZXg6IHRoaXMuX2dldExvQmFySW5kZXgoKSwgaGlfaW5kZXg6IHRoaXMuX2dldEhpQmFySW5kZXgoKSB9KTtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpLmNsYXNzZWQoJ2lzLXNlbGVjdGVkJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgdmFyIGEgPSBNYXRoLmZsb29yKGkgKiBzZWxmLmJhcldpZHRoKTtcbiAgICAgIHZhciBiID0gTWF0aC5mbG9vcihhICsgc2VsZi5iYXJXaWR0aCk7XG4gICAgICB2YXIgTE8gPSBNYXRoLmZsb29yKHNlbGYueFNjYWxlKGxvKSk7XG4gICAgICB2YXIgSEkgPSBNYXRoLmZsb29yKHNlbGYueFNjYWxlKGhpKSk7XG4gICAgICB2YXIgaXNJbiA9IChhID4gTE8gJiYgYSA8IEhJKSB8fCAoYiA+IExPICYmIGIgPCBISSkgfHwgKGEgPD0gTE8gJiYgYiA+PSBISSk7XG4gICAgICByZXR1cm4gIWlzSW47XG4gICAgfSk7XG4gIH0sXG5cbiAgX2lzRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmdldCgnZHJhZ2dpbmcnKTtcbiAgfSxcblxuICBfbW92ZTogZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5tb2RlbC5zZXQoeyBwb3M6IHBvcyB9KTtcbiAgfSxcblxuICBleHBhbmQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHRoaXMuY2FudmFzLmF0dHIoJ2hlaWdodCcsIHRoaXMubW9kZWwuZ2V0KCdoZWlnaHQnKSArIGhlaWdodCk7XG4gICAgdGhpcy5fbW92ZSh7IHg6IDAsIHk6IGhlaWdodCB9KTtcbiAgfSxcblxuICBjb250cmFjdDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgdGhpcy5jYW52YXMuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB0aGlzLl9tb3ZlKHsgeDogMCwgeTogMCB9KTtcbiAgfSxcblxuICByZXNpemVIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdoZWlnaHQnLCBoZWlnaHQpO1xuICB9LFxuXG4gIHJlbW92ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldEluZGV4ZXMoKTtcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKS5jbGFzc2VkKCdpcy1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCgpO1xuICAgIHRoaXMuX3NldHVwQnJ1c2goKTtcbiAgfSxcblxuICBzZWxlY3RSYW5nZTogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIGlmICghbG9CYXJJbmRleCAmJiAhaGlCYXJJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsb1Bvc2l0aW9uID0gdGhpcy5fZ2V0QmFyUG9zaXRpb24obG9CYXJJbmRleCk7XG4gICAgdmFyIGhpUG9zaXRpb24gPSB0aGlzLl9nZXRCYXJQb3NpdGlvbihoaUJhckluZGV4KTtcblxuICAgIHRoaXMuX3NlbGVjdFJhbmdlKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pO1xuICB9LFxuXG4gIF9zZWxlY3RSYW5nZTogZnVuY3Rpb24obG9Qb3NpdGlvbiwgaGlQb3NpdGlvbikge1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQnJ1c2gnKS50cmFuc2l0aW9uKClcbiAgICAuZHVyYXRpb24odGhpcy5icnVzaC5lbXB0eSgpID8gMCA6IDE1MClcbiAgICAuY2FsbCh0aGlzLmJydXNoLmV4dGVudChbbG9Qb3NpdGlvbiwgaGlQb3NpdGlvbl0pKVxuICAgIC5jYWxsKHRoaXMuYnJ1c2guZXZlbnQpO1xuICB9LFxuXG4gIF9nZXRMb0JhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLnhTY2FsZShleHRlbnRbMF0pIC8gdGhpcy5iYXJXaWR0aCk7XG4gIH0sXG5cbiAgX2dldEhpQmFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmJydXNoLmV4dGVudCgpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMueFNjYWxlKGV4dGVudFsxXSkgLyB0aGlzLmJhcldpZHRoKTtcbiAgfSxcblxuICBfZ2V0QmFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gZDMuZXZlbnQuc291cmNlRXZlbnQub2Zmc2V0WDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gdGhpcy5iYXJXaWR0aCk7XG4gIH0sXG5cbiAgX2dldEJhclBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICByZXR1cm4gaW5kZXggKiAoMTAwIC8gZGF0YS5sZW5ndGgpO1xuICB9LFxuXG4gIF9zZXR1cEJydXNoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgeFNjYWxlID0gdGhpcy54U2NhbGU7XG4gICAgdmFyIGJydXNoID0gdGhpcy5icnVzaCA9IGQzLnN2Zy5icnVzaCgpLngodGhpcy54U2NhbGUpO1xuXG4gICAgZnVuY3Rpb24gb25CcnVzaEVuZCgpIHtcbiAgICAgIHZhciBkYXRhID0gc2VsZi5tb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICAgIHZhciBsb1Bvc2l0aW9uLCBoaVBvc2l0aW9uO1xuXG4gICAgICBzZWxmLm1vZGVsLnNldCh7IGRyYWdnaW5nOiBmYWxzZSB9KTtcblxuICAgICAgaWYgKGJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgc2VsZi5jaGFydC5zZWxlY3RBbGwoJy5DREItQ2hhcnQtYmFyJykuY2xhc3NlZCgnaXMtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoLmV4dGVudChbMCwgMF0pKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIGxvQmFySW5kZXggPSBzZWxmLl9nZXRMb0JhckluZGV4KCk7XG4gICAgICAgIHZhciBoaUJhckluZGV4ID0gc2VsZi5fZ2V0SGlCYXJJbmRleCgpO1xuXG4gICAgICAgIGxvUG9zaXRpb24gPSBzZWxmLl9nZXRCYXJQb3NpdGlvbihsb0JhckluZGV4KTtcbiAgICAgICAgaGlQb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGhpQmFySW5kZXgpO1xuXG4gICAgICAgIGlmICghZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9CYXJJbmRleCA9PT0gaGlCYXJJbmRleCkge1xuICAgICAgICAgIGlmIChoaUJhckluZGV4ID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb1Bvc2l0aW9uID0gc2VsZi5fZ2V0QmFyUG9zaXRpb24obG9CYXJJbmRleCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaVBvc2l0aW9uID0gc2VsZi5fZ2V0QmFyUG9zaXRpb24oaGlCYXJJbmRleCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3NlbGVjdFJhbmdlKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pO1xuICAgICAgICBzZWxmLm1vZGVsLnNldCh7IGxvX2luZGV4OiBsb0JhckluZGV4LCBoaV9pbmRleDogaGlCYXJJbmRleCB9KTtcbiAgICAgICAgc2VsZi5fYWRqdXN0QnJ1c2hIYW5kbGVzKCk7XG4gICAgICAgIHNlbGYuX3NlbGVjdEJhcnMoKTtcblxuICAgICAgICBzZWxmLnRyaWdnZXIoJ29uX2JydXNoX2VuZCcsIHNlbGYubW9kZWwuZ2V0KCdsb19pbmRleCcpLCBzZWxmLm1vZGVsLmdldCgnaGlfaW5kZXgnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAmJiBsb1Bvc2l0aW9uID09PSB1bmRlZmluZWQgJiYgaGlQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBiYXJJbmRleCA9IHNlbGYuX2dldEJhckluZGV4KCk7XG5cbiAgICAgICAgbG9Qb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGJhckluZGV4KTtcbiAgICAgICAgaGlQb3NpdGlvbiA9IHNlbGYuX2dldEJhclBvc2l0aW9uKGJhckluZGV4ICsgMSk7XG5cbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoeyBsb19pbmRleDogYmFySW5kZXgsIGhpX2luZGV4OiBiYXJJbmRleCArIDEgfSk7XG4gICAgICAgIHNlbGYuX3NlbGVjdFJhbmdlKGxvUG9zaXRpb24sIGhpUG9zaXRpb24pO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ29uX2JydXNoX2VuZCcsIHNlbGYubW9kZWwuZ2V0KCdsb19pbmRleCcpLCBzZWxmLm1vZGVsLmdldCgnaGlfaW5kZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpO1xuXG4gICAgdGhpcy5icnVzaFxuICAgIC5vbignYnJ1c2hzdGFydCcsIHRoaXMuX29uQnJ1c2hTdGFydClcbiAgICAub24oJ2JydXNoJywgdGhpcy5fb25CcnVzaE1vdmUpXG4gICAgLm9uKCdicnVzaGVuZCcsIG9uQnJ1c2hFbmQpO1xuXG4gICAgdGhpcy5jaGFydC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdCcnVzaCcpXG4gICAgLmNhbGwodGhpcy5icnVzaClcbiAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAuYXR0cigneScsIDApXG4gICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuY2hhcnRIZWlnaHQoKSlcbiAgICAub24oJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dClcbiAgICAub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgfSxcblxuICBfYWRqdXN0QnJ1c2hIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5icnVzaC5leHRlbnQoKTtcblxuICAgIHZhciBsb0V4dGVudCA9IGV4dGVudFswXTtcbiAgICB2YXIgaGlFeHRlbnQgPSBleHRlbnRbMV07XG5cbiAgICB2YXIgbGVmdFggID0gdGhpcy54U2NhbGUobG9FeHRlbnQpIC0gdGhpcy5vcHRpb25zLmhhbmRsZVdpZHRoIC8gMjtcbiAgICB2YXIgcmlnaHRYID0gdGhpcy54U2NhbGUoaGlFeHRlbnQpIC0gdGhpcy5vcHRpb25zLmhhbmRsZVdpZHRoIC8gMjtcblxuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZS1sZWZ0JylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbGVmdFggKyAnLCAwKScpO1xuXG4gICAgdGhpcy5jaGFydC5zZWxlY3QoJy5DREItQ2hhcnQtaGFuZGxlLXJpZ2h0JylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgcmlnaHRYICsgJywgMCknKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFzQXhpc1RpcCkge1xuICAgICAgdGhpcy5tb2RlbC5zZXQoe1xuICAgICAgICBsZWZ0X2F4aXNfdGlwOiB0aGlzLnhBeGlzU2NhbGUobGVmdFggKyAzKSxcbiAgICAgICAgcmlnaHRfYXhpc190aXA6IHRoaXMueEF4aXNTY2FsZShyaWdodFggKyAzKVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9nZW5lcmF0ZUF4aXNUaXA6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZS5DREItQ2hhcnQtaGFuZGxlLScgKyBjbGFzc05hbWUpO1xuXG4gICAgdmFyIGF4aXNUaXAgPSBoYW5kbGUuc2VsZWN0QWxsKFwiZ1wiKVxuICAgIC5kYXRhKFsnJ10pXG4gICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYXhpc1RpcCBDREItQ2hhcnQtYXhpc1RpcC0nICsgY2xhc3NOYW1lKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKDAsNTIpXCI7IH0pO1xuXG4gICAgdGhpcy5yZWN0TGFiZWwgPSBheGlzVGlwLmFwcGVuZChcInJlY3RcIilcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWF4aXNUaXBSZWN0IENEQi1DaGFydC1heGlzVGlwLScgKyBjbGFzc05hbWUpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgMTIpXG4gICAgLmF0dHIoXCJ3aWR0aFwiLCAxMCk7XG5cbiAgICB0aGlzLnRleHRMYWJlbCA9IGF4aXNUaXAuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYXhpc1RpcFRleHQgQ0RCLUNoYXJ0LWF4aXNUaXAtJyArIGNsYXNzTmFtZSlcbiAgICAuYXR0cihcImR5XCIsIFwiMTFcIilcbiAgICAuYXR0cihcImR4XCIsIFwiMFwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0pO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUhhbmRsZTogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIG9wdHMgPSB7IHdpZHRoOiB0aGlzLm9wdGlvbnMuaGFuZGxlV2lkdGgsIGhlaWdodDogdGhpcy5vcHRpb25zLmhhbmRsZUhlaWdodCwgcmFkaXVzOiB0aGlzLm9wdGlvbnMuaGFuZGxlUmFkaXVzIH07XG4gICAgdmFyIHlQb3MgPSAodGhpcy5jaGFydEhlaWdodCgpIC8gMikgLSAodGhpcy5vcHRpb25zLmhhbmRsZUhlaWdodCAvIDIpO1xuXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZXMnKVxuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlIENEQi1DaGFydC1oYW5kbGUtJyArIGNsYXNzTmFtZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhc0F4aXNUaXApIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlQXhpc1RpcChjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGhhbmRsZVxuICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtaGFuZGxlTGluZScpXG4gICAgLmF0dHIoJ3gxJywgMylcbiAgICAuYXR0cigneTEnLCAtNClcbiAgICAuYXR0cigneDInLCAzKVxuICAgIC5hdHRyKCd5MicsIHRoaXMuY2hhcnRIZWlnaHQoKSArIDQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYXNIYW5kbGVzKSB7XG4gICAgICBoYW5kbGVcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVSZWN0JylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsICcgKyB5UG9zICsgJyknKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgb3B0cy53aWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBvcHRzLmhlaWdodClcbiAgICAgIC5hdHRyKCdyeCcsIG9wdHMucmFkaXVzKVxuICAgICAgLmF0dHIoJ3J5Jywgb3B0cy5yYWRpdXMpO1xuXG4gICAgICB2YXIgeSA9IDIxOyAvLyBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBncmlwXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGhhbmRsZVxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVHcmlwJylcbiAgICAgICAgLmF0dHIoJ3gxJywgMilcbiAgICAgICAgLmF0dHIoJ3kxJywgeSArIGkqMylcbiAgICAgICAgLmF0dHIoJ3gyJywgNClcbiAgICAgICAgLmF0dHIoJ3kyJywgeSArIGkqMyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1oYW5kbGVzJyk7XG4gICAgdGhpcy5sZWZ0SGFuZGxlICA9IHRoaXMuX2dlbmVyYXRlSGFuZGxlKCdsZWZ0Jyk7XG4gICAgdGhpcy5yaWdodEhhbmRsZSA9IHRoaXMuX2dlbmVyYXRlSGFuZGxlKCdyaWdodCcpO1xuICB9LFxuXG4gIF9nZW5lcmF0ZUhhbmRsZUxpbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNlbGVjdCgnLkNEQi1DaGFydC1oYW5kbGVzJykuYXBwZW5kKCdsaW5lJylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWhhbmRsZUxpbmUnKVxuICAgIC5hdHRyKCd4MScsIDApXG4gICAgLmF0dHIoJ3kxJywgMClcbiAgICAuYXR0cigneDInLCAwKVxuICAgIC5hdHRyKCd5MicsIHRoaXMuY2hhcnRIZWlnaHQoKSk7XG4gIH0sXG5cbiAgX3JlbW92ZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0KCcuQ0RCLUNoYXJ0LWhhbmRsZXMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfcmVtb3ZlQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW52YXMuc2VsZWN0KCcuQ0RCLUNoYXJ0LWF4aXMnKS5yZW1vdmUoKTtcbiAgfSxcblxuICBfZ2VuZXJhdGVBZGp1c3RBbmNob3JNZXRob2Q6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09ICh0aWNrcy5sZW5ndGggLSAxKSkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ21pZGRsZSc7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBfZ2VuZXJhdGVBeGlzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9heGlzID0gdGhpcy5vcHRpb25zLnR5cGUgPT09ICd0aW1lJ1xuICAgICAgPyB0aGlzLl9nZW5lcmF0ZVRpbWVBeGlzKClcbiAgICAgIDogdGhpcy5fZ2VuZXJhdGVOdW1lcmljQXhpcygpO1xuXG4gICAgdGhpcy5fb25DaGFuZ1Nob3dMYWJlbHMoKTtcbiAgfSxcblxuICBfZ2VuZXJhdGVOdW1lcmljQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhZGp1c3RUZXh0QW5jaG9yID0gdGhpcy5fZ2VuZXJhdGVBZGp1c3RBbmNob3JNZXRob2QodGhpcy52ZXJ0aWNhbFJhbmdlKTtcblxuICAgIHZhciBheGlzID0gdGhpcy5jaGFydC5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYXhpcycpO1xuXG4gICAgYXhpc1xuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5zZWxlY3RBbGwoJy5MYWJlbCcpXG4gICAgLmRhdGEodGhpcy52ZXJ0aWNhbFJhbmdlKVxuICAgIC5lbnRlcigpLmFwcGVuZChcInRleHRcIilcbiAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpICsgMTU7IH0pXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBhZGp1c3RUZXh0QW5jaG9yKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyKHNlbGYueEF4aXNTY2FsZShkKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXhpcztcbiAgfSxcblxuICBfZ2VuZXJhdGVUaW1lQXhpczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFkanVzdFRleHRBbmNob3IgPSB0aGlzLl9nZW5lcmF0ZUFkanVzdEFuY2hvck1ldGhvZCh0aGlzLnhBeGlzU2NhbGUudGlja3MoKSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgLm9yaWVudChcImJvdHRvbVwiKVxuICAgIC50aWNrUGFkZGluZyg1KVxuICAgIC5pbm5lclRpY2tTaXplKC10aGlzLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLnNjYWxlKHRoaXMueEF4aXNTY2FsZSlcbiAgICAub3JpZW50KCdib3R0b20nKTtcblxuICAgIHZhciBheGlzID0gdGhpcy5jYW52YXMuYXBwZW5kKCdnJylcbiAgICAuYXR0cihcImNsYXNzXCIsICdDREItQ2hhcnQtYXhpcycpXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArICh0aGlzLmNoYXJ0SGVpZ2h0KCkgKyA1KSArIFwiKVwiKVxuICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIGF4aXMuc2VsZWN0QWxsKCd0ZXh0Jykuc3R5bGUoJ3RleHQtYW5jaG9yJywgYWRqdXN0VGV4dEFuY2hvcik7XG4gICAgYXhpcy5tb3ZlVG9CYWNrKCk7XG5cbiAgICByZXR1cm4gYXhpcztcbiAgfSxcblxuICBfdXBkYXRlQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICB2YXIgYmFycyA9IHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWJhcicpXG4gICAgLmRhdGEoZGF0YSk7XG5cbiAgICBiYXJzXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAuYXR0cignY2xhc3MnLCAnQ0RCLUNoYXJ0LWJhcicpXG4gICAgLmF0dHIoJ2RhdGEnLCBmdW5jdGlvbihkKSB7IHJldHVybiBfLmlzRW1wdHkoZCkgPyAwIDogIGQuZnJlcTsgfSlcbiAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChpICogc2VsZi5iYXJXaWR0aCkgKyAnLCAwICknO1xuICAgIH0pXG4gICAgLmF0dHIoJ3knLCBzZWxmLmNoYXJ0SGVpZ2h0KCkpXG4gICAgLmF0dHIoJ2hlaWdodCcsIDApXG4gICAgLmF0dHIoJ3dpZHRoJywgTWF0aC5tYXgoMCwgdGhpcy5iYXJXaWR0aCAtIDEpKTtcblxuICAgIGJhcnNcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKDIwMClcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuXG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYueVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgaCA9IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfSlcbiAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoZCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLnlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCkgLSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLnlTY2FsZShkLmZyZXEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYmFyc1xuICAgIC5leGl0KClcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKDIwMClcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSlcbiAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlQmFyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKTtcblxuICAgIHRoaXMuX2NhbGNCYXJXaWR0aCgpO1xuXG4gICAgdmFyIGJhcnMgPSB0aGlzLmNoYXJ0LmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtYmFycycpXG4gICAgLnNlbGVjdEFsbCgnLkNEQi1DaGFydC1iYXInKVxuICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgYmFyc1xuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1iYXInKVxuICAgIC5hdHRyKCdkYXRhJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gXy5pc0VtcHR5KGQpID8gMCA6ICBkLmZyZXE7IH0pXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoaSAqIHNlbGYuYmFyV2lkdGgpICsgJywgMCApJztcbiAgICB9KVxuICAgIC5hdHRyKCd5Jywgc2VsZi5jaGFydEhlaWdodCgpKVxuICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgIC5hdHRyKCd3aWR0aCcsIE1hdGgubWF4KDAsIHRoaXMuYmFyV2lkdGggLSAxKSk7XG5cbiAgICBiYXJzXG4gICAgLnRyYW5zaXRpb24oKVxuICAgIC5lYXNlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVHlwZSlcbiAgICAuZHVyYXRpb24odGhpcy5vcHRpb25zLmFuaW1hdGlvblNwZWVkKVxuICAgIC5kZWxheSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uQmFyRGVsYXkpXG4gICAgLnRyYW5zaXRpb24oKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkKSB7XG5cbiAgICAgIGlmIChfLmlzRW1wdHkoZCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gc2VsZi5jaGFydEhlaWdodCgpIC0gc2VsZi55U2NhbGUoZC5mcmVxKTtcblxuICAgICAgaWYgKGggPCBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodCAmJiBoID4gMCkge1xuICAgICAgICBoID0gc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICB9KVxuICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShkKSkge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFydEhlaWdodCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYueVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYueVNjYWxlKGQuZnJlcSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgc2hvd1NoYWRvd0JhcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuc2V0KCdzaG93X3NoYWRvd19iYXJzJywgdHJ1ZSk7XG4gIH0sXG5cbiAgX2dlbmVyYXRlU2hhZG93QmFyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm9wdGlvbnMuc2hhZG93RGF0YTtcblxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIXRoaXMubW9kZWwuZ2V0KCdzaG93X3NoYWRvd19iYXJzJykpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvd0JhcnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVTaGFkb3dCYXJzKCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXy5pc0VtcHR5KGQpID8gMCA6IGQuZnJlcTsgfSApXSkucmFuZ2UoW3RoaXMuY2hhcnRIZWlnaHQoKSwgMF0pO1xuICAgIHZhciBiYXJXaWR0aCA9IHRoaXMuY2hhcnRXaWR0aCgpIC8gZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgYmFycyA9IHRoaXMuY2hhcnQuYXBwZW5kKCdnJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1DaGFydC1zaGFkb3dCYXJzJylcbiAgICAuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LXNoYWRvd0JhcicpXG4gICAgLmRhdGEoZGF0YSlcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgIC5hdHRyKCdjbGFzcycsICdDREItQ2hhcnQtc2hhZG93QmFyJylcbiAgICAuYXR0cignZGF0YScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIF8uaXNFbXB0eShkKSA/IDAgOiAgZC5mcmVxOyB9KVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKGkgKiBiYXJXaWR0aCkgKyAnLCAwICknO1xuICAgIH0pXG4gICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJ0SGVpZ2h0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoID0gc2VsZi5jaGFydEhlaWdodCgpIC0geVNjYWxlKGQuZnJlcSk7XG5cbiAgICAgIGlmIChoIDwgc2VsZi5vcHRpb25zLm1pbmltdW1CYXJIZWlnaHQgJiYgaCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhcnRIZWlnaHQoKSAtIHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShkLmZyZXEpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmF0dHIoJ3dpZHRoJywgTWF0aC5tYXgoMCwgYmFyV2lkdGggLSAxKSlcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkge1xuXG4gICAgICBpZiAoXy5pc0VtcHR5KGQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaCA9IHNlbGYuY2hhcnRIZWlnaHQoKSAtIHlTY2FsZShkLmZyZXEpO1xuXG4gICAgICBpZiAoaCA8IHNlbGYub3B0aW9ucy5taW5pbXVtQmFySGVpZ2h0ICYmIGggPiAwKSB7XG4gICAgICAgIGggPSBzZWxmLm9wdGlvbnMubWluaW11bUJhckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBleHBsaWNpdGx5IG1vdmUgdGhlIGxpbmVzIG9mIHRoZSBncmlkIGJlaGluZCB0aGUgc2hhZG93IGJhcnNcbiAgICB0aGlzLmNoYXJ0LnNlbGVjdEFsbCgnLkNEQi1DaGFydC1zaGFkb3dCYXJzJykubW92ZVRvQmFjaygpO1xuICAgIHRoaXMuY2hhcnQuc2VsZWN0QWxsKCcuQ0RCLUNoYXJ0LWxpbmVzJykubW92ZVRvQmFjaygpO1xuICB9XG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgZm9ybWF0dGVyID0gY2RiLmNvcmUuZm9ybWF0O1xudmFyIEhpc3RvZ3JhbVRpdGxlVmlldyA9IHJlcXVpcmUoJy4vaGlzdG9ncmFtX3RpdGxlX3ZpZXcnKTtcbnZhciBXaWRnZXRDb250ZW50ID0gcmVxdWlyZSgnLi4vc3RhbmRhcmQvd2lkZ2V0X2NvbnRlbnRfdmlldycpO1xudmFyIFdpZGdldFZpZXdNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9jb250ZW50X21vZGVsJyk7XG52YXIgSGlzdG9ncmFtQ2hhcnRWaWV3ID0gcmVxdWlyZSgnLi9jaGFydCcpO1xudmFyIHBsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlci50cGwnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY29udGVudC50cGwnKTtcbnZhciBBbmltYXRlVmFsdWVzID0gcmVxdWlyZSgnLi4vYW5pbWF0ZV92YWx1ZXMuanMnKTtcbnZhciBhbmltYXRpb25UZW1wbGF0ZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIFdpZGdldCBjb250ZW50IHZpZXcgZm9yIGEgaGlzdG9ncmFtXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0Q29udGVudC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgY2hhcnRIZWlnaHQ6IDQ4ICsgMjAgKyA0XG4gIH0sXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1jbGVhcic6ICdfY2xlYXInLFxuICAgICdjbGljayAuanMtem9vbSc6ICdfem9vbSdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBXaWRnZXRWaWV3TW9kZWwoKTtcbiAgICB0aGlzLmxvY2tlZEJ5VXNlciA9IGZhbHNlO1xuICAgIFdpZGdldENvbnRlbnQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGl0bGVWaWV3ID0gbmV3IEhpc3RvZ3JhbVRpdGxlVmlldyh7XG4gICAgICB2aWV3TW9kZWw6IHRoaXMudmlld01vZGVsLFxuICAgICAgZGF0YU1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtdGl0bGUnKS5odG1sKHRpdGxlVmlldy5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHRpdGxlVmlldyk7XG5cbiAgICB0aGlzLl9yZW5kZXJNaW5pQ2hhcnQoKTtcbiAgICB0aGlzLl9yZW5kZXJNYWluQ2hhcnQoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25GaXJzdExvYWQsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIGZ1bmN0aW9uKG1kbCwgaXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuJGVsLnRvZ2dsZUNsYXNzKCdpcy1jb2xsYXBzZWQnLCAhIWlzQ29sbGFwc2VkKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfb25GaXJzdExvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgdGhpcy5fc3RvcmVCb3VuZHMoKTtcblxuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VNb2RlbCwgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC5fZmV0Y2goKTtcbiAgfSxcblxuICBfc3RvcmVCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gZGF0YVswXS5zdGFydDtcbiAgICAgIHRoaXMuZW5kID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgIHRoaXMuYmluc0NvdW50ID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLm1vZGVsLnNldCh7IHN0YXJ0OiB0aGlzLnN0YXJ0LCBlbmQ6IHRoaXMuZW5kLCBiaW5zOiB0aGlzLmJpbnNDb3VudCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgX2lzWm9vbWVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3TW9kZWwuZ2V0KCd6b29tZWQnKTtcbiAgfSxcblxuICBfb25DaGFuZ2VNb2RlbDogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBXaGVuIHRoZSBoaXN0b2dyYW0gaXMgem9vbWVkLCB3ZSBkb24ndCBuZWVkIHRvIHJlbHlcbiAgICAvLyBvbiB0aGUgY2hhbmdlIHVybCB0byB1cGRhdGUgdGhlIGhpc3RvZ3JhbVxuICAgIGlmICh0aGlzLm1vZGVsLmNoYW5nZWQudXJsICYmIHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgYWN0aW9uIHdhcyBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgICAvLyBkb24ndCByZXBsYWNlIHRoZSBzdG9yZWQgZGF0YVxuICAgIGlmICh0aGlzLmxvY2tlZEJ5VXNlcikge1xuICAgICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgICAgdGhpcy56b29tZWREYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5zaG93U2hhZG93QmFycygpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZXBsYWNlRGF0YSh0aGlzLm1vZGVsLmdldERhdGEoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudW5zZXR0aW5nUmFuZ2UpIHtcbiAgICAgIHRoaXMuX3Vuc2V0UmFuZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkgJiYgIXRoaXMubG9ja1pvb21lZERhdGEpIHtcbiAgICAgICAgdGhpcy5sb2NrWm9vbWVkRGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMuem9vbWVkRGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0YXRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyU3ViVmlld3MoKTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcblxuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLm1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgaXRlbXNDb3VudDogIWlzRGF0YUVtcHR5ID8gZGF0YS5sZW5ndGggOiAnLSdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmIChpc0RhdGFFbXB0eSkge1xuICAgICAgdGhpcy5fYWRkUGxhY2Vob2xkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcmlnaW5hbERhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICAgIHRoaXMuX3NldHVwQmluZGluZ3MoKTtcbiAgICAgIHRoaXMuX2luaXRWaWV3cygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF91bnNldFJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVuc2V0dGluZ1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVwbGFjZURhdGEodGhpcy5vcmlnaW5hbERhdGEpO1xuICAgIHRoaXMudmlld01vZGVsLnNldCh7IGxvX2luZGV4OiBudWxsLCBoaV9pbmRleDogbnVsbCB9KTtcblxuICAgIGlmICghdGhpcy5faXNab29tZWQoKSkge1xuICAgICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuc2hvd1NoYWRvd0JhcnMoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2FkZFBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHBsYWNlaG9sZGVyKCkpO1xuICB9LFxuXG4gIF9yZW5kZXJNYWluQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3ID0gbmV3IEhpc3RvZ3JhbUNoYXJ0Vmlldygoe1xuICAgICAgbWFyZ2luOiB7IHRvcDogNCwgcmlnaHQ6IDQsIGJvdHRvbTogNCwgbGVmdDogNCB9LFxuICAgICAgaGFzU2hhZG93QmFyZHM6IHRydWUsXG4gICAgICBoYXNIYW5kbGVzOiB0cnVlLFxuICAgICAgaGFzQXhpc1RpcDogdHJ1ZSxcbiAgICAgIHdpZHRoOiB0aGlzLmNhbnZhc1dpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRlZmF1bHRzLmNoYXJ0SGVpZ2h0LFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKCksXG4gICAgICBzaGFkb3dEYXRhOiB0aGlzLm1vZGVsLmdldERhdGEoKVxuICAgIH0pKTtcblxuICAgIHRoaXMuJCgnLmpzLWNvbnRlbnQnKS5hcHBlbmQodGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldyk7XG5cbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5iaW5kKCdyYW5nZV91cGRhdGVkJywgdGhpcy5fb25SYW5nZVVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LmJpbmQoJ29uX2JydXNoX2VuZCcsIHRoaXMuX29uQnJ1c2hFbmQsIHRoaXMpO1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LmJpbmQoJ2hvdmVyJywgdGhpcy5fb25WYWx1ZUhvdmVyLCB0aGlzKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW5kZXIoKS5zaG93KCk7XG5cbiAgICB0aGlzLl91cGRhdGVTdGF0cygpO1xuICB9LFxuXG4gIF9yZW5kZXJNaW5pQ2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0VmlldyA9IG5ldyBIaXN0b2dyYW1DaGFydFZpZXcoKHtcbiAgICAgIGNsYXNzTmFtZTogJ0NEQi1DaGFydC0tbWluaScsXG4gICAgICBtYXJnaW46IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiA0LCBsZWZ0OiA0IH0sXG4gICAgICBoZWlnaHQ6IDQwLFxuICAgICAgc2hvd09uV2lkdGhDaGFuZ2U6IGZhbHNlLFxuICAgICAgZGF0YTogdGhpcy5tb2RlbC5nZXREYXRhKClcbiAgICB9KSk7XG5cbiAgICB0aGlzLmFkZFZpZXcodGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3KTtcbiAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHRoaXMubWluaUhpc3RvZ3JhbUNoYXJ0Vmlldy5lbCk7XG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LmJpbmQoJ29uX2JydXNoX2VuZCcsIHRoaXMuX29uTWluaVJhbmdlVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIF9zZXR1cEJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6em9vbWVkJywgdGhpcy5fb25DaGFuZ2Vab29tZWQsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTp6b29tX2VuYWJsZWQnLCB0aGlzLl9vbkNoYW5nZVpvb21FbmFibGVkLCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6ZmlsdGVyX2VuYWJsZWQnLCB0aGlzLl9vbkNoYW5nZUZpbHRlckVuYWJsZWQsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTp0b3RhbCcsIHRoaXMuX29uQ2hhbmdlVG90YWwsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTpudWxscycsIHRoaXMuX29uQ2hhbmdlTnVsbHMsIHRoaXMpO1xuICAgIHRoaXMudmlld01vZGVsLmJpbmQoJ2NoYW5nZTptYXgnLCAgIHRoaXMuX29uQ2hhbmdlTWF4LCB0aGlzKTtcbiAgICB0aGlzLnZpZXdNb2RlbC5iaW5kKCdjaGFuZ2U6bWluJywgICB0aGlzLl9vbkNoYW5nZU1pbiwgdGhpcyk7XG4gICAgdGhpcy52aWV3TW9kZWwuYmluZCgnY2hhbmdlOmF2ZycsICAgdGhpcy5fb25DaGFuZ2VBdmcsIHRoaXMpO1xuICB9LFxuXG4gIF9jbGVhclRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJChcIi5qcy10b29sdGlwXCIpLnN0b3AoKS5oaWRlKCk7XG4gIH0sXG5cbiAgX29uVmFsdWVIb3ZlcjogZnVuY3Rpb24oaW5mbykge1xuICAgIHZhciAkdG9vbHRpcCA9IHRoaXMuJChcIi5qcy10b29sdGlwXCIpO1xuXG4gICAgaWYgKGluZm8gJiYgaW5mby5kYXRhKSB7XG4gICAgICB2YXIgYm90dG9tID0gdGhpcy5kZWZhdWx0cy5jaGFydEhlaWdodCArIDMgLSBpbmZvLnRvcDtcblxuICAgICAgJHRvb2x0aXAuY3NzKHsgYm90dG9tOiBib3R0b20sIGxlZnQ6IGluZm8ubGVmdCB9KTtcbiAgICAgICR0b29sdGlwLnRleHQoaW5mby5kYXRhKTtcbiAgICAgICR0b29sdGlwLmNzcyh7IGxlZnQ6IGluZm8ubGVmdCAtICR0b29sdGlwLndpZHRoKCkvMiB9KTtcbiAgICAgICR0b29sdGlwLmZhZGVJbig3MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NsZWFyVG9vbHRpcCgpO1xuICAgIH1cbiAgfSxcblxuICBfb25NaW5pUmFuZ2VVcGRhdGVkOiBmdW5jdGlvbihsb0JhckluZGV4LCBoaUJhckluZGV4KSB7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgICB0aGlzLmxvY2tab29tZWREYXRhID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jbGVhclRvb2x0aXAoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW1vdmVTZWxlY3Rpb24oKTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5vcmlnaW5hbERhdGE7XG5cbiAgICBpZiAobG9CYXJJbmRleCA+PSAwICYmIGxvQmFySW5kZXggPCBkYXRhLmxlbmd0aCAmJiAoaGlCYXJJbmRleCAtIDEpID49IDAgJiYgKGhpQmFySW5kZXggLSAxKSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZpbHRlci5zZXRSYW5nZShcbiAgICAgICAgZGF0YVtsb0JhckluZGV4XS5zdGFydCxcbiAgICAgICAgZGF0YVtoaUJhckluZGV4IC0gMV0uZW5kXG4gICAgICApO1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIGFycmF5IGJvdW5kcycsIGxvQmFySW5kZXgsIGhpQmFySW5kZXgsIGRhdGEpO1xuICAgIH1cbiAgfSxcblxuICBfb25CcnVzaEVuZDogZnVuY3Rpb24obG9CYXJJbmRleCwgaGlCYXJJbmRleCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fZ2V0RGF0YSgpO1xuICAgIFxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNab29tZWQoKSkge1xuICAgICAgdGhpcy5sb2NrZWRCeVVzZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0aWVzID0geyBmaWx0ZXJfZW5hYmxlZDogdHJ1ZSwgbG9faW5kZXg6IGxvQmFySW5kZXgsIGhpX2luZGV4OiBoaUJhckluZGV4IH07XG5cbiAgICBpZiAoIXRoaXMudmlld01vZGVsLmdldCgnem9vbWVkJykpIHtcbiAgICAgIHByb3BlcnRpZXMuem9vbV9lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQocHJvcGVydGllcyk7XG5cbiAgICBpZiAobG9CYXJJbmRleCA+PSAwICYmIGxvQmFySW5kZXggPCBkYXRhLmxlbmd0aCAmJiAoaGlCYXJJbmRleCAtIDEpID49IDAgJiYgKGhpQmFySW5kZXggLSAxKSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLmZpbHRlci5zZXRSYW5nZShcbiAgICAgICAgZGF0YVtsb0JhckluZGV4XS5zdGFydCxcbiAgICAgICAgZGF0YVtoaUJhckluZGV4IC0gMV0uZW5kXG4gICAgICApO1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIGFycmF5IGJvdW5kcycsIGxvQmFySW5kZXgsIGhpQmFySW5kZXgsIGRhdGEpO1xuICAgIH1cbiAgfSxcblxuICBfb25SYW5nZVVwZGF0ZWQ6IGZ1bmN0aW9uKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZ2V0KCd6b29tZWQnKSkge1xuICAgICAgdGhpcy52aWV3TW9kZWwuc2V0KHsgem9vbV9lbmFibGVkOiBmYWxzZSwgbG9faW5kZXg6IGxvQmFySW5kZXgsIGhpX2luZGV4OiBoaUJhckluZGV4IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZXdNb2RlbC5zZXQoeyBsb19pbmRleDogbG9CYXJJbmRleCwgaGlfaW5kZXg6IGhpQmFySW5kZXggfSk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZVN0YXRzID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHsgc2VsZi5fdXBkYXRlU3RhdHMoKTsgfSwgNDAwKTtcbiAgICB1cGRhdGVTdGF0cygpO1xuICB9LFxuXG4gIF9nZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgaWYgKHRoaXMuX2lzWm9vbWVkKCkpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnpvb21lZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIF9vbkNoYW5nZUZpbHRlckVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJChcIi5qcy1maWx0ZXJcIikudG9nZ2xlQ2xhc3MoJ2lzLWhpZGRlbicsICF0aGlzLnZpZXdNb2RlbC5nZXQoJ2ZpbHRlcl9lbmFibGVkJykpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVpvb21FbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoXCIuanMtem9vbVwiKS50b2dnbGVDbGFzcygnaXMtaGlkZGVuJywgIXRoaXMudmlld01vZGVsLmdldCgnem9vbV9lbmFibGVkJykpO1xuICB9LFxuXG4gIF9jaGFuZ2VIZWFkZXJWYWx1ZTogZnVuY3Rpb24oY2xhc3NOYW1lLCB3aGF0LCBzdWZmaXgpIHtcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZ2V0KHdoYXQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuJChjbGFzc05hbWUpLnRleHQoJzAgJyArIHN1ZmZpeCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fYWRkVGl0bGVGb3JWYWx1ZShjbGFzc05hbWUsIHdoYXQsIHN1ZmZpeCk7XG5cbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0ZVZhbHVlcyh7XG4gICAgICBlbDogdGhpcy4kZWxcbiAgICB9KTtcblxuICAgIGFuaW1hdG9yLmFuaW1hdGVWYWx1ZSh0aGlzLnZpZXdNb2RlbCwgd2hhdCwgY2xhc3NOYW1lLCBhbmltYXRpb25UZW1wbGF0ZSwge1xuICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIuZm9ybWF0TnVtYmVyLFxuICAgICAgdGVtcGxhdGVEYXRhOiB7IHN1ZmZpeDogXCIgXCIgKyBzdWZmaXggfVxuICAgIH0pO1xuICB9LFxuXG4gIF9vbkNoYW5nZU51bGxzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFuZ2VIZWFkZXJWYWx1ZSgnLmpzLW51bGxzJywgJ251bGxzJywgJ05VTEwgUk9XUycpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVRvdGFsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFuZ2VIZWFkZXJWYWx1ZSgnLmpzLXZhbCcsICd0b3RhbCcsICdTRUxFQ1RFRCcpO1xuICB9LFxuXG4gIF9vbkNoYW5nZU1heDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1tYXgnLCAnbWF4JywgJ01BWCcpO1xuICB9LFxuXG4gIF9vbkNoYW5nZU1pbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1taW4nLCAnbWluJywgJ01JTicpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUF2ZzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlSGVhZGVyVmFsdWUoJy5qcy1hdmcnLCAnYXZnJywgJ0FWRycpO1xuICB9LFxuXG4gIF9hZGRUaXRsZUZvclZhbHVlOiBmdW5jdGlvbihjbGFzc05hbWUsIHdoYXQsIHVuaXQpIHtcbiAgICB0aGlzLiQoY2xhc3NOYW1lKS5hdHRyKCd0aXRsZScsIHRoaXMuX2Zvcm1hdE51bWJlcldpdGhDb21tYXModGhpcy52aWV3TW9kZWwuZ2V0KHdoYXQpLnRvRml4ZWQoMikpICsgJyAnICsgdW5pdCk7XG4gIH0sXG5cbiAgX2Zvcm1hdE51bWJlcldpdGhDb21tYXM6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geC50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTtcbiAgfSxcblxuICBfdXBkYXRlU3RhdHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5vcmlnaW5hbERhdGE7XG5cbiAgICBpZiAodGhpcy5faXNab29tZWQoKSkge1xuICAgICAgZGF0YSA9IHRoaXMuem9vbWVkRGF0YTtcbiAgICB9XG5cbiAgICB2YXIgbnVsbHMgPSB0aGlzLm1vZGVsLmdldCgnbnVsbHMnKTtcblxuICAgIHZhciBtaW4sIG1heDtcblxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG5cbiAgICAgIHZhciBsb0JhckluZGV4ID0gdGhpcy52aWV3TW9kZWwuZ2V0KCdsb19pbmRleCcpIHx8IDA7XG4gICAgICB2YXIgaGlCYXJJbmRleCA9IHRoaXMudmlld01vZGVsLmdldCgnaGlfaW5kZXgnKSB8fCBkYXRhLmxlbmd0aDtcblxuICAgICAgdmFyIHN1bSA9IHRoaXMuX2NhbGNTdW0oZGF0YSwgbG9CYXJJbmRleCwgaGlCYXJJbmRleCk7XG4gICAgICB2YXIgYXZnID0gdGhpcy5fY2FsY0F2ZyhkYXRhLCBsb0JhckluZGV4LCBoaUJhckluZGV4KTtcblxuICAgICAgaWYgKGxvQmFySW5kZXggPj0gMCAmJiBsb0JhckluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbWluID0gZGF0YVtsb0JhckluZGV4XS5zdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhpQmFySW5kZXggPj0gMCAmJiBoaUJhckluZGV4IC0gMSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIG1heCA9IGRhdGFbaGlCYXJJbmRleCAtIDFdLmVuZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3TW9kZWwuc2V0KHsgdG90YWw6IHN1bSwgbnVsbHM6IG51bGxzLCBtaW46IG1pbiwgbWF4OiBtYXgsIGF2ZzogYXZnIH0pO1xuICAgIH1cbiAgfSxcblxuICBfY2FsY0F2ZzogZnVuY3Rpb24oZGF0YSwgc3RhcnQsIGVuZCkge1xuXG4gICAgdmFyIHNlbGVjdGVkRGF0YSA9IGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICB2YXIgdG90YWwgPSB0aGlzLl9jYWxjU3VtKGRhdGEsIHN0YXJ0LCBlbmQsIHRvdGFsKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBhcmVhID0gXy5yZWR1Y2Uoc2VsZWN0ZWREYXRhLCBmdW5jdGlvbihtZW1vLCBkKSB7XG4gICAgICByZXR1cm4gKGQuYXZnICYmIGQuZnJlcSkgPyAoZC5hdmcgKiBkLmZyZXEpICsgbWVtbyA6IG1lbW87XG4gICAgfSwgMCk7XG5cbiAgICByZXR1cm4gYXJlYSAvIHRvdGFsO1xuICB9LFxuXG4gIF9jYWxjU3VtOiBmdW5jdGlvbihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCksIGZ1bmN0aW9uKG1lbW8sIGQpIHtcbiAgICAgIHJldHVybiBkLmZyZXEgKyBtZW1vO1xuICAgIH0sIDApO1xuICB9LFxuXG4gIF9vbkNoYW5nZVpvb21lZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmlld01vZGVsLmdldCgnem9vbWVkJykpIHtcbiAgICAgIHRoaXMuX29uWm9vbUluKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29uWm9vbU91dCgpO1xuICAgIH1cbiAgfSxcblxuICBfb25ab29tSW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Nob3dNaW5pUmFuZ2UoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5leHBhbmQoMjApO1xuXG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVtb3ZlU2hhZG93QmFycygpO1xuXG4gICAgdGhpcy5tb2RlbC5zZXQoeyBzdGFydDogbnVsbCwgZW5kOiBudWxsLCBiaW5zOiBudWxsLCBvd25fZmlsdGVyOiAxIH0pO1xuICAgIHRoaXMubW9kZWwuX2ZldGNoKCk7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSBmYWxzZTtcbiAgfSxcblxuICBfem9vbTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2NrZWRCeVVzZXIgPSB0cnVlO1xuICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21lZDogdHJ1ZSwgem9vbV9lbmFibGVkOiBmYWxzZSB9KTtcbiAgICB0aGlzLmhpc3RvZ3JhbUNoYXJ0Vmlldy5yZW1vdmVTZWxlY3Rpb24oKTtcbiAgfSxcblxuICBfb25ab29tT3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxvY2tlZEJ5VXNlciAgID0gdHJ1ZTtcbiAgICB0aGlzLmxvY2tab29tZWREYXRhID0gZmFsc2U7XG4gICAgdGhpcy51bnNldHRpbmdSYW5nZSA9IHRydWU7XG5cbiAgICB0aGlzLm1vZGVsLnNldCh7IHN0YXJ0OiB0aGlzLnN0YXJ0LCBlbmQ6IHRoaXMuZW5kLCBiaW5zOiB0aGlzLmJpbnNDb3VudCwgb3duX2ZpbHRlcjogbnVsbCB9KTtcblxuICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21fZW5hYmxlZDogZmFsc2UsIGZpbHRlcl9lbmFibGVkOiBmYWxzZSwgbG9faW5kZXg6IG51bGwsIGhpX2luZGV4OiBudWxsIH0pO1xuXG4gICAgdGhpcy5maWx0ZXIudW5zZXRSYW5nZSgpO1xuXG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcuY29udHJhY3QodGhpcy5kZWZhdWx0cy5jaGFydEhlaWdodCk7XG4gICAgdGhpcy5oaXN0b2dyYW1DaGFydFZpZXcucmVzZXRJbmRleGVzKCk7XG5cbiAgICB0aGlzLm1pbmlIaXN0b2dyYW1DaGFydFZpZXcuaGlkZSgpO1xuICB9LFxuXG4gIF9zaG93TWluaVJhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgdmFyIGxvQmFySW5kZXggPSB0aGlzLnZpZXdNb2RlbC5nZXQoJ2xvX2luZGV4Jyk7XG4gICAgdmFyIGhpQmFySW5kZXggPSB0aGlzLnZpZXdNb2RlbC5nZXQoJ2hpX2luZGV4Jyk7XG5cbiAgICB0aGlzLm1pbmlIaXN0b2dyYW1DaGFydFZpZXcuc2VsZWN0UmFuZ2UobG9CYXJJbmRleCwgaGlCYXJJbmRleCk7XG4gICAgdGhpcy5taW5pSGlzdG9ncmFtQ2hhcnRWaWV3LnNob3coKTtcbiAgfSxcblxuICBfY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGlzdG9ncmFtQ2hhcnRWaWV3LnJlbW92ZVNlbGVjdGlvbigpO1xuICAgIHRoaXMudmlld01vZGVsLnNldCh7IHpvb21lZDogZmFsc2UsIHpvb21fZW5hYmxlZDogZmFsc2UgfSk7XG4gICAgdGhpcy52aWV3TW9kZWwudHJpZ2dlcignY2hhbmdlOnpvb21lZCcpO1xuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyXCI+IDxkaXYgY2xhc3M9XCJqcy10aXRsZVwiPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aXRsZSBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPC9kaXY+IDwvZGl2PiA8ZGwgY2xhc3M9XCJDREItV2lkZ2V0LWluZm8gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIGpzLW51bGxzXCI+MCBOVUxMIFJPV1M8L2R0PiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIGpzLW1pblwiPjAgTUlOPC9kdD4gPGR0IGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvSXRlbSBqcy1hdmdcIj4wIEFWRzwvZHQ+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0ganMtbWF4XCI+MCBNQVg8L2R0PiA8L2RsPiA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudCBqcy1jb250ZW50XCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRvb2x0aXAganMtdG9vbHRpcFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1maWx0ZXIgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkIGpzLWZpbHRlciBpcy1oaWRkZW5cIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXIganMtdmFsXCI+PC9wPiA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1maWx0ZXJCdXR0b25zXCI+IDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWxpbmsgQ0RCLVdpZGdldC1maWx0ZXJCdXR0b24ganMtem9vbVwiPnpvb208L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayBDREItV2lkZ2V0LWZpbHRlckJ1dHRvbiBqcy1jbGVhclwiPmNsZWFyPC9idXR0b24+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8aDMgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdcIiB0aXRsZT1cIicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIHRpdGxlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvaDM+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LW9wdGlvbnMgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxidXR0b24gY2xhc3M9XCJDREItV2lkZ2V0LWJ1dHRvbkljb24gQ0RCLVdpZGdldC1idXR0b25JY29uLS1jaXJjbGUganMtc2l6ZXMgJytcbigoX190PSggaXNTaXplc0FwcGxpZWQgPyAnaXMtc2VsZWN0ZWQnIDogJycgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nICcrXG4oKF9fdD0oIGlzU2l6ZXNBcHBsaWVkID8gJ2pzLWNhbmNlbFNpemVzJyA6ICdqcy1hcHBseVNpemVzJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIiBkYXRhLXRvb2x0aXA9XCInK1xuKChfX3Q9KCBpc1NpemVzQXBwbGllZCA/ICdSZW1vdmUgc2l6ZXMnIDogJ0FwcGx5IHNpemVzJyApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4gPGkgY2xhc3M9XCJDREItSWNvbiBDREItSWNvbi1zeXJpbmdlIENEQi1JY29uLS10b3BcIj48L2k+IDwvYnV0dG9uPiA8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzIGpzLWNvbGxhcHNlXCIgZGF0YS10b29sdGlwPVwiJytcbigoX190PSggaXNDb2xsYXBzZWQgPyAnU2hvdycgOiAnSGlkZScgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+IDxzcGFuIGNsYXNzPVwiQ0RCLVNoYXBlLXRocmVlUG9pbnRzSXRlbVwiPjwvc3Bhbj4gPC9idXR0b24+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFRvb2x0aXBWaWV3ID0gcmVxdWlyZSgnLi4vd2lkZ2V0LXRvb2x0aXAtdmlldycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9oaXN0b2dyYW1fdGl0bGVfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogIFNob3cgdGl0bGUgKyBzaG93IGlmIGhpc3RvZ3JhbSBzaXplcyBhcmUgYXBwbGllZCBvciBub3RcbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC10aXRsZSBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQnLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtYXBwbHlTaXplcyc6ICdfYXBwbHlTaXplcycsXG4gICAgJ2NsaWNrIC5qcy1jYW5jZWxTaXplcyc6ICdfY2FuY2VsU2l6ZXMnLFxuICAgICdjbGljayAuanMtY29sbGFwc2UnOiAnX3RvZ2dsZUNvbGxhcHNlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YU1vZGVsID0gdGhpcy5vcHRpb25zLmRhdGFNb2RlbDtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ3RpdGxlJyksXG4gICAgICAgIGlzU2l6ZXNBcHBsaWVkOiB0aGlzLmRhdGFNb2RlbC5nZXQoJ2hpc3RvZ3JhbVNpemVzJyksXG4gICAgICAgIGlzQ29sbGFwc2VkOiB0aGlzLmRhdGFNb2RlbC5pc0NvbGxhcHNlZCgpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5faW5pdFZpZXdzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5iaW5kKCdjaGFuZ2U6aGlzdG9ncmFtU2l6ZXMgY2hhbmdlOmNvbGxhcHNlZCcsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuZGF0YU1vZGVsKTtcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2l6ZXNUb29sdGlwID0gbmV3IFRvb2x0aXBWaWV3KHtcbiAgICAgIHRhcmdldDogdGhpcy4kKCcuanMtc2l6ZXMnKVxuICAgIH0pO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoc2l6ZXNUb29sdGlwLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcoc2l6ZXNUb29sdGlwKTtcblxuICAgIHZhciBjb2xsYXBzZVRvb2x0aXAgPSBuZXcgVG9vbHRpcFZpZXcoe1xuICAgICAgdGFyZ2V0OiB0aGlzLiQoJy5qcy1jb2xsYXBzZScpXG4gICAgfSk7XG4gICAgJCgnYm9keScpLmFwcGVuZChjb2xsYXBzZVRvb2x0aXAucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyhjb2xsYXBzZVRvb2x0aXApO1xuICB9LFxuXG4gIF9hcHBseVNpemVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5zZXQoJ2hpc3RvZ3JhbVNpemVzJywgdHJ1ZSk7XG4gIH0sXG5cbiAgX2NhbmNlbFNpemVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRhdGFNb2RlbC5zZXQoJ2hpc3RvZ3JhbVNpemVzJywgZmFsc2UpO1xuICB9LFxuXG4gIF90b2dnbGVDb2xsYXBzZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kYXRhTW9kZWwudG9nZ2xlQ29sbGFwc2VkKCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xudmFyIFdpZGdldE1vZGVsID0gcmVxdWlyZSgnLi4vd2lkZ2V0X21vZGVsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0TW9kZWwuZXh0ZW5kKHtcblxuICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGlmICh0aGlzLmdldCgnY29sdW1uVHlwZScpKSB7XG4gICAgICBwYXJhbXMucHVzaCgnY29sdW1uX3R5cGU9JyArIHRoaXMuZ2V0KCdjb2x1bW5UeXBlJykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnc3RhcnQnKSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdzdGFydD0nICsgdGhpcy5nZXQoJ3N0YXJ0JykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnZW5kJykpKSB7XG4gICAgICBwYXJhbXMucHVzaCgnZW5kPScgKyB0aGlzLmdldCgnZW5kJykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnYmlucycpKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2JpbnM9JyArIHRoaXMuZ2V0KCdiaW5zJykpO1xuICAgIH1cbiAgICBpZiAoXy5pc051bWJlcih0aGlzLmdldCgnb3duX2ZpbHRlcicpKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ293bl9maWx0ZXI9JyArIHRoaXMuZ2V0KCdvd25fZmlsdGVyJykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXQoJ2JvdW5kaW5nQm94JykgJiYgdGhpcy5nZXQoJ3N1Ym1pdEJCb3gnKSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2Jib3g9JyArIHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsID0gdGhpcy5nZXQoJ3VybCcpO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICB1cmwgKz0gJz8nICsgcGFyYW1zLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fZGF0YSA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKHRoaXMuZ2V0KCdkYXRhJykpO1xuXG4gICAgLy8gQkJveCBzaG91bGQgb25seSBiZSBpbmNsdWRlZCB1bnRpbCBhZnRlciB0aGUgZmlyc3QgZmV0Y2gsIHNpbmNlIHdlIHdhbnQgdG8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgZnVsbCBkYXRhc2V0XG4gICAgdGhpcy5vbmNlKCdjaGFuZ2U6ZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQoJ3N1Ym1pdEJCb3gnLCB0cnVlKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMubGF5ZXIuYmluZCgnY2hhbmdlOm1ldGEnLCB0aGlzLl9vbkNoYW5nZUxheWVyTWV0YSwgdGhpcyk7XG4gIH0sXG5cbiAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEudG9KU09OKCk7XG4gIH0sXG5cbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZSgpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIG51bWJlck9mQmlucyA9IGRhdGEuYmluc19jb3VudDtcbiAgICB2YXIgd2lkdGggPSBkYXRhLmJpbl93aWR0aDtcbiAgICB2YXIgbnVsbHMgPSBkYXRhLm51bGxzX2NvdW50O1xuICAgIHZhciBzdGFydCA9IGRhdGEuYmluc19zdGFydDtcblxuICAgIHZhciBidWNrZXRzID0gbmV3IEFycmF5KG51bWJlck9mQmlucyk7XG5cbiAgICBfLmVhY2goZGF0YS5iaW5zLCBmdW5jdGlvbihiKSB7XG4gICAgICBidWNrZXRzW2IuYmluXSA9IGI7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mQmluczsgaSsrKSB7XG4gICAgICBidWNrZXRzW2ldID0gXy5leHRlbmQoe1xuICAgICAgICBiaW46IGksXG4gICAgICAgIHN0YXJ0OiBzdGFydCArIChpICogd2lkdGgpLFxuICAgICAgICBlbmQ6IHN0YXJ0ICsgKChpICsgMSkgKiB3aWR0aCksXG4gICAgICAgIGZyZXE6IDBcbiAgICAgIH0sIGJ1Y2tldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEucmVzZXQoYnVja2V0cyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogYnVja2V0cyxcbiAgICAgIG51bGxzOiBkYXRhLm51bGxzXG4gICAgfTtcbiAgfSxcblxuICAvLyBzZXQgYmlucyBmb3IgdGhlIGhpc3RvZ3JhbXNcbiAgLy8gQGJpbnMgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdGhlIGZvcm1hdCBbeyBzdGFydDogLi4uLCBlbmQ6IC4uLiwgZnJlcTogLi4uLCBtaW46IC4uLiwgbWF4OiAgIH0sIC4uLl1cbiAgLy8gICAgLSBzdGFydCwgZW5kOiBhcmUgdGhlIGJ1Y2tldCBib3VuZHNcbiAgLy8gICAgLSBtaW4sIG1heDogdGhlIG1pbiBhbmQgdGhlIG1heCB2YWx1ZSBmb3IgYWxsIHRoZSBwb2ludHMgaW4gdGhhdCBidWNrZXRcbiAgLy8gICAgLSBmcmVxOiBjb3VudFxuICBzZXRCaW5zOiBmdW5jdGlvbihiaW5zLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fZGF0YS5yZXNldChiaW5zLCBvcHRpb25zKTtcbiAgICB0aGlzLnNldCgnZGF0YScsIHsgYmluczogYmlucyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaXN0b2dyYW1cIixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29sdW1uOiB0aGlzLmdldCgnY29sdW1uJyksXG4gICAgICAgIGJpbnM6IHRoaXMuZ2V0KCdiaW5zJylcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIF9vbkNoYW5nZUxheWVyTWV0YTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maWx0ZXIuc2V0KCdjb2x1bW5UeXBlJywgdGhpcy5sYXllci5nZXQoJ21ldGEnKS5jb2x1bW5fdHlwZSk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlQmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5fb25DaGFuZ2VCaW5kcy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOmhpc3RvZ3JhbVNpemVzJywgZnVuY3Rpb24obWRsLCBpc1NpemVzQXBwbGllZCwgZCkge1xuICAgICAgaWYgKGlzU2l6ZXNBcHBsaWVkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignaGlzdG9ncmFtU2l6ZXMnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jzx1bCBjbGFzcz1cIkNEQi1XaWRnZXQtY2hhcnQgQ0RCLVdpZGdldC1jaGFydC0tZmFrZVwiPiAnO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykgeyBcbl9fcCs9JyA8bGkgY2xhc3M9XCJDREItV2lkZ2V0LWNoYXJ0SXRlbSBDREItV2lkZ2V0LWNoYXJ0SXRlbS0tJytcbigoX190PSggXy5zYW1wbGUoWydzbWFsbCcsICdtZWRpdW0nLCAnYmlnJ10sIDEpWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyBXaWRnZXQtY2hhcnRJdGVtLS1mYWtlXCI+PC9saT4gJztcbiB9IFxuX19wKz0nIDwvdWw+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+IDxoMyBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiIHRpdGxlPVwiJytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggdGl0bGUgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9oMz4gPC9kaXY+IDxkbCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb1wiPiA8ZHQgY2xhc3M9XCJDREItV2lkZ2V0LWluZm9JdGVtIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tdXBwZXJcIj4nK1xuKChfX3Q9KCBpdGVtc0NvdW50ICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyByb3dzPC9kdD4gPC9kbD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS1ub1NpZGVzTWFyZ2luXCI+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RXcmFwcGVyIGpzLWNvbnRlbnRcIj48L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWZvb3RlciBqcy1mb290ZXJcIj48L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdCA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBXaWRnZXRDb250ZW50VmlldyA9IHJlcXVpcmUoJy4uL3N0YW5kYXJkL3dpZGdldF9jb250ZW50X3ZpZXcnKTtcbnZhciBXaWRnZXRMaXN0SXRlbXNWaWV3ID0gcmVxdWlyZSgnLi9pdGVtc192aWV3Jyk7XG52YXIgV2lkZ2V0TGlzdFBhZ2luYXRvclZpZXcgPSByZXF1aXJlKCcuL3BhZ2luYXRvcl92aWV3Jyk7XG52YXIgV2lkZ2V0TGlzdEVkZ2VzVmlldyA9IHJlcXVpcmUoJy4vZWRnZXNfdmlldycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi9jb250ZW50X3RlbXBsYXRlLnRwbCcpO1xudmFyIHRlbXBsYXRlUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL3BsYWNlaG9sZGVyX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IGNvbnRlbnQgdmlldzpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRDb250ZW50Vmlldy5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICBzaG93U2Nyb2xsOiBmYWxzZVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgaXNEYXRhRW1wdHkgPSBfLmlzRW1wdHkoZGF0YSkgfHwgXy5zaXplKGRhdGEpID09PSAwO1xuICAgIHRoaXMuJGVsLmh0bWwoXG4gICAgICB0ZW1wbGF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aGlzLm1vZGVsLmdldCgndGl0bGUnKSxcbiAgICAgICAgaXRlbXNDb3VudDogIWlzRGF0YUVtcHR5ID8gZm9ybWF0LmZvcm1hdFZhbHVlKGRhdGEubGVuZ3RoKSA6ICctJ1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKGlzRGF0YUVtcHR5KSB7XG4gICAgICB0aGlzLl9hZGRQbGFjZWhvbGRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0Vmlld3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfaW5pdFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSB0aGlzLm1vZGVsLmdldFNpemUoKTtcblxuICAgIC8vIExpc3QgdmlldyAtPiBpdGVtcyB2aWV3XG4gICAgdGhpcy5fbGlzdCA9IG5ldyBXaWRnZXRMaXN0SXRlbXNWaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kKCcuanMtY29udGVudCcpLmh0bWwodGhpcy5fbGlzdC5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KHRoaXMuX2xpc3QpO1xuXG4gICAgdmFyIGlzU2Nyb2xsTGlzdCA9ICh0aGlzLl9saXN0LiRlbC5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fbGlzdC4kZWwub3V0ZXJIZWlnaHQoKSkgPiAwO1xuXG4gICAgaWYgKGlzU2Nyb2xsTGlzdCB8fMKgdGhpcy5vcHRpb25zLnNob3dTY3JvbGwpIHtcbiAgICAgIC8vIFBhZ2luYXRvclxuICAgICAgdGhpcy5fcGFnaW5hdGlvbiA9IG5ldyBXaWRnZXRMaXN0UGFnaW5hdG9yVmlldyh7XG4gICAgICAgICR0YXJnZXQ6IHRoaXMuX2xpc3QuJGVsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJCgnLmpzLWZvb3RlcicpLmFwcGVuZCh0aGlzLl9wYWdpbmF0aW9uLnJlbmRlcigpLmVsKTtcbiAgICAgIHRoaXMuYWRkVmlldyh0aGlzLl9wYWdpbmF0aW9uKTtcblxuICAgICAgLy8gRWRnZXNcbiAgICAgIHRoaXMuX2VkZ2VzID0gbmV3IFdpZGdldExpc3RFZGdlc1ZpZXcoe1xuICAgICAgICAkdGFyZ2V0OiB0aGlzLl9saXN0LiRlbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiQoJy5qcy1jb250ZW50JykuYXBwZW5kKHRoaXMuX2VkZ2VzLnJlbmRlcigpLmVsKTtcbiAgICAgIHRoaXMuYWRkVmlldyh0aGlzLl9lZGdlcyk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcblxuLyoqXG4gKiAgTGlzdCBlZGdlcyB2aWV3OlxuICpcbiAqICAtIEl0IHNob3dzIHRoZSBib3JkZXJzIGFuZCB0aGUgc2hhZG93cywgaWYgbmVlZGVkLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBfVEVNUExBVEU6ICcgJyArXG4gICAgJzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RFZGdlIENEQi1XaWRnZXQtbGlzdEVkZ2UtLXRvcFwiPicrXG4gICAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEVkZ2VTaGFkb3cganMtdG9wU2hhZG93XCI+PC9kaXY+JytcbiAgICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0RWRnZUJvcmRlclwiPjwvZGl2PicrXG4gICAgJzwvZGl2PicrXG4gICAgJzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWxpc3RFZGdlIENEQi1XaWRnZXQtbGlzdEVkZ2UtLWJvdHRvbVwiPicrXG4gICAgICAnPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEVkZ2VTaGFkb3cganMtYm90dG9tU2hhZG93XCI+PC9kaXY+JytcbiAgICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0RWRnZUJvcmRlclwiPjwvZGl2PicrXG4gICAgJzwvZGl2PicsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fJHRhcmdldCA9IHRoaXMub3B0aW9ucy4kdGFyZ2V0O1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZSh0aGlzLl9URU1QTEFURSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl8kdGFyZ2V0LmJpbmQoJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fY2hlY2tTY3JvbGwoKTtcbiAgICB9KTtcbiAgfSxcblxuICBfdW5iaW5kU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0LnVuYmluZCgnc2Nyb2xsJyk7XG4gIH0sXG5cbiAgX2NoZWNrU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudFNjcm9sbCA9IHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKCk7XG4gICAgdmFyIG1heFNjcm9sbCA9IHRoaXMuXyR0YXJnZXQuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHRoaXMuXyR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcbiAgICB0aGlzLiQoJy5qcy10b3BTaGFkb3cnKS50b2dnbGUoY3VycmVudFNjcm9sbCAhPT0gMCk7XG4gICAgdGhpcy4kKCcuanMtYm90dG9tU2hhZG93JykudG9nZ2xlKGN1cnJlbnRTY3JvbGwgIT09IG1heFNjcm9sbCk7XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VuYmluZFNjcm9sbCgpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jyc7XG4gaWYgKGlzQ2xpY2thYmxlKSB7IFxuX19wKz0nIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0SXRlbUlubmVyIENEQi1XaWRnZXQtbGlzdEJ1dHRvbiBDREItV2lkZ2V0LWxpc3RCdXR0b24tLXdpdGhCb3JkZXIganMtYnV0dG9uXCI+ICc7XG4gfSBlbHNlIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW1Jbm5lciBDREItV2lkZ2V0LWxpc3RJdGVtSW5uZXItLXdpdGhCb3JkZXJzXCI+ICc7XG4gfSBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkIENEQi1XaWRnZXQtY29udGVudFNwYWNlZC0tdG9wQWxpZ25lZCBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQtLXN0YXJ0XCI+IDxlbSBjbGFzcz1cIkNEQi1TaGFwZS1kb3QgQ0RCLVdpZGdldC1saXN0RG90XCI+PC9lbT4gJztcbiBpZiAoaXRlbXNDb3VudCA+IDApIHsgXG5fX3ArPScgPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudEZ1bGxcIj4gPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbCBDREItV2lkZ2V0LXRleHRTbWFsbC0tdXBwZXIgQ0RCLVdpZGdldC10ZXh0U21hbGwtLWJvbGRcIiB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zWzBdWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zWzBdWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvcD4gJztcbiBpZiAoaXRlbXNDb3VudCA+IDIpIHsgXG5fX3ArPScgPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmxpbmVMaXN0XCI+ICc7XG4gZm9yICh2YXIgaSA9IDEsIGwgPSBpdGVtc0NvdW50OyBpIDwgbDsgaSsrKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWlubGluZUxpc3RJdGVtIENEQi1XaWRnZXQtdGV4dFNtYWxsZXIgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tbm9FbGxpcFwiPiA8ZGQgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ib2xkIENEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWRhcmsgdS1yU3BhY2VcIiB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zW2ldWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zW2ldWzFdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZGQ+IDxkdCB0aXRsZT1cIicrXG4oKF9fdD0oIGl0ZW1zW2ldWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJ1wiPicrXG4oKF9fdD0oIGl0ZW1zW2ldWzBdICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJzwvZHQ+IDwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kbD4gJztcbiB9IGVsc2UgaWYgKGl0ZW1zQ291bnQgPT09IDIpIHsgXG5fX3ArPScgPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS1ub0VsbGlwIHUtdFNwYWNlXCI+IDxkZCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsZXItLWJvbGQgQ0RCLVdpZGdldC10ZXh0U21hbGxlci0tZGFyayB1LXJTcGFjZVwiIHRpdGxlPVwiJytcbigoX190PSggaXRlbXNbMV1bMV0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggaXRlbXNbMV1bMV0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9kZD4gPGR0IHRpdGxlPVwiJytcbigoX190PSggaXRlbXNbMV1bMF0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+JytcbigoX190PSggaXRlbXNbMV1bMF0gKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nPC9kdD4gPC9kbD4gJztcbiB9IFxuX19wKz0nIDwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kaXY+ICc7XG4gaWYgKGlzQ2xpY2thYmxlKSB7IFxuX19wKz0nIDwvZGl2PjwvYnV0dG9uPiAnO1xuIH0gZWxzZSB7IFxuX19wKz0nICAnO1xuIH0gXG5fX3ArPScnO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIGZvcm1hdCA9IGNkYi5jb3JlLmZvcm1hdDtcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaXRlbV90ZW1wbGF0ZS50cGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgdGFnTmFtZTogJ2xpJyxcbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0SXRlbScsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5qcy1idXR0b24nOiAnX29uSXRlbUNsaWNrJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5vcHRpb25zLnZpZXdNb2RlbDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC50b0pTT04oKTtcbiAgICB2YXIgaGFzSW50ZXJhY3Rpdml0eSA9IHRoaXMuX2hhc0ludGVyYWN0aXZpdHkoZGF0YSk7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fc2FuaXRpemVEYXRhKGRhdGEpO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICBpc0NsaWNrYWJsZTogaGFzSW50ZXJhY3Rpdml0eSxcbiAgICAgICAgaXRlbXNDb3VudDogXy5zaXplKGl0ZW1zKVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY2FydG9kYl9pZCBkZWZpbmVkLCBjbGljayBldmVudCBzaG91bGRcbiAgICAvLyBiZSBkaXNhYmxlZFxuICAgIHRoaXNbIGhhc0ludGVyYWN0aXZpdHkgPyAnZGVsZWdhdGVFdmVudHMnIDogJ3VuZGVsZWdhdGVFdmVudHMnIF0oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBSZW1vdmUgY2FydG9kYl9pZCwgaWYgZXhpc3RzXG4gIC8vIFJlcGxhY2UgdGl0bGVzIGlmIHRoZXJlIGFyZSBhbHRlcm5hdGl2ZXNcbiAgLy8gQ29udmVydCBkYXRhIG9iamVjdCB0byBhcnJheSBpdGVtc1xuICBfc2FuaXRpemVEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGhhc0ludGVyYWN0aXZpdHkgPSB0aGlzLl9oYXNJbnRlcmFjdGl2aXR5KGRhdGEpO1xuICAgIHZhciBkYXRhID0gXy5vbWl0KGRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGtleSA9PT0gJ2NhcnRvZGJfaWQnO1xuICAgIH0pO1xuXG4gICAgdmFyIGNvbHVtblRpdGxlcyA9IHRoaXMudmlld01vZGVsLmdldCgnY29sdW1uc190aXRsZScpO1xuICAgIGlmIChoYXNJbnRlcmFjdGl2aXR5ICYmICFfLmlzRW1wdHkoY29sdW1uVGl0bGVzKSkge1xuICAgICAgY29sdW1uVGl0bGVzID0gXy5yZXN0KGNvbHVtblRpdGxlcywgMSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0byBwYWlyIGl0ZW1zIGFuZCBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbHVtbiB0aXRsZVxuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgdmFyIHRpdGxlID0gY29sdW1uVGl0bGVzICYmIGNvbHVtblRpdGxlc1tpXSB8fCBrZXk7XG4gICAgICBhcnIucHVzaChbIHRpdGxlLCBmb3JtYXQuZm9ybWF0VmFsdWUodmFsdWUpIF0pO1xuICAgICAgKytpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcblxuICBfaGFzSW50ZXJhY3Rpdml0eTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiAhXy5pc0VtcHR5KFxuICAgICAgXy5maWx0ZXIoZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSl7XG4gICAgICAgIHJldHVybiBrZXkgPT09ICdjYXJ0b2RiX2lkJ1xuICAgICAgfSlcbiAgICApXG4gIH0sXG5cbiAgX29uSXRlbUNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2l0ZW1DbGlja2VkJywgdGhpcy5tb2RlbCwgdGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgV2lkZ2V0TGlzdEl0ZW1WaWV3ID0gcmVxdWlyZSgnLi9pdGVtX3ZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1saXN0IGpzLWxpc3QnLFxuICB0YWdOYW1lOiAndWwnLFxuXG4gIGV2ZW50czoge1xuICAgICdzY3JvbGwnOiAnX2NoZWNrU2Nyb2xsJ1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmdldERhdGEoKS5lYWNoKHRoaXMuX2FkZEl0ZW0sIHRoaXMpO1xuICB9LFxuXG4gIF9hZGRJdGVtOiBmdW5jdGlvbihtZGwpIHtcbiAgICB2YXIgdiA9IG5ldyBXaWRnZXRMaXN0SXRlbVZpZXcoe1xuICAgICAgbW9kZWw6IG1kbCxcbiAgICAgIHZpZXdNb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHYuYmluZCgnaXRlbUNsaWNrZWQnLCBmdW5jdGlvbigpe1xuICAgICAgdGhpcy50cmlnZ2VyKCdpdGVtQ2xpY2tlZCcsIG1kbCwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5hZGRWaWV3KHYpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh2LnJlbmRlcigpLmVsKTtcbiAgfVxuXG59KTtcbiIsInZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBXaWRnZXRNb2RlbCA9IHJlcXVpcmUoJy4uL3dpZGdldF9tb2RlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpZGdldE1vZGVsLmV4dGVuZCh7XG5cbiAgb3B0aW9uczoge1xuICAgIHBhZ2U6IDAsXG4gICAgcGVyX3BhZ2U6IDEwMFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG4gICAgdGhpcy5fZGF0YSA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKHRoaXMuZ2V0KCdkYXRhJykpO1xuICAgIFdpZGdldE1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYXR0cnMsIG9wdHMpO1xuICB9LFxuXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9LFxuXG4gIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNpemUoKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciByb3dzID0gZGF0YS5yb3dzO1xuICAgIHRoaXMuX2RhdGEucmVzZXQocm93cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHJvd3NcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2x1bW5zOiB0aGlzLmdldCgnY29sdW1ucycpXG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LW5hdiBDREItV2lkZ2V0LWNvbnRlbnRTcGFjZWQnLFxuXG4gIF9URU1QTEFURTogJyAnICtcbiAgICAnPHNwYW4+PC9zcGFuPicgK1xuICAgICc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1uYXZBcnJvd3MgQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkXCI+JytcbiAgICAgICc8YnV0dG9uIGNsYXNzPVwiQ0RCLVNoYXBlLWFycm93IENEQi1TaGFwZS1hcnJvdy0tdXAganMtdXBcIj48L2J1dHRvbj4nK1xuICAgICAgJzxidXR0b24gY2xhc3M9XCJDREItU2hhcGUtYXJyb3cgQ0RCLVNoYXBlLWFycm93LS1kb3duIGpzLWRvd25cIj48L2J1dHRvbj4nK1xuICAgICc8L2Rpdj4nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtdXAnOiAnX3Njcm9sbFVwJyxcbiAgICAnY2xpY2sgLmpzLWRvd24nOiAnX3Njcm9sbERvd24nXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuJHRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgc2hvdWxkIGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBwYWdpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLl8kdGFyZ2V0ID0gdGhpcy5vcHRpb25zLiR0YXJnZXQ7XG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fJHRhcmdldC5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fJHRhcmdldC5vdXRlckhlaWdodCgpO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZSh0aGlzLl9URU1QTEFURSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl8kdGFyZ2V0LmJpbmQoJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fY2hlY2tTY3JvbGwoKTtcbiAgICB9KTtcbiAgfSxcblxuICBfdW5iaW5kU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0LnVuYmluZCgnc2Nyb2xsJyk7XG4gIH0sXG5cbiAgX2NoZWNrU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudFNjcm9sbCA9IHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKCk7XG4gICAgdGhpcy4kKCcuanMtdXAnKS50b2dnbGVDbGFzcygnaXMtZGlzYWJsZWQnLCBjdXJyZW50U2Nyb2xsID09PSAwKTtcbiAgICB0aGlzLiQoJy5qcy1kb3duJykudG9nZ2xlQ2xhc3MoJ2lzLWRpc2FibGVkJywgY3VycmVudFNjcm9sbCA+PSB0aGlzLl9zY3JvbGxIZWlnaHQpO1xuICB9LFxuXG4gIF9nZXRFZGdlVmlzaWJsZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYUhlaWdodCA9IHRoaXMuXyR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgZmlyc3RFbCA9IG51bGw7XG4gICAgdmFyIGxhc3RFbCA9IG51bGw7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fJHRhcmdldC5jaGlsZHJlbignLkNEQi1XaWRnZXQtbGlzdEl0ZW0nKTtcblxuICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgdG9wID0gJCh0aGlzKS5wb3NpdGlvbigpLnRvcDtcbiAgICAgIHZhciBoZWlnaHQgPSAkKHRoaXMpLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIGlmICh0b3AgPiAtMSAmJiBmaXJzdEVsID09PSBudWxsKXsgLy9maXJzdCBlbnRpcmVseSB2aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgZmlyc3RFbCA9IHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKCh0b3AgKyBoZWlnaHQpID4gYXJlYUhlaWdodCAmJiBsYXN0RWwgPT09IG51bGwpe1xuICAgICAgICBsYXN0RWwgPSBpdGVtc1tpbmRleC0xXTsvL3RoZSBsYXN0IGVudGlyZWx5IHZpc2libGUgd2FzIHRoZSBlbGVtZW50IGJlZm9yZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtmaXJzdEVsLGxhc3RFbF07XG4gIH0sXG5cbiAgX3Njcm9sbERvd246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0VmlzaWJsZUl0ZW0gPSB0aGlzLl9nZXRFZGdlVmlzaWJsZUl0ZW1zKClbMV07XG4gICAgdmFyIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcCgpO1xuICAgIHZhciAkbmV4dCA9ICQobGFzdFZpc2libGVJdGVtKS5uZXh0KCk7XG4gICAgaWYgKCRuZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIHRvcCA9ICRuZXh0LnBvc2l0aW9uKCkudG9wO1xuICAgICAgdmFyIGhlaWdodCA9ICRuZXh0Lm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gdG9wICsgaGVpZ2h0IC0gdGhpcy5fJHRhcmdldC5vdXRlckhlaWdodCgpICsgY3VycmVudFNjcm9sbDtcbiAgICAgIGlmIChzY3JvbGxQb3MgPiAwKSB7XG4gICAgICAgIHRoaXMuXyR0YXJnZXQuc2Nyb2xsVG9wKHNjcm9sbFBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9zY3JvbGxVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpcnN0VmlzaWJsZUl0ZW0gPSB0aGlzLl9nZXRFZGdlVmlzaWJsZUl0ZW1zKClbMF07XG4gICAgdmFyIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl8kdGFyZ2V0LnNjcm9sbFRvcCgpO1xuICAgIHZhciAkcHJldiA9ICQoZmlyc3RWaXNpYmxlSXRlbSkucHJldigpO1xuICAgIGlmICgkcHJldi5sZW5ndGgpIHtcbiAgICAgIHZhciB0b3AgPSAkcHJldi5wb3NpdGlvbigpLnRvcDtcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjdXJyZW50U2Nyb2xsICsgdG9wO1xuICAgICAgdGhpcy5fJHRhcmdldC5zY3JvbGxUb3Aoc2Nyb2xsUG9zKTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VuYmluZFNjcm9sbCgpO1xuICAgIFZpZXcucHJvdG90eXBlLmNsZWFuLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9Jzx1bCBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdCBDREItV2lkZ2V0LWxpc3QtLXdpdGhCb3JkZXJzXCI+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDxsaSBjbGFzcz1cIkNEQi1XaWRnZXQtbGlzdEl0ZW0gQ0RCLVdpZGdldC1saXN0SXRlbS0tZmFrZVwiPjwvbGk+IDwvdWw+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1oZWFkZXJcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGl0bGUgV2lkZ2V0LWNvbnRlbnRTcGFjZWRcIj4gPGgzIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCIgdGl0bGU9XCInK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbidcIj4nK1xuKChfX3Q9KCB0aXRsZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbic8L2gzPiA8L2Rpdj4gPGRsIGNsYXNzPVwiQ0RCLVdpZGdldC1pbmZvXCI+IDxkdCBjbGFzcz1cIkNEQi1XaWRnZXQtaW5mb0l0ZW0gQ0RCLVdpZGdldC10ZXh0U21hbGxlciBDREItV2lkZ2V0LXRleHRTbWFsbGVyLS11cHBlclwiPicrXG4oKF9fdD0oIGl0ZW1zQ291bnQgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIGl0ZW1zPC9kdD4gPC9kbD4gPC9kaXY+IDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWNvbnRlbnQganMtY29udGVudFwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciAkID0gY2RiLiQ7XG52YXIgXyA9IGNkYi5fO1xudmFyIGxvZyA9IGNkYi5sb2c7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgZDMgPSBjZGIuZDM7XG52YXIgY29udGVudFRlbXBsYXRlID0gcmVxdWlyZSgnLi93aWRnZXRfY29udGVudF90ZW1wbGF0ZS50cGwnKTtcbnZhciBwbGFjZWhvbGRlclRlbXBsYXRlID0gcmVxdWlyZSgnLi93aWRnZXRfcGxhY2Vob2xkZXJfdGVtcGxhdGUudHBsJyk7XG5cbi8qKlxuICogRGVmYXVsdCB3aWRnZXQgY29udGVudCB2aWV3OlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWJvZHknLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIGlzRGF0YUVtcHR5ID0gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgY29udGVudFRlbXBsYXRlKHtcbiAgICAgICAgdGl0bGU6IHRoaXMubW9kZWwuZ2V0KCd0aXRsZScpLFxuICAgICAgICBpdGVtc0NvdW50OiAhaXNEYXRhRW1wdHkgPyBkYXRhLmxlbmd0aCA6ICctJ1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKGlzRGF0YUVtcHR5KSB7XG4gICAgICB0aGlzLl9hZGRQbGFjZWhvbGRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOmRhdGEnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gIH0sXG5cbiAgX2FkZFBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAocGxhY2Vob2xkZXJUZW1wbGF0ZSkge1xuICAgICAgdGhpcy4kKCcuanMtY29udGVudCcpLmFwcGVuZChwbGFjZWhvbGRlclRlbXBsYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuaW5mbygnUGxhY2Vob2xkZXIgdGVtcGxhdGUgZG9lc25cXCd0IGV4aXN0Jyk7XG4gICAgfVxuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtYnV0dG9uIENEQi1XaWRnZXQtZXJyb3JCdXR0b24ganMtcmVmcmVzaFwiPiA8c3BhbiBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dFNtYWxsIENEQi1XaWRnZXQtdGV4dFNtYWxsLS1ib2xkXCI+UkVGUkVTSDwvc3Bhbj4gPC9idXR0b24+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBWaWV3ID0gY2RiLmNvcmUuVmlldztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vd2lkZ2V0X2Vycm9yX3RlbXBsYXRlLnRwbCcpO1xuXG4vKipcbiAqICBEZWZhdWx0IHdpZGdldCBlcnJvciB2aWV3OlxuICpcbiAqICBJdCB3aWxsIGxpc3RlbiBvciBub3QgdG8gZGF0YU1vZGVsIGNoYW5nZXMgd2hlblxuICogIGZpcnN0IGxvYWQgaXMgZG9uZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC1lcnJvciBpcy1oaWRkZW4nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtcmVmcmVzaCc6ICdfb25SZWZyZXNoQ2xpY2snXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdEJpbmRzKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnZXJyb3InLCB0aGlzLnNob3csIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnbG9hZGluZycsIHRoaXMuaGlkZSwgdGhpcyk7XG4gIH0sXG5cbiAgX29uUmVmcmVzaENsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnJlZnJlc2goKTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnaXMtaGlkZGVuJyk7XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICB9XG5cbn0pO1xuIiwidmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xuXG4vKipcbiAqICBEZWZhdWx0IHdpZGdldCBsb2FkZXIgdmlldzpcbiAqXG4gKiAgSXQgd2lsbCBsaXN0ZW4gb3Igbm90IHRvIGRhdGFNb2RlbCBjaGFuZ2VzIHdoZW5cbiAqICBmaXJzdCBsb2FkIGlzIGRvbmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtbG9hZGVyJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2xvYWRpbmcnLCB0aGlzLnNob3csIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuYmluZCgnc3luYyBlcnJvcicsIHRoaXMuaGlkZSwgdGhpcyk7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuJGVsLnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XG4gICAgfSwgNTAwKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPHVsIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0IENEQi1XaWRnZXQtbGlzdC0td2l0aEJvcmRlcnNcIj4gPGxpIGNsYXNzPVwiQ0RCLVdpZGdldC1saXN0SXRlbSBDREItV2lkZ2V0LWxpc3RJdGVtLS13aXRoQm9yZGVycyBDREItV2lkZ2V0LWxpc3RJdGVtLS1mYWtlXCI+PC9saT4gPC91bD4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIHBsYWNlaG9sZGVyVGVtcGxhdGUgPSByZXF1aXJlKCcuL3BsYWNlaG9sZGVyLnRwbCcpO1xudmFyIEhpc3RvZ3JhbVZpZXcgPSByZXF1aXJlKCcuL2hpc3RvZ3JhbS12aWV3Jyk7XG5cbi8qKlxuICogV2lkZ2V0IGNvbnRlbnQgdmlldyBmb3IgYSB0aW1lLXNlcmllc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWJvZHkgQ0RCLVdpZGdldC1ib2R5LS10aW1lU2VyaWVzJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25GaXJzdExvYWQsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwub25jZSgnZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgIGFsZXJ0KCd0aGUgdGlsZXIgZG9lcyBub3Qgc3VwcG9ydCBub24tdG9ycXVlIGxheWVycyBqdXN0IHlldOKApicpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclN1YlZpZXdzKCk7XG4gICAgdGhpcy4kZWwuaHRtbCgnJyk7IC8vIHRvIHJlbW92ZSBwbGFjZWhvbGRlciBpZiB0aGVyZSBpcyBhbnlcblxuICAgIGlmICh0aGlzLl9pc0RhdGFFbXB0eSgpKSB7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQocGxhY2Vob2xkZXJUZW1wbGF0ZSh7XG4gICAgICAgIGhhc1RvcnF1ZUxheWVyOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcHBlbmRWaWV3KG5ldyBIaXN0b2dyYW1WaWV3KHRoaXMub3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9vbkZpcnN0TG9hZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc3RvcmVCb3VuZHMoKTtcbiAgICB0aGlzLm1vZGVsLm9uY2UoJ2NoYW5nZTpkYXRhJywgdGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMubW9kZWwuX2ZldGNoKCk7XG4gIH0sXG5cbiAgX3N0b3JlQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHN0YXJ0ID0gZGF0YVswXS5zdGFydDtcbiAgICAgIHZhciBlbmQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uZW5kO1xuICAgICAgdGhpcy5tb2RlbC5zZXQoeyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBiaW5zOiBkYXRhLmxlbmd0aCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgX2FwcGVuZFZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICB0aGlzLmFkZFZpZXcodmlldyk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHZpZXcucmVuZGVyKCkuZWwpO1xuICB9LFxuXG4gIF9pc0RhdGFFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICByZXR1cm4gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIEhpc3RvZ3JhbUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4uL2hpc3RvZ3JhbS9jaGFydCcpO1xuXG4vKipcbiAqIFRpbWUtc2VyaWVzIGhpc3RvZ3JhbSB2aWV3LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS10aW1lU2VyaWVzJyxcblxuICBkZWZhdWx0czoge1xuICAgIG1vYmlsZVRocmVzaG9sZDogOTYwLCAvLyBweDsgc2hvdWxkIG1hdGNoIENTUyBtZWRpYS1xdWVyeVxuICAgIGhpc3RvZ3JhbUNoYXJ0SGVpZ2h0OlxuICAgICAgNDggKyAvLyBpbmxpbmUgYmFycyBoZWlnaHRcbiAgICAgIDQgKyAvLyBib3R0b20gbWFyZ2luXG4gICAgICAxNiArIC8vIGxhYmVsc1xuICAgICAgNCwgLy8gbWFyZ2luc1xuICAgIGhpc3RvZ3JhbUNoYXJ0TW9iaWxlSGVpZ2h0OlxuICAgICAgMjAgKyAvLyBpbmxpbmUgYmFycyBoZWlnaHQgKG5vIGJvdHRvbSBsYWJlbHMpXG4gICAgICA0IC8vIG1hcmdpbnNcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXI7XG5cbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25DaGFuZ2VEYXRhLCB0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuX2NyZWF0ZUhpc3RvZ3JhbVZpZXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfY3JlYXRlSGlzdG9ncmFtVmlldzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhcnRWaWV3ID0gbmV3IEhpc3RvZ3JhbUNoYXJ0Vmlldyh7XG4gICAgICB0eXBlOiAndGltZScsXG4gICAgICBhbmltYXRpb25TcGVlZDogMTAwLFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgcmlnaHQ6IDQsXG4gICAgICAgIGJvdHRvbTogNCxcbiAgICAgICAgbGVmdDogNFxuICAgICAgfSxcbiAgICAgIGhhc0hhbmRsZXM6IHRydWUsXG4gICAgICBhbmltYXRpb25CYXJEZWxheTogZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gKGkgKiAzKTtcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHRoaXMuZGVmYXVsdHMuaGlzdG9ncmFtQ2hhcnRIZWlnaHQsXG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLmdldERhdGEoKVxuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLl9jaGFydFZpZXcpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9jaGFydFZpZXcucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5zaG93KCk7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcuYmluZCgnb25fYnJ1c2hfZW5kJywgdGhpcy5fb25CcnVzaEVuZCwgdGhpcyk7XG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTp3aWR0aCcsIHRoaXMuX29uQ2hhbmdlQ2hhcnRXaWR0aCwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLl9jaGFydFZpZXcubW9kZWwpO1xuICB9LFxuXG4gIF9vbkNoYW5nZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jaGFydFZpZXcpIHtcbiAgICAgIHRoaXMuX2NoYXJ0Vmlldy5yZXBsYWNlRGF0YSh0aGlzLm1vZGVsLmdldERhdGEoKSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkJydXNoRW5kOiBmdW5jdGlvbihsb0JhckluZGV4LCBoaUJhckluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICB0aGlzLmZpbHRlci5zZXRSYW5nZShcbiAgICAgIGRhdGFbbG9CYXJJbmRleF0uc3RhcnQsXG4gICAgICBkYXRhW2hpQmFySW5kZXggLSAxXS5lbmRcbiAgICApO1xuICB9LFxuXG4gIF9vbkNoYW5nZUNoYXJ0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc01vYmlsZVNpemUgPSAkKHdpbmRvdykud2lkdGgoKSA8IHRoaXMuZGVmYXVsdHMubW9iaWxlVGhyZXNob2xkO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3LnRvZ2dsZUxhYmVscyghaXNNb2JpbGVTaXplKTtcblxuICAgIHZhciBoZWlnaHQgPSBpc01vYmlsZVNpemVcbiAgICAgID8gdGhpcy5kZWZhdWx0cy5oaXN0b2dyYW1DaGFydE1vYmlsZUhlaWdodFxuICAgICAgOiB0aGlzLmRlZmF1bHRzLmhpc3RvZ3JhbUNoYXJ0SGVpZ2h0O1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5tb2RlbC5zZXQoJ2hlaWdodCcsIGhlaWdodCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LWhlYWRlciBDREItV2lkZ2V0LWhlYWRlci0tdGltZVNlcmllc1wiPiAnO1xuIGlmIChoYXNUb3JxdWVMYXllcikgeyBcbl9fcCs9JyA8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC10aW1lU2VyaWVzRmFrZUNvbnRyb2xcIj48L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGltZVNlcmllc1RpbWVJbmZvIENEQi1XaWRnZXQtdGltZVNlcmllc1RpbWVJbmZvLS1mYWtlXCI+PC9kaXY+ICc7XG4gfSBcbl9fcCs9JyA8L2Rpdj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtY29udGVudCBDREItV2lkZ2V0LWNvbnRlbnQtLXRpbWVTZXJpZXNcIj4gPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtdGltZVNlcmllc0Zha2VDaGFydCAnO1xuIGlmIChoYXNUb3JxdWVMYXllcikgeyBcbl9fcCs9J0NEQi1XaWRnZXQtdGltZVNlcmllc0Zha2VDaGFydC0tdG9ycXVlJztcbiB9IFxuX19wKz0nXCI+ICc7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgaSsrKSB7IFxuX19wKz0nIDxkaXYgY2xhc3M9XCJDREItV2lkZ2V0LXRpbWVTZXJpZXNGYWtlQ2hhcnRJdGVtXCIgc3R5bGU9XCJoZWlnaHQ6ICcrXG4oKF9fdD0oIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nJVwiPjwvZGl2PiAnO1xuIH0gXG5fX3ArPScgPC9kaXY+IDwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdG9ycXVlVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS10ZW1wbGF0ZS50cGwnKTtcbnZhciBwbGFjZWhvbGRlclRlbXBsYXRlID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlci50cGwnKTtcbnZhciBUb3JxdWVIZWFkZXJWaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtaGVhZGVyLXZpZXcnKTtcbnZhciBUb3JxdWVIaXN0b2dyYW1WaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtaGlzdG9ncmFtLXZpZXcnKTtcblxuLyoqXG4gKiBXaWRnZXQgY29udGVudCB2aWV3IGZvciBhIFRvcnF1ZSB0aW1lLXNlcmllc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWJvZHkgQ0RCLVdpZGdldC1ib2R5LS10aW1lU2VyaWVzJyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsID0gdGhpcy5vcHRpb25zLnRvcnF1ZUxheWVyTW9kZWw7XG4gICAgdGhpcy5tb2RlbC5vbmNlKCdjaGFuZ2U6ZGF0YScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuXG4gICAgaWYgKHRoaXMuX2lzRGF0YUVtcHR5KCkpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwocGxhY2Vob2xkZXJUZW1wbGF0ZSh7XG4gICAgICAgIGhhc1RvcnF1ZUxheWVyOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwodG9ycXVlVGVtcGxhdGUoKSk7XG5cbiAgICAgIHRoaXMuX2FwcGVuZFZpZXcoXG4gICAgICAgIG5ldyBUb3JxdWVIZWFkZXJWaWV3KHtcbiAgICAgICAgICBlbDogdGhpcy4kKCcuanMtaGVhZGVyJyksXG4gICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgdG9ycXVlTGF5ZXJNb2RlbDogdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVG9ycXVlSGlzdG9ncmFtVmlldyh0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5fYXBwZW5kVmlldyh2aWV3KTtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh2aWV3LmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfYXBwZW5kVmlldzogZnVuY3Rpb24odmlldykge1xuICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICB2aWV3LnJlbmRlcigpO1xuICB9LFxuXG4gIF9pc0RhdGFFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldERhdGEoKTtcbiAgICByZXR1cm4gXy5pc0VtcHR5KGRhdGEpIHx8IF8uc2l6ZShkYXRhKSA9PT0gMDtcbiAgfVxufSk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS1jb250cm9scy50cGwnKTtcblxuLyoqXG4gKiBUb3JxdWUgYW5pbWF0aW9uIGNvbnRyb2xzLCB0byBtYW5hZ2UgcnVuIHN0YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIHRhZ05hbWU6ICdidXR0b24nLFxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWNvbnRyb2xCdXR0b24nLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayc6ICdfb25DbGljaydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTppc1J1bm5pbmcnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFxuICAgICAgdGVtcGxhdGUoe1xuICAgICAgICBpY29uQ2xhc3M6ICdDREItV2lkZ2V0LWNvbnRyb2xCdXR0b24taWNvbiBDREItV2lkZ2V0LWNvbnRyb2xCdXR0b24taWNvbi0tJyArIChcbiAgICAgICAgICB0aGlzLm1vZGVsLmdldCgnaXNSdW5uaW5nJylcbiAgICAgICAgICAgID8gJ3BhdXNlJ1xuICAgICAgICAgICAgOiAncGxheScpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdpc1J1bm5pbmcnKSkge1xuICAgICAgdGhpcy5tb2RlbC5wYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vZGVsLnBsYXkoKTtcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iail7XG52YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4scHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcbndpdGgob2JqfHx7fSl7XG5fX3ArPSc8ZGl2IGNsYXNzPVwiQ0RCLVdpZGdldC1jb250cm9sQnV0dG9uLWNvbnRlbnRcIj4gPGkgY2xhc3M9XCInK1xuKChfX3Q9KCBpY29uQ2xhc3MgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nXCI+PC9pPiA8L2Rpdj4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgZDMgPSBjZGIuZDM7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS1jdW11bGF0aXZlLXJlbmRlci1pbmZvLnRwbCcpO1xuXG4vKipcbiAqIFZpZXcgZm9yIHRvIGRpc3BsYXkgaW5mbyBhYm91dCB0aGUgY3VtdWxhdGl2ZSByZW5kZXIgZGF0YSwgZS5nLiB0aGUgdGltZSByYW5nZSB0aGF0J3MgYmVpbmcgZGlzcGxheWVkXG4gKiB0aGlzLm1vZGVsIGlzIGV4cGVjdGVkIHRvIGJlIGEgdG9ycXVlTGF5ZXIgbW9kZWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCA9IHRoaXMub3B0aW9ucy50b3JxdWVMYXllck1vZGVsO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldCgnZGF0YScpO1xuICAgIHRoaXMuX3NjYWxlID0gZDMudGltZS5zY2FsZSgpXG4gICAgICAuZG9tYWluKFtkYXRhWzBdLnN0YXJ0ICogMTAwMCwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmVuZCAqIDEwMDBdKVxuICAgICAgLm5pY2UoKVxuICAgICAgLnJhbmdlKFswLCB0aGlzLm1vZGVsLmdldCgnYmlucycpXSk7XG5cbiAgICAvLyBmb3IgZm9ybWF0IHJ1bGVzIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9UaW1lLUZvcm1hdHRpbmdcbiAgICB0aGlzLl90aW1lRm9ybWF0dGVyID0gZDMudGltZS5mb3JtYXQoJyVIOiVNJyk7XG4gICAgdGhpcy5fZGF0ZUZvcm1hdHRlciA9IGQzLnRpbWUuZm9ybWF0KCcleCcpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1bXVsYXRpdmVSZW5kZXIgPSB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnY3VtdWxhdGl2ZVJlbmRlcicpXG5cbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHtcbiAgICAgIHRpbWVGb3JtYXR0ZXI6IHRoaXMuX3RpbWVGb3JtYXR0ZXIsXG4gICAgICBkYXRlRm9ybWF0dGVyOiB0aGlzLl9kYXRlRm9ybWF0dGVyLFxuICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSh0aGlzLl9zY2FsZS5pbnZlcnQoY3VtdWxhdGl2ZVJlbmRlci5zdGFydCkpLFxuICAgICAgZW5kRGF0ZTogbmV3IERhdGUodGhpcy5fc2NhbGUuaW52ZXJ0KGN1bXVsYXRpdmVSZW5kZXIuZW5kKSlcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKXtcbnZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xud2l0aChvYmp8fHt9KXtcbl9fcCs9JzxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnIENEQi1XaWRnZXQtdGV4dC0tc2Vjb25kYXJ5XCI+IFNlbGVjdGVkIGZyb20gPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZ1wiPiAnK1xuKChfX3Q9KCB0aW1lRm9ybWF0dGVyKHN0YXJ0RGF0ZSkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nICcrXG4oKF9fdD0oIGRhdGVGb3JtYXR0ZXIoc3RhcnREYXRlKSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZyBDREItV2lkZ2V0LXRleHQtLXNlY29uZGFyeVwiPiB0byA8L3A+IDxwIGNsYXNzPVwiQ0RCLVdpZGdldC10ZXh0QmlnXCI+ICcrXG4oKF9fdD0oIHRpbWVGb3JtYXR0ZXIoZW5kRGF0ZSkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nICcrXG4oKF9fdD0oIGRhdGVGb3JtYXR0ZXIoZW5kRGF0ZSkgKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXG4nIDwvcD4nO1xufVxucmV0dXJuIF9fcDtcbn07XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIFRvcnF1ZUNvbnRyb2xzVmlldyA9IHJlcXVpcmUoJy4vdG9ycXVlLWNvbnRyb2xzLXZpZXcnKTtcbnZhciBUb3JxdWVUaW1lSW5mb1ZpZXcgPSByZXF1aXJlKCcuL3RvcnF1ZS10aW1lLWluZm8tdmlldycpO1xudmFyIFRvcnF1ZUN1bXVsYXRpdmVSZW5kZXJJbmZvVmlldyA9IHJlcXVpcmUoJy4vdG9ycXVlLWN1bXVsYXRpdmUtcmVuZGVyLWluZm8tdmlldycpO1xudmFyIFRvcnF1ZVJlc2V0Q3VtdWxhdGl2ZVJlbmRlclZpZXcgPSByZXF1aXJlKCcuL3RvcnF1ZS1yZXNldC1jdW11bGF0aXZlLXJlbmRlci12aWV3Jyk7XG5cbi8qKlxuICogVmlldyBmb3IgdGhlIGhlYWRlciBpbiB0aGUgdG9ycXVlIHRpbWUtc2VyaWVzIHZpZXdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCA9IHRoaXMub3B0aW9ucy50b3JxdWVMYXllck1vZGVsO1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuYmluZCgnY2hhbmdlOmN1bXVsYXRpdmVSZW5kZXInLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgdGhpcy5hZGRfcmVsYXRlZF9tb2RlbCh0aGlzLl90b3JxdWVMYXllck1vZGVsKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuXG4gICAgaWYgKHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuZ2V0KCdjdW11bGF0aXZlUmVuZGVyJykpIHtcbiAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnQ0RCLVdpZGdldC1jb250ZW50U3BhY2VkJyk7XG4gICAgICAvLyBUT0RPIGltcGxlbWVudCB2aWV3IGZvciBzZWxlY3RlZCByYW5nZSBvZiBjdW11bGF0aXZlUmVuZGVyICsgY2xlYXItYnV0dG9uXG4gICAgICB0aGlzLl9hcHBlbmRWaWV3KFxuICAgICAgICBuZXcgVG9ycXVlQ3VtdWxhdGl2ZVJlbmRlckluZm9WaWV3KHtcbiAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICB0b3JxdWVMYXllck1vZGVsOiB0aGlzLl90b3JxdWVMYXllck1vZGVsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5fYXBwZW5kVmlldyhcbiAgICAgICAgbmV3IFRvcnF1ZVJlc2V0Q3VtdWxhdGl2ZVJlbmRlclZpZXcoe1xuICAgICAgICAgIG1vZGVsOiB0aGlzLl90b3JxdWVMYXllck1vZGVsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ0NEQi1XaWRnZXQtY29udGVudFNwYWNlZCcpO1xuICAgICAgdGhpcy5fYXBwZW5kVmlldyhcbiAgICAgICAgbmV3IFRvcnF1ZUNvbnRyb2xzVmlldyh7XG4gICAgICAgICAgbW9kZWw6IHRoaXMuX3RvcnF1ZUxheWVyTW9kZWxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLl9hcHBlbmRWaWV3KFxuICAgICAgICBuZXcgVG9ycXVlVGltZUluZm9WaWV3KHtcbiAgICAgICAgICBtb2RlbDogdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfYXBwZW5kVmlldzogZnVuY3Rpb24odmlldykge1xuICAgIHRoaXMuYWRkVmlldyh2aWV3KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodmlldy5lbCk7XG4gICAgdmlldy5yZW5kZXIoKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IGNkYi4kO1xudmFyIFZpZXcgPSBjZGIuY29yZS5WaWV3O1xudmFyIEhpc3RvZ3JhbUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4uL2hpc3RvZ3JhbS9jaGFydCcpO1xudmFyIFRvcnF1ZVRpbWVTbGlkZXJWaWV3ID0gcmVxdWlyZSgnLi90b3JxdWUtdGltZS1zbGlkZXItdmlldycpO1xuXG4vKipcbiAqIFRvcnF1ZSB0aW1lLXNlcmllcyBoaXN0b2dyYW0gdmlldy5cbiAqIEV4dGVuZHMgdGhlIGNvbW1vbiBoaXN0b2dyYW0gY2hhcnQgdmlldyB3aXRoIHRpbWUtY29udHJvbFxuICogdGhpcy5tb2RlbCBpcyBhIGhpc3RvZ3JhbSBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0LWNvbnRlbnQgQ0RCLVdpZGdldC1jb250ZW50LS10aW1lU2VyaWVzJyxcblxuICAvLyBUT0RPIGNvdWxkIGJlIGNhbGN1bGF0ZWQgZnJvbSBlbGVtZW50IHN0eWxlcyBpbnN0ZWFkIG9mIGR1cGxpY2F0ZWQgbnVtYmVycyBoZXJlP1xuICBkZWZhdWx0czoge1xuICAgIG1vYmlsZVRocmVzaG9sZDogOTYwLCAvLyBweDsgc2hvdWxkIG1hdGNoIENTUyBtZWRpYS1xdWVyeVxuICAgIGhpc3RvZ3JhbUNoYXJ0SGVpZ2h0OlxuICAgICAgNDggKyAvLyBpbmxpbmUgYmFycyBoZWlnaHRcbiAgICAgIDQgKyAvLyBib3R0b20gbWFyZ2luXG4gICAgICAxNiArIC8vIGJvdHRvbSBsYWJlbHNcbiAgICAgIDQsIC8vIG1hcmdpbnNcbiAgICBoaXN0b2dyYW1DaGFydE1vYmlsZUhlaWdodDpcbiAgICAgIDIwICsgLy8gaW5saW5lIGJhcnMgaGVpZ2h0IChubyBib3R0b20gbGFiZWxzKVxuICAgICAgNCAvLyBtYXJnaW5zXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbCkgdGhyb3cgbmV3IEVycm9yKCd0b3JxZUxheWVyTW9kZWwgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yYW5nZUZpbHRlcikgdGhyb3cgbmV3IEVycm9yKCdyYW5nZUZpbHRlciBpcyByZXF1aXJlZCcpO1xuXG4gICAgdGhpcy5fcmFuZ2VGaWx0ZXIgPSB0aGlzLm9wdGlvbnMucmFuZ2VGaWx0ZXI7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCA9IHRoaXMub3B0aW9ucy50b3JxdWVMYXllck1vZGVsO1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuYmluZCgnY2hhbmdlOmN1bXVsYXRpdmVSZW5kZXInLCB0aGlzLl9vbkNoYW5nZUN1bXVsYXRpdmVSZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5fdG9ycXVlTGF5ZXJNb2RlbCk7XG5cbiAgICB0aGlzLm1vZGVsLmJpbmQoJ2NoYW5nZTpkYXRhJywgdGhpcy5fb25DaGFuZ2VEYXRhLCB0aGlzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJTdWJWaWV3cygpO1xuICAgIHRoaXMuX2NyZWF0ZUhpc3RvZ3JhbVZpZXcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfY3JlYXRlSGlzdG9ncmFtVmlldzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhcnRWaWV3ID0gbmV3IEhpc3RvZ3JhbUNoYXJ0Vmlldyh7XG4gICAgICB0eXBlOiAndGltZScsXG4gICAgICBhbmltYXRpb25TcGVlZDogMTAwLFxuICAgICAgYW5pbWF0aW9uQmFyRGVsYXk6IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIChpICogMyk7XG4gICAgICB9LFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgcmlnaHQ6IDQsXG4gICAgICAgIGJvdHRvbTogNCxcbiAgICAgICAgbGVmdDogNFxuICAgICAgfSxcbiAgICAgIGhhc0hhbmRsZXM6IHRydWUsXG4gICAgICBoZWlnaHQ6IHRoaXMuZGVmYXVsdHMuaGlzdG9ncmFtQ2hhcnRIZWlnaHQsXG4gICAgICBkYXRhOiB0aGlzLm1vZGVsLmdldERhdGEoKSxcbiAgICAgIHNoYWRvd0RhdGE6IHRoaXMubW9kZWwuZ2V0RGF0YSgpXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZFZpZXcodGhpcy5fY2hhcnRWaWV3KTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5fY2hhcnRWaWV3LnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLl9jaGFydFZpZXcuc2hvdygpO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3LmJpbmQoJ29uX2JydXNoX2VuZCcsIHRoaXMuX29uQnJ1c2hFbmQsIHRoaXMpO1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5tb2RlbC5iaW5kKCdjaGFuZ2U6d2lkdGgnLCB0aGlzLl9vbkNoYW5nZUNoYXJ0V2lkdGgsIHRoaXMpO1xuICAgIHRoaXMuYWRkX3JlbGF0ZWRfbW9kZWwodGhpcy5fY2hhcnRWaWV3Lm1vZGVsKTtcblxuICAgIHZhciB0aW1lU2xpZGVyVmlldyA9IG5ldyBUb3JxdWVUaW1lU2xpZGVyVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbCwgLy8gYSBoaXN0b2dyYW0gbW9kZWxcbiAgICAgIGNoYXJ0VmlldzogdGhpcy5fY2hhcnRWaWV3LFxuICAgICAgdG9ycXVlTGF5ZXJNb2RlbDogdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuYWRkVmlldyh0aW1lU2xpZGVyVmlldyk7XG4gICAgdGltZVNsaWRlclZpZXcucmVuZGVyKCk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NoYXJ0Vmlldykge1xuICAgICAgdGhpcy5fY2hhcnRWaWV3LnJlcGxhY2VEYXRhKHRoaXMubW9kZWwuZ2V0RGF0YSgpKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlQ3VtdWxhdGl2ZVJlbmRlcjogZnVuY3Rpb24obSwgdmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHRoaXMuX2NoYXJ0Vmlldy5yZW1vdmVTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQnJ1c2hFbmQ6IGZ1bmN0aW9uKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuZ2V0RGF0YSgpO1xuICAgIHRoaXMuX3JhbmdlRmlsdGVyLnNldFJhbmdlKFxuICAgICAgZGF0YVtsb0JhckluZGV4XS5zdGFydCxcbiAgICAgIGRhdGFbaGlCYXJJbmRleCAtIDFdLmVuZFxuICAgICk7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5zZXRDdW11bGF0aXZlUmVuZGVyKGxvQmFySW5kZXgsIGhpQmFySW5kZXgpO1xuICB9LFxuXG4gIF9vbkNoYW5nZUNoYXJ0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc01vYmlsZVNpemUgPSAkKHdpbmRvdykud2lkdGgoKSA8IHRoaXMuZGVmYXVsdHMubW9iaWxlVGhyZXNob2xkO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3LnRvZ2dsZUxhYmVscyghaXNNb2JpbGVTaXplKTtcblxuICAgIHZhciBoZWlnaHQgPSBpc01vYmlsZVNpemVcbiAgICAgID8gdGhpcy5kZWZhdWx0cy5oaXN0b2dyYW1DaGFydE1vYmlsZUhlaWdodFxuICAgICAgOiB0aGlzLmRlZmF1bHRzLmhpc3RvZ3JhbUNoYXJ0SGVpZ2h0O1xuICAgIHRoaXMuX2NoYXJ0Vmlldy5tb2RlbC5zZXQoJ2hlaWdodCcsIGhlaWdodCk7XG4gIH1cblxufSk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS1yZXNldC1jdW11bGF0aXZlLXJlbmRlci50cGwnKTtcblxuLyoqXG4gKiBWaWV3IHRvIHJlc2V0IGN1bXVsYXRpdmUgcmVuZGVyLlxuICogdGhpcy5tb2RlbCBpcyBleHBlY3RlZCB0byBiZSBhIHRvcnF1ZUxheWVyIG1vZGVsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtZmlsdGVyQnV0dG9ucycsXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuanMtY2xlYXInOiAnX29uQ2xpY2snXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9vbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnJlc2V0Q3VtdWxhdGl2ZVJlbmRlcigpO1xuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGJ1dHRvbiBjbGFzcz1cIkNEQi1XaWRnZXQtbGluayBDREItV2lkZ2V0LWZpbHRlckJ1dHRvbiBqcy1jbGVhclwiPkNsZWFyIHNlbGVjdGlvbjwvYnV0dG9uPic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPGRpdiBjbGFzcz1cIkNEQi1XaWRnZXQtaGVhZGVyIENEQi1XaWRnZXQtaGVhZGVyLS10aW1lU2VyaWVzIGpzLWhlYWRlclwiPjwvZGl2Pic7XG59XG5yZXR1cm4gX19wO1xufTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgZDMgPSBjZGIuZDM7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RvcnF1ZS10aW1lLWluZm8udHBsJyk7XG5cbi8qKlxuICogVmlldyByZW5kZXJpbmcgdGhlIGN1cnJlbnQgc3RlcCB0aW1lXG4gKlxuICogTW9kZWwgaXMgZXhwZWN0ZWQgdG8gYmUgYSB0b3JxdWUgbGF5ZXIgbW9kZWxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAnQ0RCLVdpZGdldC10aW1lU2VyaWVzVGltZUluZm8nLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlOnN0ZXAnLCB0aGlzLnJlbmRlciwgdGhpcyk7XG5cbiAgICAvLyBmb3IgZm9ybWF0IHJ1bGVzIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9UaW1lLUZvcm1hdHRpbmdcbiAgICB0aGlzLl90aW1lRm9ybWF0dGVyID0gZDMudGltZS5mb3JtYXQoJyVIOiVNJyk7XG4gICAgdGhpcy5fZGF0ZUZvcm1hdHRlciA9IGQzLnRpbWUuZm9ybWF0KCcleCcpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGUgPSB0aGlzLm1vZGVsLmdldCgndGltZScpO1xuXG4gICAgdGhpcy4kZWwuaHRtbChcbiAgICAgIGlzTmFOKGRhdGUgJiYgZGF0ZS5nZXRUaW1lKCkpXG4gICAgICAgID8gJydcbiAgICAgICAgOiB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICB0aW1lOiB0aGlzLl90aW1lRm9ybWF0dGVyKGRhdGUpLFxuICAgICAgICAgICAgZGF0ZTogdGhpcy5fZGF0ZUZvcm1hdHRlcihkYXRlKVxuICAgICAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmope1xudmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLHByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XG53aXRoKG9ianx8e30pe1xuX19wKz0nPHAgY2xhc3M9XCJDREItV2lkZ2V0LXRleHRCaWdcIj4gJytcbigoX190PSggdGltZSApKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcbicgPC9wPiA8cCBjbGFzcz1cIkNEQi1XaWRnZXQtdGV4dEJpZyBDREItV2lkZ2V0LXRleHQtLXNlY29uZGFyeVwiPiAnK1xuKChfX3Q9KCBkYXRlICkpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xuJyA8L3A+Jztcbn1cbnJldHVybiBfX3A7XG59O1xuIiwidmFyIGQzID0gY2RiLmQzO1xudmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG52YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG5cbi8qKlxuICogVGltZS1zbGlkZXIsIGV4cGVjdGVkIHRvIGJlIHVzZWQgaW4gYSBoaXN0b2dyYW0gdmlld1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHdpZHRoOiA0LFxuICAgIGhlaWdodDogOFxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLm1vZGVsKSB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY2hhcnRWaWV3KSB0aHJvdyBuZXcgRXJyb3IoJ2NoYXJ0VmlldyBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnRvcnF1ZUxheWVyTW9kZWwpIHRocm93IG5ldyBFcnJvcigndG9ycWVMYXllck1vZGVsIGlzIHJlcXVpcmVkJyk7XG5cbiAgICB0aGlzLl9jaGFydFZpZXcgPSB0aGlzLm9wdGlvbnMuY2hhcnRWaWV3O1xuICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwgPSB0aGlzLm9wdGlvbnMudG9ycXVlTGF5ZXJNb2RlbDtcbiAgICB0aGlzLnZpZXdNb2RlbCA9IG5ldyBNb2RlbCgpO1xuXG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5iaW5kKCdjaGFuZ2U6c3RlcCcsIHRoaXMuX29uQ2hhbmdlU3RlcCwgdGhpcyk7XG4gICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5iaW5kKCdjaGFuZ2U6c3RlcHMnLCB0aGlzLl9vbkNoYW5nZVN0ZXBzLCB0aGlzKTtcbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLmJpbmQoJ2NoYW5nZTpzdGVwc1JhbmdlJywgdGhpcy5fb25TdGVwc1JhbmdlLCB0aGlzKTtcbiAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLmJpbmQoJ2NoYW5nZTpjdW11bGF0aXZlUmVuZGVyJywgdGhpcy5fb25DaGFuZ2VDdW11bGF0aXZlUmVuZGVyLCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwpO1xuXG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTp3aWR0aCcsIHRoaXMuX29uQ2hhbmdlQ2hhcnRXaWR0aCwgdGhpcyk7XG4gICAgdGhpcy5fY2hhcnRWaWV3Lm1vZGVsLmJpbmQoJ2NoYW5nZTpoZWlnaHQnLCB0aGlzLl9vbkNoYW5nZUNoYXJ0SGVpZ2h0LCB0aGlzKTtcbiAgICB0aGlzLmFkZF9yZWxhdGVkX21vZGVsKHRoaXMuX2NoYXJ0Vmlldy5tb2RlbCk7XG5cbiAgICB0aGlzLl91cGRhdGVYU2NhbGUoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE1ha2UgdGhlIHJlbmRlciBjYWxsIGlkZW1wb3RlbnQ7IG9ubHkgY3JlYXRlIHRpbWUgc2xpZGVyIG9uY2VcbiAgICBpZiAoIXRoaXMudGltZVNsaWRlcikge1xuICAgICAgdmFyIGRyYWdCZWhhdmlvciA9IGQzLmJlaGF2aW9yLmRyYWcoKVxuICAgICAgICAub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcykpXG4gICAgICAgIC5vbignZHJhZycsIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKVxuICAgICAgICAub24oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG5cbiAgICAgIHZhciBkM2VsID0gdGhpcy5fY2hhcnRWaWV3LmNhbnZhcy5hcHBlbmQoJ3JlY3QnKTtcbiAgICAgIHRoaXMudGltZVNsaWRlciA9IGQzZWxcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ0NEQi1UaW1lU2xpZGVyJylcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5kZWZhdWx0cy53aWR0aClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuX2NhbGNIZWlnaHQoKSlcbiAgICAgICAgLmF0dHIoJ3J4JywgMylcbiAgICAgICAgLmF0dHIoJ3J5JywgMylcbiAgICAgICAgLmRhdGEoW3sgeDogMCwgeTogMCB9XSlcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHRoaXMuX3RyYW5zbGF0ZVhZKVxuICAgICAgICAuY2FsbChkcmFnQmVoYXZpb3IpO1xuICAgIH1cbiAgICB0aGlzLnNldEVsZW1lbnQoZDNlbC5ub2RlKCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRpbWVTbGlkZXIpIHtcbiAgICAgIHRoaXMudGltZVNsaWRlci5yZW1vdmUoKTtcbiAgICB9XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfSxcblxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc1J1bm5pbmcgPSB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnaXNSdW5uaW5nJyk7XG4gICAgaWYgKGlzUnVubmluZykge1xuICAgICAgdGhpcy5fdG9ycXVlTGF5ZXJNb2RlbC5wYXVzZSgpO1xuICAgIH1cbiAgICB0aGlzLnZpZXdNb2RlbC5zZXQoe1xuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIHdhc1J1bm5pbmc6IGlzUnVubmluZ1xuICAgIH0pO1xuICB9LFxuXG4gIF9vbkRyYWc6IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICB2YXIgbmV4dFggPSBkLnggKyBkMy5ldmVudC5keDtcbiAgICBpZiAodGhpcy5faXNXaXRoaW5SYW5nZShuZXh0WCkpIHtcbiAgICAgIGQueCA9IG5leHRYO1xuICAgICAgdGhpcy50aW1lU2xpZGVyLmF0dHIoJ3RyYW5zZm9ybScsIHRoaXMuX3RyYW5zbGF0ZVhZKTtcblxuICAgICAgdmFyIHN0ZXAgPSBNYXRoLnJvdW5kKHRoaXMuX3hTY2FsZS5pbnZlcnQoZC54KSk7XG4gICAgICB0aGlzLl90b3JxdWVMYXllck1vZGVsLnNldFN0ZXAoc3RlcCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlld01vZGVsLnNldCgnaXNEcmFnZ2luZycsIGZhbHNlKTtcbiAgICBpZiAodGhpcy52aWV3TW9kZWwuZ2V0KCd3YXNSdW5uaW5nJykpIHtcbiAgICAgIHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwucGxheSgpO1xuICAgIH1cbiAgfSxcblxuICBfdHJhbnNsYXRlWFk6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgW2QueCwgZC55XSArICcpJztcbiAgfSxcblxuICBfaXNXaXRoaW5SYW5nZTogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4ID49IDAgJiYgeCA8PSB0aGlzLl93aWR0aCgpO1xuICB9LFxuXG4gIF9vbkNoYW5nZVN0ZXA6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRpbWUgc2xpZGVyIG1pZ2h0IG5vdCBiZSBjcmVhdGVkIHdoZW4gdGhpcyBtZXRob2QgaXMgZmlyc3QgY2FsbGVkXG4gICAgaWYgKHRoaXMudGltZVNsaWRlciAmJiAhdGhpcy52aWV3TW9kZWwuZ2V0KCdpc0RyYWdnaW5nJykpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy50aW1lU2xpZGVyLmRhdGEoKTtcbiAgICAgIHZhciBuZXdYID0gdGhpcy5feFNjYWxlKHRoaXMuX3RvcnF1ZUxheWVyTW9kZWwuZ2V0KCdzdGVwJykpO1xuICAgICAgaWYgKCFpc05hTihuZXdYKSkge1xuICAgICAgICBkYXRhWzBdLnggPSBuZXdYO1xuICAgICAgICB0aGlzLnRpbWVTbGlkZXJcbiAgICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuZWFzZSgnbGluZWFyJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdGhpcy5fdHJhbnNsYXRlWFkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfb25DaGFuZ2VTdGVwczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlWFNjYWxlKCk7XG4gIH0sXG5cbiAgX29uU3RlcHNSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnc3RlcHNSYW5nZScpO1xuICAgIGlmIChyLnN0YXJ0ID09PSAwICYmIHIuZW5kID09PSB0aGlzLm1vZGVsLmdldCgnYmlucycpKSB7XG4gICAgICB0aGlzLl9jaGFydFZpZXcucmVtb3ZlU2VsZWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoYXJ0Vmlldy5zZWxlY3RSYW5nZShyLnN0YXJ0LCByLmVuZCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNoYW5nZUN1bXVsYXRpdmVSZW5kZXI6IGZ1bmN0aW9uKG0sIHZhbCkge1xuICAgIHRoaXMuJGVsLnRvZ2dsZSghdmFsKTtcbiAgfSxcblxuICBfb25DaGFuZ2VDaGFydFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91cGRhdGVYU2NhbGUoKTtcbiAgICB0aGlzLl9vbkNoYW5nZVN0ZXAoKTtcbiAgfSxcblxuICBfb25DaGFuZ2VDaGFydEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lU2xpZGVyLmF0dHIoJ2hlaWdodCcsIHRoaXMuX2NhbGNIZWlnaHQoKSk7XG4gIH0sXG5cbiAgX2NhbGNIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydFZpZXcuY2hhcnRIZWlnaHQoKSArIHRoaXMuZGVmYXVsdHMuaGVpZ2h0O1xuICB9LFxuXG4gIF91cGRhdGVYU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3hTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAuZG9tYWluKFswLCB0aGlzLl90b3JxdWVMYXllck1vZGVsLmdldCgnc3RlcHMnKV0pXG4gICAgICAucmFuZ2UoWzAsIHRoaXMuX3dpZHRoKCldKTtcbiAgfSxcblxuICBfd2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydFZpZXcubW9kZWwuZ2V0KCd3aWR0aCcpO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcblxudmFyIFdpZGdldE1vZGVsRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlcykge1xuICB0eXBlcyA9IHR5cGVzIHx8IHt9O1xuICB0aGlzLnR5cGVzID0ge307XG4gIGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcbiAgICB2YXIgY3JlYXRlTW9kZWwgPSB0eXBlc1t0eXBlXTtcbiAgICB0aGlzLmFkZFR5cGUodHlwZSwgY3JlYXRlTW9kZWwpO1xuICB9XG59O1xuXG5XaWRnZXRNb2RlbEZhY3RvcnkucHJvdG90eXBlLmFkZFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3JlYXRlTW9kZWwpIHtcbiAgaWYgKCFfLmlzU3RyaW5nKHR5cGUpKSBuZXcgRXJyb3IoJ3R5cGUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uJyk7XG4gIGlmICghXy5pc0Z1bmN0aW9uKGNyZWF0ZU1vZGVsKSkgbmV3IEVycm9yKCdjcmVhdGVNb2RlbCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy50eXBlc1t0eXBlXSA9IGNyZWF0ZU1vZGVsO1xufTtcblxuV2lkZ2V0TW9kZWxGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChsYXllciwgbGF5ZXJJbmRleCwgYXR0cnMpIHtcbiAgaWYgKCFhdHRycy5pZCkgdGhyb3cgbmV3IEVycm9yKCdhdHRycy5pZCBpcyByZXF1aXJlZCcpO1xuXG4gIHZhciBjcmVhdGVNb2RlbCA9IHRoaXMudHlwZXNbYXR0cnMudHlwZV07XG4gIGlmIChjcmVhdGVNb2RlbCkge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgbGF5ZXI6IGxheWVyXG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlTW9kZWwoYXR0cnMsIG9wdHMsIGxheWVySW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gbW9kZWwgZm91bmQgZm9yIGFyZ3VtZW50cyAnICsgYXJndW1lbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRNb2RlbEZhY3Rvcnk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgXyA9IGNkYi5fO1xuXG4vKipcbiAqIFN0YW5kYXJkIHdpZGdldCB0b29sdGlwIHZpZXdcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ0NEQi1XaWRnZXQtdG9vbHRpcCcsXG5cbiAgb3B0aW9uczoge1xuICAgIGF0dHJpYnV0ZTogJ2RhdGEtdG9vbHRpcCcsXG4gICAgb2Zmc2V0WDogMTAsXG4gICAgb2Zmc2V0WTogLTI4XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgIGlmICghb3B0cy50YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICAgIHRoaXMuXyR0YXJnZXQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0O1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5fJHRhcmdldC5hdHRyKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGUpO1xuICAgIHRoaXMuJGVsLmh0bWwodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuXyR0YXJnZXQuaG92ZXIoXG4gICAgICBfLmJpbmQodGhpcy5zaG93LCB0aGlzKSxcbiAgICAgIF8uYmluZCh0aGlzLmhpZGUsIHRoaXMpXG4gICAgKTtcbiAgfSxcblxuICBfc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3MgPSB0aGlzLl8kdGFyZ2V0Lm9mZnNldCgpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuJGVsLm91dGVyV2lkdGgoKTtcblxuICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICB0b3A6IHBvcy50b3AgKyB0aGlzLm9wdGlvbnMub2Zmc2V0WSxcbiAgICAgIGxlZnQ6IHBvcy5sZWZ0IC0gKHdpZHRoLzIpICsgdGhpcy5vcHRpb25zLm9mZnNldFhcbiAgICB9KTtcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgVmlldy5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMpO1xuICB9LFxuXG4gIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl8kdGFyZ2V0Lm9mZignbW91c2VlbnRlciBtb3VzZWxlYXZlJyk7XG4gICAgVmlldy5wcm90b3R5cGUuY2xlYW4uY2FsbCh0aGlzKTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgV2lkZ2V0VmlldyA9IHJlcXVpcmUoJy4vd2lkZ2V0LXZpZXcnKTtcblxudmFyIFdpZGdldFZpZXdGYWN0b3J5ID0gZnVuY3Rpb24oZGVmcykge1xuICB0aGlzLmRlZnMgPSBbXTtcbiAgXy5lYWNoKGRlZnMsIGZ1bmN0aW9uKGRlZikge1xuICAgIHRoaXMuYWRkVHlwZShkZWYpO1xuICB9LCB0aGlzKTtcbn07XG5cbldpZGdldFZpZXdGYWN0b3J5LnByb3RvdHlwZS5ERUZBVUxUX0NMQVNTX05BTUVTID0gJ0NEQi1XaWRnZXQgQ0RCLVdpZGdldC0tbGlnaHQnO1xuXG5XaWRnZXRWaWV3RmFjdG9yeS5wcm90b3R5cGUuYWRkVHlwZSA9IGZ1bmN0aW9uKGRlZikge1xuICBpZiAoIWRlZi5tYXRjaCkge1xuICAgIGlmIChkZWYudHlwZSkge1xuICAgICAgZGVmLm1hdGNoID0gZnVuY3Rpb24od2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB3aWRnZXQuZ2V0KCd0eXBlJykgPT09IHRoaXMudHlwZTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBFcnJvcignZGVmLnR5cGUgb3IgZGVmLm1hdGNoIG11c3QgYmUgcHJvdmlkZWQgZm9yIGNyZWF0ZUNvbnRlbnRWaWV3IHRvIHdvcmsnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFfLmlzRnVuY3Rpb24oZGVmLmNyZWF0ZUNvbnRlbnRWaWV3KSkgbmV3IEVycm9yKCdkZWYuY3JlYXRlQ29udGVudFZpZXcgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMuZGVmcy5wdXNoKGRlZik7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3QsIHVuZGVmaW5lZH0gUmV0dXJucyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vdCBtYXRjaGluZyB2aWV3IGZvciB0aGUgZ2l2ZW4gbW9kZWxcbiAqL1xuV2lkZ2V0Vmlld0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVdpZGdldFZpZXcgPSBmdW5jdGlvbih3aWRnZXQpIHtcbiAgdmFyIGRlZiA9IF8uZmluZCh0aGlzLmRlZnMsIGZ1bmN0aW9uKGRlZikge1xuICAgIHJldHVybiBkZWYubWF0Y2god2lkZ2V0KTtcbiAgfSk7XG5cbiAgaWYgKGRlZikge1xuICAgIHZhciBhdHRycyA9IHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5ERUZBVUxUX0NMQVNTX05BTUVTLFxuICAgICAgbW9kZWw6IHdpZGdldCxcbiAgICAgIGNvbnRlbnRWaWV3OiBkZWYuY3JlYXRlQ29udGVudFZpZXcod2lkZ2V0KVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFdpZGdldFZpZXcoXG4gICAgICBfLmlzRnVuY3Rpb24oZGVmLmN1c3RvbWl6ZVdpZGdldEF0dHJzKVxuICAgICAgICA/IGRlZi5jdXN0b21pemVXaWRnZXRBdHRycyhhdHRycylcbiAgICAgICAgOiBhdHRyc1xuICAgICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0Vmlld0ZhY3Rvcnk7XG4iLCJ2YXIgVmlldyA9IGNkYi5jb3JlLlZpZXc7XG52YXIgV2lkZ2V0TG9hZGVyVmlldyA9IHJlcXVpcmUoJy4vc3RhbmRhcmQvd2lkZ2V0X2xvYWRlcl92aWV3Jyk7XG52YXIgV2lkZ2V0RXJyb3JWaWV3ID0gcmVxdWlyZSgnLi9zdGFuZGFyZC93aWRnZXRfZXJyb3JfdmlldycpO1xuXG4vKipcbiAqIERlZmF1bHQgd2lkZ2V0IHZpZXdcbiAqIFRoZSBtb2RlbCBpcyBhIGV4cGVjdGVkIHRvIGJlIHdpZGdldCBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdDREItV2lkZ2V0IENEQi1XaWRnZXQtLWxpZ2h0JyxcblxuICBvcHRpb25zOiB7XG4gICAgY29sdW1uc190aXRsZTogW10sXG4gICAgc3luYzogdHJ1ZVxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubW9kZWwubGF5ZXIuYmluZCgnY2hhbmdlOnZpc2libGUnLCB0aGlzLl9vbkNoYW5nZUxheWVyVmlzaWJsZSwgdGhpcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBuZXcgV2lkZ2V0TG9hZGVyVmlldyh7XG4gICAgICBtb2RlbDogdGhpcy5tb2RlbFxuICAgIH0pO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLl9sb2FkZXIucmVuZGVyKCkuZWwpO1xuICAgIHRoaXMuYWRkVmlldyh0aGlzLl9sb2FkZXIpO1xuXG4gICAgdGhpcy5fZXJyb3IgPSBuZXcgV2lkZ2V0RXJyb3JWaWV3KHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gICAgdGhpcy4kZWwuYXBwZW5kKHRoaXMuX2Vycm9yLnJlbmRlcigpLmVsKTtcbiAgICB0aGlzLmFkZFZpZXcodGhpcy5fZXJyb3IpO1xuXG4gICAgdmFyIGNvbnRlbnRWaWV3ID0gdGhpcy5vcHRpb25zLmNvbnRlbnRWaWV3O1xuICAgIHRoaXMuJGVsLmFwcGVuZChjb250ZW50Vmlldy5yZW5kZXIoKS5lbCk7XG4gICAgdGhpcy5hZGRWaWV3KGNvbnRlbnRWaWV3KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9vbkNoYW5nZUxheWVyVmlzaWJsZTogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAvLyAhISB0byBmb3JjZSBhIGJvb2xlYW4gdmFsdWUsIHNvIG9ubHkgYSB0cnVlIHZhbHVlIGFjdHVhbGx5IHNob3dzIHRoZSB2aWV3XG4gICAgdGhpcy4kZWwudG9nZ2xlKCEhbGF5ZXIuZ2V0KCd2aXNpYmxlJykpO1xuICB9XG59KTtcbiIsInZhciBNb2RlbCA9IGNkYi5jb3JlLk1vZGVsO1xuXG4vKipcbiAqICBWaWV3IG1vZGVsLCBzcGVjaWFsIGZvciB3aWRnZXRzIHdpdGggc2VhcmNoIGFuZCBjb2xsYXBzZVxuICogIGZ1bmN0aW9uYWxpdGllc1xuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICBzZWFyY2g6IGZhbHNlXG4gIH0sXG5cbiAgdG9nZ2xlU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnc2VhcmNoJywgIXRoaXMuZ2V0KCdzZWFyY2gnKSk7XG4gIH0sXG5cbiAgZW5hYmxlU2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnc2VhcmNoJywgdHJ1ZSk7XG4gIH0sXG5cbiAgZGlzYWJsZVNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ3NlYXJjaCcsIGZhbHNlKTtcbiAgfSxcblxuICBpc1NlYXJjaEVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnc2VhcmNoJyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxuLyoqXG4gKiBEZWZhdWx0IHdpZGdldCBtb2RlbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHtcbiAgICB1cmw6ICcnLFxuICAgIGRhdGE6IFtdLFxuICAgIGNvbHVtbnM6IFtdLFxuICAgIHN5bmM6IHRydWUsXG4gICAgYmJveDogdHJ1ZSxcbiAgICBjb2xsYXBzZWQ6IGZhbHNlXG4gIH0sXG5cbiAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3VybCcpICsgJz9iYm94PScgKyB0aGlzLmdldCgnYm91bmRpbmdCb3gnKTtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdGhpcy5sYXllciA9IG9wdHMubGF5ZXI7XG4gICAgdGhpcy5maWx0ZXIgPSBvcHRzLmZpbHRlcjsgLy8gb3B0aW9uYWwvbWlnaHQgYmUgdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9pbml0QmluZHMoKTtcbiAgfSxcblxuICBfaW5pdEJpbmRzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uY2UoJ2NoYW5nZTp1cmwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuX2ZldGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9vbkNoYW5nZUJpbmRzKCk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIFJldHJpZ2dlciBhbiBldmVudCB3aGVuIHRoZSBmaWx0ZXIgY2hhbmdlc1xuICAgIGlmICh0aGlzLmZpbHRlcikge1xuICAgICAgdGhpcy5maWx0ZXIuYmluZCgnY2hhbmdlJywgdGhpcy5fb25GaWx0ZXJDaGFuZ2VkLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQ2hhbmdlQmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmluZCgnY2hhbmdlOnVybCcsIGZ1bmN0aW9uKCl7XG4gICAgICBpZiAodGhpcy5nZXQoJ3N5bmMnKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6Ym91bmRpbmdCb3gnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdldCgnYmJveCcpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuYmluZCgnY2hhbmdlOmNvbGxhcHNlZCcsIGZ1bmN0aW9uKG1kbCwgaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICghaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKG1kbC5jaGFuZ2VkQXR0cmlidXRlcyh0aGlzLl9wcmV2aW91c0F0dHJzKSkge1xuICAgICAgICAgIHRoaXMuX2ZldGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cnMgPSB7XG4gICAgICAgICAgdXJsOiB0aGlzLmdldCgndXJsJyksXG4gICAgICAgICAgYm91bmRpbmdCb3g6IHRoaXMuZ2V0KCdib3VuZGluZ0JveCcpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX2ZldGNoOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZldGNoKHtcbiAgICAgIHN1Y2Nlc3M6IGNhbGxiYWNrLFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZmV0Y2goKTtcbiAgfSxcblxuICBpc0NvbGxhcHNlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdjb2xsYXBzZWQnKTtcbiAgfSxcblxuICB0b2dnbGVDb2xsYXBzZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdjb2xsYXBzZWQnLCAhdGhpcy5nZXQoJ2NvbGxhcHNlZCcpKTtcbiAgfSxcblxuICBfb25GaWx0ZXJDaGFuZ2VkOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpmaWx0ZXInLCB0aGlzLCBmaWx0ZXIpO1xuICB9LFxuXG4gIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnZGF0YScpO1xuICB9LFxuXG4gIGdldFByZXZpb3VzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXMoJ2RhdGEnKTtcbiAgfSxcblxuICBmZXRjaDogZnVuY3Rpb24ob3B0cykge1xuICAgIHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIiwgdGhpcyk7XG4gICAgcmV0dXJuIE1vZGVsLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsb3B0cyk7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvSlNPTiBzaG91bGQgYmUgZGVmaW5lZCBmb3IgZWFjaCB3aWRnZXQnKTtcbiAgfVxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgXyA9IGNkYi5fO1xuXG4vKipcbiAqICBDb2xsZWN0aW9uIHRoYXQgY29udHJvbHMgd2lkZ2V0IG1vZGVscyBwZXIgbGF5ZXJcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIGEgY2F0ZWdvcnkgbW9kZWwgYXBwbGllcyB0aGUgY2F0ZWdvcnkgY29sb3JzLCByZXN0IHNob3VsZCByZW1vdmUvZGlzYWJsZVxuICAgIC8vIHRoZSBjYXRlZ29yeSBjb2xvcnMgYXBwbGllZCBiZWZvcmUuXG4gICAgdGhpcy5iaW5kKCdjaGFuZ2U6Y2F0ZWdvcnlDb2xvcnMnLCBmdW5jdGlvbihtLCBpc0NvbG9yQ2F0ZWdvcml6ZWQpIHtcbiAgICAgIGlmIChpc0NvbG9yQ2F0ZWdvcml6ZWQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKG1kbCkge1xuICAgICAgICAgIGlmIChtZGwgIT09IG0gJiYgbWRsLmdldCgnY2F0ZWdvcnlDb2xvcnMnKSkge1xuICAgICAgICAgICAgbWRsLnNldCgnY2F0ZWdvcnlDb2xvcnMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gSWYgYSBoaXN0b2dyYW0gbW9kZWwgYXBwbGllcyB0aGUgaGlzdG9ncmFtIHNpemVzLCByZXN0IHNob3VsZCByZW1vdmUvZGlzYWJsZVxuICAgIC8vIHRoZSBzaXplcyBhcHBsaWVkIGJlZm9yZS5cbiAgICB0aGlzLmJpbmQoJ2NoYW5nZTpoaXN0b2dyYW1TaXplcycsIGZ1bmN0aW9uKG0sIGlzU2l6ZXNBcHBsaWVkKSB7XG4gICAgICBpZiAoaXNTaXplc0FwcGxpZWQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKG1kbCkge1xuICAgICAgICAgIGlmIChtZGwgIT09IG0gJiYgbWRsLmdldCgnaGlzdG9ncmFtU2l6ZXMnKSkge1xuICAgICAgICAgICAgbWRsLnNldCgnaGlzdG9ncmFtU2l6ZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9XG5cbn0pO1xuIiwidmFyICQgPSBjZGIuJDtcbnZhciBfID0gY2RiLl87XG52YXIgTFpNQSA9IGNkYi5MWk1BO1xudmFyIHV0aWwgPSBjZGIuY29yZS51dGlsO1xudmFyIFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtaW5zdGFuY2UnKTtcblxudmFyIHZhbGlkYXRlUHJlc2VuY2VPZk9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCByZXF1aXJlZE9wdGlvbnMpIHtcbiAgdmFyIG1pc3NpbmdPcHRpb25zID0gXy5maWx0ZXIocmVxdWlyZWRPcHRpb25zLCBmdW5jdGlvbihvcHRpb24pIHtcbiAgICByZXR1cm4gIW9wdGlvbnNbb3B0aW9uXTtcbiAgfSk7XG4gIGlmIChtaXNzaW5nT3B0aW9ucy5sZW5ndGgpIHtcbiAgICB0aHJvdyAnVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSByZXF1aXJlZDogJyArIG1pc3NpbmdPcHRpb25zLmpvaW4oJywgJyk7XG4gIH1cbn07XG5cbi8qKlxuICogV2luZHNoYWZ0IGNsaWVudC4gSXQgcHJvdmlkZXMgYSBtZXRob2QgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBkYXNoYm9hcmRzLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9ucyB0byBzZXQgdXAgdGhlIGNsaWVudFxuICovXG5XaW5kc2hhZnRDbGllbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhbGlkYXRlUHJlc2VuY2VPZk9wdGlvbnMob3B0aW9ucywgWyd1cmxUZW1wbGF0ZScsICd1c2VyTmFtZScsICdlbmRwb2ludCcsICdzdGF0VGFnJ10pO1xuXG4gIHRoaXMudXJsVGVtcGxhdGUgPSBvcHRpb25zLnVybFRlbXBsYXRlO1xuICB0aGlzLnVzZXJOYW1lID0gb3B0aW9ucy51c2VyTmFtZTtcbiAgdGhpcy5lbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gIHRoaXMuc3RhdFRhZyA9IG9wdGlvbnMuc3RhdFRhZztcbiAgdGhpcy5mb3JjZUNvcnMgPSBvcHRpb25zLmZvcmNlQ29ycyB8fCBmYWxzZTtcblxuICB0aGlzLnVybCA9IHRoaXMudXJsVGVtcGxhdGUucmVwbGFjZSgne3VzZXJ9JywgdGhpcy51c2VyTmFtZSk7XG59O1xuXG5XaW5kc2hhZnRDbGllbnQuREVGQVVMVF9DT01QUkVTU0lPTl9MRVZFTCA9IDM7XG5XaW5kc2hhZnRDbGllbnQuTUFYX0dFVF9TSVpFID0gMjAzMztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgbWFwIGluIFdpbmRzaGFmdFxuICogQHBhcmFtIHtvYmplY3R9IG1hcERlZmluaXRpb24gQW4gb2JqZWN0IHRoYXQgcmVzcG9uZHMgdG8gLnRvSlNPTiB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBtYXBcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgd2lsbCBnZXQgdGhlIHB1YmxpYyBvciBwcml2YXRlIG1hcFxuICogQHJldHVybiB7Y2RiLndpbmRzaGFmdC5EYXNoYm9hcmRJbnN0YW5jZX0gVGhlIGluc3RhbmNlIG9mIHRoZSBkYXNoYm9hcmRcbiAqL1xuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5pbnN0YW50aWF0ZU1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG1hcERlZmluaXRpb24gPSBvcHRpb25zLm1hcERlZmluaXRpb247XG4gIHZhciBmaWx0ZXJzID0gb3B0aW9ucy5maWx0ZXJzO1xuICB2YXIgc3VjY2Vzc0NhbGxiYWNrID0gb3B0aW9ucy5zdWNjZXNzO1xuICB2YXIgZXJyb3JDYWxsYmFjayA9IG9wdGlvbnMuZXJyb3I7XG4gIHZhciBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkobWFwRGVmaW5pdGlvbik7XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZXJyb3JzKSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZGF0YS5lcnJvcnNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS51cmxUZW1wbGF0ZSA9IHRoaXMudXJsVGVtcGxhdGU7XG4gICAgICAgIGRhdGEudXNlck5hbWUgPSB0aGlzLnVzZXJOYW1lO1xuICAgICAgICBzdWNjZXNzQ2FsbGJhY2sobmV3IFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlKGRhdGEpKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyksXG4gICAgZXJyb3I6IGZ1bmN0aW9uKHhocikge1xuICAgICAgdmFyIGVyciA9IHsgZXJyb3JzOiBbJ1Vua25vd24gZXJyb3InXSB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIGVycm9yQ2FsbGJhY2soZXJyLmVycm9yc1swXSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IE1vdmUgdGhpc1xuICB2YXIgcGFyYW1zID0gW1xuICAgIFtcInN0YXRfdGFnXCIsIHRoaXMuc3RhdFRhZ10uam9pbihcIj1cIilcbiAgXTtcblxuICB2YXIgZmlsdGVycyA9IGZpbHRlcnMgfHwge307XG4gIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJzKS5sZW5ndGgpIHtcbiAgICBwYXJhbXMucHVzaChbXCJmaWx0ZXJzXCIsIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmaWx0ZXJzKSldLmpvaW4oJz0nKSk7XG4gIH1cblxuICBpZiAodGhpcy5fdXNlUE9TVChwYXlsb2FkLCBwYXJhbXMpKSB7XG4gICAgdGhpcy5fcG9zdChwYXlsb2FkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2dldChwYXlsb2FkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICB9XG59XG5cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuX3VzZVBPU1QgPSBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMpIHtcbiAgaWYgKHV0aWwuaXNDT1JTU3VwcG9ydGVkKCkgJiYgdGhpcy5mb3JjZUNvcnMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZC5sZW5ndGggPj0gdGhpcy5jb25zdHJ1Y3Rvci5NQVhfR0VUX1NJWkU7XG59XG5cbldpbmRzaGFmdENsaWVudC5wcm90b3R5cGUuX3Bvc3QgPSBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgJC5hamF4KHtcbiAgICBjcm9zc09yaWdpbjogdHJ1ZSxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgdXJsOiB0aGlzLl9nZXRVUkwocGFyYW1zKSxcbiAgICBkYXRhOiBwYXlsb2FkLFxuICAgIHN1Y2Nlc3M6IG9wdGlvbnMuc3VjY2VzcyxcbiAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxuICB9KTtcbn1cblxuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIHZhciBjb21wcmVzc0Z1bmN0aW9uID0gdGhpcy5fZ2V0Q29tcHJlc3NvcihwYXlsb2FkKTtcbiAgY29tcHJlc3NGdW5jdGlvbihwYXlsb2FkLCB0aGlzLmNvbnN0cnVjdG9yLkRFRkFVTFRfQ09NUFJFU1NJT05fTEVWRUwsIGZ1bmN0aW9uKGRhdGFQYXJhbWV0ZXIpIHtcbiAgICBwYXJhbXMucHVzaChkYXRhUGFyYW1ldGVyKTtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiB0aGlzLl9nZXRVUkwocGFyYW1zKSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBkYXRhVHlwZTogJ2pzb25wJyxcbiAgICAgIGpzb25wQ2FsbGJhY2s6IHRoaXMuX2pzb25wQ2FsbGJhY2tOYW1lKHBheWxvYWQpLFxuICAgICAgY2FjaGU6IHRydWUsXG4gICAgICBzdWNjZXNzOiBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgICBlcnJvcjogb3B0aW9ucy5lcnJvclxuICAgIH0pO1xuICB9LmJpbmQodGhpcykpO1xufVxuXG5XaW5kc2hhZnRDbGllbnQucHJvdG90eXBlLl9nZXRDb21wcmVzc29yID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5sZW5ndGggPCB0aGlzLmNvbnN0cnVjdG9yLk1BWF9HRVRfU0laRSkge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBsZXZlbCwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKFwiY29uZmlnPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGxldmVsLCBjYWxsYmFjaykge1xuICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh7IGNvbmZpZzogZGF0YSB9KTtcbiAgICBMWk1BLmNvbXByZXNzKGRhdGEsIGxldmVsLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICBjYWxsYmFjayhcImx6bWE9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbC5hcnJheTJoZXgoZW5jb2RlZCkpKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuXG5XaW5kc2hhZnRDbGllbnQucHJvdG90eXBlLl9nZXRVUkwgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIFt0aGlzLnVybCwgdGhpcy5lbmRwb2ludF0uam9pbignLycpICsgJz8nICsgcGFyYW1zLmpvaW4oJyYnKTtcbn1cblxuV2luZHNoYWZ0Q2xpZW50LnByb3RvdHlwZS5fanNvbnBDYWxsYmFja05hbWUgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG4gIHJldHVybiAnX2NkYmNfJyArIHV0aWwudW5pcXVlQ2FsbGJhY2tOYW1lKHBheWxvYWQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdENsaWVudDtcbiIsInZhciBjb25maWcgPSB7fTtcbmNvbmZpZy5NQVBTX0FQSV9CQVNFX1VSTCA9ICdhcGkvdjEvbWFwJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZztcbiIsInZhciBfID0gY2RiLl87XG52YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcbnZhciBXaW5kc2hhZnRDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIEVNUFRZX0dJRiA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBUSUxFX0VYVEVOU0lPTlNfQllfTEFZRVJfVFlQRToge1xuICAgICdtYXBuaWsnOiAnLnBuZycsXG4gICAgJ3RvcnF1ZSc6ICcuanNvbi50b3JxdWUnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBUT0RPOiBXaGF0IHBhcmFtcyBhcmUgcmVhbGx5IHVzZWQ/XG4gICAgdGhpcy5wbmdQYXJhbXMgPSBbJ21hcF9rZXknLCAnYXBpX2tleScsICdjYWNoZV9wb2xpY3knLCAndXBkYXRlZF9hdCddO1xuICAgIHRoaXMuZ3JpZFBhcmFtcyA9IFsnbWFwX2tleScsICdhcGlfa2V5JywgJ2NhY2hlX3BvbGljeScsICd1cGRhdGVkX2F0J107XG4gIH0sXG5cbiAgaXNMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0KCdsYXllcmdyb3VwaWQnKTtcbiAgfSxcblxuICBnZXRCYXNlVVJMOiBmdW5jdGlvbihzdWJob3N0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuX2dldEhvc3Qoc3ViaG9zdCksXG4gICAgICBXaW5kc2hhZnRDb25maWcuTUFQU19BUElfQkFTRV9VUkwsXG4gICAgICB0aGlzLl9nZXRNYXBJZCgpLFxuICAgIF0uam9pbignLycpO1xuICB9LFxuXG4gIF9nZXRNYXBJZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdsYXllcmdyb3VwaWQnKTtcbiAgfSxcblxuICBfZ2V0SG9zdDogZnVuY3Rpb24oc3ViaG9zdCkge1xuICAgIHZhciB1c2VyTmFtZSA9IHRoaXMuZ2V0KCd1c2VyTmFtZScpO1xuICAgIHZhciBwcm90b2NvbCA9IHRoaXMuX3VzZUhUVFBTKCkgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgIHZhciBzdWJob3N0ID0gc3ViaG9zdCA/IHN1Ymhvc3QgKyAnLicgOiAnJztcbiAgICB2YXIgaG9zdCA9IHRoaXMuZ2V0KCd1cmxUZW1wbGF0ZScpLnJlcGxhY2UoJ3t1c2VyfScsIHVzZXJOYW1lKTtcbiAgICB2YXIgY2RuSG9zdCA9IHRoaXMuZ2V0KCdjZG5fdXJsJykgJiYgdGhpcy5nZXQoJ2Nkbl91cmwnKVtwcm90b2NvbF07XG4gICAgaWYgKGNkbkhvc3QpIHtcbiAgICAgIGhvc3QgPSBbcHJvdG9jb2wsICc6Ly8nLCBzdWJob3N0LCBjZG5Ib3N0LCAnLycsIHVzZXJOYW1lXS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdDtcbiAgfSxcblxuICBfdXNlSFRUUFM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndXJsVGVtcGxhdGUnKS5pbmRleE9mKCdodHRwcycpID09PSAwO1xuICB9LFxuXG4gIGdldFRpbGVzOiBmdW5jdGlvbihsYXllclR5cGUsIHBhcmFtcykge1xuICAgIHZhciBncmlkcyA9IFtdO1xuICAgIHZhciB0aWxlcyA9IFtdO1xuXG4gICAgdmFyIHBuZ1BhcmFtcyA9IHRoaXMuX2VuY29kZVBhcmFtcyhwYXJhbXMsIHRoaXMucG5nUGFyYW1zKTtcbiAgICB2YXIgZ3JpZFBhcmFtcyA9IHRoaXMuX2VuY29kZVBhcmFtcyhwYXJhbXMsIHRoaXMuZ3JpZFBhcmFtcyk7XG4gICAgdmFyIHN1YmRvbWFpbnMgPSBbJzAnLCAnMScsICcyJywgJzMnXTtcblxuICAgIGlmKHRoaXMuX3VzZUhUVFBTKCkpIHtcbiAgICAgIHN1YmRvbWFpbnMgPSBbJyddO1xuICAgIH1cblxuICAgIGxheWVyVHlwZSA9IGxheWVyVHlwZSB8fCAnbWFwbmlrJztcblxuICAgIHZhciBsYXllckluZGV4ZXMgPSB0aGlzLl9nZXRMYXllckluZGV4ZXNCeVR5cGUobGF5ZXJUeXBlKTtcbiAgICBpZiAobGF5ZXJJbmRleGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGdyaWRUZW1wbGF0ZSA9ICcve3p9L3t4fS97eX0nO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ViZG9tYWlucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3ViZG9tYWluID0gc3ViZG9tYWluc1tpXTtcbiAgICAgICAgdmFyIHRpbGVVUkxUZW1wbGF0ZSA9IFtcbiAgICAgICAgICB0aGlzLmdldEJhc2VVUkwoc3ViZG9tYWluKSxcbiAgICAgICAgICAnLycsXG4gICAgICAgICAgbGF5ZXJJbmRleGVzLmpvaW4oJywnKSxcbiAgICAgICAgICAnL3t6fS97eH0ve3l9JyxcbiAgICAgICAgICB0aGlzLlRJTEVfRVhURU5TSU9OU19CWV9MQVlFUl9UWVBFW2xheWVyVHlwZV0sXG4gICAgICAgICAgKHBuZ1BhcmFtcyA/IFwiP1wiICsgcG5nUGFyYW1zOiAnJylcbiAgICAgICAgXS5qb2luKCcnKTtcblxuICAgICAgICB0aWxlcy5wdXNoKHRpbGVVUkxUZW1wbGF0ZSk7XG5cbiAgICAgICAgLy8gZm9yIG1hcG5payBsYXllcnMgYWRkIGdyaWQganNvbiB0b29cbiAgICAgICAgaWYgKGxheWVyVHlwZSA9PT0gJ21hcG5paycpIHtcbiAgICAgICAgICBmb3IodmFyIGxheWVyID0gMDsgbGF5ZXIgPCB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnMubGVuZ3RoOyArK2xheWVyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9nZXRMYXllckluZGV4QnlUeXBlKGxheWVyLCBcIm1hcG5pa1wiKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBncmlkVVJMVGVtcGxhdGUgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRCYXNlVVJMKHN1YmRvbWFpbiksXG4gICAgICAgICAgICAgICAgXCIvXCIsXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIFwiLmdyaWQuanNvblwiLFxuICAgICAgICAgICAgICAgIChncmlkUGFyYW1zID8gXCI/XCIgKyBncmlkUGFyYW1zOiAnJylcbiAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICBncmlkc1tsYXllcl0gPSBncmlkc1tsYXllcl0gfHwgW107XG4gICAgICAgICAgICAgIGdyaWRzW2xheWVyXS5wdXNoKGdyaWRVUkxUZW1wbGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IENsaWVudHMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIGRlY2lkZSB3aGF0IHRvIHJlbmRlciBpZiBubyBsYXllcnMgYXJlIHByZXNlbnRcbiAgICAgIHRpbGVzID0gW0VNUFRZX0dJRl07XG4gICAgfVxuXG4gICAgdGhpcy51cmxzID0ge1xuICAgICAgdGlsZXM6IHRpbGVzLFxuICAgICAgZ3JpZHM6IGdyaWRzXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy51cmxzO1xuICB9LFxuXG4gIGdldExheWVyTWV0YTogZnVuY3Rpb24obGF5ZXJJbmRleCkge1xuICAgIHZhciBsYXllck1ldGEgPSB7fTtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXQoJ21ldGFkYXRhJykgJiYgdGhpcy5nZXQoJ21ldGFkYXRhJykubGF5ZXJzO1xuICAgIGlmIChsYXllcnMgJiYgbGF5ZXJzW2xheWVySW5kZXhdKSB7XG4gICAgICAgIGxheWVyTWV0YSA9IGxheWVyc1tsYXllckluZGV4XS5tZXRhIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJNZXRhO1xuICB9LFxuXG4gIF9lbmNvZGVQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcywgaW5jbHVkZWQpIHtcbiAgICBpZighcGFyYW1zKSByZXR1cm4gJyc7XG4gICAgdmFyIHVybF9wYXJhbXMgPSBbXTtcbiAgICBpbmNsdWRlZCA9IGluY2x1ZGVkIHx8IF8ua2V5cyhwYXJhbXMpO1xuICAgIGZvcih2YXIgaSBpbiBpbmNsdWRlZCkge1xuICAgICAgdmFyIGsgPSBpbmNsdWRlZFtpXTtcbiAgICAgIHZhciBwID0gcGFyYW1zW2tdO1xuICAgICAgaWYocCkge1xuICAgICAgICBpZiAoXy5pc0FycmF5KHApKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHAubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHVybF9wYXJhbXMucHVzaChrICsgXCJbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwW2pdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBxID0gZW5jb2RlVVJJQ29tcG9uZW50KHApO1xuICAgICAgICAgIHEgPSBxLnJlcGxhY2UoLyU3QnglN0QvZyxcInt4fVwiKS5yZXBsYWNlKC8lN0J5JTdEL2csXCJ7eX1cIikucmVwbGFjZSgvJTdCeiU3RC9nLFwie3p9XCIpO1xuICAgICAgICAgIHVybF9wYXJhbXMucHVzaChrICsgXCI9XCIgKyBxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsX3BhcmFtcy5qb2luKCcmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgbGF5ZXIgb2YgYSBnaXZlbiB0eXBlLCBhcyB0aGUgdGlsZXIga3dvd3MgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB0eXBlcyAtIFR5cGUgb3IgdHlwZXMgb2YgbGF5ZXJzXG4gICAqL1xuICBfZ2V0TGF5ZXJJbmRleGVzQnlUeXBlOiBmdW5jdGlvbih0eXBlcykge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldCgnbWV0YWRhdGEnKSAmJiB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnM7XG5cbiAgICBpZiAoIWxheWVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGF5ZXJJbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBpc1ZhbGlkVHlwZSA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXNWYWxpZFR5cGUgPSB0eXBlcy5pbmRleE9mKGxheWVyLnR5cGUpICE9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGlzVmFsaWRUeXBlKSB7XG4gICAgICAgIGxheWVySW5kZXhlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJJbmRleGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxheWVyIG9mIGEgZ2l2ZW4gdHlwZSwgYXMgdGhlIHRpbGVyIGt3b3dzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gbnVtYmVyIG9mIGxheWVyIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJUeXBlIC0gdHlwZSBvZiB0aGUgbGF5ZXJzXG4gICAqL1xuICBfZ2V0TGF5ZXJJbmRleEJ5VHlwZTogZnVuY3Rpb24oaW5kZXgsIGxheWVyVHlwZSkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldCgnbWV0YWRhdGEnKSAmJiB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnM7XG5cbiAgICBpZiAoIWxheWVycykge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIHZhciB0aWxlckxheWVySW5kZXggPSB7fTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsYXllcnNbaV0udHlwZSA9PSBsYXllclR5cGUpIHtcbiAgICAgICAgdGlsZXJMYXllckluZGV4W2pdID0gaTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGlsZXJMYXllckluZGV4W2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiB0aWxlckxheWVySW5kZXhbaW5kZXhdO1xuICB9LFxuXG4gIGdldFdpZGdldFVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciB3aWRnZXRJZCA9IG9wdGlvbnMud2lkZ2V0SWQ7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbDtcbiAgICB2YXIgdXJsO1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldCgnbWV0YWRhdGEnKSAmJiB0aGlzLmdldCgnbWV0YWRhdGEnKS5sYXllcnM7XG5cbiAgICBfLmVhY2gobGF5ZXJzLCBmdW5jdGlvbihsYXllcikge1xuICAgICAgdmFyIHdpZGdldHMgPSBsYXllci53aWRnZXRzO1xuICAgICAgZm9yICh2YXIgaWQgaW4gd2lkZ2V0cykge1xuICAgICAgICBpZiAod2lkZ2V0SWQgPT09IGlkKSB7XG4gICAgICAgICAgdXJsID0gd2lkZ2V0c1tpZF0udXJsW3Byb3RvY29sXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB1cmw7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSBjZGIuXztcbnZhciBCYWNrYm9uZSA9IGNkYi5CYWNrYm9uZTtcbnZhciBXaW5kc2hhZnRGaWx0ZXJzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vZmlsdGVycy9jb2xsZWN0aW9uJyk7XG52YXIgV2luZHNoYWZ0RmlsdGVyc0JvdW5kaW5nQm94RmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL2JvdW5kaW5nX2JveCcpO1xudmFyIFdpbmRzaGFmdERhc2hib2FyZEluc3RhbmNlID0gcmVxdWlyZSgnLi9kYXNoYm9hcmQtaW5zdGFuY2UnKTtcblxudmFyIFdpbmRzaGFmdERhc2hib2FyZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgQk9VTkRJTkdfQk9YX0ZJTFRFUl9XQUlUID0gNTAwO1xuXG4gIHRoaXMubGF5ZXJHcm91cCA9IG9wdGlvbnMubGF5ZXJHcm91cDtcbiAgdGhpcy5sYXllcnMgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbihvcHRpb25zLmxheWVycyk7XG4gIHRoaXMud2lkZ2V0cyA9IG9wdGlvbnMud2lkZ2V0cztcbiAgdGhpcy5tYXAgPSBvcHRpb25zLm1hcDtcbiAgdGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgdGhpcy5zdGF0VGFnID0gb3B0aW9ucy5zdGF0VGFnO1xuICB0aGlzLmNvbmZpZ0dlbmVyYXRvciA9IG9wdGlvbnMuY29uZmlnR2VuZXJhdG9yO1xuXG4gIHRoaXMuaW5zdGFuY2UgPSBuZXcgV2luZHNoYWZ0RGFzaGJvYXJkSW5zdGFuY2UoKTtcblxuICB0aGlzLm1hcC5iaW5kKCdjaGFuZ2U6Y2VudGVyIGNoYW5nZTp6b29tJywgXy5kZWJvdW5jZSh0aGlzLl9ib3VuZGluZ0JveENoYW5nZWQsIEJPVU5ESU5HX0JPWF9GSUxURVJfV0FJVCksIHRoaXMpO1xuXG4gIHRoaXMubGF5ZXJzLmJpbmQoJ2NoYW5nZScsIHRoaXMuX2xheWVyQ2hhbmdlZCwgdGhpcyk7XG4gIHRoaXMud2lkZ2V0cy5iaW5kKCdjaGFuZ2U6ZmlsdGVyJywgdGhpcy5fZmlsdGVyQ2hhbmdlZCwgdGhpcyk7XG5cbiAgdGhpcy5fY3JlYXRlSW5zdGFuY2UoKTtcbn07XG5cbldpbmRzaGFmdERhc2hib2FyZC5wcm90b3R5cGUuX2NyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGRhc2hib2FyZENvbmZpZyA9IHRoaXMuY29uZmlnR2VuZXJhdG9yLmdlbmVyYXRlKHtcbiAgICBsYXllcnM6IHRoaXMubGF5ZXJzLm1vZGVscyxcbiAgICB3aWRnZXRzOiB0aGlzLndpZGdldHNcbiAgfSk7XG5cblxuICB2YXIgZmlsdGVyc0Zyb21WaXNpYmxlTGF5ZXJzID0gdGhpcy53aWRnZXRzLmNoYWluKClcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHcubGF5ZXIuaXNWaXNpYmxlKCkgfSlcbiAgICAubWFwKGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHcuZmlsdGVyIH0pXG4gICAgLmNvbXBhY3QoKSAvLyBub3QgYWxsIHdpZGdldHMgaGF2ZSBmaWx0ZXJzXG4gICAgLnZhbHVlKCk7XG5cbiAgdmFyIGZpbHRlcnMgPSBuZXcgV2luZHNoYWZ0RmlsdGVyc0NvbGxlY3Rpb24oZmlsdGVyc0Zyb21WaXNpYmxlTGF5ZXJzKTtcblxuICB0aGlzLmNsaWVudC5pbnN0YW50aWF0ZU1hcCh7XG4gICAgbWFwRGVmaW5pdGlvbjogZGFzaGJvYXJkQ29uZmlnLFxuICAgIGZpbHRlcnM6IGZpbHRlcnMudG9KU09OKCksXG4gICAgc3VjY2VzczogZnVuY3Rpb24oZGFzaGJvYXJkSW5zdGFuY2UpIHtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBkYXNoYm9hcmQgaW5zdGFuY2Ugd2l0aCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbmV3IG9uZVxuICAgICAgdGhpcy5pbnN0YW5jZS5zZXQoZGFzaGJvYXJkSW5zdGFuY2UudG9KU09OKCkpO1xuXG4gICAgICAvLyBUT0RPOiBTZXQgdGhlIFVSTCBvZiB0aGUgYXR0cmlidXRlcyBzZXJ2aWNlIG9uY2UgaXQncyBhdmFpbGFibGVcbiAgICAgIHRoaXMubGF5ZXJHcm91cCAmJiB0aGlzLmxheWVyR3JvdXAuc2V0KHtcbiAgICAgICAgYmFzZVVSTDogZGFzaGJvYXJkSW5zdGFuY2UuZ2V0QmFzZVVSTCgpLFxuICAgICAgICB1cmxzOiBkYXNoYm9hcmRJbnN0YW5jZS5nZXRUaWxlcygnbWFwbmlrJylcbiAgICAgIH0pO1xuXG4gICAgICAvLyB1cGRhdGUgb3RoZXIga2luZCBvZiBsYXllcnMgdG9vXG4gICAgICB0aGlzLmxheWVycy5lYWNoKGZ1bmN0aW9uKGxheWVyLCBsYXllckluZGV4KSB7XG4gICAgICAgIGlmIChsYXllci5nZXQoJ3R5cGUnKSA9PT0gJ3RvcnF1ZScpIHtcbiAgICAgICAgICBsYXllci5zZXQoJ21ldGEnLCBkYXNoYm9hcmRJbnN0YW5jZS5nZXRMYXllck1ldGEobGF5ZXJJbmRleCkpO1xuICAgICAgICAgIGxheWVyLnNldCgndXJscycsIGRhc2hib2FyZEluc3RhbmNlLmdldFRpbGVzKCd0b3JxdWUnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl91cGRhdGVXaWRnZXRVUkxzKHtcbiAgICAgICAgbGF5ZXJJZDogb3B0aW9ucy5sYXllcklkXG4gICAgICB9KTtcblxuICAgIH0uYmluZCh0aGlzKSxcbiAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBjcmVhdGluZyBkYXNoYm9hcmQgaW5zdGFuY2U6ICcgKyBlcnJvcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbn07XG5cbldpbmRzaGFmdERhc2hib2FyZC5wcm90b3R5cGUuX2JvdW5kaW5nQm94Q2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pbnN0YW5jZS5pc0xvYWRlZCgpKSB7XG4gICAgdGhpcy5fdXBkYXRlV2lkZ2V0VVJMcygpO1xuICB9XG59O1xuXG5XaW5kc2hhZnREYXNoYm9hcmQucHJvdG90eXBlLl91cGRhdGVXaWRnZXRVUkxzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGJvdW5kaW5nQm94RmlsdGVyID0gbmV3IFdpbmRzaGFmdEZpbHRlcnNCb3VuZGluZ0JveEZpbHRlcih0aGlzLm1hcC5nZXRWaWV3Qm91bmRzKCkpO1xuICB2YXIgYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveEZpbHRlci50b1N0cmluZygpO1xuICB2YXIgbGF5ZXJJZCA9IG9wdGlvbnMubGF5ZXJJZDtcblxuICB0aGlzLndpZGdldHMuZWFjaChmdW5jdGlvbih3aWRnZXQpIHtcbiAgICB2YXIgdXJsID0gdGhpcy5pbnN0YW5jZS5nZXRXaWRnZXRVUkwoe1xuICAgICAgd2lkZ2V0SWQ6IHdpZGdldC5nZXQoJ2lkJyksXG4gICAgICBwcm90b2NvbDogJ2h0dHAnXG4gICAgfSk7XG5cbiAgICB2YXIgbGF5ZXJNZXRhID0gd2lkZ2V0LmxheWVyLmdldCgnbWV0YScpIHx8IHt9O1xuICAgIHZhciBleHRyYUF0dHJzID0ge307XG4gICAgaWYgKGxheWVyTWV0YS5zdGVwcyAmJiBsYXllck1ldGEuY29sdW1uX3R5cGUgJiYgXy5pc051bWJlcihsYXllck1ldGEuc3RhcnQpICYmIF8uaXNOdW1iZXIobGF5ZXJNZXRhLmVuZCkpIHtcbiAgICAgIGV4dHJhQXR0cnMgPSB7XG4gICAgICAgIGJpbnM6IGxheWVyTWV0YS5zdGVwcyxcbiAgICAgICAgY29sdW1uVHlwZTogbGF5ZXJNZXRhLmNvbHVtbl90eXBlLFxuICAgICAgICBzdGFydDogbGF5ZXJNZXRhLnN0YXJ0ICAvIDEwMDAsXG4gICAgICAgIGVuZDogIGxheWVyTWV0YS5lbmQgLyAxMDAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHdpZGdldC5zZXQoXy5leHRlbmQoe1xuICAgICAgJ3VybCc6IHVybCxcbiAgICAgICdib3VuZGluZ0JveCc6IGJvdW5kaW5nQm94XG4gICAgfSwgZXh0cmFBdHRycyksIHtcbiAgICAgIHNpbGVudDogbGF5ZXJJZCAmJiBsYXllcklkICE9PSB3aWRnZXQubGF5ZXIuZ2V0KCdpZCcpXG4gICAgfSk7XG4gIH0sIHRoaXMpO1xufTtcblxuV2luZHNoYWZ0RGFzaGJvYXJkLnByb3RvdHlwZS5fZmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uKHcpIHtcbiAgdGhpcy5fY3JlYXRlSW5zdGFuY2Uoe1xuICAgIGxheWVySWQ6IHcubGF5ZXIuZ2V0KCdpZCcpXG4gIH0pO1xufTtcblxuV2luZHNoYWZ0RGFzaGJvYXJkLnByb3RvdHlwZS5fbGF5ZXJDaGFuZ2VkID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIGxheWVySWQgPSBsYXllci5nZXQoJ2lkJyk7XG4gIHRoaXMuX2NyZWF0ZUluc3RhbmNlKHtcbiAgICBsYXllcklkOiBsYXllcklkXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnREYXNoYm9hcmQ7XG4iLCJ2YXIgTW9kZWwgPSBjZGIuY29yZS5Nb2RlbDtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbC5leHRlbmQoe1xuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IFwiRmlsdGVycyBtdXN0IGltcGxlbWVudCB0aGUgLmlzRW1wdHkgbWV0aG9kXCI7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBcIkZpbHRlcnMgbXVzdCBpbXBsZW1lbnQgdGhlIC50b0pTT04gbWV0aG9kXCI7XG4gIH1cbn0pO1xuIiwidmFyIE1vZGVsID0gY2RiLmNvcmUuTW9kZWw7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICB0aGlzLnNldEJvdW5kcyhib3VuZHMpO1xuICB9LFxuXG4gIHNldEJvdW5kczogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgd2VzdDogYm91bmRzWzBdWzFdLFxuICAgICAgc291dGg6IGJvdW5kc1swXVswXSxcbiAgICAgIGVhc3Q6IGJvdW5kc1sxXVsxXSxcbiAgICAgIG5vcnRoOiBib3VuZHNbMV1bMF1cbiAgICB9KTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZ2V0KCd3ZXN0JyksXG4gICAgICB0aGlzLmdldCgnc291dGgnKSxcbiAgICAgIHRoaXMuZ2V0KCdlYXN0JyksXG4gICAgICB0aGlzLmdldCgnbm9ydGgnKVxuICAgIF0uam9pbignLCcpO1xuICB9XG59KTtcbiIsInZhciBfID0gY2RiLl87XG52YXIgQmFja2JvbmUgPSBjZGIuQmFja2JvbmU7XG52YXIgV2luZHNoYWZ0RmlsdGVyQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG4vKipcbiAqICBGaWx0ZXIgdXNlZCBieSB0aGUgY2F0ZWdvcnkgd2lkZ2V0XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdEZpbHRlckJhc2UuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHJlamVjdEFsbDogZmFsc2VcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcyA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuX2luaXRCaW5kcygpO1xuICB9LFxuXG4gIF9pbml0QmluZHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLmJpbmQoJ2FkZCByZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0KCdyZWplY3RBbGwnLCBmYWxzZSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMuYmluZCgnYWRkIHJlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQoJ3JlamVjdEFsbCcsIGZhbHNlKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3RlZENhdGVnb3JpZXMuc2l6ZSgpID09PSAwICYmIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLnNpemUoKSA9PT0gMCAmJiAhdGhpcy5nZXQoJ3JlamVjdEFsbCcpO1xuICB9LFxuXG4gIGFjY2VwdDogZnVuY3Rpb24odmFsdWVzLCBhcHBseUZpbHRlcikge1xuICAgIHZhbHVlcyA9ICFfLmlzQXJyYXkodmFsdWVzKSA/IFt2YWx1ZXNdIDogdmFsdWVzO1xuICAgIHZhciBhY2NlcHRlZENvdW50ID0gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMuc2l6ZSgpO1xuXG4gICAgXy5lYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBkID0geyBuYW1lOiB2YWx1ZSB9O1xuICAgICAgdmFyIHJlamVjdGVkTWRscyA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLndoZXJlKGQpO1xuICAgICAgdmFyIGFjY2VwdGVkTWRscyA9IHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLndoZXJlKGQpO1xuICAgICAgaWYgKHJlamVjdGVkTWRscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnJlbW92ZShyZWplY3RlZE1kbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFhY2NlcHRlZE1kbHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLmFkZChkKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmIChhcHBseUZpbHRlciAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgYWNjZXB0QWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgncmVqZWN0QWxsJywgZmFsc2UpO1xuICAgIHRoaXMuY2xlYW5GaWx0ZXIoKTtcbiAgfSxcblxuICBpc0FjY2VwdGVkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzLndoZXJlKHsgbmFtZTogbmFtZSB9KS5sZW5ndGggPiAwO1xuICB9LFxuXG4gIGdldEFjY2VwdGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXM7XG4gIH0sXG5cbiAgcmVqZWN0OiBmdW5jdGlvbih2YWx1ZXMsIGFwcGx5RmlsdGVyKSB7XG4gICAgdmFsdWVzID0gIV8uaXNBcnJheSh2YWx1ZXMpID8gW3ZhbHVlc10gOiB2YWx1ZXM7XG5cbiAgICBfLmVhY2godmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGQgPSB7IG5hbWU6IHZhbHVlIH07XG4gICAgICB2YXIgYWNjZXB0ZWRNZGxzID0gdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMud2hlcmUoZCk7XG4gICAgICB2YXIgcmVqZWN0ZWRNZGxzID0gdGhpcy5yZWplY3RlZENhdGVnb3JpZXMud2hlcmUoZCk7XG4gICAgICBpZiAoYWNjZXB0ZWRNZGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hY2NlcHRlZENhdGVnb3JpZXMucmVtb3ZlKGFjY2VwdGVkTWRscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXJlamVjdGVkTWRscy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy5hZGQoZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmIChhcHBseUZpbHRlciAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgaXNSZWplY3RlZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciByZWplY3RDb3VudCA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnNpemUoKTtcbiAgICB2YXIgYWNjZXB0Q291bnQgPSB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5zaXplKCk7XG4gICAgaWYgKHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLndoZXJlKHsgbmFtZTogbmFtZSB9KS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGFjY2VwdENvdW50ID4gMCAmJiB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy53aGVyZSh7IG5hbWU6IG5hbWUgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KCdyZWplY3RBbGwnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UmVqZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcztcbiAgfSxcblxuICByZWplY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0KCdyZWplY3RBbGwnLCB0cnVlKTtcbiAgICB0aGlzLmNsZWFuRmlsdGVyKCk7XG4gIH0sXG5cbiAgY2xlYW5GaWx0ZXI6IGZ1bmN0aW9uKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5yZXNldCgpO1xuICAgIHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnJlc2V0KCk7XG4gICAgaWYgKHRyaWdnZXJDaGFuZ2UgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVyKCk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5RmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlciA9IHt9O1xuICAgIHZhciByZWplY3RDb3VudCA9IHRoaXMucmVqZWN0ZWRDYXRlZ29yaWVzLnNpemUoKTtcbiAgICB2YXIgYWNjZXB0Q291bnQgPSB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy5zaXplKCk7XG4gICAgdmFyIGFjY2VwdGVkQ2F0cyA9IHvCoGFjY2VwdDogXy5wbHVjayh0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcy50b0pTT04oKSwgJ25hbWUnKSB9O1xuICAgIHZhciByZWplY3RlZENhdHMgPSB7IHJlamVjdDogXy5wbHVjayh0aGlzLnJlamVjdGVkQ2F0ZWdvcmllcy50b0pTT04oKSwgJ25hbWUnKSB9O1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdyZWplY3RBbGwnKSkge1xuICAgICAgZmlsdGVyID0geyBhY2NlcHQ6IFtdIH07XG4gICAgfSBlbHNlIGlmIChhY2NlcHRDb3VudCA+IDApIHtcbiAgICAgIGZpbHRlciA9IGFjY2VwdGVkQ2F0cztcbiAgICB9IGVsc2UgaWYgKHJlamVjdENvdW50ID4gMCAmJiBhY2NlcHRDb3VudCA9PT0gMCkge1xuICAgICAgZmlsdGVyID0gcmVqZWN0ZWRDYXRzO1xuICAgIH1cblxuICAgIHZhciBqc29uID0ge307XG4gICAganNvblt0aGlzLmdldCgnd2lkZ2V0SWQnKV0gPSBmaWx0ZXI7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBqc29uID0ge307XG4gICAgdmFyIGFjdGl2ZUZpbHRlcnMgPSB0aGlzLmdldEFjdGl2ZUZpbHRlcnMoKTtcbiAgICBpZiAoYWN0aXZlRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGpzb24ubGF5ZXJzID0gW107XG4gICAgICBfLmVhY2goYWN0aXZlRmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGlmICghZmlsdGVyLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGZpbHRlci5nZXQoJ2xheWVySW5kZXgnKTtcbiAgICAgICAgICBpZiAoanNvbi5sYXllcnNbaW5kZXhdKSB7XG4gICAgICAgICAgICBfLmV4dGVuZChqc29uLmxheWVyc1tpbmRleF0sZmlsdGVyLnRvSlNPTigpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAganNvbi5sYXllcnNbaW5kZXhdID0gZmlsdGVyLnRvSlNPTigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBmaWxsIHRoZSBob2xlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBqc29uLmxheWVyc1tpXSA9IGpzb24ubGF5ZXJzW2ldIHx8IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9LFxuXG4gIGdldEFjdGl2ZUZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHJldHVybiAhZmlsdGVyLmlzRW1wdHkoKTtcbiAgICB9KTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpbmRzaGFmdEZpbHRlckJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaW5kc2hhZnRGaWx0ZXJCYXNlLmV4dGVuZCh7XG5cbiAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodGhpcy5nZXQoJ21pbicpKSAmJiBfLmlzVW5kZWZpbmVkKHRoaXMuZ2V0KCdtYXgnKSk7XG4gIH0sXG5cbiAgc2V0UmFuZ2U6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH0pO1xuICB9LFxuXG4gIHVuc2V0UmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0UmFuZ2UodW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGpzb24gPSB7fTtcbiAgICBqc29uW3RoaXMuZ2V0KCd3aWRnZXRJZCcpXSA9IHtcbiAgICAgIG1pbjogdGhpcy5nZXQoJ21pbicpLFxuICAgICAgbWF4OiB0aGlzLmdldCgnbWF4JyksXG4gICAgICBjb2x1bW5fdHlwZTogdGhpcy5nZXQoJ2NvbHVtblR5cGUnKVxuICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWcgPSB7fTtcblxuV2luZHNoYWZ0UHJpdmF0ZURhc2hib2FyZENvbmZpZy5nZW5lcmF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGxheWVycyA9IG9wdGlvbnMubGF5ZXJzO1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgXy5lYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIsIGluZGV4KXtcbiAgICBjb25maWdbJ2xheWVyJyArIGluZGV4XSA9IGxheWVyLmlzVmlzaWJsZSgpID8gMSA6IDA7XG4gIH0pO1xuXG4gIC8vIFRPRE86IFdlIHNob3VsZCBhZGQgdGhlIHBhcmFtc1xuICAvLyBUT0RPOiBXZSBzaG91bGQgYWRkIHRoZSBhdXRoX3Rva2VuXG4gIHJldHVybiBjb25maWc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRzaGFmdFByaXZhdGVEYXNoYm9hcmRDb25maWc7XG4iLCJ2YXIgXyA9IGNkYi5fO1xudmFyIFdpbmRzaGFmdFB1YmxpY0Rhc2hib2FyZENvbmZpZyA9IHt9O1xuXG5XaW5kc2hhZnRQdWJsaWNEYXNoYm9hcmRDb25maWcuZ2VuZXJhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgdmFyIHdpZGdldHMgPSBvcHRpb25zLndpZGdldHM7XG4gIHZhciBjb25maWcgPSB7IGxheWVyczogW10gfTtcbiAgXy5lYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIuaXNWaXNpYmxlKCkpIHtcbiAgICAgIHZhciBsYXllckNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogbGF5ZXIuZ2V0KCd0eXBlJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNxbDogbGF5ZXIuZ2V0KCdzcWwnKSxcbiAgICAgICAgICBjYXJ0b2NzczogbGF5ZXIuZ2V0KCdjYXJ0b2NzcycpLFxuICAgICAgICAgIGNhcnRvY3NzX3ZlcnNpb246IGxheWVyLmdldCgnY2FydG9jc3NfdmVyc2lvbicpLFxuICAgICAgICAgIGludGVyYWN0aXZpdHk6IGxheWVyLmdldEludGVyYWN0aXZlQ29sdW1uTmFtZXMoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGxheWVyLmdldEluZm93aW5kb3dGaWVsZE5hbWVzKCkubGVuZ3RoKSB7XG4gICAgICAgIGxheWVyQ29uZmlnLm9wdGlvbnMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBpZDogXCJjYXJ0b2RiX2lkXCIsXG4gICAgICAgICAgY29sdW1uczogbGF5ZXIuZ2V0SW5mb3dpbmRvd0ZpZWxkTmFtZXMoKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsYXllckNvbmZpZy5vcHRpb25zLndpZGdldHMgPSB7fTtcbiAgICAgIHZhciBsYXllcklkID0gbGF5ZXIuZ2V0KCdpZCcpO1xuICAgICAgd2lkZ2V0cy5lYWNoKGZ1bmN0aW9uKHdpZGdldCkge1xuICAgICAgICBpZiAobGF5ZXJJZCA9PT0gd2lkZ2V0LmxheWVyLmdldCgnaWQnKSkge1xuICAgICAgICAgIGxheWVyQ29uZmlnLm9wdGlvbnMud2lkZ2V0c1t3aWRnZXQuZ2V0KCdpZCcpXSA9IHdpZGdldC50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25maWcubGF5ZXJzLnB1c2gobGF5ZXJDb25maWcpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZHNoYWZ0UHVibGljRGFzaGJvYXJkQ29uZmlnO1xuIl19
