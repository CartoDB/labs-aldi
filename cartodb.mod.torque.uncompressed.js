// cartodb.js version: 3.15.8
// uncompressed version: cartodb.mod.torque.uncompressed.js
// sha: 3f146e6c70e399a44f14e24558e228b2932a1f96
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
//     Backbone.js 1.2.3

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = (typeof self == 'object' && self.self == self && self) ||
            (typeof global == 'object' && global.global == global && global);

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'), $;
    try { $ = require('jquery'); } catch(e) {}
    factory(root, exports, _, $);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.2.3';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function(length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return _[method](this[attribute]);
      };
      case 2: return function(value) {
        return _[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return _[method](this[attribute], cb(iteratee, this), context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return _[method].apply(_, args);
      };
    }
  };
  var addUnderscoreMethods = function(Class, methods, attribute) {
    _.each(methods, function(length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
    return iteratee;
  };
  var modelMatcher = function(attrs) {
    var matcher = _.matches(attrs);
    return function(model) {
      return matcher(model.attributes);
    };
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function(iteratee, events, name, callback, opts) {
    var i = 0, names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length ; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {
    return internalOn(this, name, callback, context);
  };

  // Guard the `listening` argument from the public API.
  var internalOn = function(obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
        context: context,
        ctx: obj,
        listening: listening
    });

    if (listening) {
      var listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    return obj;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo =  function(obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
    }

    // Bind callbacks on obj, and keep track of them on listening.
    internalOn(obj, name, callback, this, listening);
    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context, ctx = options.ctx, listening = options.listening;
      if (listening) listening.count++;

      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off =  function(name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
        context: context,
        listeners: this._listeners
    });
    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening =  function(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
    }
    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {
    if (!events) return;

    var i = 0, listening;
    var context = options.context, listeners = options.listeners;

    // Delete all events listeners and "drop" events.
    if (!name && !callback && !context) {
      var ids = _.keys(listeners);
      for (; i < ids.length; i++) {
        listening = listeners[ids[i]];
        delete listeners[listening.id];
        delete listening.listeningTo[listening.objId];
      }
      return;
    }

    var names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Replace events if there are any remaining.  Otherwise, clean up.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (
          callback && callback !== handler.callback &&
            callback !== handler.callback._callback ||
              context && context !== handler.context
        ) {
          remaining.push(handler);
        } else {
          listening = handler.listening;
          if (listening && --listening.count === 0) {
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
        }
      }

      // Update tail event if the list has any events.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }
    if (_.size(events)) return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once =  function(name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
    return this.on(events, void 0, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce =  function(obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function() {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger =  function(name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, cb, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset      = options.unset;
      var silent     = options.silent;
      var changes    = [];
      var changing   = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev    = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      this.id = this.get(this.idAttribute);

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
      }
      return _.size(changed) ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.defaults({validate: true}, options));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
      omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Splices `insert` into `array` at index `at`.
  var splice = function(array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    for (var i = 0; i < tail.length; i++) tail[i] = array[i + at];
    for (i = 0; i < length; i++) array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model) { return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      var removed = this._removeModels(models, options);
      if (!options.silent && removed) this.trigger('update', this, options);
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      if (models == null) return;

      options = _.defaults({}, options, setOptions);
      if (options.parse && !this._isModel(models)) models = this.parse(models, options);

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model;
      for (var i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length != set.length || _.some(this.models, function(model, index) {
          return model !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length) this.trigger('update', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp, callbackOpts) {
        if (wait) collection.add(model, callbackOpts);
        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function (attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed.length ? removed : false;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function (model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (event === 'change') {
        var prevId = this.modelId(model.previousAttributes());
        var id = this.modelId(model.attributes);
        if (prevId !== id) {
          if (prevId != null) delete this._byId[prevId];
          if (id != null) this._byId[id] = model;
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
      sortBy: 3, indexBy: 3};

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], _.bind(method, this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    this.checkUrl = _.bind(this.checkUrl, this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var root = path.slice(0, this.root.length - 1) + '/';
      return root === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var root = this.root.slice(0, -1) || '/';
          this.location.replace(root + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function (eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function (eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var root = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        root = root.slice(0, -1) || '/';
      }
      var url = root + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"jquery":"jquery","underscore":76}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":8}],4:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],5:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":6}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],8:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":7,"_process":6,"inherits":4}],9:[function(require,module,exports){
/**
 * Abstract handler for animator steps
 */
var AnimatorStepsRange = function(start, end) {
  if (start < 0) throw new Error('start must be a positive number');
  if (start >= end) throw new Error('start must be smaller than end');

  this.start = start;
  this.end = end;
};

AnimatorStepsRange.prototype = {

  diff: function() {
    return this.end - this.start;
  },

  isLast: function(step) {
    // round step into an integer, to be able to compare number as expected (also converts bad input to 0)
    return (step | 0) === this.end;
  }
};

module.exports = AnimatorStepsRange;

},{}],10:[function(require,module,exports){
(function (global){
var torque = require('./');
var AnimatorStepsRange = require('./animator-steps-range');

var requestAnimationFrame = global.requestAnimationFrame
    || global.mozRequestAnimationFrame
    || global.webkitRequestAnimationFrame
    || global.msRequestAnimationFrame
    || function(callback) { return global.setTimeout(callback, 1000 / 60); };

var cancelAnimationFrame = global.cancelAnimationFrame
    || global.mozCancelAnimationFrame
    || global.webkitCancelAnimationFrame
    || global.msCancelAnimationFrame
    || function(id) { clearTimeout(id); };

  /**
   * options:
   *    animationDuration in seconds
   *    animationDelay in seconds
   */
  function Animator(callback, options) {
    if(!options.steps) {
      throw new Error("steps option missing")
    }
    this.options = options;
    this.running = false;
    this._tick = this._tick.bind(this);
    this._t0 = +new Date();
    this.callback = callback;
    this._time = 0.0;
    this.itemsReady = false;

    this.options = torque.extend({
        animationDelay: 0,
        maxDelta: 0.2,
        loop: options.loop === undefined ? true : options.loop
    }, this.options);

    this.steps(options.steps);
  }

  Animator.prototype = {

    start: function() {
        this.running = true;
        requestAnimationFrame(this._tick);
        this.options.onStart && this.options.onStart();
        if (this.stepsRange().diff() === 1) {
          this.running = false;
        }
    },

    isRunning: function() {
      return this.running;
    },

    stop: function() {
      this.pause();
      this.time(this.stepsRange().start);
      this.options.onStop && this.options.onStop();
    },

    // real animation time
    time: function(_) {
      if (!arguments.length) return this._time;
      this._time = _;
      var t = this.range(this.domain(this._time));
      this.callback(t);
    },

    toggle: function() {
      if (this.running) {
        this.pause()
      } else {
        this.start()
      }
    },

    rescale: function() {
      this.domainInv = torque.math.linear(this.options.animationDelay, this.options.animationDelay + this.options.animationDuration);
      this.domain = this.domainInv.invert();
      this.range = torque.math.linear(0, this._defaultStepsRange.end);
      this.rangeInv = this.range.invert();
      this.time(this._time);
      this.running? this.start(): this.pause();
      return this;
    },

    duration: function(_) {
      if (!arguments.length)  return this.options.animationDuration;
      this.options.animationDuration = _;
      if (this.time() > _) {
        this.time(0);
      }
      this.rescale();
      return this;
    },

    steps: function(_) {
      this.options.steps = _;
      this._defaultStepsRange = new AnimatorStepsRange(0, _);
      return this.rescale();
    },

    // Returns or sets a (custom) steps range
    // Setting a steps range must be within the full range
    stepsRange: function(start, end) {
      if (arguments.length === 2) {
        if (start < this._defaultStepsRange.start) throw new Error('start must be within default steps range');
        if (end > this._defaultStepsRange.end) throw new Error('end must be within default steps range');

        this._customStepsRange = new AnimatorStepsRange(start, end);
        this.options.onStepsRange && this.options.onStepsRange();

        // Change current step if it's outside the new custom range
        var step = this.step() | 0; // round to an integer
        if (step < start || step > end) {
          this.step(start);
        }
      }
      return this._customStepsRange || this._defaultStepsRange;
    },

    removeCustomStepsRange: function() {
      this._customStepsRange = undefined;
      this.options.onStepsRange && this.options.onStepsRange();
    },

    step: function(s) {
      if(arguments.length === 0) return this.range(this.domain(this._time));
      this._time = this.domainInv(this.rangeInv(s));
    },

    pause: function() {
      this.running = false;
      cancelAnimationFrame(this._tick);
      this.options.onPause && this.options.onPause();
    },

    _tick: function() {
      var t1 = +new Date();
      var delta = (t1 - this._t0)*0.001;
      // if delta is really big means the tab lost the focus
      // at some point, so limit delta change
      delta = Math.min(this.options.maxDelta, delta);
      this._t0 = t1;
      this._time += delta;

      var stepsRange = this.stepsRange();
      if (stepsRange.isLast(this.step())) {
        if(!this.options.loop){
          // set time to max time
          this.time(this.options.animationDuration);
          this.pause();
        } else {
          this.step(stepsRange.start);
        }
      }
      if(this.running) {
        this.time(this._time);
        requestAnimationFrame(this._tick);
      }
    }

  };

module.exports = Animator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./":19,"./animator-steps-range":9}],11:[function(require,module,exports){
var _torque_reference_latest = {
    "version": "1.0.0",
    "style": {
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": [
                "src", //
                "src-over", //
                "dst-over", //
                "src-in", //
                "dst-in", //
                "src-out", //
                "dst-out", //
                "src-atop", //
                "dst-atop", //
                "xor", //
                "darken", //
                "lighten" //
            ]
        }
    },
    "layer" : {
        "buffer-size": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "-torque-clear-color": {
            "css": "-torque-clear-color",
            "type": "color",
            "default-value": "rgba(255, 255, 255, 0)",
            "default-meaning": "full clear",
            "doc": "color used to clear canvas on each frame"
        },
        "-torque-frame-count": {
            "css": "-torque-frame-count",
            "default-value": "128",
            "type":"number",
            "default-meaning": "the data is broken into 128 time frames",
            "doc": "Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used."
        },
        "-torque-resolution": {
            "css": "-torque-resolution",
            "default-value": "2",
            "type":"number",
            "default-meaning": "",
            "doc": "Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2"
        },
        "-torque-animation-duration": {
            "css": "-torque-animation-duration",
            "default-value": "30",
            "type":"number",
            "default-meaning": "the animation lasts 30 seconds",
            "doc": "Animation duration in seconds"
        },
        "-torque-aggregation-function": {
            "css": "-torque-aggregation-function",
            "default-value": "count(cartodb_id)",
            "type": "string",
            "default-meaning": "the value for each cell is the count of points in that cell",
            "doc": "A function used to calculate a value from the aggregate data for each cell. See -torque-resolution"
        },
        "-torque-time-attribute": {
            "css": "-torque-time-attribute",
            "default-value": "time",
            "type": "string",
            "default-meaning": "the data column in your table that is of a time based type",
            "doc": "The table column that contains the time information used create the animation"
        },
        "-torque-data-aggregation": {
            "css": "-torque-data-aggregation",
            "default-value": "linear",
            "type": [
              "cumulative"
            ],
            "default-meaning": "previous values are discarded",
            "doc": "A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts"
        }
    },
    "symbolizers" : {
        "*": {
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": [
                  "src", //
                  "src-over", //
                  "dst-over", //
                  "src-in", //
                  "dst-in", //
                  "src-out", //
                  "dst-out", //
                  "src-atop", //
                  "dst-atop", //
                  "xor", //
                  "darken", //
                  "lighten" //
                ]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "trail": {
          "steps": {
            "css": "trail-steps",
            "type": "float",
            "default-value": 1,
            "default-meaning": "no trail steps",
            "doc": "How many steps of trails are going to be rendered"
          }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon"
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque"
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line"
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels"
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": [
                    "miter",
                    "round",
                    "bevel"
                ],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": [
                    "butt",
                    "round",
                    "square"
                ],
                "doc": "The display of line endings"
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri"
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color"
            },
            "marker-type": {
                "css": "marker-type",
                "type": [
                    "rectangle",
                    "ellipse"
                ],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an rectangle or an ellipse (a circle if height is equal to width)"
            },
             "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "float"
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            }
        }
    },
    "colors": {
        "aliceblue":  [240, 248, 255],
        "antiquewhite":  [250, 235, 215],
        "aqua":  [0, 255, 255],
        "aquamarine":  [127, 255, 212],
        "azure":  [240, 255, 255],
        "beige":  [245, 245, 220],
        "bisque":  [255, 228, 196],
        "black":  [0, 0, 0],
        "blanchedalmond":  [255,235,205],
        "blue":  [0, 0, 255],
        "blueviolet":  [138, 43, 226],
        "brown":  [165, 42, 42],
        "burlywood":  [222, 184, 135],
        "cadetblue":  [95, 158, 160],
        "chartreuse":  [127, 255, 0],
        "chocolate":  [210, 105, 30],
        "coral":  [255, 127, 80],
        "cornflowerblue":  [100, 149, 237],
        "cornsilk":  [255, 248, 220],
        "crimson":  [220, 20, 60],
        "cyan":  [0, 255, 255],
        "darkblue":  [0, 0, 139],
        "darkcyan":  [0, 139, 139],
        "darkgoldenrod":  [184, 134, 11],
        "darkgray":  [169, 169, 169],
        "darkgreen":  [0, 100, 0],
        "darkgrey":  [169, 169, 169],
        "darkkhaki":  [189, 183, 107],
        "darkmagenta":  [139, 0, 139],
        "darkolivegreen":  [85, 107, 47],
        "darkorange":  [255, 140, 0],
        "darkorchid":  [153, 50, 204],
        "darkred":  [139, 0, 0],
        "darksalmon":  [233, 150, 122],
        "darkseagreen":  [143, 188, 143],
        "darkslateblue":  [72, 61, 139],
        "darkslategrey":  [47, 79, 79],
        "darkturquoise":  [0, 206, 209],
        "darkviolet":  [148, 0, 211],
        "deeppink":  [255, 20, 147],
        "deepskyblue":  [0, 191, 255],
        "dimgray":  [105, 105, 105],
        "dimgrey":  [105, 105, 105],
        "dodgerblue":  [30, 144, 255],
        "firebrick":  [178, 34, 34],
        "floralwhite":  [255, 250, 240],
        "forestgreen":  [34, 139, 34],
        "fuchsia":  [255, 0, 255],
        "gainsboro":  [220, 220, 220],
        "ghostwhite":  [248, 248, 255],
        "gold":  [255, 215, 0],
        "goldenrod":  [218, 165, 32],
        "gray":  [128, 128, 128],
        "grey":  [128, 128, 128],
        "green":  [0, 128, 0],
        "greenyellow":  [173, 255, 47],
        "honeydew":  [240, 255, 240],
        "hotpink":  [255, 105, 180],
        "indianred":  [205, 92, 92],
        "indigo":  [75, 0, 130],
        "ivory":  [255, 255, 240],
        "khaki":  [240, 230, 140],
        "lavender":  [230, 230, 250],
        "lavenderblush":  [255, 240, 245],
        "lawngreen":  [124, 252, 0],
        "lemonchiffon":  [255, 250, 205],
        "lightblue":  [173, 216, 230],
        "lightcoral":  [240, 128, 128],
        "lightcyan":  [224, 255, 255],
        "lightgoldenrodyellow":  [250, 250, 210],
        "lightgray":  [211, 211, 211],
        "lightgreen":  [144, 238, 144],
        "lightgrey":  [211, 211, 211],
        "lightpink":  [255, 182, 193],
        "lightsalmon":  [255, 160, 122],
        "lightseagreen":  [32, 178, 170],
        "lightskyblue":  [135, 206, 250],
        "lightslategray":  [119, 136, 153],
        "lightslategrey":  [119, 136, 153],
        "lightsteelblue":  [176, 196, 222],
        "lightyellow":  [255, 255, 224],
        "lime":  [0, 255, 0],
        "limegreen":  [50, 205, 50],
        "linen":  [250, 240, 230],
        "magenta":  [255, 0, 255],
        "maroon":  [128, 0, 0],
        "mediumaquamarine":  [102, 205, 170],
        "mediumblue":  [0, 0, 205],
        "mediumorchid":  [186, 85, 211],
        "mediumpurple":  [147, 112, 219],
        "mediumseagreen":  [60, 179, 113],
        "mediumslateblue":  [123, 104, 238],
        "mediumspringgreen":  [0, 250, 154],
        "mediumturquoise":  [72, 209, 204],
        "mediumvioletred":  [199, 21, 133],
        "midnightblue":  [25, 25, 112],
        "mintcream":  [245, 255, 250],
        "mistyrose":  [255, 228, 225],
        "moccasin":  [255, 228, 181],
        "navajowhite":  [255, 222, 173],
        "navy":  [0, 0, 128],
        "oldlace":  [253, 245, 230],
        "olive":  [128, 128, 0],
        "olivedrab":  [107, 142, 35],
        "orange":  [255, 165, 0],
        "orangered":  [255, 69, 0],
        "orchid":  [218, 112, 214],
        "palegoldenrod":  [238, 232, 170],
        "palegreen":  [152, 251, 152],
        "paleturquoise":  [175, 238, 238],
        "palevioletred":  [219, 112, 147],
        "papayawhip":  [255, 239, 213],
        "peachpuff":  [255, 218, 185],
        "peru":  [205, 133, 63],
        "pink":  [255, 192, 203],
        "plum":  [221, 160, 221],
        "powderblue":  [176, 224, 230],
        "purple":  [128, 0, 128],
        "red":  [255, 0, 0],
        "rosybrown":  [188, 143, 143],
        "royalblue":  [65, 105, 225],
        "saddlebrown":  [139, 69, 19],
        "salmon":  [250, 128, 114],
        "sandybrown":  [244, 164, 96],
        "seagreen":  [46, 139, 87],
        "seashell":  [255, 245, 238],
        "sienna":  [160, 82, 45],
        "silver":  [192, 192, 192],
        "skyblue":  [135, 206, 235],
        "slateblue":  [106, 90, 205],
        "slategray":  [112, 128, 144],
        "slategrey":  [112, 128, 144],
        "snow":  [255, 250, 250],
        "springgreen":  [0, 255, 127],
        "steelblue":  [70, 130, 180],
        "tan":  [210, 180, 140],
        "teal":  [0, 128, 128],
        "thistle":  [216, 191, 216],
        "tomato":  [255, 99, 71],
        "turquoise":  [64, 224, 208],
        "violet":  [238, 130, 238],
        "wheat":  [245, 222, 179],
        "white":  [255, 255, 255],
        "whitesmoke":  [245, 245, 245],
        "yellow":  [255, 255, 0],
        "yellowgreen":  [154, 205, 50],
        "transparent":  [0, 0, 0, 0]
    }
};

module.exports = {
  version: {
    latest: _torque_reference_latest,
    '1.0.0': _torque_reference_latest
  }
};

},{}],12:[function(require,module,exports){
(function (global){
//
// common functionallity for torque layers
//
var carto = global.carto || require('carto');

function TorqueLayer() {}

TorqueLayer.prototype = {
};

TorqueLayer.optionsFromLayer = function(mapConfig) {
  var opts = {};
  if (!mapConfig) return opts;
  var attrs = {
    'buffer-size': 'buffer-size',
    '-torque-frame-count': 'steps',
    '-torque-resolution': 'resolution',
    '-torque-animation-duration': 'animationDuration',
    '-torque-aggregation-function': 'countby',
    '-torque-time-attribute': 'column',
    '-torque-data-aggregation': 'data_aggregation'
  };
  for (var i in attrs) {
    var v = mapConfig.eval(i);
    if (v !== undefined) {
      var a = attrs[i];
      opts[a] = v;
    }
  }
  return opts;
};

TorqueLayer.optionsFromCartoCSS = function(cartocss) {
  var shader = new carto.RendererJS().render(cartocss);
  var mapConfig = shader.findLayer({ name: 'Map' });
  return TorqueLayer.optionsFromLayer(mapConfig);
};

module.exports.TorqueLayer = TorqueLayer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"carto":39}],13:[function(require,module,exports){
(function (global){
  var Event = {};
  Event.on = function(evt, callback) {
      var cb = this._evt_callbacks = this._evt_callbacks || {};
      var l = cb[evt] || (cb[evt] = []);
      l.push(callback);
      return this;
  };

  Event.trigger = function(evt) {
      var c = this._evt_callbacks && this._evt_callbacks[evt];
      for(var i = 0; c && i < c.length; ++i) {
          c[i].apply(this, Array.prototype.slice.call(arguments, 1));
      }
      return this;
  };

  Event.fire = Event.trigger;

  Event.off = function (evt, callback) {
      var c = this._evt_callbacks && this._evt_callbacks[evt];
      if (c && !callback) {
        delete this._evt_callbacks[evt];
        return this;
     }
     var remove = [];
     for(var i = 0; c && i < c.length; ++i) {
       if(c[i] === callback) remove.push(i);
     }
     while((i = remove.pop()) !== undefined) c.splice(i, 1);
    return this;
  };

  Event.callbacks = function(evt) {
    return (this._evt_callbacks && this._evt_callbacks[evt]) || [];
  };

  function extend() {
      var objs = arguments;
      var a = objs[0];
      for (var i = 1; i < objs.length; ++i) {
          var b = objs[i];
          for (var k in b) {
              a[k] = b[k];
          }
      }
      return a;
  }

  function clone(a) {
    return extend({}, a);
  }

  function isFunction(f) {
    return typeof f == 'function' || false;
  }

  function isArray(value) {
      return value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object Array]';
  }

  // types
  var types = {
    Uint8Array: typeof(global['Uint8Array']) !== 'undefined' ? global.Uint8Array : Array,
    Uint8ClampedArray: typeof(global['Uint8ClampedArray']) !== 'undefined' ? global.Uint8ClampedArray: Array,
    Uint32Array: typeof(global['Uint32Array']) !== 'undefined' ? global.Uint32Array : Array,
    Int16Array: typeof(global['Int16Array']) !== 'undefined' ? global.Int16Array : Array,
    Int32Array: typeof(global['Int32Array']) !== 'undefined' ? global.Int32Array: Array
  };

  function isBrowserSupported() {
    return !!document.createElement('canvas');
  }

  function userAgent() {
      return typeof navigator !== 'undefined' ? navigator.userAgent : '';
  }

  var flags = {
    sprites_to_images: userAgent().indexOf('Safari') === -1 && userAgent().indexOf('Firefox') === -1
  };

module.exports = {
    Event: Event,
    extend: extend,
    clone: clone,
    isFunction: isFunction,
    isArray: isArray,
    types: types,
    isBrowserSupported: isBrowserSupported,
    flags: flags
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Extends OverlayView to provide a canvas "Layer".
 * @author Brendan Kenny
 */

/**
 * A map layer that provides a canvas over the slippy map and a callback
 * system for efficient animation. Requires canvas and CSS 2D transform
 * support.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {CanvasLayerOptions=} opt_options Options to set in this CanvasLayer.
 */

function CanvasLayer(opt_options) {
  /**
   * If true, canvas is in a map pane and the OverlayView is fully functional.
   * See google.maps.OverlayView.onAdd for more information.
   * @type {boolean}
   * @private
   */
  this.isAdded_ = false;

  /**
   * If true, each update will immediately schedule the next.
   * @type {boolean}
   * @private
   */
  this.isAnimated_ = false;

  /**
   * The name of the MapPane in which this layer will be displayed.
   * @type {string}
   * @private
   */
  this.paneName_ = CanvasLayer.DEFAULT_PANE_NAME_;

  /**
   * A user-supplied function called whenever an update is required. Null or
   * undefined if a callback is not provided.
   * @type {?function=}
   * @private
   */
  this.updateHandler_ = null;

  /**
   * A user-supplied function called whenever an update is required and the
   * map has been resized since the last update. Null or undefined if a
   * callback is not provided.
   * @type {?function}
   * @private
   */
  this.resizeHandler_ = null;

  /**
   * The LatLng coordinate of the top left of the current view of the map. Will
   * be null when this.isAdded_ is false.
   * @type {google.maps.LatLng}
   * @private
   */
  this.topLeft_ = null;

  /**
   * The map-pan event listener. Will be null when this.isAdded_ is false. Will
   * be null when this.isAdded_ is false.
   * @type {?function}
   * @private
   */
  this.centerListener_ = null;

  /**
   * The map-resize event listener. Will be null when this.isAdded_ is false.
   * @type {?function}
   * @private
   */
  this.resizeListener_ = null;

  /**
   * If true, the map size has changed and this.resizeHandler_ must be called
   * on the next update.
   * @type {boolean}
   * @private
   */
  this.needsResize_ = true;

  /**
   * A browser-defined id for the currently requested callback. Null when no
   * callback is queued.
   * @type {?number}
   * @private
   */
  this.requestAnimationFrameId_ = null;

  var canvas = document.createElement('canvas');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.pointerEvents = 'none';

  /**
   * The canvas element.
   * @type {!HTMLCanvasElement}
   */
  this.canvas = canvas;

  /**
   * Simple bind for functions with no args for bind-less browsers (Safari).
   * @param {Object} thisArg The this value used for the target function.
   * @param {function} func The function to be bound.
   */
  function simpleBindShim(thisArg, func) {
    return function() { func.apply(thisArg); };
  }

  /**
   * A reference to this.repositionCanvas_ with this bound as its this value.
   * @type {function}
   * @private
   */
  this.repositionFunction_ = simpleBindShim(this, this.repositionCanvas_);

  /**
   * A reference to this.resize_ with this bound as its this value.
   * @type {function}
   * @private
   */
  this.resizeFunction_ = simpleBindShim(this, this.resize_);

  /**
   * A reference to this.update_ with this bound as its this value.
   * @type {function}
   * @private
   */
  this.requestUpdateFunction_ = simpleBindShim(this, this.update_);

  // set provided options, if any
  if (opt_options) {
    this.setOptions(opt_options);
  }
}

CanvasLayer.prototype = new google.maps.OverlayView();

/**
 * The default MapPane to contain the canvas.
 * @type {string}
 * @const
 * @private
 */
CanvasLayer.DEFAULT_PANE_NAME_ = 'overlayLayer';

/**
 * Transform CSS property name, with vendor prefix if required. If browser
 * does not support transforms, property will be ignored.
 * @type {string}
 * @const
 * @private
 */
CanvasLayer.CSS_TRANSFORM_ = (function() {
  var div = document.createElement('div');
  var transformProps = [
    'transform',
    'WebkitTransform',
    'MozTransform',
    'OTransform',
    'msTransform'
  ];
  for (var i = 0; i < transformProps.length; i++) {
    var prop = transformProps[i];
    if (div.style[prop] !== undefined) {
      return prop;
    }
  }

  // return unprefixed version by default
  return transformProps[0];
})();

/**
 * The requestAnimationFrame function, with vendor-prefixed or setTimeout-based
 * fallbacks. MUST be called with window as thisArg.
 * @type {function}
 * @param {function} callback The function to add to the frame request queue.
 * @return {number} The browser-defined id for the requested callback.
 * @private
 */
CanvasLayer.prototype.requestAnimFrame_ =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };

/**
 * The cancelAnimationFrame function, with vendor-prefixed fallback. Does not
 * fall back to clearTimeout as some platforms implement requestAnimationFrame
 * but not cancelAnimationFrame, and the cost is an extra frame on onRemove.
 * MUST be called with window as thisArg.
 * @type {function}
 * @param {number=} requestId The id of the frame request to cancel.
 * @private
 */
CanvasLayer.prototype.cancelAnimFrame_ =
    window.cancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.oCancelAnimationFrame ||
    window.msCancelAnimationFrame ||
    function(requestId) {};

/**
 * Sets any options provided. See CanvasLayerOptions for more information.
 * @param {CanvasLayerOptions} options The options to set.
 */
CanvasLayer.prototype.setOptions = function(options) {
  if (options.animate !== undefined) {
    this.setAnimate(options.animate);
  }

  if (options.paneName !== undefined) {
    this.setPane(options.paneName);
  }

  if (options.updateHandler !== undefined) {
    this.setUpdateHandler(options.updateHandler);
  }

  if (options.resizeHandler !== undefined) {
    this.setResizeHandler(options.resizeHandler);
  }

  if(options.readyHandler) {
    this.readyHandler = options.readyHandler;
  }

};

/**
 * Set the animated state of the layer. If true, updateHandler will be called
 * repeatedly, once per frame. If false, updateHandler will only be called when
 * a map property changes that could require the canvas content to be redrawn.
 * @param {boolean} animate Whether the canvas is animated.
 */
CanvasLayer.prototype.setAnimate = function(animate) {
  this.isAnimated_ = !!animate;

  if (this.isAnimated_) {
    this.scheduleUpdate();
  }
};

/**
 * @return {boolean} Whether the canvas is animated.
 */
CanvasLayer.prototype.isAnimated = function() {
  return this.isAnimated_;
};

/**
 * Set the MapPane in which this layer will be displayed, by name. See
 * {@code google.maps.MapPanes} for the panes available.
 * @param {string} paneName The name of the desired MapPane.
 */
CanvasLayer.prototype.setPaneName = function(paneName) {
  this.paneName_ = paneName;

  this.setPane_();
};

/**
 * Set the opacity for the canvas.
 * 
 * @param {number} opacity The opacity of the canvas
 */
CanvasLayer.prototype.setOpacity = function (opacity) {
  this.canvas.style.opacity = opacity;
};

/**
 * Get the canvases opacity.
 * 
 * @return {number} The opacity of the canvas
 */
CanvasLayer.prototype.getOpacity = function () {
  return this.canvas.style.opacity;
};

/**
 * @return {string} The name of the current container pane.
 */
CanvasLayer.prototype.getPaneName = function() {
  return this.paneName_;
};

/**
 * Adds the canvas to the specified container pane. Since this is guaranteed to
 * execute only after onAdd is called, this is when paneName's existence is
 * checked (and an error is thrown if it doesn't exist).
 * @private
 */
CanvasLayer.prototype.setPane_ = function() {
  if (!this.isAdded_) {
    return;
  }

  // onAdd has been called, so panes can be used
  var panes = this.getPanes();
  if (!panes[this.paneName_]) {
    throw new Error('"' + this.paneName_ + '" is not a valid MapPane name.');
  }

  panes[this.paneName_].appendChild(this.canvas);
};

/**
 * Set a function that will be called whenever the parent map and the overlay's
 * canvas have been resized. If opt_resizeHandler is null or unspecified, any
 * existing callback is removed.
 * @param {?function=} opt_resizeHandler The resize callback function.
 */
CanvasLayer.prototype.setResizeHandler = function(opt_resizeHandler) {
  this.resizeHandler_ = opt_resizeHandler;
};

/**
 * Set a function that will be called when a repaint of the canvas is required.
 * If opt_updateHandler is null or unspecified, any existing callback is
 * removed.
 * @param {?function=} opt_updateHandler The update callback function.
 */
CanvasLayer.prototype.setUpdateHandler = function(opt_updateHandler) {
  this.updateHandler_ = opt_updateHandler;
};

/**
 * @inheritDoc
 */
CanvasLayer.prototype.onAdd = function() {
  if (this.isAdded_) {
    return;
  }

  this.isAdded_ = true;
  this.setPane_();

  this.resizeListener_ = google.maps.event.addListener(this.getMap(),
      'resize', this.resizeFunction_);
  this.centerListener_ = google.maps.event.addListener(this.getMap(),
      'center_changed', this.repositionFunction_);

  this.resize_();
  this.repositionCanvas_();
  this.readyHandler && this.readyHandler();
};

/**
 * @inheritDoc
 */
CanvasLayer.prototype.onRemove = function() {
  if (!this.isAdded_) {
    return;
  }

  this.isAdded_ = false;
  this.topLeft_ = null;

  // remove canvas and listeners for pan and resize from map
  this.canvas.parentElement.removeChild(this.canvas);
  if (this.centerListener_) {
    google.maps.event.removeListener(this.centerListener_);
    this.centerListener_ = null;
  }
  if (this.resizeListener_) {
    google.maps.event.removeListener(this.resizeListener_);
    this.resizeListener_ = null;
  }

  // cease canvas update callbacks
  if (this.requestAnimationFrameId_) {
    this.cancelAnimFrame_.call(window, this.requestAnimationFrameId_);
    this.requestAnimationFrameId_ = null;
  }
};

/**
 * The internal callback for resize events that resizes the canvas to keep the
 * map properly covered.
 * @private
 */
CanvasLayer.prototype.resize_ = function() {
  // TODO(bckenny): it's common to use a smaller canvas but use CSS to scale
  // what is drawn by the browser to save on fill rate. Add an option to do
  // this.

  if (!this.isAdded_) {
    return;
  }

  var map = this.getMap();
  var width = map.getDiv().offsetWidth;
  var height = map.getDiv().offsetHeight;
  var oldWidth = this.canvas.width;
  var oldHeight = this.canvas.height;

  // resizing may allocate a new back buffer, so do so conservatively
  if (oldWidth !== width || oldHeight !== height) {
    this.canvas.width = width;
    this.canvas.height = height;
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';

    this.needsResize_ = true;
    this.scheduleUpdate();
  }
};

/**
 * @inheritDoc
 */
CanvasLayer.prototype.draw = function() {
  this.repositionCanvas_();
};

/**
 * Internal callback for map view changes. Since the Maps API moves the overlay
 * along with the map, this function calculates the opposite translation to
 * keep the canvas in place.
 * @private
 */
CanvasLayer.prototype.repositionCanvas_ = function() {
  // TODO(bckenny): *should* only be executed on RAF, but in current browsers
  //     this causes noticeable hitches in map and overlay relative
  //     positioning.

  var bounds = this.getMap().getBounds();
  this.topLeft_ = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getSouthWest().lng());

  // canvas position relative to draggable map's conatainer depends on
  // overlayView's projection, not the map's
  var projection = this.getProjection();
  var divTopLeft = projection.fromLatLngToDivPixel(this.topLeft_);

  // when the zoom level is low, more than one map can be shown in the screen
  // so the canvas should be attach to the map with more are in the screen
  var mapSize = (1 << this.getMap().getZoom())*256;
  if (Math.abs(divTopLeft.x) > mapSize) {
    divTopLeft.x -= mapSize;
  }
  this.canvas.style[CanvasLayer.CSS_TRANSFORM_] = 'translate(' +
      Math.round(divTopLeft.x) + 'px,' + Math.round(divTopLeft.y) + 'px)';

  this.scheduleUpdate();
};

/**
 * Internal callback that serves as main animation scheduler via
 * requestAnimationFrame. Calls resize and update callbacks if set, and
 * schedules the next frame if overlay is animated.
 * @private
 */
CanvasLayer.prototype.update_ = function() {
  this.requestAnimationFrameId_ = null;

  if (!this.isAdded_) {
    return;
  }

  if (this.isAnimated_) {
    this.scheduleUpdate();
  }

  if (this.needsResize_ && this.resizeHandler_) {
    this.needsResize_ = false;
    this.resizeHandler_();
  }

  if (this.updateHandler_) {
    this.updateHandler_();
  }
};

/**
 * A convenience method to get the current LatLng coordinate of the top left of
 * the current view of the map.
 * @return {google.maps.LatLng} The top left coordinate.
 */
CanvasLayer.prototype.getTopLeft = function() {
  return this.topLeft_;
};

/**
 * Schedule a requestAnimationFrame callback to updateHandler. If one is
 * already scheduled, there is no effect.
 */
CanvasLayer.prototype.scheduleUpdate = function() {
  if (this.isAdded_ && !this.requestAnimationFrameId_) {
    this.requestAnimationFrameId_ =
        this.requestAnimFrame_.call(window, this.requestUpdateFunction_);
  }
};

module.exports = CanvasLayer;

},{}],15:[function(require,module,exports){
/*
 ====================
 canvas setup for drawing tiles
 ====================
 */

function CanvasTileLayer(canvas_setup, render) {
  this.tileSize = new google.maps.Size(256, 256);
  this.maxZoom = 19;
  this.name = "Tile #s";
  this.alt = "Canvas tile layer";
  this.tiles = {};
  this.canvas_setup = canvas_setup;
  this.render = render;
  if (!render) {
      this.render = canvas_setup;
  }
}


// create a tile with a canvas element
CanvasTileLayer.prototype.create_tile_canvas = function (coord, zoom, ownerDocument) {

  // create canvas and reset style
  var canvas = ownerDocument.createElement('canvas');
  var hit_canvas = ownerDocument.createElement('canvas');
  canvas.style.border = hit_canvas.style.border = "none";
  canvas.style.margin = hit_canvas.style.margin = "0";
  canvas.style.padding = hit_canvas.style.padding = "0";

  // prepare canvas and context sizes
  var ctx = canvas.getContext('2d');
  ctx.width = canvas.width = this.tileSize.width;
  ctx.height = canvas.height = this.tileSize.height;

  var hit_ctx = hit_canvas.getContext('2d');
  hit_canvas.width = hit_ctx.width = this.tileSize.width;
  hit_canvas.height = hit_ctx.height = this.tileSize.height;

  //set unique id
  var tile_id = coord.x + '_' + coord.y + '_' + zoom;

  canvas.setAttribute('id', tile_id);
  hit_canvas.setAttribute('id', tile_id);

  if (tile_id in this.tiles)
      delete this.tiles[tile_id];

  this.tiles[tile_id] = {canvas:canvas, ctx:ctx, hit_canvas:hit_canvas, hit_ctx:hit_ctx, coord:coord, zoom:zoom, primitives:null};

  // custom setup
  //if (tile_id == '19295_24654_16'){
  if (this.canvas_setup)
      this.canvas_setup(this.tiles[tile_id], coord, zoom);
  //}
  return canvas;

}


CanvasTileLayer.prototype.each = function (callback) {
  for (var t in this.tiles) {
      var tile = this.tiles[t];
      callback(tile);
  }
}

CanvasTileLayer.prototype.recreate = function () {
  for (var t in this.tiles) {
      var tile = this.tiles[t];
      this.canvas_setup(tile, tile.coord, tile.zoom);
  }
};

CanvasTileLayer.prototype.redraw_tile = function (tile) {
  this.render(tile, tile.coord, tile.zoom);
};

CanvasTileLayer.prototype.redraw = function () {
  for (var t in this.tiles) {
      var tile = this.tiles[t];
      this.render(tile, tile.coord, tile.zoom);
  }
};

// could be called directly...
CanvasTileLayer.prototype.getTile = function (coord, zoom, ownerDocument) {
  return this.create_tile_canvas(coord, zoom, ownerDocument);
};

CanvasTileLayer.prototype.releaseTile = function (tile) {
  var id = tile.getAttribute('id');
  delete this.tiles[id];
};

module.exports = CanvasTileLayer;

},{}],16:[function(require,module,exports){
function GMapsTileLoader() {
}


GMapsTileLoader.prototype = {

  _initTileLoader: function(map, projection) {
    this._map = map;
    this._projection = projection;
    this._tiles = {};
    this._tilesLoading = {};
    this._tilesToLoad = 0;
    this._updateTiles = this._updateTiles.bind(this);
    this._listeners = [];
    this._listeners.push(
      google.maps.event.addListener(this._map, 'dragend', this._updateTiles),
      google.maps.event.addListener(this._map, 'zoom_changed', this._updateTiles)
    );
    this.tileSize = 256;
    this._updateTiles();
  },

  _removeTileLoader: function() {
    this._listeners.forEach(function (listener) {
      google.maps.event.removeListener(listener);
    });
    
    this._removeTiles();
  },

  _removeTiles: function () {
    for (var key in this._tiles) {
      this._removeTile(key);
    }
  },

  _reloadTiles: function() {
    this._removeTiles();
    this._updateTiles();
  },

  _updateTiles: function () {

      if (!this._map) { return; }

      var bounds = this._map.getBounds();
      var zoom = this._map.getZoom();
      var tileSize = this.tileSize;
      var mzoom = (1 << zoom);

      var topLeft = new google.maps.LatLng(
        bounds.getNorthEast().lat(),
        bounds.getSouthWest().lng()
      );

      var bottomRigth = new google.maps.LatLng(
        bounds.getSouthWest().lat(),
        bounds.getNorthEast().lng()
      );


      this._projection = this._map.getProjection();
      var divTopLeft = this._projection.fromLatLngToPoint(topLeft);
      var divBottomRight = this._projection.fromLatLngToPoint(bottomRigth);


      var nwTilePoint = new google.maps.Point(
              Math.floor(divTopLeft.x*mzoom / tileSize),
              Math.floor(divTopLeft.y*mzoom / tileSize)),
          seTilePoint = new google.maps.Point(
              Math.floor(divBottomRight.x*mzoom / tileSize),
              Math.floor(divBottomRight.y*mzoom / tileSize));


      this._addTilesFromCenterOut(nwTilePoint, seTilePoint);
      this._removeOtherTiles(nwTilePoint, seTilePoint);
  },

  _removeOtherTiles: function (nwTilePoint, seTilePoint) {
      var kArr, x, y, key;

      var zoom = this._map.getZoom();
      for (key in this._tiles) {
          if (this._tiles.hasOwnProperty(key)) {
              kArr = key.split(':');
              x = parseInt(kArr[0], 10);
              y = parseInt(kArr[1], 10);
              z = parseInt(kArr[2], 10);

              // remove tile if it's out of bounds
              if (z !== zoom || x < nwTilePoint.x || x > seTilePoint.x || y < nwTilePoint.y || y > seTilePoint.y) {
                  this._removeTile(key);
              }
          }
      }
  },

  _removeTile: function (key) {
      this.onTileRemoved && this.onTileRemoved(this._tiles[key]); 
      delete this._tiles[key];
      delete this._tilesLoading[key];
  },

  _tileKey: function(tilePoint) {
    return tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom;
  },

  _tileShouldBeLoaded: function (tilePoint) {
      var k = this._tileKey(tilePoint);
      return !(k in this._tiles) && !(k in this._tilesLoading);
  },

  _tileLoaded: function(tilePoint, tileData) {
    this._tilesToLoad--;
    var k = tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom
    this._tiles[k] = tileData;
    delete this._tilesLoading[k];
    if(this._tilesToLoad === 0) {
      this.onTilesLoaded && this.onTilesLoaded();
    }
  },

  getTilePos: function (tilePoint) {
    var limit = (1 << this._map.getZoom());
    // wrap tile
    tilePoint = {
      x: ((tilePoint.x % limit) + limit) % limit,
      y: tilePoint.y
    };

    tilePoint = new google.maps.Point(
      tilePoint.x * this.tileSize, 
      tilePoint.y * this.tileSize
    );

    var bounds = this._map.getBounds();
    var topLeft = new google.maps.LatLng(
      bounds.getNorthEast().lat(),
      bounds.getSouthWest().lng()
    );

    var divTopLeft = this._map.getProjection().fromLatLngToPoint(topLeft);
    zoom = (1 << this._map.getZoom());
    divTopLeft.x = divTopLeft.x * zoom;
    divTopLeft.y = divTopLeft.y * zoom;

    return new google.maps.Point(
      tilePoint.x - divTopLeft.x,
      tilePoint.y - divTopLeft.y
    );
  },

  _addTilesFromCenterOut: function (nwTilePoint, seTilePoint) {
      var queue = [],
          center = new google.maps.Point(
            (nwTilePoint.x + seTilePoint.x) * 0.5,
            (nwTilePoint.y + seTilePoint.y) * 0.5
          ),
          zoom = this._map.getZoom();

      var j, i, point;

      for (j = nwTilePoint.y; j <= seTilePoint.y; j++) {
          for (i = nwTilePoint.x; i <= seTilePoint.x; i++) {
              point = new google.maps.Point (i, j);
              point.zoom = zoom;

              if (this._tileShouldBeLoaded(point)) {
                  queue.push(point);
              }
          }
      }

      var tilesToLoad = queue.length;

      if (tilesToLoad === 0) { return; }

      function distanceToCenterSq(point) {
        var dx = point.x - center.x;
        var dy = point.y - center.y;
        return dx * dx + dy * dy;
      }

      // load tiles in order of their distance to center
      queue.sort(function (a, b) {
          return distanceToCenterSq(a) - distanceToCenterSq(b);
      });

      this._tilesToLoad += tilesToLoad;

        for (i = 0; i < tilesToLoad; i++) {
          var t = queue[i];
          var k = this._tileKey(t);
          this._tilesLoading[k] = t;
          // events
          if (this.onTileAdded) {
            this.onTileAdded(t);
          }
        }

      this.onTilesLoading && this.onTilesLoading();
  }

}

module.exports = GMapsTileLoader;

},{}],17:[function(require,module,exports){
var gmaps = {};
if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
    gmaps = require('./torque');
    gmaps.GMapsTileLoader = require('./gmaps_tileloader_mixin');
}
module.exports = gmaps;

},{"./gmaps_tileloader_mixin":16,"./torque":18}],18:[function(require,module,exports){
(function (global){
var carto = global.carto || require('carto');
var torque = require('../');
var CanvasLayer = require('./CanvasLayer');
var CanvasTileLayer = require('./canvas_tile_layer');
var GMapsTileLoader = require('./gmaps_tileloader_mixin');

function GMapsTorqueLayer(options) {
  var self = this;
  if (!torque.isBrowserSupported()) {
    throw new Error("browser is not supported by torque");
  }
  this.key = 0;
  this.shader = null;
  this.ready = false;
  this.options = torque.extend({}, options);
  this.options = torque.extend({
    provider: 'windshaft',
    renderer: 'point',
    resolution: 2,
    steps: 100,
    visible: true
  }, this.options);
  if (options.cartocss) {
    torque.extend(this.options,
        torque.common.TorqueLayer.optionsFromCartoCSS(options.cartocss));
  }

  if(options.tileJSON) this.options.provider = "tileJSON";

  this.hidden = !this.options.visible;

  this.animator = new torque.Animator(function(time) {
    var k = time | 0;
    if(self.key !== k) {
      self.setKey(k);
    }
  }, torque.extend(torque.clone(this.options), {
    onPause: function() {
      self.fire('pause');
    },
    onStop: function() {
      self.fire('stop');
    },
    onStart: function() {
      self.fire('play');
    },
    onStepsRange: function() {
      self.fire('change:stepsRange', self.animator.stepsRange());
    }
  }));

  this.play = this.animator.start.bind(this.animator);
  this.stop = this.animator.stop.bind(this.animator);
  this.pause = this.animator.pause.bind(this.animator);
  this.toggle = this.animator.toggle.bind(this.animator);
  this.setDuration = this.animator.duration.bind(this.animator);
  this.isRunning = this.animator.isRunning.bind(this.animator);


  CanvasLayer.call(this, {
    map: this.options.map,
    //resizeHandler: this.redraw,
    animate: false,
    updateHandler: this.render,
    readyHandler: this.initialize
  });

}

/**
 * torque layer
 */
GMapsTorqueLayer.prototype = torque.extend({},
  CanvasLayer.prototype,
  GMapsTileLoader.prototype,
  torque.Event,
  {

  providers: {
    'sql_api': torque.providers.json,
    'url_template': torque.providers.JsonArray,
    'windshaft': torque.providers.windshaft,
    'tileJSON': torque.providers.tileJSON
  },

  renderers: {
    'point': torque.renderer.Point,
    'pixel': torque.renderer.Rectangle
  },

  initialize: function() {
    var self = this;

    this.onTileAdded = this.onTileAdded.bind(this);

    this.options.ready = function() {
      self.fire("change:bounds", {
        bounds: self.provider.getBounds()
      });
      self.animator.steps(self.provider.getSteps());
      self.animator.rescale();
      self.fire('change:steps', {
        steps: self.provider.getSteps()
      });
      self.setKey(self.key);
    };

    this.provider = new this.providers[this.options.provider](this.options);
    this.renderer = new this.renderers[this.options.renderer](this.getCanvas(), this.options);
    this.renderer.options.errorCallback = this.options.errorCallback;

    // this listener should be before tile loader
    this._cacheListener = google.maps.event.addListener(this.options.map, 'zoom_changed', function() {
      self.renderer && self.renderer.clearSpriteCache();
    });

    this._initTileLoader(this.options.map, this.getProjection());

    if (this.shader) {
      this.renderer.setShader(this.shader);
    }

  },

  hide: function() {
    if(this.hidden) return this;
    this.pause();
    this.clear();
    this.hidden = true;
    return this;
  },

  show: function() {
    if(!this.hidden) return this;
    this.hidden = false;
    this.play();
    if (this.options.steps === 1){
      this.redraw();
    }
    return this;
  },

  setSQL: function(sql) {
    if (this.provider.options.named_map) throw new Error("SQL queries on named maps are read-only");
    if (!this.provider || !this.provider.setSQL) {
      throw new Error("this provider does not support SQL");
    }
    this.provider.setSQL(sql);
    this._reloadTiles();
    return this;
  },

  setBlendMode: function(_) {
    this.renderer && this.renderer.setBlendMode(_);
    this.redraw();
  },

  setSteps: function(steps) {
    this.provider && this.provider.setSteps(steps);
    this.animator && this.animator.steps(steps);
    this._reloadTiles();
  },

  setColumn: function(column, isTime) {
    this.provider && this.provider.setColumn(column, isTime);
    this._reloadTiles();
  },

  getTimeBounds: function() {
    return this.provider && this.provider.getKeySpan();
  },

  getCanvas: function() {
    return this.canvas;
  },

    // for each tile shown on the map request the data
  onTileAdded: function(t) {
    var self = this;
    this.provider.getTileData(t, t.zoom, function(tileData) {
      // don't load tiles that are not being shown
      if (t.zoom !== self.options.map.getZoom()) return;
      self._tileLoaded(t, tileData);
      self.fire('tileLoaded');
      if (tileData) {
        self.redraw();
      }
    });
  },

  clear: function() {
    var canvas = this.canvas;
    canvas.width = canvas.width;
  },

  /**
   * render the selectef key
   * don't call this function directly, it's called by
   * requestAnimationFrame. Use redraw to refresh it
   */
  render: function() {
    if(this.hidden) return;
    var t, tile, pos;
    var canvas = this.canvas;
    this.renderer.clearCanvas();
    var ctx = canvas.getContext('2d');

    // renders only a "frame"
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        pos = this.getTilePos(tile.coord);
        ctx.setTransform(1, 0, 0, 1, pos.x, pos.y);
        this.renderer.renderTile(tile, this.key);
      }
    }
    this.renderer.applyFilters();
  },

  getActivePointsBBox: function(step) {
    var positions = [];
    var tileMax = this.options.resolution * (256/this.options.resolution - 1);
    for(var t in this._tiles) {
      var tile = this._tiles[t];
      positions = positions.concat(this.renderer.getActivePointsBBox(tile, step));
    }
    return positions;
  },

  /**
   * set key to be shown. If it's a single value
   * it renders directly, if it's an array it renders
   * accumulated
   */
  setKey: function(key) {
    this.key = key;
    this.animator.step(key);
    this.redraw();
    this.fire('change:time', { time: this.getTime(), step: this.key });
  },

  /**
   * helper function, does the same than ``setKey`` but only
   * accepts scalars.
   */
  setStep: function(time) {
    if(time === undefined || time.length !== undefined) {
      throw new Error("setTime only accept scalars");
    }
    this.setKey(time);
  },

  /**
   * transform from animation step to Date object
   * that contains the animation time
   *
   * ``step`` should be between 0 and ``steps - 1``
   */
  stepToTime: function(step) {
    if (!this.provider) return 0;
    var times = this.provider.getKeySpan();
    var time = times.start + (times.end - times.start)*(step/this.provider.getSteps());
    return new Date(time);
  },

  timeToStep: function(timestamp) {
    if (typeof timestamp === "Date") timestamp = timestamp.getTime();
    if (!this.provider) return 0;
    var times = this.provider.getKeySpan();
    var step = (this.provider.getSteps() * (timestamp - times.start)) / (times.end - times.start);
    return step;
  },

  getStep: function() {
    return this.key;
  },

  /**
   * returns the animation time defined by the data
   * in the defined column. Date object
   */
  getTime: function() {
    return this.stepToTime(this.key);
  },

  /**
   * set the cartocss for the current renderer
   */
  setCartoCSS: function(cartocss) {
    if (this.provider && this.provider.options.named_map) throw new Error("CartoCSS style on named maps is read-only");
    var shader = new carto.RendererJS().render(cartocss);
    this.shader = shader;
    if (this.renderer) {
      this.renderer.setShader(shader);
    }

    // provider options
    var options = torque.common.TorqueLayer.optionsFromLayer(shader.findLayer({ name: 'Map' }));
    this.provider && this.provider.setCartoCSS && this.provider.setCartoCSS(cartocss);
    if(this.provider && this.provider.setOptions(options)) {
      this._reloadTiles();
    }
    torque.extend(this.options, options);

    // animator options
    if (options.animationDuration) {
      this.animator.duration(options.animationDuration);
    }

    this.redraw();
    return this;
  },

  redraw: function() {
    this.scheduleUpdate();
  },

  onRemove: function() {
    this.fire('remove');
    CanvasLayer.prototype.onRemove.call(this);
    this.animator.stop();
    this._removeTileLoader();
    google.maps.event.removeListener(this._cacheListener);
  },

  /**
   * return an array with the values for all the pixels active for the step
   */
  getValues: function(step) {
    var values = [];
    step = step === undefined ? this.key: step;
    var t, tile;
    for(t in this._tiles) {
      tile = this._tiles[t];
      this.renderer.getValues(tile, step, values);
    }
    return values;
  },

  getValueForPos: function(x, y, step) {
    step = step === undefined ? this.key: step;
    var t, tile, pos, value = null, xx, yy;
    for(t in this._tiles) {
      tile = this._tiles[t];
      pos = this.getTilePos(tile.coord);
      xx = x - pos.x;
      yy = y - pos.y;
      if (xx >= 0 && yy >= 0 && xx < this.renderer.TILE_SIZE && yy <= this.renderer.TILE_SIZE) {
        value = this.renderer.getValueFor(tile, step, xx, yy);
      }
      if (value !== null) {
        return value;
      }
    }
    return null;
  },
  getValueForBBox: function(x, y, w, h) {
    var xf = x + w, yf = y + h;
    var sum = 0;
    for(_y = y; y<yf; y+=this.options.resolution){
      for(_x = x; x<xf; x+=this.options.resolution){
        var thisValue = this.getValueForPos(_x,_y);
        if (thisValue){
          var bb = thisValue.bbox;
          var proj = this.getProjection()
          var xy = proj.fromLatLngToContainerPixel(new google.maps.LatLng(bb[1].lat, bb[1].lon));
          if(xy.x < xf && xy.y < yf){
            sum += thisValue.value;
          }
        }
      }
    }
    return sum;
  },

  error: function (callback) {
    this.options.errorCallback = callback;
    return this;
  }

});



function GMapsTiledTorqueLayer(options) {
  this.options = torque.extend({}, options);
  CanvasTileLayer.call(this, this._loadTile.bind(this), this.drawTile.bind(this));
  this.initialize(options);
}

GMapsTiledTorqueLayer.prototype = torque.extend({}, CanvasTileLayer.prototype, {

  providers: {
    'sql_api': torque.providers.json,
    'url_template': torque.providers.JsonArray
  },

  renderers: {
    'point': torque.renderer.Point,
    'pixel': torque.renderer.Rectangle
  },

  initialize: function(options) {
    var self = this;
    this.key = 0;

    this.options.renderer = this.options.renderer || 'pixel';
    this.options.provider = this.options.provider || 'sql_api';

    this.provider = new this.providers[this.options.provider](options);
    this.renderer = new this.renderers[this.options.renderer](null, options);

  },

  _tileLoaded: function(tile, tileData) {
    tile.data = tileData;
    this.drawTile(tile);
  },

  _loadTile: function(tile, coord, zoom) {
    var self = this;
    var limit = 1 << zoom;
    // wrap tile
    var wrappedCoord = {
      x: ((coord.x % limit) + limit) % limit,
      y: coord.y
    };

    this.provider.getTileData(wrappedCoord, zoom, function(tileData) {
      self._tileLoaded(tile, tileData);
    });
  },

  drawTile: function (tile) {
    var canvas = tile.canvas;
    if(!tile.data) return;
    canvas.width = canvas.width;

    this.renderer.setCanvas(canvas);

    var accum = this.renderer.accumulate(tile.data, this.key);
    this.renderer.renderTileAccum(accum, 0, 0);
  },

  setKey: function(key) {
    this.key = key;
    this.redraw();
  },

  /**
   * set the cartocss for the current renderer
   */
  setCartoCSS: function(cartocss) {
    if (!this.renderer) throw new Error('renderer is not valid');
    return this.renderer.setCartoCSS(cartocss);
  },

  setStepsRange: function(start, end) {
    this.animator.stepsRange(start, end);
  },

  removeStepsRange: function() {
    this.animator.removeCustomStepsRange();
  },

  getStepsRange: function() {
    return this.animator.stepsRange();
  }

});

module.exports = {
    GMapsTiledTorqueLayer: GMapsTiledTorqueLayer,
    GMapsTorqueLayer: GMapsTorqueLayer
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":19,"./CanvasLayer":14,"./canvas_tile_layer":15,"./gmaps_tileloader_mixin":16,"carto":39}],19:[function(require,module,exports){
module.exports = require('./core');

module.exports.Animator = require('./animator');
module.exports.cartocss_reference = require('./cartocss_reference');
module.exports.common = require('./common');
module.exports.math = require('./math');
module.exports.Mercator = require('./mercator');
module.exports.net = require('./request');
module.exports.renderer = require('./renderer');
module.exports.providers = require('./provider');

require('./leaflet');

var gmaps = require('./gmaps');
module.exports.GMapsTileLoader = gmaps.GMapsTileLoader;
module.exports.GMapsTorqueLayer = gmaps.GMapsTorqueLayer;
module.exports.GMapsTiledTorqueLayer = gmaps.GMapsTiledTorqueLayer;

},{"./animator":10,"./cartocss_reference":11,"./common":12,"./core":13,"./gmaps":17,"./leaflet":21,"./math":24,"./mercator":25,"./provider":27,"./renderer":33,"./request":37}],20:[function(require,module,exports){
require('./leaflet_tileloader_mixin');

/**
 * full canvas layer implementation for Leaflet
 */

L.CanvasLayer = L.Class.extend({

  includes: [L.Mixin.Events, L.Mixin.TileLoader],

  options: {
      minZoom: 0,
      maxZoom: 28,
      tileSize: 256,
      subdomains: 'abc',
      errorTileUrl: '',
      attribution: '',
      zoomOffset: 0,
      opacity: 1,
      unloadInvisibleTiles: L.Browser.mobile,
      updateWhenIdle: L.Browser.mobile,
      tileLoader: false, // installs tile loading events
      zoomAnimation: true
  },

  initialize: function (options) {
    var self = this;
    options = options || {};
    //this.project = this._project.bind(this);
    this.render = this.render.bind(this);
    L.Util.setOptions(this, options);
    this._canvas = this._createCanvas();
    // backCanvas for zoom animation
    if (this.options.zoomAnimation) {
      this._backCanvas = this._createCanvas();
    }
    this._ctx = this._canvas.getContext('2d');
    this.currentAnimationFrame = -1;
    this.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                                    return window.setTimeout(callback, 1000 / 60);
                                };
    this.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame ||
                                window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function(id) { clearTimeout(id); };
  },

  _createCanvas: function() {
    var canvas;
    canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.top = 0;
    canvas.style.left = 0;
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = this.options.zIndex || 0;
    var className = 'leaflet-tile-container';
    if (this.options.zoomAnimation) {
      className += ' leaflet-zoom-animated';
    }
    canvas.setAttribute('class', className);
    return canvas;
  },

  onAdd: function (map) {
    this._map = map;

    // add container with the canvas to the tile pane
    // the container is moved in the oposite direction of the 
    // map pane to keep the canvas always in (0, 0)
    var tilePane = this._map._panes.tilePane;
    var _container = L.DomUtil.create('div', 'leaflet-layer');
    _container.appendChild(this._canvas);
    if (this.options.zoomAnimation) {
      _container.appendChild(this._backCanvas);
      this._backCanvas.style.display = 'none';
    }
    tilePane.appendChild(_container);

    this._container = _container;

    // hack: listen to predrag event launched by dragging to
    // set container in position (0, 0) in screen coordinates
    map.dragging._draggable.on('predrag', function() {
      var d = map.dragging._draggable;
      L.DomUtil.setPosition(this._canvas, { x: -d._newPos.x, y: -d._newPos.y });
    }, this);

    map.on({ 'viewreset': this._reset }, this);
    map.on('move', this.redraw, this);
    map.on('resize', this._reset, this);

    if (this.options.zoomAnimation) {
      map.on({
        'zoomanim': this._animateZoom,
        'zoomend': this._endZoomAnim,
        'moveend': this._reset
      }, this);
    }

    if(this.options.tileLoader) {
      this._initTileLoader();
    }

    this._reset();
  },

  _animateZoom: function (e) {
    if (!this._animating) {
        this._animating = true;
    }
    var back = this._backCanvas;

    back.width = this._canvas.width;
    back.height = this._canvas.height;

    // paint current canvas in back canvas with trasnformation
    var pos = this._canvas._leaflet_pos || { x: 0, y: 0 };
    back.getContext('2d').drawImage(this._canvas, 0, 0);

    L.DomUtil.setPosition(back, L.DomUtil.getPosition(this._canvas));

    // hide original
    this._canvas.style.display = 'none';
    back.style.display = 'block';
    var map = this._map;
    var scale = map.getZoomScale(e.zoom);
    var newCenter = map._latLngToNewLayerPoint(map.getCenter(), e.zoom, e.center);
    var oldCenter = map._latLngToNewLayerPoint(e.center, e.zoom, e.center);

    var origin = {
      x:  newCenter.x - oldCenter.x + pos.x,
      y:  newCenter.y - oldCenter.y + pos.y,
    };

    var bg = back;
    var transform = L.DomUtil.TRANSFORM;
    setTimeout(function() {
      bg.style[transform] = L.DomUtil.getTranslateString(origin) + ' scale(' + e.scale + ') ';
    }, 0)
  },

  _endZoomAnim: function () {
    this._animating = false;
    this._canvas.style.display = 'block';
    this._backCanvas.style.display = 'none';
    this._backCanvas.style[L.DomUtil.TRANSFORM] = '';
  },

  getCanvas: function() {
    return this._canvas;
  },

  getAttribution: function() {
    return this.options.attribution;
  },

  draw: function() {
    return this._reset();
  },

  onRemove: function (map) {
    this._container.parentNode.removeChild(this._container);
    map.off({
      'viewreset': this._reset,
      'move': this._render,
      'moveend': this._reset,
      'resize': this._reset,
      'zoomanim': this._animateZoom,
      'zoomend': this._endZoomAnim
    }, this);
  },

  addTo: function (map) {
    map.addLayer(this);
    return this;
  },

  error: function (callback) {
    this.provider.options.errorCallback = callback;
    return this;
  },

  setOpacity: function (opacity) {
    this.options.opacity = opacity;
    this._updateOpacity();
    return this;
  },

  setZIndex: function(zIndex) {
    this._canvas.style.zIndex = zIndex;
    if (this.options.zoomAnimation) {
      this._backCanvas.style.zIndex = zIndex;
    }
  },

  bringToFront: function () {
    return this;
  },

  bringToBack: function () {
    return this;
  },

  _reset: function () {
    var size = this._map.getSize();
    this._canvas.width = size.x;
    this._canvas.height = size.y;

    // fix position
    var pos = L.DomUtil.getPosition(this._map.getPanes().mapPane);
    if (pos) {
      L.DomUtil.setPosition(this._canvas, { x: -pos.x, y: -pos.y });
    }
    this.onResize();
    this._render();
  },

  /*
  _project: function(x) {
    var point = this._map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
    return [point.x, point.y];
  },
  */

  _updateOpacity: function () { },

  _render: function() {
    if (this.currentAnimationFrame >= 0) {
      this.cancelAnimationFrame.call(window, this.currentAnimationFrame);
    }
    this.currentAnimationFrame = this.requestAnimationFrame.call(window, this.render);
  },

  // use direct: true if you are inside an animation frame call
  redraw: function(direct) {
    var domPosition = L.DomUtil.getPosition(this._map.getPanes().mapPane);
    if (domPosition) {
      L.DomUtil.setPosition(this._canvas, { x: -domPosition.x, y: -domPosition.y });
    }
    if (direct) {
      this.render();
    } else {
      this._render();
    }
  },

  onResize: function() {
  },

  render: function() {
    throw new Error('render function should be implemented');
  }

});

},{"./leaflet_tileloader_mixin":22}],21:[function(require,module,exports){
if (typeof L !== 'undefined') {
    require('./torque');
}

},{"./torque":23}],22:[function(require,module,exports){
L.Mixin.TileLoader = {

  _initTileLoader: function() {
    this._tiles = {}
    this._tilesLoading = {};
    this._tilesToLoad = 0;
    this._map.on({
        'moveend': this._updateTiles
    }, this);
    this._updateTiles();
  },

  _removeTileLoader: function() {
    this._map.off({
        'moveend': this._updateTiles
    }, this);
    this._removeTiles();
  },

  _updateTiles: function () {

      if (!this._map) { return; }

      var bounds = this._map.getPixelBounds(),
          zoom = this._map.getZoom(),
          tileSize = this.options.tileSize;

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
          return;
      }

      var nwTilePoint = new L.Point(
              Math.floor(bounds.min.x / tileSize),
              Math.floor(bounds.min.y / tileSize)),

          seTilePoint = new L.Point(
              Math.floor(bounds.max.x / tileSize),
              Math.floor(bounds.max.y / tileSize)),

          tileBounds = new L.Bounds(nwTilePoint, seTilePoint);

      this._addTilesFromCenterOut(tileBounds);
      this._removeOtherTiles(tileBounds);
  },

  _removeTiles: function (bounds) {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
  },

  _reloadTiles: function() {
    this._removeTiles();
    this._updateTiles();
  },

  _removeOtherTiles: function (bounds) {
      var kArr, x, y, z, key;
      var zoom = this._map.getZoom();

      for (key in this._tiles) {
          if (this._tiles.hasOwnProperty(key)) {
              kArr = key.split(':');
              x = parseInt(kArr[0], 10);
              y = parseInt(kArr[1], 10);
              z = parseInt(kArr[2], 10);

              // remove tile if it's out of bounds
              if (zoom !== z || x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                  this._removeTile(key);
              }
          }
      }
  },

  _removeTile: function (key) {
      this.fire('tileRemoved', this._tiles[key]);
      delete this._tiles[key];
      delete this._tilesLoading[key];
  },

  _tileKey: function(tilePoint) {
    return tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom;
  },

  _tileShouldBeLoaded: function (tilePoint) {
      var k = this._tileKey(tilePoint);
      return !(k in this._tiles) && !(k in this._tilesLoading);
  },

  _tileLoaded: function(tilePoint, tileData) {
    this._tilesToLoad--;
    var k = tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom
    this._tiles[k] = tileData;
    delete this._tilesLoading[k];
    if(this._tilesToLoad === 0) {
      this.fire("tilesLoaded");
    }
  },

  getTilePos: function (tilePoint) {
    tilePoint = new L.Point(tilePoint.x, tilePoint.y);
    var origin = this._map._getNewTopLeftPoint(this._map.getCenter()),
        tileSize = this.options.tileSize;

    return tilePoint.multiplyBy(tileSize).subtract(origin);
  },

  _addTilesFromCenterOut: function (bounds) {
      var queue = [],
          center = bounds.getCenter(),
          zoom = this._map.getZoom();

      var j, i, point;

      for (j = bounds.min.y; j <= bounds.max.y; j++) {
          for (i = bounds.min.x; i <= bounds.max.x; i++) {
              point = new L.Point(i, j);
              point.zoom =  zoom;

              if (this._tileShouldBeLoaded(point)) {
                  queue.push(point);
              }
          }
      }

      var tilesToLoad = queue.length;

      if (tilesToLoad === 0) { return; }

      // load tiles in order of their distance to center
      queue.sort(function (a, b) {
          return a.distanceTo(center) - b.distanceTo(center);
      });

      this._tilesToLoad += tilesToLoad;

      for (i = 0; i < tilesToLoad; i++) {
        var t = queue[i];
        var k = this._tileKey(t);
        this._tilesLoading[k] = t;
        this.fire('tileAdded', t);
      }
      this.fire("tilesLoading");

  }

}

},{}],23:[function(require,module,exports){
(function (global){
var carto = global.carto || require('carto');
var torque = require('../');

require('./canvas_layer');

/**
 * torque layer
 */
L.TorqueLayer = L.CanvasLayer.extend({

  providers: {
    'sql_api': torque.providers.json,
    'url_template': torque.providers.JsonArray,
    'windshaft': torque.providers.windshaft,
    'tileJSON': torque.providers.tileJSON
  },

  renderers: {
    'point': torque.renderer.Point,
    'pixel': torque.renderer.Rectangle
  },

  initialize: function(options) {
    var self = this;
    if (!torque.isBrowserSupported()) {
      throw new Error("browser is not supported by torque");
    }
    options.tileLoader = true;
    this.key = 0;
    this.prevRenderedKey = 0;
    if (options.cartocss) {
      torque.extend(options, torque.common.TorqueLayer.optionsFromCartoCSS(options.cartocss));
    }

    options.resolution = options.resolution || 2;
    options.steps = options.steps || 100;
    options.visible = options.visible === undefined ? true: options.visible;
    this.hidden = !options.visible;

    this.animator = new torque.Animator(function(time) {
      var k = time | 0;
      if(self.key !== k) {
        self.setKey(k, { direct: true });
      }
    }, torque.extend(torque.clone(options), {
      onPause: function() {
        self.fire('pause');
      },
      onStop: function() {
        self.fire('stop');
      },
      onStart: function() {
        self.fire('play');
      },
      onStepsRange: function() {
        self.fire('change:stepsRange', self.animator.stepsRange());
      }
    }));

    this.play = this.animator.start.bind(this.animator);
    this.stop = this.animator.stop.bind(this.animator);
    this.pause = this.animator.pause.bind(this.animator);
    this.toggle = this.animator.toggle.bind(this.animator);
    this.setDuration = this.animator.duration.bind(this.animator);
    this.isRunning = this.animator.isRunning.bind(this.animator);


    L.CanvasLayer.prototype.initialize.call(this, options);

    this.options.renderer = this.options.renderer || 'point';
    this.options.provider = this.options.provider || 'windshaft';

    if (this.options.tileJSON) this.options.provider = 'tileJSON';

    this.provider = new this.providers[this.options.provider](options);
    this.renderer = new this.renderers[this.options.renderer](this.getCanvas(), options);

    options.ready = function() {
      self.fire("change:bounds", {
        bounds: self.provider.getBounds()
      });
      self.animator.steps(self.provider.getSteps());
      self.animator.rescale();
      self.fire('change:steps', {
        steps: self.provider.getSteps()
      });
      self.setKey(self.key);
    };

    this.renderer.on("allIconsLoaded", this.render.bind(this));


    // for each tile shown on the map request the data
    this.on('tileAdded', function(t) {
      var tileData = this.provider.getTileData(t, t.zoom, function(tileData) {
        // don't load tiles that are not being shown
        if (t.zoom !== self._map.getZoom()) return;
        self._tileLoaded(t, tileData);
        self._clearTileCaches();
        if (tileData) {
          self.redraw();
        }
        self.fire('tileLoaded');
      });
    }, this);

  },

  _clearTileCaches: function() {
    var t, tile;
    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile && tile._tileCache) {
        tile._tileCache = null;
      }
    }
  },

  _clearCaches: function() {
    this.renderer && this.renderer.clearSpriteCache();
    this._clearTileCaches();
  },

  onAdd: function (map) {
    map.on({
      'zoomend': this._clearCaches,
      'zoomstart': this._pauseOnZoom,
    }, this);

    map.on({
      'zoomend': this._resumeOnZoom
    }, this);
    L.CanvasLayer.prototype.onAdd.call(this, map);
  },

  onRemove: function(map) {
    this.fire('remove');
    this._removeTileLoader();
    map.off({
      'zoomend': this._clearCaches,
      'zoomstart': this._pauseOnZoom,
    }, this);
    map.off({
      'zoomend': this._resumeOnZoom
    }, this);
    L.CanvasLayer.prototype.onRemove.call(this, map);
  },

  _pauseOnZoom: function() {
    this.wasRunning = this.isRunning();
    if (this.wasRunning) {
      this.pause();
    }
  },

  _resumeOnZoom: function() {
    if (this.wasRunning) {
      this.play();
    }
  },

  hide: function() {
    if(this.hidden) return this;
    this.pause();
    this.clear();
    this.hidden = true;
    return this;
  },

  show: function() {
    if(!this.hidden) return this;
    this.hidden = false;
    this.play();
    if (this.options.steps === 1){
      this.redraw();
    }
    return this;
  },

  setSQL: function(sql) {
    if (this.provider.options.named_map) throw new Error("SQL queries on named maps are read-only");
    if (!this.provider || !this.provider.setSQL) {
      throw new Error("this provider does not support SQL");
    }
    this.provider.setSQL(sql);
    this._reloadTiles();
    return this;
  },

  setBlendMode: function(_) {
    this.renderer.setBlendMode(_);
    this.redraw();
  },

  setSteps: function(steps) {
    this.provider.setSteps(steps);
    this._reloadTiles();
  },

  setColumn: function(column, isTime) {
    this.provider.setColumn(column, isTime);
    this._reloadTiles();
  },

  getTimeBounds: function() {
    return this.provider && this.provider.getKeySpan();
  },

  clear: function() {
    var canvas = this.getCanvas();
    canvas.width = canvas.width;
  },

  /**
   * render the selectef key
   * don't call this function directly, it's called by
   * requestAnimationFrame. Use redraw to refresh it
   */
  render: function() {
    if(this.hidden) return;
    var t, tile, pos;
    var canvas = this.getCanvas();
    this.renderer.clearCanvas();
    var ctx = canvas.getContext('2d');

    for(t in this._tiles) {
      tile = this._tiles[t];
      if (tile) {
        // clear cache
        if (this.animator.isRunning()) {
          tile._tileCache = null;
        }

        pos = this.getTilePos(tile.coord);
        ctx.setTransform(1, 0, 0, 1, pos.x, pos.y);

        if (tile._tileCache) {
          // when the tile has a cached image just render it and avoid to render
          // all the points
          this.renderer._ctx.drawImage(tile._tileCache, 0, 0);
        } else {
          this.renderer.renderTile(tile, this.key);
        }
      }
    }
    this.renderer.applyFilters();

    // prepare caches if the animation is not running
    // don't cache if the key has just changed, this avoids to cache
    // when the user is dragging, it only cache when the map is still
    if (!this.animator.isRunning() && this.key === this.prevRenderedKey) {
      var tile_size = this.renderer.TILE_SIZE;
      for(t in this._tiles) {
        tile = this._tiles[t];
        if (tile && !tile._tileCache) {
          var c = tile._tileCache = document.createElement('canvas');
          c.width = c.height = tile_size;
          pos = this.getTilePos(tile.coord);
          // clip bounds, firefox raise an exception when try to get data from outside canvas
          var x = Math.max(0, pos.x)
          var y = Math.max(0, pos.y)
          var w = Math.min(tile_size, this.getCanvas().width - x);
          var h = Math.min(tile_size, this.getCanvas().height - y);
          if (w > 0 && h > 0) {
            c.getContext('2d').drawImage(this.getCanvas(), x, y, w, h, x - pos.x, y - pos.y, w, h);
          }
        }
      }
    }

    this.prevRenderedKey = this.key;

  },

  /**
   * set key to be shown. If it's a single value
   * it renders directly, if it's an array it renders
   * accumulated
   */
  setKey: function(key, options) {
    this.key = key;
    this.animator.step(key);
    this._clearTileCaches();
    this.redraw(options && options.direct);
    this.fire('change:time', { time: this.getTime(), step: this.key });
  },

  /**
   * helper function, does the same than ``setKey`` but only
   * accepts scalars.
   */
  setStep: function(time) {
    if(time === undefined || time.length !== undefined) {
      throw new Error("setTime only accept scalars");
    }
    this.setKey(time);
  },

  /**
   * transform from animation step to Date object
   * that contains the animation time
   *
   * ``step`` should be between 0 and ``steps - 1``
   */
  stepToTime: function(step) {
    var times = this.provider.getKeySpan();
    var time = times.start + (times.end - times.start)*(step/this.provider.getSteps());
    return new Date(time);
  },

  timeToStep: function(timestamp) {
    if (typeof timestamp === "Date") timestamp = timestamp.getTime();
    if (!this.provider) return 0;
    var times = this.provider.getKeySpan();
    var step = (this.provider.getSteps() * (timestamp - times.start)) / (times.end - times.start);
    return step;
  },

  getStep: function() {
    return this.key;
  },

  /**
   * returns the animation time defined by the data
   * in the defined column. Date object
   */
  getTime: function() {
    return this.stepToTime(this.key);
  },

  /**
   * returns an object with the start and end times
   */
  getTimeSpan: function() {
    return this.provider.getKeySpan();
  },

  /**
   * set the cartocss for the current renderer
   */
  setCartoCSS: function(cartocss) {
    if (this.provider.options.named_map) throw new Error("CartoCSS style on named maps is read-only");
    if (!this.renderer) throw new Error('renderer is not valid');
    var shader = new carto.RendererJS().render(cartocss);
    this.renderer.setShader(shader);

    // provider options
    var options = torque.common.TorqueLayer.optionsFromLayer(shader.findLayer({ name: 'Map' }));
    this.provider.setCartoCSS && this.provider.setCartoCSS(cartocss);
    if(this.provider.setOptions(options)) {
      this._reloadTiles();
    }

    torque.extend(this.options, options);

    // animator options
    if (options.animationDuration) {
      this.animator.duration(options.animationDuration);
    }
    this._clearCaches();
    this.redraw();
    return this;
  },

  /**
   * get active points for a step in active zoom
   * returns a list of bounding boxes [[] , [], []]
   * empty list if there is no active pixels
   */
  getActivePointsBBox: function(step) {
    var positions = [];
    for(var t in this._tiles) {
      var tile = this._tiles[t];
      positions = positions.concat(this.renderer.getActivePointsBBox(tile, step));
    }
    return positions;
  },

  /**
   * return an array with the values for all the pixels active for the step
   */
  getValues: function(step) {
    var values = [];
    step = step === undefined ? this.key: step;
    var t, tile;
    for(t in this._tiles) {
      tile = this._tiles[t];
      this.renderer.getValues(tile, step, values);
    }
    return values;
  },

  /**
   * return the value for position relative to map coordinates. null for no value
   */
  getValueForPos: function(x, y, step) {
    step = step === undefined ? this.key: step;
    var t, tile, pos, value = null, xx, yy;
    for(t in this._tiles) {
      tile = this._tiles[t];
      pos = this.getTilePos(tile.coord);
      xx = x - pos.x;
      yy = y - pos.y;
      if (xx >= 0 && yy >= 0 && xx < this.renderer.TILE_SIZE && yy <= this.renderer.TILE_SIZE) {
        value = this.renderer.getValueFor(tile, step, xx, yy);
      }
      if (value !== null) {
        return value;
      }
    }
    return null;
  },

  getValueForBBox: function(x, y, w, h) {
    var xf = x + w, yf = y + h, _x=x;
    var sum = 0;
    for(_y = y; _y<yf; _y+=this.options.resolution){
      for(_x = x; _x<xf; _x+=this.options.resolution){
        var thisValue = this.getValueForPos(_x,_y);
        if (thisValue){
          var bb = thisValue.bbox;
          var xy = this._map.latLngToContainerPoint([bb[1].lat, bb[1].lon]);
          if(xy.x < xf && xy.y < yf){
            sum += thisValue.value;
          }
        }
      }
    }
    return sum;
  },

  invalidate: function() {
    this.provider.reload();
  },

  setStepsRange: function(start, end) {
    this.animator.stepsRange(start, end);
  },

  removeStepsRange: function() {
    this.animator.removeCustomStepsRange();
  },

  getStepsRange: function() {
    return this.animator.stepsRange();
  }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":19,"./canvas_layer":20,"carto":39}],24:[function(require,module,exports){
  function clamp(a, b) {
    return function(t) {
      return Math.max(Math.min(t, b), a);
    };
  }

  function invLinear(a, b) {
    var c = clamp(0, 1.0);
    return function(t) {
      return c((t - a)/(b - a));
    };
  }

  function linear(a, b) {
    var c = clamp(a, b);
    function _linear(t) {
      return c(a*(1.0 - t) + t*b);
    }

    _linear.invert = function() {
      return invLinear(a, b);
    };

    return _linear;
  }

module.exports = {
    clamp: clamp,
    linear: linear,
    invLinear: invLinear
};

},{}],25:[function(require,module,exports){
var Point = function(x, y) {
  this.x = x || 0;
  this.y = y || 0;
};

function clamp(value, optMin, optMax) {
  if (optMin !== null) value = Math.max(value, optMin);
  if (optMax !== null) value = Math.min(value, optMax);
  return value;
}

function degreesToRadians(deg) {
  return deg * (Math.PI / 180);
}

function radiansToDegrees(rad) {
  return rad / (Math.PI / 180);
}


var MercatorProjection = function() {
//  this._tileSize = L.Browser.retina ? 512 : 256;
  this._tileSize = 256;
  this._pixelOrigin = new Point(this._tileSize / 2, this._tileSize / 2);
  this._pixelsPerLonDegree = this._tileSize / 360;
  this._pixelsPerLonRadian = this._tileSize / (2 * Math.PI);
};

MercatorProjection.prototype._fromLatLonToPoint = function(lat, lon) {
  var point = new Point(0, 0);
  var origin = this._pixelOrigin;

  point.x = origin.x + lon * this._pixelsPerLonDegree;

  // NOTE(appleton): Truncating to 0.9999 effectively limits latitude to
  // 89.189.  This is about a third of a tile past the edge of the world
  // tile.
  var siny = clamp(Math.sin(degreesToRadians(lat)), -0.9999, 0.9999);
  point.y = origin.y + 0.5 * Math.log((1 + siny) / (1 - siny)) * -this._pixelsPerLonRadian;
  return point;
};

MercatorProjection.prototype._fromPointToLatLon = function(point) {
  var me = this;
  var origin = me._pixelOrigin;
  var lon = (point.x - origin.x) / me._pixelsPerLonDegree;
  var latRadians = (point.y - origin.y) / -me._pixelsPerLonRadian;
  var lat = radiansToDegrees(2 * Math.atan(Math.exp(latRadians)) - Math.PI / 2);
  return { lat:lat, lon:lon };
};

MercatorProjection.prototype._tilePixelPos = function(tileX, tileY) {
  return {
    x: tileX*this._tileSize,
    y: tileY*this._tileSize
  };
};

MercatorProjection.prototype.tilePixelBBox = function(x, y, zoom, px, py, res) {
  res = res || 1.0;
  var numTiles = 1 <<zoom;
  var inc = res/numTiles;
  px = (x*this._tileSize + px)/numTiles;
  py = (y*this._tileSize + py)/numTiles;
  return [
    this._fromPointToLatLon(new Point(px, py + inc)),
    this._fromPointToLatLon(new Point(px + inc, py))
  ];
};

MercatorProjection.prototype.tileBBox = function(x, y, zoom, bufferSize) {
  var numTiles = 1 <<zoom;
  bufferSize = bufferSize || 0;
  var inc =  (this._tileSize + bufferSize*2)/numTiles;
  var px = (x*this._tileSize - bufferSize  )/numTiles;
  var py = (y*this._tileSize - bufferSize  )/numTiles;
  return [
    this._fromPointToLatLon(new Point(px, py + inc)),
    this._fromPointToLatLon(new Point(px + inc, py))
  ];
};

MercatorProjection.prototype.latLonToTilePoint = function(lat, lon, tileX, tileY, zoom) {
  var numTiles = 1 <<zoom;
  var worldCoordinate = this._fromLatLonToPoint(lat, lon);
  var pixelCoordinate = new Point(worldCoordinate.x*numTiles, worldCoordinate.y*numTiles);
  var tilePixelPos    = this._tilePixelPos(tileX, tileY);
  return new Point(Math.round(pixelCoordinate.x-tilePixelPos.x), Math.round(pixelCoordinate.y-tilePixelPos.y));
};

module.exports = MercatorProjection;

},{}],26:[function(require,module,exports){
/*
# metrics profiler

## timing

```
 var timer = Profiler.metric('resource:load')
 time.start();
 ...
 time.end();
```

## counters

```
 var counter = Profiler.metric('requests')
 counter.inc();   // 1
 counter.inc(10); // 11
 counter.dec()    // 10
 counter.dec(10)  // 0
```

## Calls per second
```
  var fps = Profiler.metric('fps')
  function render() {
    fps.mark();
  }
```
*/
var MAX_HISTORY = 1024;
function Profiler() {}
Profiler.metrics = {};

Profiler.get = function(name) {
  return Profiler.metrics[name] || {
    max: 0,
    min: Number.MAX_VALUE,
    avg: 0,
    total: 0,
    count: 0,
    history: typeof(Float32Array) !== 'undefined' ? new Float32Array(MAX_HISTORY) : []
  };
};

Profiler.new_value = function (name, value) {
  var t = Profiler.metrics[name] = Profiler.get(name);

  t.max = Math.max(t.max, value);
  t.min = Math.min(t.min, value);
  t.total += value;
  ++t.count;
  t.avg = t.total / t.count;
  t.history[t.count%MAX_HISTORY] = value;
};

Profiler.print_stats = function () {
  for (k in Profiler.metrics) {
    var t = Profiler.metrics[k];
    console.log(" === " + k + " === ");
    console.log(" max: " + t.max);
    console.log(" min: " + t.min);
    console.log(" avg: " + t.avg);
    console.log(" count: " + t.count);
    console.log(" total: " + t.total);
  }
};

function Metric(name) {
  this.t0 = null;
  this.name = name;
  this.count = 0;
}

Metric.prototype = {

  //
  // start a time measurement
  //
  start: function() {
    this.t0 = +new Date();
    return this;
  },

  // elapsed time since start was called
  _elapsed: function() {
    return +new Date() - this.t0;
  },

  //
  // finish a time measurement and register it
  // ``start`` should be called first, if not this 
  // function does not take effect
  //
  end: function() {
    if (this.t0 !== null) {
      Profiler.new_value(this.name, this._elapsed());
      this.t0 = null;
    }
  },

  //
  // increments the value 
  // qty: how many, default = 1
  //
  inc: function(qty) {
    qty = qty === undefined ? 1: qty;
    Profiler.new_value(this.name, Profiler.get(this.name).count + (qty ? qty: 0));
  },

  //
  // decrements the value 
  // qty: how many, default = 1
  //
  dec: function(qty) {
    qty = qty === undefined ? 1: qty;
    this.inc(-qty);
  },

  //
  // measures how many times per second this function is called
  //
  mark: function() {
    ++this.count;
    if(this.t0 === null) {
      this.start();
      return;
    }
    var elapsed = this._elapsed();
    if(elapsed > 1) {
      Profiler.new_value(this.name, this.count);
      this.count = 0;
      this.start();
    }
  }
};

Profiler.metric = function(name) {
  return new Metric(name);
};

module.exports = Profiler;

},{}],27:[function(require,module,exports){
module.exports = {
    json: require('./json'),
    JsonArray: require('./jsonarray'),
    windshaft: require('./windshaft'),
    tileJSON: require('./tilejson')
};

},{"./json":28,"./jsonarray":29,"./tilejson":30,"./windshaft":31}],28:[function(require,module,exports){
var torque = require('../');
var Profiler = require('../profiler');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var json = function (options) {
    this._ready = false;
    this._tileQueue = [];
    this.options = options;

    this.options.is_time = this.options.is_time === undefined ? true: this.options.is_time;
    this.options.tiler_protocol = options.tiler_protocol || 'http';
    this.options.tiler_domain = options.tiler_domain || 'cartodb.com';
    this.options.tiler_port = options.tiler_port || 80;

    if (this.options.data_aggregation) {
      this.options.cumulative = this.options.data_aggregation === 'cumulative';
    }

    // check options
    if (options.resolution === undefined ) throw new Error("resolution should be provided");
    if (options.steps === undefined ) throw new Error("steps should be provided");
    if(options.start === undefined) {
      this._fetchKeySpan();
    } else {
      this._setReady(true);
    }
  };

  json.prototype = {

    /**
     * return the torque tile encoded in an efficient javascript
     * structure:
     * {
     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255
     *   y:Uint8Array y coordinates in tile reference system
     *   Index: Array index to the properties
     * }
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new Uint8Array(rows.length);
      var y = new Uint8Array(rows.length);

      var prof_mem = Profiler.metric('ProviderJSON:mem');
      var prof_point_count = Profiler.metric('ProviderJSON:point_count');
      var prof_process_time = Profiler.metric('ProviderJSON:process_time').start()

      // count number of dates
      var dates = 0;
      var maxDateSlots = -1;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.dates__uint16.length;
        for(var d = 0; d < row.dates__uint16.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);
        }
      }

      if(this.options.cumulative) {
        dates = (1 + maxDateSlots) * rows.length;
      }

      var type = this.options.cumulative ? Uint32Array: Uint8Array;

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || type)(dates);
      var renderDataPos = new Uint32Array(dates);

      prof_mem.inc(
        4 * maxDateSlots + // timeIndex
        4 * maxDateSlots + // timeCount
        dates + //renderData
        dates * 4
      ); //renderDataPos

      prof_point_count.inc(rows.length);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x__uint8 * this.options.resolution;
        // fix value when it's in the tile EDGE
        // TODO: this should be fixed in SQL query
        if (row.y__uint8 === -1) {
          y[r] = 0;
        } else {
          y[r] = row.y__uint8 * this.options.resolution;
        }

        var dates = row.dates__uint16;
        var vals = row.vals__uint8;
        if (!this.options.cumulative) {
          for (var j = 0, len = dates.length; j < len; ++j) {
              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
              if(this.options.cumulative) {
                  vals[j] += prev_val;
              }
              prev_val = vals[j];
              rr.push([r, vals[j]]);
          }
        } else {
          var valByDate = {}
          for (var j = 0, len = dates.length; j < len; ++j) {
            valByDate[dates[j]] = vals[j];
          }
          var accum = 0;

          // extend the latest to the end
          for (var j = dates[0]; j <= maxDateSlots; ++j) {
              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
              var v = valByDate[j];
              if (v) {
                accum += v;
              }
              rr.push([r, accum]);
          }

          /*var lastDateSlot = dates[dates.length - 1];
          for (var j = lastDateSlot + 1; j <= maxDateSlots; ++j) {
            var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
            rr.push([r, prev_val]);
          }
          */
        }

      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      prof_process_time.end();

      return {
        x: x,
        y: y,
        z: zoom,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData,
        maxDate: maxDateSlots
      };
    },

    _host: function() {
      var opts = this.options;
      var port = opts.sql_api_port;
      var domain = ((opts.user_name || opts.user) + '.' + (opts.sql_api_domain || 'cartodb.com')) + (port ? ':' + port: '');
      var protocol = opts.sql_api_protocol || 'http';
      return this.options.url || protocol + '://' + domain + '/api/v2/sql';
    },

    url: function(subhost) {
      var opts = this.options;
      var protocol = opts.sql_api_protocol || 'http';
      if (!this.options.cdn_url) {
        return this._host();
      }
      var h = protocol+ "://";
      if (subhost) {
        h += subhost + ".";
      }
      var cdn_host = opts.cdn_url;
      if(!cdn_host.http && !cdn_host.https) {
        throw new Error("cdn_host should contain http and/or https entries");
      }
      h += cdn_host[protocol] + "/" + (opts.user_name || opts.user) + '/api/v2/sql';
      return h;
    },

    _hash: function(str) {
      var hash = 0;
      if (!str || str.length == 0) return hash;
      for (var i = 0, l = str.length; i < l; ++i) {
          hash = (( (hash << 5 ) - hash ) + str.charCodeAt(i)) | 0;
      }
      return hash;
    },

    _extraParams: function() {
      if (this.options.extra_params) {
        var p = [];
        for(var k in this.options.extra_params) {
          var v = this.options.extra_params[k];
          if (v) {
            p.push(k + "=" + encodeURIComponent(v));
          }
        }
        return p.join('&');
      }
      return null;
    },

    isHttps: function() {
      return this.options.sql_api_protocol && this.options.sql_api_protocol === 'https';
    },

    // execute actual query
    sql: function(sql, callback, options) {
      options = options || {};
      var subdomains = this.options.subdomains || '0123';
      if(this.isHttps()) {
        subdomains = [null]; // no subdomain
      }


      var url;
      if (options.no_cdn) {
        url = this._host();
      } else {
        url = this.url(subdomains[Math.abs(this._hash(sql))%subdomains.length]);
      }
      var extra = this._extraParams();
      torque.net.get( url + "?q=" + encodeURIComponent(sql) + (extra ? "&" + extra: ''), function (data) {
          if(options.parseJSON) {
            data = JSON.parse(data && data.responseText);
          }
          callback && callback(data);
      });
    },

    getTileData: function(coord, zoom, callback) {
      if(!this._ready) {
        this._tileQueue.push([coord, zoom, callback]);
      } else {
        this._getTileData(coord, zoom, callback);
      }
    },

    _setReady: function(ready) {
      this._ready = true;
      this._processQueue();
      this.options.ready && this.options.ready();
    },

    _processQueue: function() {
      var item;
      while (item = this._tileQueue.pop()) {
        this._getTileData.apply(this, item);
      }
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    _getTileData: function(coord, zoom, callback) {
      var prof_fetch_time = Profiler.metric('ProviderJSON:tile_fetch_time').start()
      this.table = this.options.table;
      var numTiles = 1 << zoom;

      var column_conv = this.options.column;

      if(this.options.is_time) {
        column_conv = format("date_part('epoch', {column})", this.options);
      }

      var sql = "" +
        "WITH " +
        "par AS (" +
        "  SELECT CDB_XYZ_Resolution({zoom})*{resolution} as res" +
        ",  256/{resolution} as tile_size" +
        ", CDB_XYZ_Extent({x}, {y}, {zoom}) as ext "  +
        ")," +
        "cte AS ( "+
        "  SELECT ST_SnapToGrid(i.the_geom_webmercator, p.res) g" +
        ", {countby} c" +
        ", floor(({column_conv} - {start})/{step}) d" +
        "  FROM ({_sql}) i, par p " +
        "  WHERE i.the_geom_webmercator && p.ext " +
        "  GROUP BY g, d" +
        ") " +
        "" +
        "SELECT (st_x(g)-st_xmin(p.ext))/p.res x__uint8, " +
        "       (st_y(g)-st_ymin(p.ext))/p.res y__uint8," +
        " array_agg(c) vals__uint8," +
        " array_agg(d) dates__uint16" +
        // the tile_size where are needed because the overlaps query in cte subquery includes the points
        // in the left and bottom borders of the tile
        " FROM cte, par p where (st_y(g)-st_ymin(p.ext))/p.res < tile_size and (st_x(g)-st_xmin(p.ext))/p.res < tile_size GROUP BY x__uint8, y__uint8";


      var query = format(sql, this.options, {
        zoom: zoom,
        x: coord.x,
        y: coord.y,
        column_conv: column_conv,
        _sql: this.getSQL()
      });

      var self = this;
      this.sql(query, function (data) {
        if (data) {
          var rows = JSON.parse(data.responseText).rows;
          callback(self.proccessTile(rows, coord, zoom));
        } else {
          callback(null);
        }
        prof_fetch_time.end();
      });
    },

    getKeySpan: function() {
      return {
        start: this.options.start * 1000,
        end: this.options.end * 1000,
        step: this.options.step,
        steps: this.options.steps,
        columnType: this.options.is_time ? 'date': 'number'
      };
    },

    setColumn: function(column, isTime) {
      this.options.column = column;
      this.options.is_time = isTime === undefined ? true: false;
      this.reload();
    },

    setResolution: function(res) {
      this.options.resolution = res;
    },

    // return true if tiles has been changed
    setOptions: function(opt) {
      var refresh = false;

      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {
        this.options.resolution = opt.resolution;
        refresh = true;
      }

      if(opt.steps !== undefined && opt.steps !== this.options.steps) {
        this.setSteps(opt.steps, { silent: true });
        refresh = true;
      }

      if(opt.column !== undefined && opt.column !== this.options.column) {
        this.options.column = opt.column;
        refresh = true;
      }

      if(opt.countby !== undefined && opt.countby !== this.options.countby) {
        this.options.countby = opt.countby;
        refresh = true;
      }

      if(opt.data_aggregation !== undefined) {
        var c = opt.data_aggregation === 'cumulative';
        if (this.options.cumulative !== c) {
          this.options.cumulative = c;
          refresh = true;
        }
      }

      if (refresh) this.reload();
      return refresh;

    },

    reload: function() {
      this._ready = false;
      this._fetchKeySpan();
    },

    setSQL: function(sql) {
      if (this.options.sql != sql) {
        this.options.sql = sql;
        this.reload();
      }
    },

    getSteps: function() {
      return Math.min(this.options.steps, this.options.data_steps);
    },

    setSteps: function(steps, opt) {
      opt = opt || {};
      if (this.options.steps !== steps) {
        this.options.steps = steps;
        this.options.step = (this.options.end - this.options.start)/this.getSteps();
        this.options.step = this.options.step || 1;
        if (!opt.silent) this.reload();
      }
    },

    getBounds: function() {
      return this.options.bounds;
    },

    getSQL: function() {
      return this.options.sql || "select * from " + this.options.table;
    },

    _tilerHost: function() {
      var opts = this.options;
      var user = (opts.user_name || opts.user);
      return opts.tiler_protocol +
           "://" + (user ? user + "." : "")  +
           opts.tiler_domain +
           ((opts.tiler_port != "") ? (":" + opts.tiler_port) : "");
    },

    _fetchUpdateAt: function(callback) {
      var self = this;
      var layergroup = {
        "version": "1.0.1",
        "stat_tag": this.options.stat_tag || 'torque',
        "layers": [{
          "type": "cartodb",
          "options": {
            "cartocss_version": "2.1.1", 
            "cartocss": "#layer {}",
            "sql": this.getSQL()
          }
        }]
      };
      var url = this._tilerHost() + "/tiles/layergroup";
      var extra = this._extraParams();

      // tiler needs map_key instead of api_key
      // so replace it
      if (extra) {
        extra = extra.replace('api_key=', 'map_key=');
      }

      url = url +
        "?config=" + encodeURIComponent(JSON.stringify(layergroup)) +
        "&callback=?" + (extra ? "&" + extra: '');

      torque.net.jsonp(url, function (data) {
        var query = format("select * from ({sql}) __torque_wrap_sql limit 0", { sql: self.getSQL() });
        self.sql(query, function (queryData) {
          if (data && queryData) {
            callback({
              updated_at: data.last_updated,
              fields: queryData.fields
            });
          }
        }, { parseJSON: true });
      });
    },

    //
    // the data range could be set by the user though ``start``
    // option. It can be fecthed from the table when the start
    // is not specified.
    //
    _fetchKeySpan: function() {
      var self = this;
      var max_col, min_col, max_tmpl, min_tmpl;

      this._fetchUpdateAt(function(data) {
        if (!data) return;
        self.options.extra_params = self.options.extra_params || {};
        self.options.extra_params.last_updated = data.updated_at || 0;
        self.options.extra_params.cache_policy = 'persist';
        self.options.is_time = data.fields[self.options.column].type === 'date';

        var column_conv = self.options.column;
        if (self.options.is_time){
          max_tmpl = "date_part('epoch', max({column}))";
          min_tmpl = "date_part('epoch', min({column}))";
          column_conv = format("date_part('epoch', {column})", self.options);
        } else {
          max_tmpl = "max({column})";
          min_tmpl = "min({column})";
        }

        max_col = format(max_tmpl, { column: self.options.column });
        min_col = format(min_tmpl, { column: self.options.column });

        /*var sql_stats = "" +
        "WITH summary_groups as ( " +
          "WITH summary as ( " +
           "select   (row_number() over (order by __time_col asc nulls last)+1)/2 as rownum, __time_col " +
            "from (select *, {column} as __time_col from ({sql}) __s) __torque_wrap_sql " +
            "order by __time_col asc " +
          ") " +
          "SELECT " +
          "max(__time_col) OVER(PARTITION BY rownum) -  " +
          "min(__time_col) OVER(PARTITION BY rownum) diff " +
          "FROM summary " +
        "), subq as ( " +
        " SELECT " +
            "st_xmax(st_envelope(st_collect(the_geom))) xmax, " +
            "st_ymax(st_envelope(st_collect(the_geom))) ymax, " +
            "st_xmin(st_envelope(st_collect(the_geom))) xmin, " +
            "st_ymin(st_envelope(st_collect(the_geom))) ymin, " +
            "{max_col} max, " +
            "{min_col} min FROM  ({sql}) __torque_wrap_sql " +
        ")" +
        "SELECT " +
        "xmax, xmin, ymax, ymin, a.max as max_date, a.min as min_date, " +
        "avg(diff) as diffavg," +
        "(a.max - a.min)/avg(diff) as num_steps " +
        "FROM summary_groups, subq a  " +
        "WHERE diff > 0 group by xmax, xmin, ymax, ymin, max_date, min_date";
        */
        var sql_stats = " SELECT " +
            "st_xmax(st_envelope(st_collect(the_geom))) xmax, " +
            "st_ymax(st_envelope(st_collect(the_geom))) ymax, " +
            "st_xmin(st_envelope(st_collect(the_geom))) xmin, " +
            "st_ymin(st_envelope(st_collect(the_geom))) ymin, " +
            "count(*) as num_steps, " +
            "{max_col} max_date, " +
            "{min_col} min_date FROM  ({sql}) __torque_wrap_sql ";

        var sql = format(sql_stats, {
          max_col: max_col,
          min_col: min_col,
          column: column_conv,
          sql: self.getSQL()
        });

        self.sql(sql, function(data) {
          //TODO: manage bounds
          data = data.rows[0];
          self.options.start = data.min_date;
          self.options.end = data.max_date;
          self.options.step = (data.max_date - data.min_date)/Math.min(self.options.steps, data.num_steps>>0);
          self.options.data_steps = data.num_steps >> 0;
          // step can't be 0
          self.options.step = self.options.step || 1;
          self.options.bounds = [
            [data.ymin, data.xmin],
            [data.ymax, data.xmax]
          ];
          self._setReady(true);
        }, { parseJSON: true, no_cdn: true });
      }, { parseJSON: true, no_cdn: true})
    }

  };

module.exports = json;

},{"../":19,"../profiler":26}],29:[function(require,module,exports){
var torque = require('../');
var Profiler = require('../profiler');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str, attrs) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var json = function (options) {
    // check options
    this.options = options;
  };


  json.prototype = {

    //
    // return the data aggregated by key:
    // {
    //  key0: 12,
    //  key1: 32
    //  key2: 25
    // }
    //
    aggregateByKey: function(rows) {
      function getKeys(row) {
        var HEADER_SIZE = 3;
        var valuesCount = row.data[2];
        var keys = {};
        for (var s = 0; s < valuesCount; ++s) {
          keys[row.data[HEADER_SIZE + s]] = row.data[HEADER_SIZE + valuesCount + s];
        }
        return keys;
      }
      var keys = {};
      for (r = 0; r < rows.length; ++r) {
        var rowKeys = getKeys(rows[r]);
        for(var k in rowKeys) {
          keys[k] = keys[k] || 0;
          keys[k] += rowKeys[k];
        }
      }
      return keys;
    },
    



    /**
     *
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new Uint8Array(rows.length);
      var y = new Uint8Array(rows.length);
      var self = this;

      // decode into a javascript strcuture the array
      function decode_row(row) {
        var HEADER_SIZE = 3;
        var o = {
          x: row.data[0] * self.options.resolution,
          y: row.data[1] * self.options.resolution,
          valuesCount: row.data[2],
          times: [],
          values: []
        };
        for (var s = 0; s < o.valuesCount; ++s) {
           o.times.push(row.data[HEADER_SIZE + s]);
           o.values.push(row.data[HEADER_SIZE + o.valuesCount + s]);
        }
        if(self.options.cumulative) {
          for (var s = 1; s < o.valuesCount; ++s) {
           o.values[s] += o.values[s - 1];
          }
        }
        return o
      }

      // decode all the rows
      for (r = 0; r < rows.length; ++r) {
        rows[r] = decode_row(rows[r]);
      }

      // count number of dates
      var dates = 0;
      var maxDateSlots = 0;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.times.length;
        for(var d = 0; d < row.times.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.times[d]);
        }
      }

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || Uint8Array)(dates);
      var renderDataPos = new Uint32Array(dates);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x;
        y[r] = row.y;

        var dates = row.times;
        var vals = row.values;
        for (var j = 0, len = dates.length; j < len; ++j) {
            var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
            rr.push([r, vals[j]]);
        }
      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      return {
        x: x,
        y: y,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData
      };
    },

    url: function() {
      return this.options.url;
    },


    tileUrl: function(coord, zoom) {
      var template = this.url();
      var s = (this.options.subdomains || 'abcd')[(coord.x + coord.y + zoom) % 4];
      return template
        .replace('{x}', coord.x)
        .replace('{y}', coord.y)
        .replace('{z}', zoom)
        .replace('{s}', s);
    },

    getTile: function(coord, zoom, callback) {
      var template = this.tileUrl(coord, zoom);

      var self = this;
      var fetchTime = Profiler.metric('jsonarray:fetch time');
      fetchTime.start();
      torque.net.get(template, function (data) {
        fetchTime.end();
        if(data) {
          data = JSON.parse(data.responseText);
        }
        callback(data);
      });
    },

    /**
     * `coord` object like {x : tilex, y: tiley } 
     * `zoom` quadtree zoom level
     */
    getTileData: function(coord, zoom, callback) {
      var template = this.tileUrl(coord, zoom);

      var self = this;
      var fetchTime = Profiler.metric('jsonarray:fetch time');
      fetchTime.start();
      torque.net.get(template, function (data) {
        fetchTime.end();
        var processed = null;
        
        var processingTime = Profiler.metric('jsonarray:processing time');
        var parsingTime = Profiler.metric('jsonarray:parsing time');
        try {
          processingTime.start();
          parsingTime.start();
          var rows = JSON.parse(data.responseText || data.response).rows;
          parsingTime.end();
          processed = self.proccessTile(rows, coord, zoom);
          processingTime.end();
        } catch(e) {
          console.error("problem parsing JSON on ", coord, zoom);
        }

        callback(processed);

      });
    }

  };

  module.exports = json;

},{"../":19,"../profiler":26}],30:[function(require,module,exports){
  var torque = require('../');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;
  var Uint8ClampedArray = torque.types.Uint8ClampedArray;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var tileJSON = function (options) {
    this._ready = false;
    this._tileQueue = [];
    this.options = options;

    this.options.coordinates_data_type = this.options.coordinates_data_type || Uint8Array;

    if (this.options.data_aggregation) {
      this.options.cumulative = this.options.data_aggregation === 'cumulative';
    }
    if (this.options.auth_token) {
      var e = this.options.extra_params || (this.options.extra_params = {});
      e.auth_token = this.options.auth_token;
    }
    if (!this.options.no_fetch_map) {
      this._fetchMap();
    }
  };

  tileJSON.prototype = {

    NAME: "tileJSON",

    /**
     * return the torque tile encoded in an efficient javascript
     * structure:
     * {
     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255
     *   y:Uint8Array y coordinates in tile reference system
     *   Index: Array index to the properties
     * }
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new this.options.coordinates_data_type(rows.length);
      var y = new this.options.coordinates_data_type(rows.length);

      // count number of dates
      var dates = 0;
      var maxDateSlots = -1;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.dates__uint16.length;
        for(var d = 0; d < row.dates__uint16.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);
        }
      }

      if(this.options.cumulative) {
        dates = (1 + maxDateSlots) * rows.length;
      }

      var type = this.options.cumulative ? Uint32Array: Uint8ClampedArray;

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || type)(dates);
      var renderDataPos = new Uint32Array(dates);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x__uint8 * this.options.resolution;
        y[r] = row.y__uint8 * this.options.resolution;

        var dates = row.dates__uint16;
        var vals = row.vals__uint8;
        if (!this.options.cumulative) {
          for (var j = 0, len = dates.length; j < len; ++j) {
              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
              if(this.options.cumulative) {
                  vals[j] += prev_val;
              }
              prev_val = vals[j];
              rr.push([r, vals[j]]);
          }
        } else {
          var valByDate = {}
          for (var j = 0, len = dates.length; j < len; ++j) {
            valByDate[dates[j]] = vals[j];
          }
          var accum = 0;

          // extend the latest to the end
          for (var j = dates[0]; j <= maxDateSlots; ++j) {
              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
              var v = valByDate[j];
              if (v) {
                accum += v;
              }
              rr.push([r, accum]);
          }
        }
      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      return {
        x: x,
        y: y,
        z: zoom,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData,
        maxDate: maxDateSlots
      };
    },

    setSteps: function(steps, opt) { 
      opt = opt || {};
      if (this.options.steps !== steps) {
        this.options.steps = steps;
        this.options.step = (this.options.end - this.options.start)/this.getSteps();
        this.options.step = this.options.step || 1;
        if (!opt.silent) this.reload();
      }
    },

    setOptions: function(opt) {
      var refresh = false;

      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {
        this.options.resolution = opt.resolution;
        refresh = true;
      }

      if(opt.steps !== undefined && opt.steps !== this.options.steps) {
        this.setSteps(opt.steps, { silent: true });
        refresh = true;
      }

      if(opt.column !== undefined && opt.column !== this.options.column) {
        this.options.column = opt.column;
        refresh = true;
      }

      if(opt.countby !== undefined && opt.countby !== this.options.countby) {
        this.options.countby = opt.countby;
        refresh = true;
      }

      if(opt.data_aggregation !== undefined) {
        var c = opt.data_aggregation === 'cumulative';
        if (this.options.cumulative !== c) {
          this.options.cumulative = c;
          refresh = true;
        }
      }

      if (refresh) this.reload();
      return refresh;
    },

    _extraParams: function(e) {
      e = torque.extend(torque.extend({}, e), this.options.extra_params);
      if (e) {
        var p = [];
        for(var k in e) {
          var v = e[k];
          if (v) {
            if (torque.isArray(v)) {
              for (var i = 0, len = v.length; i < len; i++) {
                p.push(k + "[]=" + encodeURIComponent(v[i]));
              }
            } else {
              p.push(k + "=" + encodeURIComponent(v));
            }
          }
        }
        return p.join('&');
      }
      return null;
    },

    getTileData: function(coord, zoom, callback) {
      if(!this._ready) {
        this._tileQueue.push([coord, zoom, callback]);
      } else {
        this._getTileData(coord, zoom, callback);
      }
    },

    _setReady: function(ready) {
      this._ready = true;
      this._processQueue();
      this.options.ready && this.options.ready();
    },

    _processQueue: function() {
      var item;
      while (item = this._tileQueue.pop()) {
        this._getTileData.apply(this, item);
      }
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    _getTileData: function(coord, zoom, callback) {
      var self = this;
      var subdomains = this.options.subdomains || '0123';
      var limit_x = Math.pow(2, zoom);
      var corrected_x = ((coord.x % limit_x) + limit_x) % limit_x;
      var index = Math.abs(corrected_x + coord.y) % subdomains.length;
      var extra = this._extraParams();
      var url = this.templateUrl
                .replace('{x}', corrected_x)
                .replace('{y}', coord.y)
                .replace('{z}', zoom)
                .replace('{s}', subdomains[index])
      url += extra;
      torque.net.get( url , function (data) {
        if (data && data.responseText) {
          var rows = JSON.parse(data.responseText);
          callback(self.proccessTile(rows, coord, zoom));
        } else {
          callback(null);
        }
      });
    },

    getKeySpan: function() {
      return {
        start: this.options.start,
        end: this.options.end,
        step: this.options.step,
        steps: this.options.steps,
        columnType: this.options.column_type
      };
    },

    setColumn: function(column, isTime) {
      this.options.column = column;
      this.options.is_time = isTime === undefined ? true: false;
      this.reload();
    },

    reload: function() {
      this._ready = false;
      this._fetchMap();
    },

    getSteps: function() {
      return Math.min(this.options.steps, this.options.data_steps);
    },

    getBounds: function() {
      return this.options.bounds;
    },

    getSQL: function() {
      return this.options.sql || "select * from " + this.options.table;
    },

    setSQL: function(sql) {
      if (this.options.sql != sql) {
        this.options.sql = sql;
        this.reload();
      }
    },

    _isUserTemplateUrl: function(t) {
      return t && t.indexOf('{user}') !== -1;
    },

    isHttps: function() {
      return this.options.maps_api_template.indexOf('https') === 0;
    },

    _fetchMap: function(callback) {
      var self = this;
      torque.net.get(this.options.tileJSON, function (data) {
        data = JSON.parse(data.response);
        if (data) {
          if (data.errors){
            self.options.errorCallback && self.options.errorCallback(data.errors);
            return;
          }
          for(var k in data) {
            self.options[k] = data[k];
          }
          self.templateUrl = data.tiles[0];
          if (self.templateUrl.indexOf("http") !== 0){
            self.templateUrl = self.options.tileJSON.substring(0, self.options.tileJSON.lastIndexOf("/") + 1) + self.templateUrl;
          }
          self._setReady(true);
        }
      });
    }
  };

  module.exports = tileJSON;
},{"../":19}],31:[function(require,module,exports){
  var torque = require('../');
  var Profiler = require('../profiler');

  var Uint8Array = torque.types.Uint8Array;
  var Int32Array = torque.types.Int32Array;
  var Uint32Array = torque.types.Uint32Array;
  var Uint8ClampedArray = torque.types.Uint8ClampedArray;

  // format('hello, {0}', 'rambo') -> "hello, rambo"
  function format(str) {
    for(var i = 1; i < arguments.length; ++i) {
      var attrs = arguments[i];
      for(var attr in attrs) {
        str = str.replace(RegExp('\\{' + attr + '\\}', 'g'), attrs[attr]);
      }
    }
    return str;
  }

  var windshaft = function (options) {
    this._ready = false;
    this._tileQueue = [];
    this.options = options;

    this.options.is_time = this.options.is_time === undefined ? true: this.options.is_time;
    this.options.tiler_protocol = options.tiler_protocol || 'http';
    this.options.tiler_domain = options.tiler_domain || 'cartodb.com';
    this.options.tiler_port = options.tiler_port || 80;

    // backwards compatible
    if (!options.maps_api_template) {
      this._buildMapsApiTemplate(this.options);
    } else {
      this.options.maps_api_template =  options.maps_api_template;
    }

    this.options.coordinates_data_type = this.options.coordinates_data_type || Uint8Array;

    if (this.options.data_aggregation) {
      this.options.cumulative = this.options.data_aggregation === 'cumulative';
    }
    if (this.options.auth_token) {
      var e = this.options.extra_params || (this.options.extra_params = {});
      e.auth_token = this.options.auth_token;
    }
    if (!this.options.no_fetch_map) {
      this._fetchMap();
    }
  };

  windshaft.prototype = {

    /**
     * return the torque tile encoded in an efficient javascript
     * structure:
     * {
     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255
     *   y:Uint8Array y coordinates in tile reference system
     *   Index: Array index to the properties
     * }
     */
    proccessTile: function(rows, coord, zoom) {
      var r;
      var x = new this.options.coordinates_data_type(rows.length);
      var y = new this.options.coordinates_data_type(rows.length);

      var prof_mem = Profiler.metric('torque.provider.windshaft.mem');
      var prof_point_count = Profiler.metric('torque.provider.windshaft.points');
      var prof_process_time = Profiler.metric('torque.provider.windshaft.process_time').start();

      // count number of dates
      var dates = 0;
      var maxDateSlots = -1;
      for (r = 0; r < rows.length; ++r) {
        var row = rows[r];
        dates += row.dates__uint16.length;
        for(var d = 0; d < row.dates__uint16.length; ++d) {
          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);
        }
      }

      if(this.options.cumulative) {
        dates = (1 + maxDateSlots) * rows.length;
      }

      var type = this.options.cumulative ? Uint32Array: Uint8ClampedArray;

      // reserve memory for all the dates
      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size
      var timeCount = new Int32Array(maxDateSlots + 1);
      var renderData = new (this.options.valueDataType || type)(dates);
      var renderDataPos = new Uint32Array(dates);

      prof_mem.inc(
        4 * maxDateSlots + // timeIndex
        4 * maxDateSlots + // timeCount
        dates + //renderData
        dates * 4
      ); //renderDataPos

      prof_point_count.inc(rows.length);

      var rowsPerSlot = {};

      // precache pixel positions
      for (var r = 0; r < rows.length; ++r) {
        var row = rows[r];
        x[r] = row.x__uint8 * this.options.resolution;
        y[r] = row.y__uint8 * this.options.resolution;

        var dates = row.dates__uint16;
        var vals = row.vals__uint8;
        if (!this.options.cumulative) {
          for (var j = 0, len = dates.length; j < len; ++j) {
              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);
              if(this.options.cumulative) {
                  vals[j] += prev_val;
              }
              prev_val = vals[j];
              rr.push([r, vals[j]]);
          }
        } else {
          var valByDate = {}
          for (var j = 0, len = dates.length; j < len; ++j) {
            valByDate[dates[j]] = vals[j];
          }
          var accum = 0;

          // extend the latest to the end
          for (var j = dates[0]; j <= maxDateSlots; ++j) {
              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
              var v = valByDate[j];
              if (v) {
                accum += v;
              }
              rr.push([r, accum]);
          }

          /*var lastDateSlot = dates[dates.length - 1];
          for (var j = lastDateSlot + 1; j <= maxDateSlots; ++j) {
            var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);
            rr.push([r, prev_val]);
          }
          */
        }

      }

      // for each timeslot search active buckets
      var renderDataIndex = 0;
      var timeSlotIndex = 0;
      var i = 0;
      for(var i = 0; i <= maxDateSlots; ++i) {
        var c = 0;
        var slotRows = rowsPerSlot[i]
        if(slotRows) {
          for (var r = 0; r < slotRows.length; ++r) {
            var rr = slotRows[r];
            ++c;
            renderDataPos[renderDataIndex] = rr[0]
            renderData[renderDataIndex] = rr[1];
            ++renderDataIndex;
          }
        }
        timeIndex[i] = timeSlotIndex;
        timeCount[i] = c;
        timeSlotIndex += c;
      }

      prof_process_time.end();

      return {
        x: x,
        y: y,
        z: zoom,
        coord: {
          x: coord.x,
          y: coord.y,
          z: zoom
        },
        timeCount: timeCount,
        timeIndex: timeIndex,
        renderDataPos: renderDataPos,
        renderData: renderData,
        maxDate: maxDateSlots
      };
    },

    /*setCartoCSS: function(c) {
      this.options.cartocss = c;
    },*/

    setSteps: function(steps, opt) { 
      opt = opt || {};
      if (this.options.steps !== steps) {
        this.options.steps = steps;
        this.options.step = (this.options.end - this.options.start)/this.getSteps();
        this.options.step = this.options.step || 1;
        if (!opt.silent) this.reload();
      }
    },

    setOptions: function(opt) {
      var refresh = false;

      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {
        this.options.resolution = opt.resolution;
        refresh = true;
      }

      if(opt.steps !== undefined && opt.steps !== this.options.steps) {
        this.setSteps(opt.steps, { silent: true });
        refresh = true;
      }

      if(opt.column !== undefined && opt.column !== this.options.column) {
        this.options.column = opt.column;
        refresh = true;
      }

      if(opt.countby !== undefined && opt.countby !== this.options.countby) {
        this.options.countby = opt.countby;
        refresh = true;
      }

      if(opt.data_aggregation !== undefined) {
        var c = opt.data_aggregation === 'cumulative';
        if (this.options.cumulative !== c) {
          this.options.cumulative = c;
          refresh = true;
        }
      }

      if (refresh) this.reload();
      return refresh;
    },

    _extraParams: function(e) {
      e = torque.extend(torque.extend({}, e), this.options.extra_params);
      if (e) {
        var p = [];
        for(var k in e) {
          var v = e[k];
          if (v) {
            if (torque.isArray(v)) {
              for (var i = 0, len = v.length; i < len; i++) {
                p.push(k + "[]=" + encodeURIComponent(v[i]));
              }
            } else {
              p.push(k + "=" + encodeURIComponent(v));
            }
          }
        }
        return p.join('&');
      }
      return null;
    },

    getTileData: function(coord, zoom, callback) {
      if(!this._ready) {
        this._tileQueue.push([coord, zoom, callback]);
      } else {
        this._getTileData(coord, zoom, callback);
      }
    },

    _setReady: function(ready) {
      this._ready = true;
      this._processQueue();
      this.options.ready && this.options.ready();
    },

    _processQueue: function() {
      var item;
      while (item = this._tileQueue.pop()) {
        this._getTileData.apply(this, item);
      }
    },

    /**
     * `coord` object like {x : tilex, y: tiley }
     * `zoom` quadtree zoom level
     */
    _getTileData: function(coord, zoom, callback) {
      var self = this;
      var prof_fetch_time = Profiler.metric('torque.provider.windshaft.tile.fetch').start();
      var subdomains = this.options.subdomains || '0123';
      var limit_x = Math.pow(2, zoom);
      var corrected_x = ((coord.x % limit_x) + limit_x) % limit_x;
      var index = Math.abs(corrected_x + coord.y) % subdomains.length;
      var url = this.templateUrl
                .replace('{x}', corrected_x)
                .replace('{y}', coord.y)
                .replace('{z}', zoom)
                .replace('{s}', subdomains[index])

      var extra = this._extraParams();
      torque.net.get( url + (extra ? "?" + extra: ''), function (data) {
        prof_fetch_time.end();
        if (data && data.responseText) {
          var rows = JSON.parse(data.responseText);
          callback(self.proccessTile(rows, coord, zoom));
        } else {
          Profiler.metric('torque.provider.windshaft.tile.error').inc();
          callback(null);
        }
      });
    },

    getKeySpan: function() {
      return {
        start: this.options.start,
        end: this.options.end,
        step: this.options.step,
        steps: this.options.steps,
        columnType: this.options.column_type
      };
    },

    setColumn: function(column, isTime) {
      this.options.column = column;
      this.options.is_time = isTime === undefined ? true: false;
      this.reload();
    },

    reload: function() {
      this._ready = false;
      this._fetchMap();
    },

    getSteps: function() {
      return Math.min(this.options.steps, this.options.data_steps);
    },

    getBounds: function() {
      return this.options.bounds;
    },

    getSQL: function() {
      return this.options.sql || "select * from " + this.options.table;
    },

    setSQL: function(sql) {
      if (this.options.sql != sql) {
        this.options.sql = sql;
        this.reload();
      }
    },

    _buildMapsApiTemplate: function(opts) {
       var user = opts.user_name || opts.user;
       opts.maps_api_template = opts.tiler_protocol +
           "://" + ((user) ? "{user}.":"")  +
           opts.tiler_domain +
           ((opts.tiler_port != "") ? (":" + opts.tiler_port) : "");
    },

    _tilerHost: function() {
      var opts = this.options;
      var user = opts.user_name || opts.user;
      return opts.maps_api_template.replace('{user}', user);
    },

    url: function () {
      var opts = this.options;
      var cdn_host = opts.cdn_url;
      var has_empty_cdn = !cdn_host || (cdn_host && (!cdn_host.http && !cdn_host.https));

      if (opts.no_cdn || has_empty_cdn) {
        return this._tilerHost();
      } else {
        var protocol = this.isHttps() ? 'https': 'http';
        var h = protocol + "://";
        if (!this.isHttps()) {
          h += "{s}.";
        }
        var cdn_url = cdn_host[protocol];
        // build default template url if the cdn url is not templatized
        // this is for backwards compatiblity, ideally we should use the url
        // that tiler sends to us right away
        if (!this._isUserTemplateUrl(cdn_url)) {
          cdn_url = cdn_url  + "/{user}";
        }
        var user = opts.user_name || opts.user;
        h += cdn_url.replace('{user}', user)
        return h;
      }

    },

    _isUserTemplateUrl: function(t) {
      return t && t.indexOf('{user}') !== -1;
    },

    isHttps: function() {
      return this.options.maps_api_template.indexOf('https') === 0;
    },

    _generateCartoCSS: function() {
      var attr = {
        '-torque-frame-count': this.options.steps,
        '-torque-resolution': this.options.resolution,
        '-torque-aggregation-function': "'" + this.options.countby + "'",
        '-torque-time-attribute': "'" + this.options.column + "'",
        '-torque-data-aggregation': this.options.cumulative ? 'cumulative': 'linear',
      };
      var st = 'Map{';
      for (var k in attr) {
        st += k + ":" + attr[k] + ";";
      }
      return st + "}";
    },

    _fetchMap: function(callback) {
      var self = this;
      var layergroup = {};
      var host = this.options.dynamic_cdn ? this.url().replace('{s}', '0'): this._tilerHost();
      var url = host + "/api/v1/map";
      var named = this.options.named_map;
      var allParams = {};

      if(named) {
        //tiles/template
        url = host + "/api/v1/map/named/" + named.name + "/jsonp";
        if(typeof named.params !== "undefined"){
          layergroup = named.params;
        }
      } else {
        layergroup = {
          "version": "1.0.1",
          "stat_tag": this.options.stat_tag || 'torque',
          "layers": [{
            "type": "torque",
            "options": {
              "cartocss_version": "1.0.0",
              "cartocss": this._generateCartoCSS(),
              "sql": this.getSQL()
            }
          }]
        };
      }
      
      if(this.options.stat_tag){
        allParams["stat_tag"] = this.options.stat_tag;
      }

      extra = this._extraParams(allParams);

      // tiler needs map_key instead of api_key
      // so replace it
      if (extra) {
        extra = extra.replace('api_key=', 'map_key=');
      }

      url = url +
        "?config=" + encodeURIComponent(JSON.stringify(layergroup)) +
        "&callback=?" + (extra ? "&" + extra: '');

      var map_instance_time = Profiler.metric('torque.provider.windshaft.layergroup.time').start();
      torque.net.jsonp(url, function (data) {
        map_instance_time.end();
        if (data) {
          if (data.errors){
            self.options.errorCallback && self.options.errorCallback(data.errors);
            return;
          }
          var torque_key = Object.keys(data.metadata.torque)[0]
          var opt = data.metadata.torque[torque_key];
          for(var k in opt) {
            self.options[k] = opt[k];
          }
          // use cdn_url if present
          if (data.cdn_url) {
            var c = self.options.cdn_url = self.options.cdn_url || {};
            c.http = data.cdn_url.http || c.http;
            c.https = data.cdn_url.https || c.https;
          }
          self.templateUrl = self.url() + "/api/v1/map/" + data.layergroupid + "/" + torque_key + "/{z}/{x}/{y}.json.torque";
          self._setReady(true);
        } else {
          Profiler.metric('torque.provider.windshaft.layergroup.error').inc();
        }
      }, { callbackName: self.options.instanciateCallback });
    }

  };

  module.exports = windshaft;

},{"../":19,"../profiler":26}],32:[function(require,module,exports){
  var TAU = Math.PI*2;
  // min value to render a line. 
  // it does not make sense to render a line of a width is not even visible
  var LINEWIDTH_MIN_VALUE = 0.05; 
  var MAX_SPRITE_RADIUS = 255;

  function renderPoint(ctx, st) {
    ctx.fillStyle = st['marker-fill'];
    var pixel_size = st['marker-width'];

    // render a circle
    // TODO: fill and stroke order should depend on the order of the properties
    // in the cartocss.

    // fill
    ctx.beginPath();
    ctx.arc(0, 0, pixel_size, 0, TAU, true, true);
    ctx.closePath();

    if (st['marker-opacity'] !== undefined )  st['marker-fill-opacity'] = st['marker-line-opacity'] = st['marker-opacity'];

    if (st['marker-fill']) {
        ctx.globalAlpha = st['marker-fill-opacity'] >= 0? st['marker-fill-opacity']: 1;

      if (ctx.globalAlpha > 0) {
        ctx.fill();
      }
    }

    // stroke
    if (st['marker-line-color'] && st['marker-line-width'] && st['marker-line-width'] > LINEWIDTH_MIN_VALUE) {
      ctx.globalAlpha = st['marker-line-opacity'] >= 0? st['marker-line-opacity']: 1;
      if (st['marker-line-width'] !== undefined) {
        ctx.lineWidth = st['marker-line-width'];
      }
      ctx.strokeStyle = st['marker-line-color'];

      // do not render for alpha = 0
      if (ctx.globalAlpha > 0) {
        ctx.stroke();
      }
    }
  }

  function renderRectangle(ctx, st) {
    ctx.fillStyle = st['marker-fill'];
    var pixel_size = st['marker-width'];
    var w = pixel_size * 2;

    // fill
    if (st['marker-fill']) {
      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {
        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];
      }
      ctx.fillRect(-pixel_size, -pixel_size, w, w)
    }

    // stroke
    ctx.globalAlpha = 1.0;
    if (st['marker-line-color'] && st['marker-line-width']) {
      if (st['marker-line-opacity']) {
        ctx.globalAlpha = st['marker-line-opacity'];
      }
      if (st['marker-line-width']) {
        ctx.lineWidth = st['marker-line-width'];
      }
      ctx.strokeStyle = st['marker-line-color'];

      // do not render for alpha = 0
      if (ctx.globalAlpha > 0) {
        ctx.strokeRect(-pixel_size, -pixel_size, w, w)
      }
    }
  }

  function renderSprite(ctx, img, st) {

    if(img.complete){
      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {
        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];
      }
      ctx.drawImage(img, 0, 0, Math.min(img.width, MAX_SPRITE_RADIUS), Math.min(img.height, MAX_SPRITE_RADIUS));
    }
  }

module.exports = {
    renderPoint: renderPoint,
    renderSprite: renderSprite,
    renderRectangle: renderRectangle,
    MAX_SPRITE_RADIUS: MAX_SPRITE_RADIUS
};

},{}],33:[function(require,module,exports){
module.exports = {
    cartocss: require('./cartocss_render'),
    Point: require('./point'),
    Rectangle: require('./rectangle')
};
},{"./cartocss_render":32,"./point":34,"./rectangle":35}],34:[function(require,module,exports){
(function (global){
var torque = require('../');
var cartocss = require('./cartocss_render');
var Profiler = require('../profiler');
var carto = global.carto || require('carto');
var Filters = require('./torque_filters');

  var TAU = Math.PI * 2;
  var DEFAULT_CARTOCSS = [
    '#layer {',
    '  marker-fill: #662506;',
    '  marker-width: 4;',
    '  [value > 1] { marker-fill: #FEE391; }',
    '  [value > 2] { marker-fill: #FEC44F; }',
    '  [value > 3] { marker-fill: #FE9929; }',
    '  [value > 4] { marker-fill: #EC7014; }',
    '  [value > 5] { marker-fill: #CC4C02; }',
    '  [value > 6] { marker-fill: #993404; }',
    '  [value > 7] { marker-fill: #662506; }',
    '}'
  ].join('\n');

  var COMP_OP_TO_CANVAS = {
    "src": 'source-over',
    "src-over": 'source-over',
    "dst-over": 'destination-over',
    "src-in": 'source-in',
    "dst-in": 'destination-in',
    "src-out": 'source-out',
    "dst-out": 'destination-out',
    "src-atop": 'source-atop',
    "dst-atop": 'destination-atop',
    "xor": 'xor',
    "darken": 'darken',
    "lighten": 'lighten'
  }

  function compop2canvas(compop) {
    return COMP_OP_TO_CANVAS[compop] || compop;
  }

  //
  // this renderer just render points depending of the value
  //
  function PointRenderer(canvas, options) {
    if (!canvas) {
      throw new Error("canvas can't be undefined");
    }
    this.options = options;
    this._canvas = canvas;
    this._ctx = canvas.getContext('2d');
    this._sprites = []; // sprites per layer
    this._shader = null;
    this._icons = {};
    this._iconsToLoad = 0;
    this._filters = new Filters(this._canvas, {canvasClass: options.canvasClass});
    this.setCartoCSS(this.options.cartocss || DEFAULT_CARTOCSS);
    this.TILE_SIZE = 256;
    this._style = null;
    this._gradients = {};
    
    this._forcePoints = false;
  }

  torque.extend(PointRenderer.prototype, torque.Event, {

    clearCanvas: function() {
      var canvas = this._canvas;
      var color = this._Map['-torque-clear-color']
      // shortcut for the default value
      if (color  === "rgba(255, 255, 255, 0)" || !color) {
        this._canvas.width = this._canvas.width;
      } else {
        var ctx = this._ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var compop = this._Map['comp-op']
        ctx.globalCompositeOperation = compop2canvas(compop);
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    },

    setCanvas: function(canvas) {
      this._canvas = canvas;
      this._ctx = canvas.getContext('2d');
    },

    //
    // sets the cartocss style to render stuff
    //
    setCartoCSS: function(cartocss) {
      // clean sprites
      this.setShader(new carto.RendererJS().render(cartocss));
    },

    setShader: function(shader) {
      // clean sprites
      this._sprites = [];
      this._shader = shader;
      this._Map = this._shader.getDefault().getStyle({}, { zoom: 0 });
      var img_names = this._shader.getImageURLs();
      this._preloadIcons(img_names);
    },

    clearSpriteCache: function() {
      this._sprites = [];
    },


    //
    // generate sprite based on cartocss style
    //
    generateSprite: function(shader, value, shaderVars) {
      var self = this;
      var prof = Profiler.metric('torque.renderer.point.generateSprite').start();
      var st = shader.getStyle({
        value: value
      }, shaderVars);
      if(this._style === null || this._style !== st){
        this._style = st;
      }

      var pointSize = st['marker-width'];
      if (!pointSize) {
        return null;
      }

      if (st['marker-opacity'] === 0 && !st['marker-line-opacity']) {
        return null;
      }

      var canvas = this._createCanvas();
      var ctx = canvas.getContext('2d');

      var markerFile = st["marker-file"] || st["point-file"];
      var qualifiedUrl = markerFile && this._qualifyURL(markerFile);

      if (qualifiedUrl && this._iconsToLoad <= 0 && this._icons[qualifiedUrl]) {
        var img = this._icons[qualifiedUrl];

        var dWidth =  Math.min(st['marker-width'] * 2 || img.width, cartocss.MAX_SPRITE_RADIUS * 2);
        var dHeight = Math.min((st['marker-height'] || dWidth) * (img.width / img.height), cartocss.MAX_SPRITE_RADIUS * 2);

        canvas.width = ctx.width = dWidth;
        canvas.height = ctx.height = dHeight;

        ctx.scale(dWidth/img.width, dHeight/img.height);

        cartocss.renderSprite(ctx, img, st);
      } else {
        // take into account the exterior ring to calculate the size
        var canvasSize = (st['marker-line-width'] || 0) + pointSize*2;
        var w = ctx.width = canvas.width = ctx.height = canvas.height = Math.ceil(canvasSize);
        ctx.translate(w/2, w/2);

        var mt = st['marker-type'];
        if (mt && mt === 'rectangle') {
          cartocss.renderRectangle(ctx, st);
        } else {
          cartocss.renderPoint(ctx, st);
        }
      }
      prof.end(true);
      if (torque.flags.sprites_to_images) {
        var i = this._createImage();
        i.src = canvas.toDataURL();
        return i;
      }
      
      return canvas;
    },

    //
    // renders all the layers (and frames for each layer) from cartocss
    //
    renderTile: function(tile, key, callback) {
      if (this._iconsToLoad > 0) {
          this.on('allIconsLoaded', function() {
              this.renderTile.apply(this, [tile, key, callback]);
          });
          return false;
      }
      var prof = Profiler.metric('torque.renderer.point.renderLayers').start();
      var layers = this._shader.getLayers();
      for(var i = 0, n = layers.length; i < n; ++i ) {
        var layer = layers[i];
        if (layer.name() !== "Map") {
          var sprites = this._sprites[i] || (this._sprites[i] = {});
          // frames for each layer
          for(var fr = 0; fr < layer.frames().length; ++fr) {
            var frame = layer.frames()[fr];
            var fr_sprites = sprites[frame] || (sprites[frame] = []);
            this._renderTile(tile, key - frame, frame, fr_sprites, layer);
          }
        }
      }
      
      prof.end(true);

      return callback && callback(null);
    },

    _createCanvas: function() {
      return this.options.canvasClass
        ? new this.options.canvasClass()
        : document.createElement('canvas');
    },

    _createImage: function() {
      return this.options.imageClass
        ? new this.options.imageClass()
        : new Image();
    },

    _setImageSrc: function(img, url, callback) {
      if (this.options.setImageSrc) {
        this.options.setImageSrc(img, url, callback);
      } else {
        img.onload = function(){
            callback(null);
        };
        img.onerror = function(){
            callback(new Error('Could not load image'));
        };
        img.src = url;
      }
    },

    _qualifyURL: function(url) {
      if (typeof this.options.qualifyURL !== "undefined"){
        return this.options.qualifyURL(url);
      }
      else{
        var a = document.createElement('a');
        a.href = url;
        return a.href;
      }
    },

    //
    // renders a tile in the canvas for key defined in 
    // the torque tile
    //
    _renderTile: function(tile, key, frame_offset, sprites, shader, shaderVars) {
      if (!this._canvas) return;

      var prof = Profiler.metric('torque.renderer.point.renderTile').start();
      var ctx = this._ctx;
      var blendMode = compop2canvas(shader.eval('comp-op')) || this.options.blendmode;
      if (blendMode) {
        ctx.globalCompositeOperation = blendMode;
      }
      if (this.options.cumulative && key > tile.maxDate) {
        //TODO: precache because this tile is not going to change
        key = tile.maxDate;
      }
      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1)
      var activePixels = tile.timeCount[key];
      var anchor = this.options.resolution/2;
      if (activePixels) {
        var pixelIndex = tile.timeIndex[key];
        for(var p = 0; p < activePixels; ++p) {
          var posIdx = tile.renderDataPos[pixelIndex + p];
          var c = tile.renderData[pixelIndex + p];
          if (c) {
           var sp = sprites[c];
           if (sp === undefined) {
             sp = sprites[c] = this.generateSprite(shader, c, torque.extend({ zoom: tile.z, 'frame-offset': frame_offset }, shaderVars));
           }
           if (sp) {
             var x = tile.x[posIdx]- (sp.width >> 1) + anchor;
             var y = tileMax - tile.y[posIdx] + anchor; // flip mercator
             ctx.drawImage(sp, x, y - (sp.height >> 1));
           }
          }
        }
      }
      

      prof.end(true);
    },

    setBlendMode: function(b) {
      this.options.blendmode = b;
    },

    /**
     * get active points for a step in active zoom
     * returns a list of bounding boxes [[sw, ne] , [], []] where ne is a {lat: .., lon: ...} obj
     * empty list if there is no active pixels
     */
    getActivePointsBBox: function(tile, step) {
      var positions = [];
      var mercator = new torque.Mercator();

      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1);
      //this.renderer.renderTile(tile, this.key, pos.x, pos.y);
      var activePixels = tile.timeCount[step];
      var pixelIndex = tile.timeIndex[step];
      for(var p = 0; p < activePixels; ++p) {
        var posIdx = tile.renderDataPos[pixelIndex + p];
        var c = tile.renderData[pixelIndex + p];
        if (c) {
         var x = tile.x[posIdx];
         var y = tileMax - tile.y[posIdx]; // flip mercator
         positions.push(mercator.tilePixelBBox(
           tile.coord.x,
           tile.coord.y,
           tile.coord.z,
           x, y
         ));
        }
      }
      return positions;
    },

    /**
     * returns an array with all the values for the active pixels
     * @tile tile object
     * @step integer with the step
     * @values (optional) an array where the values will be placed
     */
    getValues: function(tile, step, values) {
      values = values || [];
      var activePixels = tile.timeCount[step];
      var pixelIndex = tile.timeIndex[step];
      for(var p = 0; p < activePixels; ++p) {
        var posIdx = tile.renderDataPos[pixelIndex + p];
        values.push(tile.renderData[pixelIndex + p]);
      }
      return values;
    },

    // return the value for x, y (tile coordinates)
    // null for no value
    getValueFor: function(tile, step, px, py) {
      var mercator = new torque.Mercator();
      var res = this.options.resolution;
      var res2 = res >> 1;

      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1);
      //this.renderer.renderTile(tile, this.key, pos.x, pos.y);
      var activePixels = tile.timeCount[step];
      var pixelIndex = tile.timeIndex[step];
      for(var p = 0; p < activePixels; ++p) {
        var posIdx = tile.renderDataPos[pixelIndex + p];
        var c = tile.renderData[pixelIndex + p];
        if (c) {
         var x = tile.x[posIdx];
         var y = tileMax - tile.y[posIdx];
         var dx = px + res2 - x;
         var dy = py + res2 - y;
         if (dx >= 0 && dx < res && dy >= 0 && dy < res) {
           return {
             value: c,
             bbox: mercator.tilePixelBBox(
               tile.coord.x,
               tile.coord.y,
               tile.coord.z,
               x - res2, y - res2, res
             )
           }
         }
        }
      }
      return null;
    },

    _preloadIcons: function(img_names) {
      var self = this;

      if (img_names.length > 0 && !this._forcePoints) {

        var qualifiedImageUrlSet = Object.keys(img_names.reduce(function(imgNamesMap, imgName) {
            var qualifiedUrl = self._qualifyURL(imgName);
            if (!self._icons[qualifiedUrl]) {
                imgNamesMap[qualifiedUrl] = true;
            }
            return imgNamesMap;
        }, {}));

        var filtered = self._shader.getLayers().some(function(layer) {
          return typeof layer.shader["image-filters"] !== "undefined";
        });

        this._iconsToLoad += qualifiedImageUrlSet.length;

        qualifiedImageUrlSet.forEach(function(qualifiedImageUrl) {
          self._icons[qualifiedImageUrl] = null;

          var img = self._createImage();

          if (filtered) {
            img.crossOrigin = 'Anonymous';
          }

          self._setImageSrc(img, qualifiedImageUrl, function(err) {
            if (err) {
              self._forcePoints = true;
              self.clearSpriteCache();
              self._iconsToLoad = 0;
              self.fire("allIconsLoaded");
              if(filtered) {
                console.info("Only CORS-enabled, or same domain image-files can be used in combination with image-filters");
              }
              console.error("Couldn't get marker-file " + qualifiedImageUrl);
            } else {
              self._icons[qualifiedImageUrl] = img;
              self._iconsToLoad--;

              if (self._iconsToLoad <= 0){
                self.clearSpriteCache();
                self.fire("allIconsLoaded");
              }
            }
          });
        });
      } else {
          this.fire("allIconsLoaded");
      }
  },

  applyFilters: function(){
    if(this._style){
      if(this._style['image-filters']){
        function gradientKey(imf){
          var hash = ""
          for(var i = 0; i < imf.args.length; i++){
            var rgb = imf.args[i].rgb;
            hash += rgb[0] + ":" + rgb[1] + ":" + rgb[2];
          }
          return hash;
        }
        var gradient = this._gradients[gradientKey(this._style['image-filters'])];
        if(!gradient){
          function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
          }

          function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
          }
          gradient = {};
          var colorize = this._style['image-filters'].args;
          
          var increment = 1/colorize.length;
          for (var i = 0; i < colorize.length; i++){
            var key = increment * i + increment;
            var rgb = colorize[i].rgb;
            var formattedColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
            gradient[key] = formattedColor;
          }
          this._gradients[gradientKey(this._style['image-filters'])] = gradient;
        }
        this._filters.gradient(gradient);
        this._filters.draw();
      }
    }
  }
});


  // exports public api
module.exports = PointRenderer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../":19,"../profiler":26,"./cartocss_render":32,"./torque_filters":36,"carto":39}],35:[function(require,module,exports){
(function (global){
var carto = global.carto || require('carto');

  var DEFAULT_CARTOCSS = [
    '#layer {',
    '  polygon-fill: #FFFF00;',
    '  [value > 10] { polygon-fill: #FFFF00; }',
    '  [value > 100] { polygon-fill: #FFCC00; }',
    '  [value > 1000] { polygon-fill: #FE9929; }',
    '  [value > 10000] { polygon-fill: #FF6600; }',
    '  [value > 100000] { polygon-fill: #FF3300; }',
    '}'
  ].join('\n');

  var TAU = Math.PI * 2;

  //
  // this renderer just render points depending of the value
  // 
  function RectanbleRenderer(canvas, options) {
    this.options = options;
    carto.tree.Reference.set(torque['torque-reference']);
    this.setCanvas(canvas);
    this.setCartoCSS(this.options.cartocss || DEFAULT_CARTOCSS);
  }

  RectanbleRenderer.prototype = {

    //
    // sets the cartocss style to render stuff
    //
    setCartoCSS: function(cartocss) {
      this._cartoCssStyle = new carto.RendererJS().render(cartocss);
      if(this._cartoCssStyle.getLayers().length > 1) {
        throw new Error("only one CartoCSS layer is supported");
      }
      this._shader = this._cartoCssStyle.getLayers()[0].shader;
    },

    setCanvas: function(canvas) {
      if(!canvas) return;
      this._canvas = canvas;
      this._ctx = canvas.getContext('2d');
    },

    accumulate: function(tile, keys) {
      var prof = Profiler.metric('RectangleRender:accumulate').start();
      var x, y, posIdx, p, k, key, activePixels, pixelIndex;
      var res = this.options.resolution;
      var s = 256/res;
      var accum = new Float32Array(s*s);

      if(typeof(keys) !== 'object') {
        keys = [keys];
      }

      for(k = 0; k < keys.length; ++k) {
        key = keys[k];
        activePixels = tile.timeCount[key];
        if(activePixels) {
          pixelIndex = tile.timeIndex[key];
          for(p = 0; p < activePixels; ++p) {
            posIdx = tile.renderDataPos[pixelIndex + p];
            x = tile.x[posIdx]/res;
            y = tile.y[posIdx]/res;
            accum[x*s + y] += tile.renderData[pixelIndex + p];
          }
        }
      }

      prof.end();
      return accum;
    },

    renderTileAccum: function(accum, px, py) {
      var prof = Profiler.metric('RectangleRender:renderTileAccum').start();
      var color, x, y, alpha;
      var res = this.options.resolution;
      var ctx = this._ctx;
      var s = (256/res) | 0;
      var s2 = s*s;
      var colors = this._colors;
      if(this.options.blendmode) {
        ctx.globalCompositeOperation = this.options.blendmode;
      }
      var polygon_alpha = this._shader['polygon-opacity'] || function() { return 1.0; };
      for(var i = 0; i < s2; ++i) {
        var xy = i;
        var value = accum[i];
        if(value) {
          x = (xy/s) | 0;
          y = xy % s;
          // by-pass the style generation for improving performance
          color = this._shader['polygon-fill']({ value: value }, { zoom: 0 });
          ctx.fillStyle = color;
          //TODO: each function should have a default value for each 
          //property defined in the cartocss
          alpha = polygon_alpha({ value: value }, { zoom: 0 });
          if(alpha === null) {
            alpha = 1.0;
          }
          ctx.globalAlpha = alpha;
          ctx.fillRect(x * res, 256 - res - y * res, res, res);
        }
      }
      prof.end();
    },

    //
    // renders a tile in the canvas for key defined in 
    // the torque tile
    //
    renderTile: function(tile, key, callback) {
      if(!this._canvas) return;

      var res = this.options.resolution;

      //var prof = Profiler.get('render').start();
      var ctx = this._ctx;
      var colors = this._colors;
      var activepixels = tile.timeCount[key];
      if(activepixels) {
        var w = this._canvas.width;
        var h = this._canvas.height;
        //var imageData = ctx.getImageData(0, 0, w, h);
        //var pixels = imageData.data;
        var pixelIndex = tile.timeIndex[key];
        for(var p = 0; p < activePixels; ++p) {
          var posIdx = tile.renderDataPos[pixelIndex + p];
          var c = tile.renderData[pixelIndex + p];
          if(c) {
           var color = colors[Math.min(c, colors.length - 1)];
           var x = tile.x[posIdx];// + px;
           var y = tile.y[posIdx]; //+ py;

           ctx.fillStyle = color;
           ctx.fillRect(x, y, res, res);
           /*

           for(var xx = 0; xx < res; ++xx) {
            for(var yy = 0; yy < res; ++yy) {
              var idx = 4*((x+xx) + w*(y + yy));
              pixels[idx + 0] = color[0];
              pixels[idx + 1] = color[1];
              pixels[idx + 2] = color[2];
              pixels[idx + 3] = color[3];
            }
           }
           */
          }
        }
        //ctx.putImageData(imageData, 0, 0);
      }
      //prof.end();
      return callback && callback(null);
    }
  };


  // exports public api
module.exports = RectanbleRenderer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"carto":39}],36:[function(require,module,exports){
/*
 Based on simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas, 
 by Vladimir Agafonkin
 https://github.com/mourner/simpleheat
*/

'use strict';

function torque_filters(canvas, options) {
    // jshint newcap: false, validthis: true
    if (!(this instanceof torque_filters)) { return new torque_filters(canvas, options); }

    options = options || {};

    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;

    this._ctx = canvas.getContext('2d');
    this._width = canvas.width;
    this._height = canvas.height;

    this._max = 1;
    this._data = [];

    this.canvasClass = options.canvasClass;
}

torque_filters.prototype = {

    defaultGradient: {
        0.4: 'blue',
        0.6: 'cyan',
        0.7: 'lime',
        0.8: 'yellow',
        1.0: 'red'
    },

    gradient: function (grad) {
        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
        var canvas = this._createCanvas(),
            ctx = canvas.getContext('2d'),
            gradient = ctx.createLinearGradient(0, 0, 0, 256);

        canvas.width = 1;
        canvas.height = 256;

        for (var i in grad) {
            gradient.addColorStop(+i, grad[i]);
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1, 256);

        this._grad = ctx.getImageData(0, 0, 1, 256).data;

        return this;
    },

    draw: function () {
        if (!this._grad) {
            this.gradient(this.defaultGradient);
        }

        var ctx = this._ctx;
        var colored = ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);
        this._colorize(colored.data, this._grad);
        ctx.putImageData(colored, 0, 0);

        return this;
    },

    _colorize: function (pixels, gradient) {
        for (var i = 3, len = pixels.length, j; i < len; i += 4) {
            j = pixels[i] * 4; // get gradient color from opacity value

            if (j) {
                pixels[i - 3] = gradient[j];
                pixels[i - 2] = gradient[j + 1];
                pixels[i - 1] = gradient[j + 2];
            }
        }
    },

    _createCanvas: function() {
        return this.canvasClass
            ? new this.canvasClass()
            : document.createElement('canvas');
    }
};

module.exports = torque_filters;

},{}],37:[function(require,module,exports){
(function (global){
var torque = require('./core');

  var lastCall = null;

  function jsonp(url, callback, options) {
     options = options || {};
     options.timeout = options.timeout === undefined ? 10000: options.timeout;
     var head = document.getElementsByTagName('head')[0];
     var script = document.createElement('script');

     // function name
     var fnName = options.callbackName || 'torque_' + Date.now();

     if (torque.isFunction(fnName)) {
       fnName = fnName();
     }

     function clean() {
       head.removeChild(script);
       clearTimeout(timeoutTimer);
       delete window[fnName];
     }

     window[fnName] = function() {
       clean();
       callback.apply(window, arguments);
     };

     // timeout for errors
     var timeoutTimer = setTimeout(function() { 
       clean();
       callback.call(window, null); 
     }, options.timeout);

     // setup url
     url = url.replace('callback=\?', 'callback=' + fnName);
     script.type = 'text/javascript';
     script.src = url;
     script.async = true;
     // defer the loading because IE9 loads in the same frame the script
     // so Loader._script is null
     setTimeout(function() { head.appendChild(script); }, 0);
  }

  function get(url, callback, options) {
    options = options || {
      method: 'GET',
      data: null,
      responseType: 'text'
    };
    lastCall = { url: url, callback: callback };
    var request = XMLHttpRequest;
    // from d3.js
    if (global.XDomainRequest
        && !("withCredentials" in request)
        && /^(http(s)?:)?\/\//.test(url)) request = XDomainRequest;

    var req = new request();
    req.open(options.method, url, true);


    function respond() {
      var status = req.status, result;
      var r = options.responseType === 'arraybuffer' ? req.response: req.responseText;
      if (!status && r || status >= 200 && status < 300 || status === 304) {
        callback(req);
      } else {
        callback(null);
      }
    }

    "onload" in req
      ? req.onload = req.onerror = respond
      : req.onreadystatechange = function() { req.readyState > 3 && respond(); };

    req.onprogress = function() {};

    req.responseType = options.responseType; //'arraybuffer';
    if (options.data) {
      req.setRequestHeader("Content-type", "application/json");
      //req.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
      req.setRequestHeader("Accept", "*");
    }
    req.send(options.data);
    return req;
  }

  function post(url, data, callback) {
    return get(url, callback, {
      data: data,
      method: "POST"
    });
  }

module.exports = {
    get: get,
    post: post,
    jsonp: jsonp,
    lastCall: function() { return lastCall; }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./core":13}],38:[function(require,module,exports){
(function (tree) {

tree.functions = {
    rgb: function (r, g, b) {
        return this.rgba(r, g, b, 1.0);
    },
    rgba: function (r, g, b, a) {
        var rgb = [r, g, b].map(function (c) { return number(c); });
        a = number(a);
        if (rgb.some(isNaN) || isNaN(a)) return null;
        return new tree.Color(rgb, a);
    },
    // Only require val
    stop: function (val) {
        var color, mode;
        if (arguments.length > 1) color = arguments[1];
        if (arguments.length > 2) mode = arguments[2];

        return {
            is: 'tag',
            val: val,
            color: color,
            mode: mode,
            toString: function(env) {
                return '\n\t<stop value="' + val.ev(env) + '"' +
                    (color ? ' color="' + color.ev(env) + '" ' : '') +
                    (mode ? ' mode="' + mode.ev(env) + '" ' : '') +
                    '/>';
            }
        };
    },
    hsl: function (h, s, l) {
        return this.hsla(h, s, l, 1.0);
    },
    hsla: function (h, s, l, a) {
        h = (number(h) % 360) / 360;
        s = number(s); l = number(l); a = number(a);
        if ([h, s, l, a].some(isNaN)) return null;

        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            m1 = l * 2 - m2;

        return this.rgba(hue(h + 1/3) * 255,
                         hue(h)       * 255,
                         hue(h - 1/3) * 255,
                         a);

        function hue(h) {
            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
            if      (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
            else if (h * 2 < 1) return m2;
            else if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
            else                return m1;
        }
    },
    hue: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().h));
    },
    saturation: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().s * 100), '%');
    },
    lightness: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(Math.round(color.toHSL().l * 100), '%');
    },
    alpha: function (color) {
        if (!('toHSL' in color)) return null;
        return new tree.Dimension(color.toHSL().a);
    },
    saturate: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.s += amount.value / 100;
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    desaturate: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.s -= amount.value / 100;
        hsl.s = clamp(hsl.s);
        return hsla(hsl);
    },
    lighten: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.l += amount.value / 100;
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    darken: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.l -= amount.value / 100;
        hsl.l = clamp(hsl.l);
        return hsla(hsl);
    },
    fadein: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.a += amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    fadeout: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();

        hsl.a -= amount.value / 100;
        hsl.a = clamp(hsl.a);
        return hsla(hsl);
    },
    spin: function (color, amount) {
        if (!('toHSL' in color)) return null;
        var hsl = color.toHSL();
        var hue = (hsl.h + amount.value) % 360;

        hsl.h = hue < 0 ? 360 + hue : hue;

        return hsla(hsl);
    },
    replace: function (entity, a, b) {
        if (entity.is === 'field') {
            return entity.toString + '.replace(' + a.toString() + ', ' + b.toString() + ')';
        } else {
            return entity.replace(a, b);
        }
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function (color1, color2, weight) {
        var p = weight.value / 100.0;
        var w = p * 2 - 1;
        var a = color1.toHSL().a - color2.toHSL().a;

        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;

        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
                   color1.rgb[1] * w1 + color2.rgb[1] * w2,
                   color1.rgb[2] * w1 + color2.rgb[2] * w2];

        var alpha = color1.alpha * p + color2.alpha * (1 - p);

        return new tree.Color(rgb, alpha);
    },
    greyscale: function (color) {
        return this.desaturate(color, new tree.Dimension(100));
    },
    '%': function (quoted /* arg, arg, ...*/) {
        var args = Array.prototype.slice.call(arguments, 1),
            str = quoted.value;

        for (var i = 0; i < args.length; i++) {
            str = str.replace(/%s/,    args[i].value)
                     .replace(/%[da]/, args[i].toString());
        }
        str = str.replace(/%%/g, '%');
        return new tree.Quoted(str);
    }
};

var image_filter_functors = [
    'emboss', 'blur', 'gray', 'sobel', 'edge-detect',
    'x-gradient', 'y-gradient', 'sharpen'];

for (var i = 0; i < image_filter_functors.length; i++) {
    var f = image_filter_functors[i];
    tree.functions[f] = (function(f) {
        return function() {
            return new tree.ImageFilter(f);
        };
    })(f);
}

tree.functions['agg-stack-blur'] = function(x, y) {
    return new tree.ImageFilter('agg-stack-blur', [x, y]);
};

tree.functions['scale-hsla'] = function(h0,h1,s0,s1,l0,l1,a0,a1) {
    return new tree.ImageFilter('scale-hsla', [h0,h1,s0,s1,l0,l1,a0,a1]);
};

function hsla(h) {
    return tree.functions.hsla(h.h, h.s, h.l, h.a);
}

function number(n) {
    if (n instanceof tree.Dimension) {
        return parseFloat(n.unit == '%' ? n.value / 100 : n.value);
    } else if (typeof(n) === 'number') {
        return n;
    } else {
        return NaN;
    }
}

function clamp(val) {
    return Math.min(1, Math.max(0, val));
}

})(require('./tree'));

},{"./tree":44}],39:[function(require,module,exports){
(function (process,__dirname){
var util = require('util'),
    fs = require('fs'),
    path = require('path');


function getVersion() {
    if (process.browser) {
        return require('../../package.json').version.split('.');
    } else if (parseInt(process.version.split('.')[1], 10) > 4) {
        return require('../../package.json').version.split('.');
    } else {
        // older node
        var package_json = JSON.parse(fs.readFileSync(path.join(__dirname,'../../package.json')));
        return package_json.version.split('.');
    }
}

var carto = {
    version: getVersion(),
    Parser: require('./parser').Parser,
    Renderer: require('./renderer').Renderer,
    tree: require('./tree'),
    RendererJS: require('./renderer_js'),
    default_reference: require('./torque-reference'),

    // @TODO
    writeError: function(ctx, options) {
        var message = '';
        var extract = ctx.extract;
        var error = [];

        options = options || {};

        if (options.silent) { return; }

        options.indent = options.indent || '';

        if (!('index' in ctx) || !extract) {
            return util.error(options.indent + (ctx.stack || ctx.message));
        }

        if (typeof(extract[0]) === 'string') {
            error.push(stylize((ctx.line - 1) + ' ' + extract[0], 'grey'));
        }

        if (extract[1] === '' && typeof extract[2] === 'undefined') {
            extract[1] = '';
        }
        error.push(ctx.line + ' ' + extract[1].slice(0, ctx.column) +
            stylize(stylize(extract[1][ctx.column], 'bold') +
            extract[1].slice(ctx.column + 1), 'yellow'));

        if (typeof(extract[2]) === 'string') {
            error.push(stylize((ctx.line + 1) + ' ' + extract[2], 'grey'));
        }
        error = options.indent + error.join('\n' + options.indent) + '\033[0m\n';

        message = options.indent + message + stylize(ctx.message, 'red');
        if (ctx.filename) (message += stylize(' in ', 'red') + ctx.filename);

        util.error(message, error);

        if (ctx.callLine) {
            util.error(stylize('from ', 'red') + (ctx.filename || ''));
            util.error(stylize(ctx.callLine, 'grey') + ' ' + ctx.callExtract);
        }
        if (ctx.stack) { util.error(stylize(ctx.stack, 'red')); }
    }
};

require('./tree/call');
require('./tree/color');
require('./tree/comment');
require('./tree/definition');
require('./tree/dimension');
require('./tree/element');
require('./tree/expression');
require('./tree/filterset');
require('./tree/filter');
require('./tree/field');
require('./tree/keyword');
require('./tree/layer');
require('./tree/literal');
require('./tree/operation');
require('./tree/quoted');
require('./tree/imagefilter');
require('./tree/reference');
require('./tree/rule');
require('./tree/ruleset');
require('./tree/selector');
require('./tree/style');
require('./tree/url');
require('./tree/value');
require('./tree/variable');
require('./tree/zoom');
require('./tree/invalid');
require('./tree/fontset');
require('./tree/frame_offset');
require('./functions');

for (var k in carto) { exports[k] = carto[k]; }

// Stylize a string
function stylize(str, style) {
    var styles = {
        'bold' : [1, 22],
        'inverse' : [7, 27],
        'underline' : [4, 24],
        'yellow' : [33, 39],
        'green' : [32, 39],
        'red' : [31, 39],
        'grey' : [90, 39]
    };
    return '\033[' + styles[style][0] + 'm' + str +
           '\033[' + styles[style][1] + 'm';
}

}).call(this,require('_process'),"/node_modules/torque.js/node_modules/carto/lib/carto")

},{"../../package.json":75,"./functions":38,"./parser":40,"./renderer":41,"./renderer_js":42,"./torque-reference":43,"./tree":44,"./tree/call":45,"./tree/color":46,"./tree/comment":47,"./tree/definition":48,"./tree/dimension":49,"./tree/element":50,"./tree/expression":51,"./tree/field":52,"./tree/filter":53,"./tree/filterset":54,"./tree/fontset":55,"./tree/frame_offset":56,"./tree/imagefilter":57,"./tree/invalid":58,"./tree/keyword":59,"./tree/layer":60,"./tree/literal":61,"./tree/operation":62,"./tree/quoted":63,"./tree/reference":64,"./tree/rule":65,"./tree/ruleset":66,"./tree/selector":67,"./tree/style":68,"./tree/url":69,"./tree/value":70,"./tree/variable":71,"./tree/zoom":72,"_process":6,"fs":2,"path":5,"util":8}],40:[function(require,module,exports){
(function (global){
var carto = exports,
    tree = require('./tree'),
    _ = global._ || require('underscore');

//    Token matching is done with the `$` function, which either takes
//    a terminal string or regexp, or a non-terminal function to call.
//    It also takes care of moving all the indices forwards.
carto.Parser = function Parser(env) {
    var input,       // LeSS input string
        i,           // current index in `input`
        j,           // current chunk
        temp,        // temporarily holds a chunk's state, for backtracking
        memo,        // temporarily holds `i`, when backtracking
        furthest,    // furthest index the parser has gone to
        chunks,      // chunkified input
        current,     // index of current chunk, in `input`
        parser;

    var that = this;

    // This function is called after all files
    // have been imported through `@import`.
    var finish = function() {};

    function save()    {
        temp = chunks[j];
        memo = i;
        current = i;
    }
    function restore() {
        chunks[j] = temp;
        i = memo;
        current = i;
    }

    function sync() {
        if (i > current) {
            chunks[j] = chunks[j].slice(i - current);
            current = i;
        }
    }
    //
    // Parse from a token, regexp or string, and move forward if match
    //
    function $(tok) {
        var match, args, length, c, index, endIndex, k;

        // Non-terminal
        if (tok instanceof Function) {
            return tok.call(parser.parsers);
        // Terminal
        // Either match a single character in the input,
        // or match a regexp in the current chunk (chunk[j]).
        } else if (typeof(tok) === 'string') {
            match = input.charAt(i) === tok ? tok : null;
            length = 1;
            sync();
        } else {
            sync();

            match = tok.exec(chunks[j]);
            if (match) {
                length = match[0].length;
            } else {
                return null;
            }
        }

        // The match is confirmed, add the match length to `i`,
        // and consume any extra white-space characters (' ' || '\n')
        // which come after that. The reason for this is that LeSS's
        // grammar is mostly white-space insensitive.
        if (match) {
            var mem = i += length;
            endIndex = i + chunks[j].length - length;

            while (i < endIndex) {
                c = input.charCodeAt(i);
                if (! (c === 32 || c === 10 || c === 9)) { break; }
                i++;
            }
            chunks[j] = chunks[j].slice(length + (i - mem));
            current = i;

            if (chunks[j].length === 0 && j < chunks.length - 1) { j++; }

            if (typeof(match) === 'string') {
                return match;
            } else {
                return match.length === 1 ? match[0] : match;
            }
        }
    }

    // Same as $(), but don't change the state of the parser,
    // just return the match.
    function peek(tok) {
        if (typeof(tok) === 'string') {
            return input.charAt(i) === tok;
        } else {
            return !!tok.test(chunks[j]);
        }
    }

    function extractErrorLine(style, errorIndex) {
        return (style.slice(0, errorIndex).match(/\n/g) || '').length + 1;
    }


    // Make an error object from a passed set of properties.
    // Accepted properties:
    // - `message`: Text of the error message.
    // - `filename`: Filename where the error occurred.
    // - `index`: Char. index where the error occurred.
    function makeError(err) {
        var einput;

        _(err).defaults({
            index: furthest,
            filename: env.filename,
            message: 'Parse error.',
            line: 0,
            column: -1
        });

        if (err.filename && that.env.inputs && that.env.inputs[err.filename]) {
            einput = that.env.inputs[err.filename];
        } else {
            einput = input;
        }

        err.line = extractErrorLine(einput, err.index);
        for (var n = err.index; n >= 0 && einput.charAt(n) !== '\n'; n--) {
            err.column++;
        }

        return new Error(_('<%=filename%>:<%=line%>:<%=column%> <%=message%>').template(err));
    }

    this.env = env = env || {};
    this.env.filename = this.env.filename || null;
    this.env.inputs = this.env.inputs || {};

    // The Parser
    parser = {

        extractErrorLine: extractErrorLine,
        //
        // Parse an input string into an abstract syntax tree.
        // Throws an error on parse errors.
        parse: function(str) {
            var root, start, end, zone, line, lines, buff = [], c, error = null;

            i = j = current = furthest = 0;
            chunks = [];
            input = str.replace(/\r\n/g, '\n');
            if (env.filename) {
                that.env.inputs[env.filename] = input;
            }

            var early_exit = false;

            // Split the input into chunks.
            chunks = (function (chunks) {
                var j = 0,
                    skip = /(?:@\{[\w-]+\}|[^"'`\{\}\/\(\)\\])+/g,
                    comment = /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g,
                    string = /"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'|`((?:[^`]|\\.)*)`/g,
                    level = 0,
                    match,
                    chunk = chunks[0],
                    inParam;

                for (var i = 0, c, cc; i < input.length;) {
                    skip.lastIndex = i;
                    if (match = skip.exec(input)) {
                        if (match.index === i) {
                            i += match[0].length;
                            chunk.push(match[0]);
                        }
                    }
                    c = input.charAt(i);
                    comment.lastIndex = string.lastIndex = i;

                    if (match = string.exec(input)) {
                        if (match.index === i) {
                            i += match[0].length;
                            chunk.push(match[0]);
                            continue;
                        }
                    }

                    if (!inParam && c === '/') {
                        cc = input.charAt(i + 1);
                        if (cc === '/' || cc === '*') {
                            if (match = comment.exec(input)) {
                                if (match.index === i) {
                                    i += match[0].length;
                                    chunk.push(match[0]);
                                    continue;
                                }
                            }
                        }
                    }

                    switch (c) {
                        case '{': if (! inParam) { level ++;        chunk.push(c);                           break; }
                        case '}': if (! inParam) { level --;        chunk.push(c); chunks[++j] = chunk = []; break; }
                        case '(': if (! inParam) { inParam = true;  chunk.push(c);                           break; }
                        case ')': if (  inParam) { inParam = false; chunk.push(c);                           break; }
                        default:                                    chunk.push(c);
                    }

                    i++;
                }
                if (level !== 0) {
                    error = {
                        index: i - 1,
                        type: 'Parse',
                        message: (level > 0) ? "missing closing `}`" : "missing opening `{`"
                    };
                }

                return chunks.map(function (c) { return c.join(''); });
            })([[]]);

            if (error) {
                throw makeError(error);
            }

            // Start with the primary rule.
            // The whole syntax tree is held under a Ruleset node,
            // with the `root` property set to true, so no `{}` are
            // output.
            root = new tree.Ruleset([], $(this.parsers.primary));
            root.root = true;

            // Get an array of Ruleset objects, flattened
            // and sorted according to specificitySort
            root.toList = (function() {
                var line, lines, column;
                return function(env) {
                    env.error = function(e) {
                        if (!env.errors) env.errors = new Error('');
                        if (env.errors.message) {
                            env.errors.message += '\n' + makeError(e).message;
                        } else {
                            env.errors.message = makeError(e).message;
                        }
                    };
                    env.frames = env.frames || [];


                    // call populates Invalid-caused errors
                    var definitions = this.flatten([], [], env);
                    definitions.sort(specificitySort);
                    return definitions;
                };
            })();

            // Sort rules by specificity: this function expects selectors to be
            // split already.
            //
            // Written to be used as a .sort(Function);
            // argument.
            //
            // [1, 0, 0, 467] > [0, 0, 1, 520]
            var specificitySort = function(a, b) {
                var as = a.specificity;
                var bs = b.specificity;

                if (as[0] != bs[0]) return bs[0] - as[0];
                if (as[1] != bs[1]) return bs[1] - as[1];
                if (as[2] != bs[2]) return bs[2] - as[2];
                return bs[3] - as[3];
            };

            return root;
        },

        // Here in, the parsing rules/functions
        //
        // The basic structure of the syntax tree generated is as follows:
        //
        //   Ruleset ->  Rule -> Value -> Expression -> Entity
        //
        //  In general, most rules will try to parse a token with the `$()` function, and if the return
        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
        //  first, before parsing, that's when we use `peek()`.
        parsers: {
            // The `primary` rule is the *entry* and *exit* point of the parser.
            // The rules here can appear at any level of the parse tree.
            //
            // The recursive nature of the grammar is an interplay between the `block`
            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
            // as represented by this simplified grammar:
            //
            //     primary    (ruleset | rule)+
            //     ruleset    selector+ block
            //     block      '{' primary '}'
            //
            // Only at one point is the primary rule not called from the
            // block rule: at the root level.
            primary: function() {
                var node, root = [];

                while ((node = $(this.rule) || $(this.ruleset) ||
                               $(this.comment)) ||
                               $(/^[\s\n]+/) || (node = $(this.invalid))) {
                    if (node) root.push(node);
                }
                return root;
            },

            invalid: function () {
                var chunk = $(/^[^;\n]*[;\n]/);

                // To fail gracefully, match everything until a semicolon or linebreak.
                if (chunk) {
                    return new tree.Invalid(chunk, memo);
                }
            },

            // We create a Comment node for CSS comments `/* */`,
            // but keep the LeSS comments `//` silent, by just skipping
            // over them.
            comment: function() {
                var comment;

                if (input.charAt(i) !== '/') return;

                if (input.charAt(i + 1) === '/') {
                    return new tree.Comment($(/^\/\/.*/), true);
                } else if (comment = $(/^\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/)) {
                    return new tree.Comment(comment);
                }
            },

            // Entities are tokens which can be found inside an Expression
            entities: {

                // A string, which supports escaping " and ' "milky way" 'he\'s the one!'
                quoted: function() {
                    if (input.charAt(i) !== '"' && input.charAt(i) !== "'") return;
                    var str = $(/^"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'/);
                    if (str) {
                        return new tree.Quoted(str[1] || str[2]);
                    }
                },

                // A reference to a Mapnik field, like [NAME]
                // Behind the scenes, this has the same representation, but Carto
                // needs to be careful to warn when unsupported operations are used.
                field: function() {
                    if (! $('[')) return;
                    var field_name = $(/(^[^\]]+)/);
                    if (! $(']')) return;
                    if (field_name) return new tree.Field(field_name[1]);
                },

                // This is a comparison operator
                comparison: function() {
                    var str = $(/^=~|=|!=|<=|>=|<|>/);
                    if (str) {
                        return str;
                    }
                },

                // A catch-all word, such as: hard-light
                // These can start with either a letter or a dash (-),
                // and then contain numbers, underscores, and letters.
                keyword: function() {
                    var k = $(/^[A-Za-z-]+[A-Za-z-0-9_]*/);
                    if (k) { return new tree.Keyword(k); }
                },

                // A function call like rgb(255, 0, 255)
                // The arguments are parsed with the `entities.arguments` parser.
                call: function() {
                    var name, args;

                    if (!(name = /^([\w\-]+|%)\(/.exec(chunks[j]))) return;

                    name = name[1];

                    if (name === 'url') {
                        // url() is handled by the url parser instead
                        return null;
                    } else {
                        i += name.length;
                    }

                    $('('); // Parse the '(' and consume whitespace.

                    args = $(this.entities['arguments']);

                    if (!$(')')) return;

                    if (name) {
                        return new tree.Call(name, args, i);
                    }
                },
                // Arguments are comma-separated expressions
                'arguments': function() {
                    var args = [], arg;

                    while (arg = $(this.expression)) {
                        args.push(arg);
                        if (! $(',')) { break; }
                    }

                    return args;
                },
                literal: function() {
                    return $(this.entities.dimension) ||
                        $(this.entities.keywordcolor) ||
                        $(this.entities.hexcolor) ||
                        $(this.entities.quoted);
                },

                // Parse url() tokens
                //
                // We use a specific rule for urls, because they don't really behave like
                // standard function calls. The difference is that the argument doesn't have
                // to be enclosed within a string, so it can't be parsed as an Expression.
                url: function() {
                    var value;

                    if (input.charAt(i) !== 'u' || !$(/^url\(/)) return;
                    value = $(this.entities.quoted) || $(this.entities.variable) ||
                            $(/^[\-\w%@$\/.&=:;#+?~]+/) || '';
                    if (! $(')')) {
                        return new tree.Invalid(value, memo, 'Missing closing ) in URL.');
                    } else {
                        return new tree.URL((typeof value.value !== 'undefined' ||
                            value instanceof tree.Variable) ?
                            value : new tree.Quoted(value));
                    }
                },

                // A Variable entity, such as `@fink`, in
                //
                //     width: @fink + 2px
                //
                // We use a different parser for variable definitions,
                // see `parsers.variable`.
                variable: function() {
                    var name, index = i;

                    if (input.charAt(i) === '@' && (name = $(/^@[\w-]+/))) {
                        return new tree.Variable(name, index, env.filename);
                    }
                },

                hexcolor: function() {
                    var rgb;
                    if (input.charAt(i) === '#' && (rgb = $(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/))) {
                        return new tree.Color(rgb[1]);
                    }
                },

                keywordcolor: function() {
                    var rgb = chunks[j].match(/^[a-z]+/);
                    if (rgb && rgb[0] in tree.Reference.data.colors) {
                        return new tree.Color(tree.Reference.data.colors[$(/^[a-z]+/)]);
                    }
                },

                // A Dimension, that is, a number and a unit. The only
                // unit that has an effect is %
                dimension: function() {
                    var c = input.charCodeAt(i);
                    if ((c > 57 || c < 45) || c === 47) return;
                    var value = $(/^(-?\d*\.?\d+(?:[eE][-+]?\d+)?)(\%|\w+)?/);
                    if (value) {
                        return new tree.Dimension(value[1], value[2], memo);
                    }
                }
            },

            // The variable part of a variable definition.
            // Used in the `rule` parser. Like @fink:
            variable: function() {
                var name;

                if (input.charAt(i) === '@' && (name = $(/^(@[\w-]+)\s*:/))) {
                    return name[1];
                }
            },

            // Entities are the smallest recognized token,
            // and can be found inside a rule's value.
            entity: function() {
                return $(this.entities.call) ||
                    $(this.entities.literal) ||
                    $(this.entities.field) ||
                    $(this.entities.variable) ||
                    $(this.entities.url) ||
                    $(this.entities.keyword);
            },

            // A Rule terminator. Note that we use `peek()` to check for '}',
            // because the `block` rule will be expecting it, but we still need to make sure
            // it's there, if ';' was ommitted.
            end: function() {
                return $(';') || peek('}');
            },

            // Elements are the building blocks for Selectors. They consist of
            // an element name, such as a tag a class, or `*`.
            element: function() {
                var e = $(/^(?:[.#][\w\-]+|\*|Map)/);
                if (e) return new tree.Element(e);
            },

            // Attachments allow adding multiple lines, polygons etc. to an
            // object. There can only be one attachment per selector.
            attachment: function() {
                var s = $(/^::([\w\-]+(?:\/[\w\-]+)*)/);
                if (s) return s[1];
            },

            // Selectors are made out of one or more Elements, see above.
            selector: function() {
                var a, attachment,
                    e, elements = [],
                    f, filters = new tree.Filterset(),
                    z, zooms = [],
                    frame_offset = tree.FrameOffset.none;
                    segments = 0, conditions = 0;

                while (
                        (e = $(this.element)) ||
                        (z = $(this.zoom)) ||
                        (fo = $(this.frame_offset)) ||
                        (f = $(this.filter)) ||
                        (a = $(this.attachment))
                    ) {
                    segments++;
                    if (e) {
                        elements.push(e);
                    } else if (z) {
                        zooms.push(z);
                        conditions++;
                    } else if (fo) {
                        frame_offset = fo;
                        conditions++;
                    } else if (f) {
                        var err = filters.add(f);
                        if (err) {
                            throw makeError({
                                message: err,
                                index: i - 1
                            });
                        }
                        conditions++;
                    } else if (attachment) {
                        throw makeError({
                            message: 'Encountered second attachment name.',
                            index: i - 1
                        });
                    } else {
                        attachment = a;
                    }

                    var c = input.charAt(i);
                    if (c === '{' || c === '}' || c === ';' || c === ',') { break; }
                }

                if (segments) {
                    return new tree.Selector(filters, zooms, frame_offset, elements, attachment, conditions, memo);
                }
            },

            filter: function() {
                save();
                var key, op, val;
                if (! $('[')) return;
                if (key = $(/^[a-zA-Z0-9\-_]+/) ||
                    $(this.entities.quoted) ||
                    $(this.entities.variable) ||
                    $(this.entities.keyword) ||
                    $(this.entities.field)) {
                    // TODO: remove at 1.0.0
                    if (key instanceof tree.Quoted) {
                        key = new tree.Field(key.toString());
                    }
                    if ((op = $(this.entities.comparison)) &&
                        (val = $(this.entities.quoted) ||
                             $(this.entities.variable) ||
                             $(this.entities.dimension) ||
                             $(this.entities.keyword) ||
                             $(this.entities.field))) {
                        if (! $(']')) {
                            throw makeError({
                                message: 'Missing closing ] of filter.',
                                index: memo - 1
                            });
                        }
                        if (!key.is) key = new tree.Field(key);
                        return new tree.Filter(key, op, val, memo, env.filename);
                    }
                }
            },

            frame_offset: function() {
                save();
                var op, val;
                if ($(/^\[\s*frame-offset/g) &&
                    (op = $(this.entities.comparison)) &&
                    (val = $(/^\d+/)) &&
                    $(']'))  {
                        return tree.FrameOffset(op, val, memo);
                }
            },

            zoom: function() {
                save();
                var op, val;
                if ($(/^\[\s*zoom/g) &&
                    (op = $(this.entities.comparison)) &&
                    (val = $(this.entities.variable) || $(this.entities.dimension)) && $(']')) {
                        return new tree.Zoom(op, val, memo);
                } else {
                    // backtrack
                    restore();
                }
            },

            // The `block` rule is used by `ruleset`
            // It's a wrapper around the `primary` rule, with added `{}`.
            block: function() {
                var content;

                if ($('{') && (content = $(this.primary)) && $('}')) {
                    return content;
                }
            },

            // div, .class, body > p {...}
            ruleset: function() {
                var selectors = [], s, f, l, rules, filters = [];
                save();

                while (s = $(this.selector)) {
                    selectors.push(s);
                    while ($(this.comment)) {}
                    if (! $(',')) { break; }
                    while ($(this.comment)) {}
                }
                if (s) {
                    while ($(this.comment)) {}
                }

                if (selectors.length > 0 && (rules = $(this.block))) {
                    if (selectors.length === 1 &&
                        selectors[0].elements.length &&
                        selectors[0].elements[0].value === 'Map') {
                        var rs = new tree.Ruleset(selectors, rules);
                        rs.isMap = true;
                        return rs;
                    }
                    return new tree.Ruleset(selectors, rules);
                } else {
                    // Backtrack
                    restore();
                }
            },

            rule: function() {
                var name, value, c = input.charAt(i);
                save();

                if (c === '.' || c === '#') { return; }

                if (name = $(this.variable) || $(this.property)) {
                    value = $(this.value);

                    if (value && $(this.end)) {
                        return new tree.Rule(name, value, memo, env.filename);
                    } else {
                        furthest = i;
                        restore();
                    }
                }
            },

            font: function() {
                var value = [], expression = [], weight, font, e;

                while (e = $(this.entity)) {
                    expression.push(e);
                }

                value.push(new tree.Expression(expression));

                if ($(',')) {
                    while (e = $(this.expression)) {
                        value.push(e);
                        if (! $(',')) { break; }
                    }
                }
                return new tree.Value(value);
            },

            // A Value is a comma-delimited list of Expressions
            // In a Rule, a Value represents everything after the `:`,
            // and before the `;`.
            value: function() {
                var e, expressions = [];

                while (e = $(this.expression)) {
                    expressions.push(e);
                    if (! $(',')) { break; }
                }

                if (expressions.length > 1) {
                    return new tree.Value(expressions.map(function(e) {
                        return e.value[0];
                    }));
                } else if (expressions.length === 1) {
                    return new tree.Value(expressions);
                }
            },
            // A sub-expression, contained by parenthensis
            sub: function() {
                var e;

                if ($('(') && (e = $(this.expression)) && $(')')) {
                    return e;
                }
            },
            // This is a misnomer because it actually handles multiplication
            // and division.
            multiplication: function() {
                var m, a, op, operation;
                if (m = $(this.operand)) {
                    while ((op = ($('/') || $('*') || $('%'))) && (a = $(this.operand))) {
                        operation = new tree.Operation(op, [operation || m, a], memo);
                    }
                    return operation || m;
                }
            },
            addition: function() {
                var m, a, op, operation;
                if (m = $(this.multiplication)) {
                    while ((op = $(/^[-+]\s+/) || (input.charAt(i - 1) != ' ' && ($('+') || $('-')))) &&
                           (a = $(this.multiplication))) {
                        operation = new tree.Operation(op, [operation || m, a], memo);
                    }
                    return operation || m;
                }
            },

            // An operand is anything that can be part of an operation,
            // such as a Color, or a Variable
            operand: function() {
                return $(this.sub) || $(this.entity);
            },

            // Expressions either represent mathematical operations,
            // or white-space delimited Entities.  @var * 2
            expression: function() {
                var e, delim, entities = [], d;

                while (e = $(this.addition) || $(this.entity)) {
                    entities.push(e);
                }

                if (entities.length > 0) {
                    return new tree.Expression(entities);
                }
            },
            property: function() {
                var name = $(/^(([a-z][-a-z_0-9]*\/)?\*?-?[-a-z_0-9]+)\s*:/);
                if (name) return name[1];
            }
        }
    };
    return parser;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./tree":44,"underscore":74}],41:[function(require,module,exports){
(function (global){
var _ = global._ || require('underscore');
var carto = require('./index');

carto.Renderer = function Renderer(env, options) {
    this.env = env || {};
    this.options = options || {};
    this.options.mapnik_version = this.options.mapnik_version || '3.0.0';
};

/**
 * Prepare a MSS document (given as an string) into a
 * XML Style fragment (mostly useful for debugging)
 *
 * @param {String} data the mss contents as a string.
 */
carto.Renderer.prototype.renderMSS = function render(data) {
    // effects is a container for side-effects, which currently
    // are limited to FontSets.
    var env = _(this.env).defaults({
        benchmark: false,
        validation_data: false,
        effects: []
    });

    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {
        throw new Error("Could not set mapnik version to " + this.options.mapnik_version);
    }

    var output = [];
    var styles = [];

    if (env.benchmark) console.time('Parsing MSS');
    var parser = (carto.Parser(env)).parse(data);
    if (env.benchmark) console.timeEnd('Parsing MSS');

    if (env.benchmark) console.time('Rule generation');
    var rule_list = parser.toList(env);
    if (env.benchmark) console.timeEnd('Rule generation');

    if (env.benchmark) console.time('Rule inheritance');
    var rules = inheritDefinitions(rule_list, env);
    if (env.benchmark) console.timeEnd('Rule inheritance');

    if (env.benchmark) console.time('Style sort');
    var sorted = sortStyles(rules,env);
    if (env.benchmark) console.timeEnd('Style sort');

    if (env.benchmark) console.time('Total Style generation');
    for (var k = 0, rule, style_name; k < sorted.length; k++) {
        rule = sorted[k];
        style_name = 'style' + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');
        styles.push(style_name);
        var bench_name = '\tStyle "'+style_name+'" (#'+k+') toXML';
        if (env.benchmark) console.time(bench_name);
        // env.effects can be modified by this call
        output.push(carto.tree.StyleXML(style_name, rule.attachment, rule, env));
        if (env.benchmark) console.timeEnd(bench_name);
    }
    if (env.benchmark) console.timeEnd('Total Style generation');
    if (env.errors) throw env.errors;
    return output.join('\n');
};

/**
 * Prepare a MML document (given as an object) into a
 * fully-localized XML file ready for Mapnik2 consumption
 *
 * @param {String} m - the JSON file as a string.
 */
carto.Renderer.prototype.render = function render(m) {
    // effects is a container for side-effects, which currently
    // are limited to FontSets.
    var env = _(this.env).defaults({
        benchmark: false,
        validation_data: false,
        effects: [],
        ppi: 90.714
    });

    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {
        throw new Error("Could not set mapnik version to " + this.options.mapnik_version);
    }

    var output = [];

    // Transform stylesheets into definitions.
    var definitions = _(m.Stylesheet).chain()
        .map(function(s) {
            if (typeof s == 'string') {
                throw new Error("Stylesheet object is expected not a string: '" + s + "'");
            }
            // Passing the environment from stylesheet to stylesheet,
            // allows frames and effects to be maintained.
            env = _(env).extend({filename:s.id});

            var time = +new Date(),
                root = (carto.Parser(env)).parse(s.data);
            if (env.benchmark)
                console.warn('Parsing time: ' + (new Date() - time) + 'ms');
            return root.toList(env);
        })
        .flatten()
        .value();

    function appliesTo(name, classIndex) {
        return function(definition) {
            return definition.appliesTo(l.name, classIndex);
        };
    }

    // Iterate through layers and create styles custom-built
    // for each of them, and apply those styles to the layers.
    var styles, l, classIndex, rules, sorted, matching;
    for (var i = 0; i < m.Layer.length; i++) {
        l = m.Layer[i];
        styles = [];
        classIndex = {};

        if (env.benchmark) console.warn('processing layer: ' + l.id);
        // Classes are given as space-separated alphanumeric strings.
        var classes = (l['class'] || '').split(/\s+/g);
        for (var j = 0; j < classes.length; j++) {
            classIndex[classes[j]] = true;
        }
        matching = definitions.filter(appliesTo(l.name, classIndex));
        rules = inheritDefinitions(matching, env);
        sorted = sortStyles(rules, env);

        for (var k = 0, rule, style_name; k < sorted.length; k++) {
            rule = sorted[k];
            style_name = l.name + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');

            // env.effects can be modified by this call
            var styleXML = carto.tree.StyleXML(style_name, rule.attachment, rule, env);

            if (styleXML) {
                output.push(styleXML);
                styles.push(style_name);
            }
        }

        output.push(carto.tree.LayerXML(l, styles));
    }

    output.unshift(env.effects.map(function(e) {
        return e.toXML(env);
    }).join('\n'));

    var map_properties = getMapProperties(m, definitions, env);

    // Exit on errors.
    if (env.errors) throw env.errors;

    // Pass TileJSON and other custom parameters through to Mapnik XML.
    var parameters = _(m).reduce(function(memo, v, k) {
        if (!v && v !== 0) return memo;

        switch (k) {
        // Known skippable properties.
        case 'srs':
        case 'Layer':
        case 'Stylesheet':
            break;
        // Non URL-bound TileJSON properties.
        case 'bounds':
        case 'center':
        case 'minzoom':
        case 'maxzoom':
        case 'version':
            memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            break;
        // Properties that require CDATA.
        case 'name':
        case 'description':
        case 'legend':
        case 'attribution':
        case 'template':
            memo.push('  <Parameter name="' + k + '"><![CDATA[' + v + ']]></Parameter>');
            break;
        // Mapnik image format.
        case 'format':
            memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            break;
        // Mapnik interactivity settings.
        case 'interactivity':
            memo.push('  <Parameter name="interactivity_layer">' + v.layer + '</Parameter>');
            memo.push('  <Parameter name="interactivity_fields">' + v.fields + '</Parameter>');
            break;
        // Support any additional scalar properties.
        default:
            if ('string' === typeof v) {
                memo.push('  <Parameter name="' + k + '"><![CDATA[' + v + ']]></Parameter>');
            } else if ('number' === typeof v) {
                memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            } else if ('boolean' === typeof v) {
                memo.push('  <Parameter name="' + k + '">' + v + '</Parameter>');
            }
            break;
        }
        return memo;
    }, []);
    if (parameters.length) output.unshift(
        '<Parameters>\n' +
        parameters.join('\n') +
        '\n</Parameters>\n'
    );

    var properties = _(map_properties).map(function(v) { return ' ' + v; }).join('');

    output.unshift(
        '<?xml version="1.0" ' +
        'encoding="utf-8"?>\n' +
        '<!DOCTYPE Map[]>\n' +
        '<Map' + properties +'>\n');
    output.push('</Map>');
    return output.join('\n');
};

/**
 * This function currently modifies 'current'
 * @param {Array}  current  current list of rules
 * @param {Object} definition a Definition object to add to the rules
 * @param {Object} byFilter an object/dictionary of existing filters. This is
 * actually keyed `attachment->filter`
 * @param {Object} env the current environment
*/
function addRules(current, definition, byFilter, env) {
    var newFilters = definition.filters,
        newRules = definition.rules,
        updatedFilters, clone, previous;

    // The current definition might have been split up into
    // multiple definitions already.
    for (var k = 0; k < current.length; k++) {
        updatedFilters = current[k].filters.cloneWith(newFilters);
        if (updatedFilters) {
            previous = byFilter[updatedFilters];
            if (previous) {
                // There's already a definition with those exact
                // filters. Add the current definitions' rules
                // and stop processing it as the existing rule
                // has already gone down the inheritance chain.
                previous.addRules(newRules);
            } else {
                clone = current[k].clone(updatedFilters);
                // Make sure that we're only maintaining the clone
                // when we did actually add rules. If not, there's
                // no need to keep the clone around.
                if (clone.addRules(newRules)) {
                    // We inserted an element before this one, so we need
                    // to make sure that in the next loop iteration, we're
                    // not performing the same task for this element again,
                    // hence the k++.
                    byFilter[updatedFilters] = clone;
                    current.splice(k, 0, clone);
                    k++;
                }
            }
        } else if (updatedFilters === null) {
            // if updatedFilters is null, then adding the filters doesn't
            // invalidate or split the selector, so we addRules to the
            // combined selector

            // Filters can be added, but they don't change the
            // filters. This means we don't have to split the
            // definition.
            //
            // this is cloned here because of shared classes, see
            // sharedclass.mss
            current[k] = current[k].clone();
            current[k].addRules(newRules);
        }
        // if updatedFeatures is false, then the filters split the rule,
        // so they aren't the same inheritance chain
    }
    return current;
}

/**
 * Apply inherited styles from their ancestors to them.
 *
 * called either once per render (in the case of mss) or per layer
 * (for mml)
 *
 * @param {Object} definitions - a list of definitions objects
 *   that contain .rules
 * @param {Object} env - the environment
 * @return {Array<Array>} an array of arrays is returned,
 *   in which each array refers to a specific attachment
 */
function inheritDefinitions(definitions, env) {
    var inheritTime = +new Date();
    // definitions are ordered by specificity,
    // high (index 0) to low
    var byAttachment = {},
        byFilter = {};
    var result = [];
    var current, previous, attachment;

    // Evaluate the filters specified by each definition with the given
    // environment to correctly resolve variable references
    definitions.forEach(function(d) {
        d.filters.ev(env);
    });

    for (var i = 0; i < definitions.length; i++) {

        attachment = definitions[i].attachment;
        current = [definitions[i]];

        if (!byAttachment[attachment]) {
            byAttachment[attachment] = [];
            byAttachment[attachment].attachment = attachment;
            byFilter[attachment] = {};
            result.push(byAttachment[attachment]);
        }

        // Iterate over all subsequent rules.
        for (var j = i + 1; j < definitions.length; j++) {
            if (definitions[j].attachment === attachment) {
                // Only inherit rules from the same attachment.
                current = addRules(current, definitions[j], byFilter[attachment], env);
            }
        }

        for (var k = 0; k < current.length; k++) {
            byFilter[attachment][current[k].filters] = current[k];
            byAttachment[attachment].push(current[k]);
        }
    }

    if (env.benchmark) console.warn('Inheritance time: ' + ((new Date() - inheritTime)) + 'ms');

    return result;

}

// Sort styles by the minimum index of their rules.
// This sorts a slice of the styles, so it returns a sorted
// array but does not change the input.
function sortStylesIndex(a, b) { return b.index - a.index; }
function sortStyles(styles, env) {
    for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        style.index = Infinity;
        for (var b = 0; b < style.length; b++) {
            var rules = style[b].rules;
            for (var r = 0; r < rules.length; r++) {
                var rule = rules[r];
                if (rule.index < style.index) {
                    style.index = rule.index;
                }
            }
        }
    }

    var result = styles.slice();
    result.sort(sortStylesIndex);
    return result;
}

/**
 * Find a rule like Map { background-color: #fff; },
 * if any, and return a list of properties to be inserted
 * into the <Map element of the resulting XML. Translates
 * properties of the mml object at `m` directly into XML
 * properties.
 *
 * @param {Object} m the mml object.
 * @param {Array} definitions the output of toList.
 * @param {Object} env
 * @return {String} rendered properties.
 */
function getMapProperties(m, definitions, env) {
    var rules = {};
    var symbolizers = carto.tree.Reference.data.symbolizers.map;

    _(m).each(function(value, key) {
        if (key in symbolizers) rules[key] = key + '="' + value + '"';
    });

    definitions.filter(function(r) {
        return r.elements.join('') === 'Map';
    }).forEach(function(r) {
        for (var i = 0; i < r.rules.length; i++) {
            var key = r.rules[i].name;
            if (!(key in symbolizers)) {
                env.error({
                    message: 'Rule ' + key + ' not allowed for Map.',
                    index: r.rules[i].index
                });
            }
            rules[key] = r.rules[i].ev(env).toXML(env);
        }
    });
    return rules;
}

module.exports = carto;
module.exports.addRules = addRules;
module.exports.inheritDefinitions = inheritDefinitions;
module.exports.sortStyles = sortStyles;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./index":39,"underscore":74}],42:[function(require,module,exports){
(function (global){
(function(carto) {
var tree = require('./tree');
var _ = global._ || require('underscore');


function CartoCSS(style, options) {
  this.options = options || {};
  this.imageURLs = [];
  if(style) {
    this.setStyle(style);
  }
}

CartoCSS.Layer = function(shader, options) {
  this.options = options;
  this.shader = shader;
};


CartoCSS.Layer.prototype = {

  fullName: function() {
    return this.shader.attachment;
  },

  name: function() {
    return this.fullName().split('::')[0];
  },

  // frames this layer need to be rendered
  frames: function() {
    return this.shader.frames;
  },

  attachment: function() {
    return this.fullName().split('::')[1];
  },

  eval: function(prop) {
    var p = this.shader[prop];
    if (!p || !p.style) return;
    return p.style({}, { zoom: 0, 'frame-offset': 0 });
  },

  /*
   * `props`: feature properties
   * `context`: rendering properties, i.e zoom
   */
  getStyle: function(props, context) {
    var style = {};
    for(var i in this.shader) {
      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {
        style[i] = this.shader[i].style(props, context);
      }
    }
    return style;
  },

  /**
   * return the symbolizers that need to be rendered with 
   * this style. The order is the rendering order.
   * @returns a list with 3 possible values 'line', 'marker', 'polygon'
   */
  getSymbolizers: function() {
    return this.shader.symbolizers;
  },

  /**
   * returns if the style varies with some feature property.
   * Useful to optimize rendering
   */
  isVariable: function() {
    for(var i in this.shader) {
      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {
        if (!this.shader[i].constant) {
          return true;
        }
      }
    }
    return false;
  },

  getShader: function() {
    return this.shader;
  },

  /**
   * returns true if a feature needs to be rendered
   */
  filter: function(featureType, props, context) {
    for(var i in this.shader) {
     var s = this.shader[i](props, context);
     if(s) {
       return true;
     }
    }
    return false;
  },

  //
  // given a geoemtry type returns the transformed one acording the CartoCSS
  // For points there are two kind of types: point and sprite, the first one 
  // is a circle, second one is an image sprite
  //
  // the other geometry types are the same than geojson (polygon, linestring...)
  //
  transformGeometry: function(type) {
    return type;
  },

  transformGeometries: function(geojson) {
    return geojson;
  }

};

CartoCSS.prototype = {

  setStyle: function(style) {
    var layers = this.parse(style);
    if(!layers) {
      throw new Error(this.parse_env.errors);
    }
    this.layers = layers.map(function(shader) {
        return new CartoCSS.Layer(shader);
    });
  },

  getLayers: function() {
    return this.layers;
  },

  getDefault: function() {
    return this.findLayer({ attachment: '__default__' });
  },

  findLayer: function(where) {
    return _.find(this.layers, function(value) {
      for (var key in where) {
        var v = value[key];
        if (typeof(v) === 'function') {
          v = v.call(value);
        }
        if (where[key] !== v) return false;
      }
      return true;
    });
  },

  _createFn: function(ops) {
    var body = ops.join('\n');
    if(this.options.debug) console.log(body);
    return Function("data","ctx", "var _value = null; " +  body + "; return _value; ");
  },

  _compile: function(shader) {
    if(typeof shader === 'string') {
        shader = eval("(function() { return " + shader +"; })()");
    }
    this.shader_src = shader;
    for(var attr in shader) {
        var c = mapper[attr];
        if(c) {
            this.compiled[c] = eval("(function() { return shader[attr]; })();");
        }
    }
  },
  getImageURLs: function(){
    return this.imageURLs;
  },

  parse: function(cartocss) {
    var parse_env = {
      frames: [],
      errors: [],
      error: function(obj) {
        this.errors.push(obj);
      }
    };
    this.parse_env = parse_env;

    var ruleset = null;
    try {
      ruleset = (new carto.Parser(parse_env)).parse(cartocss);
    } catch(e) {
      // add the style.mss string to match the response from the server
      parse_env.errors.push(e.message);
      return;
    }
    if(ruleset) {

      function defKey(def) {
        return def.elements[0] + "::" + def.attachment;
      }
      var defs = ruleset.toList(parse_env);
      defs.reverse();
      // group by elements[0].value::attachment
      var layers = {};
      for(var i = 0; i < defs.length; ++i) {
        var def = defs[i];
        var key = defKey(def);
        var layer = layers[key] = (layers[key] || {
          symbolizers: []
        });
        for(var u = 0; u<def.rules.length; u++){
            if(def.rules[u].name === "marker-file" || def.rules[u].name === "point-file"){
                var value = def.rules[u].value.value[0].value[0].value.value;
                this.imageURLs.push(value);
            }
        } 
        layer.frames = [];
        layer.zoom = tree.Zoom.all;
        var props = def.toJS(parse_env);
        if (this.options.debug) console.log("props", props);
        for(var v in props) {
          var lyr = layer[v] = layer[v] || {
            constant: false,
            symbolizer: null,
            js: [],
            index: 0
          };
          // build javascript statements
          lyr.js.push(props[v].map(function(a) { return a.js; }).join('\n'));
          // get symbolizer for prop
          lyr.symbolizer = _.first(props[v].map(function(a) { return a.symbolizer; }));
          // serach the max index to know rendering order
          lyr.index = _.max(props[v].map(function(a) { return a.index; }).concat(lyr.index));
          lyr.constant = !_.any(props[v].map(function(a) { return !a.constant; }));
        }
      }

      var ordered_layers = [];
      if (this.options.debug) console.log(layers);

      var done = {};
      for(var i = 0; i < defs.length; ++i) {
        var def = defs[i];
        var k = defKey(def);
        var layer = layers[k];
        if(!done[k]) {
          if(this.options.debug) console.log("**", k);
          for(var prop in layer) {
            if (prop !== 'zoom' && prop !== 'frames' && prop !== 'symbolizers') {
              if(this.options.debug) console.log("*", prop);
              layer[prop].style = this._createFn(layer[prop].js);
              layer.symbolizers.push(layer[prop].symbolizer);
              layer.symbolizers = _.uniq(layer.symbolizers);
            }
          }
          layer.attachment = k;
          ordered_layers.push(layer);
          done[k] = true;
        }
        layer.zoom |= def.zoom;
        layer.frames.push(def.frame_offset);
      }

      // uniq the frames
      for(i = 0; i < ordered_layers.length; ++i) {
        ordered_layers[i].frames = _.uniq(ordered_layers[i].frames);
      }

      return ordered_layers;

    }
    return null;
  }
};


carto.RendererJS = function (options) {
    this.options = options || {};
    this.options.mapnik_version = this.options.mapnik_version || 'latest';
};

// Prepare a javascript object which contains the layers
carto.RendererJS.prototype.render = function render(cartocss, callback) {
    var reference = require('./torque-reference');
    tree.Reference.setData(reference.version.latest);
    return new CartoCSS(cartocss, this.options);
}

if(typeof(module) !== 'undefined') {
  module.exports = carto.RendererJS;
}


})(require('../carto'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../carto":39,"./torque-reference":43,"./tree":44,"underscore":74}],43:[function(require,module,exports){
var _mapnik_reference_latest = {
    "version": "2.1.1",
    "style": {
        "filter-mode": {
            "type": [
                "all",
                "first"
            ],
            "doc": "Control the processing behavior of Rule filters within a Style. If 'all' is used then all Rules are processed sequentially independent of whether any previous filters matched. If 'first' is used then it means processing ends after the first match (a positive filter evaluation) and no further Rules in the Style are processed ('first' is usually the default for CSS implementations on top of Mapnik to simplify translation from CSS to Mapnik XML)",
            "default-value": "all",
            "default-meaning": "All Rules in a Style are processed whether they have filters or not and whether or not the filter conditions evaluate to true."
        },
        "image-filters": {
            "css": "image-filters",
            "default-value": "none",
            "default-meaning": "no filters",
            "type": "functions",
            "functions": [
                ["agg-stack-blur", 2],
                ["emboss", 0],
                ["blur", 0],
                ["gray", 0],
                ["sobel", 0],
                ["edge-detect", 0],
                ["x-gradient", 0],
                ["y-gradient", 0],
                ["invert", 0],
                ["sharpen", 0],
                ["colorize-alpha", -1],
                ["color-to-alpha", 1],
                ["scale-hsla", 8]
            ],
            "doc": "A list of image filters."
        },
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": ["clear",
                "src",
                "dst",
                "src-over",
                "source-over", // added for torque
                "dst-over",
                "src-in",
                "dst-in",
                "src-out",
                "dst-out",
                "src-atop",
                "dst-atop",
                "xor",
                "plus",
                "minus",
                "multiply",
                "screen",
                "overlay",
                "darken",
                "lighten",
                "lighter", // added for torque
                "color-dodge",
                "color-burn",
                "hard-light",
                "soft-light",
                "difference",
                "exclusion",
                "contrast",
                "invert",
                "invert-rgb",
                "grain-merge",
                "grain-extract",
                "hue",
                "saturation",
                "color",
                "value"
            ]
        },
        "opacity": {
            "css": "opacity",
            "type": "float",
            "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
            "default-value": 1,
            "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
        }
    },
    "layer" : {
        "name": {
            "default-value": "",
            "type":"string",
            "required" : true,
            "default-meaning": "No layer name has been provided",
            "doc": "The name of a layer. Can be anything you wish and is not strictly validated, but ideally unique  in the map"
        },
        "srs": {
            "default-value": "",
            "type":"string",
            "default-meaning": "No srs value is provided and the value will be inherited from the Map's srs",
            "doc": "The spatial reference system definition for the layer, aka the projection. Can either be a proj4 literal string like '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' or, if the proper proj4 epsg/nad/etc identifier files are installed, a string that uses an id like: '+init=epsg:4326'"
        },
        "status": {
            "default-value": true,
            "type":"boolean",
            "default-meaning": "This layer will be marked as active and available for processing",
            "doc": "A property that can be set to false to disable this layer from being processed"
        },
        "minzoom": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "The layer will be visible at the minimum possible scale",
            "doc": "The minimum scale denominator that this layer will be visible at. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "maxzoom": {
            "default-value": "1.79769e+308",
            "type":"float",
            "default-meaning": "The layer will be visible at the maximum possible scale",
            "doc": "The maximum scale denominator that this layer will be visible at. The default is the numeric limit of the C++ double type, which may vary slightly by system, but is likely a massive number like 1.79769e+308 and ensures that this layer will always be visible unless the value is reduced. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "queryable": {
            "default-value": false,
            "type":"boolean",
            "default-meaning": "The layer will not be available for the direct querying of data values",
            "doc": "This property was added for GetFeatureInfo/WMS compatibility and is rarely used. It is off by default meaning that in a WMS context the layer will not be able to be queried unless the property is explicitly set to true"
        },
        "clear-label-cache": {
            "default-value": false,
            "type":"boolean",
            "default-meaning": "The renderer's collision detector cache (used for avoiding duplicate labels and overlapping markers) will not be cleared immediately before processing this layer",
            "doc": "This property, by default off, can be enabled to allow a user to clear the collision detector cache before a given layer is processed. This may be desirable to ensure that a given layers data shows up on the map even if it normally would not because of collisions with previously rendered labels or markers"
        },
        "group-by": {
            "default-value": "",
            "type":"string",
            "default-meaning": "No special layer grouping will be used during rendering",
            "doc": "https://github.com/mapnik/mapnik/wiki/Grouped-rendering"
        },
        "buffer-size": {
            "default-value": "0",
            "type":"float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "maximum-extent": {
            "default-value": "none",
            "type":"bbox",
            "default-meaning": "No clipping extent will be used",
            "doc": "An extent to be used to limit the bounds used to query this specific layer data during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Layer."
        }
    },
    "symbolizers" : {
        "*": {
            "image-filters": {
                "css": "image-filters",
                "default-value": "none",
                "default-meaning": "no filters",
                "type": "functions",
                "functions": [
                    ["agg-stack-blur", 2],
                    ["emboss", 0],
                    ["blur", 0],
                    ["gray", 0],
                    ["sobel", 0],
                    ["edge-detect", 0],
                    ["x-gradient", 0],
                    ["y-gradient", 0],
                    ["invert", 0],
                    ["sharpen", 0],
                    ["colorize-alpha", -1],
                    ["color-to-alpha", 1],
                    ["scale-hsla", 8]
                ],
                "doc": "A list of image filters."
            },
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "source-over", // added for torque
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "lighter", // added for torque
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "map": {
            "background-color": {
                "css": "background-color",
                "default-value": "none",
                "default-meaning": "transparent",
                "type": "color",
                "doc": "Map Background color"
            },
            "background-image": {
                "css": "background-image",
                "type": "uri",
                "default-value": "",
                "default-meaning": "transparent",
                "doc": "An image that is repeated below all features on a map as a background.",
                "description": "Map Background image"
            },
            "srs": {
                "css": "srs",
                "type": "string",
                "default-value": "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
                "default-meaning": "The proj4 literal of EPSG:4326 is assumed to be the Map's spatial reference and all data from layers within this map will be plotted using this coordinate system. If any layers do not declare an srs value then they will be assumed to be in the same srs as the Map and not transformations will be needed to plot them in the Map's coordinate space",
                "doc": "Map spatial reference (proj4 string)"
            },
            "buffer-size": {
                "css": "buffer-size",
                "default-value": "0",
                "type":"float",
                "default-meaning": "No buffer will be used",
                "doc": "Extra tolerance around the map (in pixels) used to ensure labels crossing tile boundaries are equally rendered in each tile (e.g. cut in each tile). Not intended to be used in combination with \"avoid-edges\"."
            },
            "maximum-extent": {
                "css": "",
                "default-value": "none",
                "type":"bbox",
                "default-meaning": "No clipping extent will be used",
                "doc": "An extent to be used to limit the bounds used to query all layers during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Map."
            },
            "base": {
                "css": "base",
                "default-value": "",
                "default-meaning": "This base path defaults to an empty string meaning that any relative paths to files referenced in styles or layers will be interpreted relative to the application process.",
                "type": "string",
                "doc": "Any relative paths used to reference files will be understood as relative to this directory path if the map is loaded from an in memory object rather than from the filesystem. If the map is loaded from the filesystem and this option is not provided it will be set to the directory of the stylesheet."
            },
            "paths-from-xml": {
                "css": "",
                "default-value": true,
                "default-meaning": "Paths read from XML will be interpreted from the location of the XML",
                "type": "boolean",
                "doc": "value to control whether paths in the XML will be interpreted from the location of the XML or from the working directory of the program that calls load_map()"
            },
            "minimum-version": {
                "css": "",
                "default-value": "none",
                "default-meaning": "Mapnik version will not be detected and no error will be thrown about compatibility",
                "type": "string",
                "doc": "The minumum Mapnik version (e.g. 0.7.2) needed to use certain functionality in the stylesheet"
            },
            "font-directory": {
                "css": "font-directory",
                "type": "uri",
                "default-value": "none",
                "default-meaning": "No map-specific fonts will be registered",
                "doc": "Path to a directory which holds fonts which should be registered when the Map is loaded (in addition to any fonts that may be automatically registered)."
            }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon"
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque"
            },
            "gamma": {
                "css": "polygon-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon edges"
            },
            "gamma-method": {
                "css": "polygon-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "clip": {
                "css": "polygon-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line"
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels"
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": [
                    "miter",
                    "round",
                    "bevel"
                ],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": [
                    "butt",
                    "round",
                    "square"
                ],
                "doc": "The display of line endings"
            },
            "stroke-gamma": {
                "css": "line-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of stroke line"
            },
            "stroke-gamma-method": {
                "css": "line-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "stroke-dasharray": {
                "css": "line-dasharray",
                "type": "numbers",
                "doc": "A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-dashoffset": {
                "css": "line-dash-offset",
                "type": "numbers",
                "doc": "valid parameter but not currently used in renderers (only exists for experimental svg support in Mapnik which is not yet enabled)",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-miterlimit": {
                "css": "line-miterlimit",
                "type": "float",
                "doc": "The limit on the ratio of the miter length to the stroke-width. Used to automatically convert miter joins to bevel joins for sharp angles to avoid the miter extending beyond the thickness of the stroking path. Normally will not need to be set, but a larger value can sometimes help avoid jaggy artifacts.",
                "default-value": 4.0,
                "default-meaning": "Will auto-convert miters to bevel line joins when theta is less than 29 degrees as per the SVG spec: 'miterLength / stroke-width = 1 / sin ( theta / 2 )'"
            },
            "clip": {
                "css": "line-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "offset": {
                "css": "line-offset",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no offset",
                "doc": "Offsets a line a number of pixels parallel to its actual path. Postive values move the line left, negative values move it right (relative to the directionality of the line)."
            },
            "rasterizer": {
                "css": "line-rasterizer",
                "type": [
                    "full",
                    "fast"
                ],
                "default-value": "full",
                "doc": "Exposes an alternate AGG rendering method that sacrifices some accuracy for speed."
            },
            "geometry-transform": {
                "css": "line-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri"
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "placement": {
                "css": "marker-placement",
                "type": [
                    "point",
                    "line",
                    "interior"
                ],
                "default-value": "point",
                "default-meaning": "Place markers at the center point (centroid) of the geometry",
                "doc": "Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior"
            },
            "multi-policy": {
                "css": "marker-multi-policy",
                "type": [
                    "each",
                    "whole",
                    "largest"
                ],
                "default-value": "each",
                "default-meaning": "If a feature contains multiple geometries and the placement type is either point or interior then a marker will be rendered for each",
                "doc": "A special setting to allow the user to control rendering behavior for 'multi-geometries' (when a feature contains multiple geometries). This setting does not apply to markers placed along lines. The 'each' policy is default and means all geometries will get a marker. The 'whole' policy means that the aggregate centroid between all geometries will be used. The 'largest' policy means that only the largest (by bounding box areas) feature will get a rendered marker (this is how text labeling behaves by default)."
            },
            "marker-type": {
                "css": "marker-type",
                "type": [
                    "arrow",
                    "ellipse",
                    "rectangle"
                ],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width)"
            },
            "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "float",
                "expression": true
            },
            "height": {
                "css": "marker-height",
                "default-value": 10,
                "doc": "The height of the marker, if using one of the default types.",
                "type": "float",
                "expression": true
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color"
            },
            "allow-overlap": {
                "css": "marker-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping markers are shown or hidden.",
                "default-meaning": "Do not allow makers to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "marker-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "spacing": {
                "css": "marker-spacing",
                "doc": "Space between repeated labels",
                "default-value": 100,
                "type": "float"
            },
            "max-error": {
                "css": "marker-max-error",
                "type": "float",
                "default-value": 0.2,
                "doc": "The maximum difference between actual marker placement and the marker-spacing parameter. Setting a high value can allow the renderer to try to resolve placement conflicts with other symbolizers."
            },
            "transform": {
                "css": "marker-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "clip": {
                "css": "marker-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "marker-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "marker-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "marker-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "shield": {
            "name": {
                "css": "shield-name",
                "type": "string",
                "expression": true,
                "serialization": "content",
                "doc": "Value to use for a shield\"s text label. Data columns are specified using brackets like [column_name]"
            },
            "file": {
                "css": "shield-file",
                "required": true,
                "type": "uri",
                "default-value": "none",
                "doc": "Image file to render behind the shield text"
            },
            "face-name": {
                "css": "shield-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to use for the shield text",
                "default-value": "",
                "required": true
            },
            "unlock-image": {
                "css": "shield-unlock-image",
                "type": "boolean",
                "doc": "This parameter should be set to true if you are trying to position text beside rather than on top of the shield image",
                "default-value": false,
                "default-meaning": "text alignment relative to the shield image uses the center of the image as the anchor for text positioning."
            },
            "size": {
                "css": "shield-size",
                "type": "float",
                "doc": "The size of the shield text in pixels"
            },
            "fill": {
                "css": "shield-fill",
                "type": "color",
                "doc": "The color of the shield text"
            },
            "placement": {
                "css": "shield-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "How this shield should be placed. Point placement attempts to place it on top of points, line places along lines multiple times per feature, vertex places on the vertexes of polygons, and interior attempts to place inside of polygons."
            },
            "avoid-edges": {
                "css": "shield-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "type": "boolean",
                "default-value": false
            },
            "allow-overlap": {
                "css": "shield-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping shields are shown or hidden.",
                "default-meaning": "Do not allow shields to overlap with other map elements already placed."
            },
            "minimum-distance": {
                "css": "shield-min-distance",
                "type": "float",
                "default-value": 0,
                "doc": "Minimum distance to the next shield symbol, not necessarily the same shield."
            },
            "spacing": {
                "css": "shield-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "The spacing between repeated occurrences of the same shield on a line"
            },
            "minimum-padding": {
                "css": "shield-min-padding",
                "default-value": 0,
                "doc": "Determines the minimum amount of padding that a shield gets relative to other shields",
                "type": "float"
            },
            "wrap-width": {
                "css": "shield-wrap-width",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Length of a chunk of text in characters before wrapping text"
            },
            "wrap-before": {
                "css": "shield-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "shield-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long names."
            },
            "halo-fill": {
                "css": "shield-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "shield-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "character-spacing": {
                "css": "shield-character-spacing",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Horizontal spacing between characters (in pixels). Currently works for point placement only, not line placement."
            },
            "line-spacing": {
                "css": "shield-line-spacing",
                "doc": "Vertical spacing between lines of multiline labels (in pixels)",
                "type": "unsigned"
            },
            "dx": {
                "css": "shield-text-dx",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "shield-text-dy",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "shield-dx": {
                "css": "shield-dx",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "shield-dy": {
                "css": "shield-dy",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "opacity": {
                "css": "shield-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the image used for the shield",
                "default-value": 1
            },
            "text-opacity": {
                "css": "shield-text-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the text placed on top of the shield",
                "default-value": 1
            },
            "horizontal-alignment": {
                "css": "shield-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The shield's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "vertical-alignment": {
                "css": "shield-vertical-alignment",
                "type": [
                    "top",
                    "middle",
                    "bottom",
                    "auto"
                ],
                "doc": "The shield's vertical alignment from its centerpoint",
                "default-value": "middle"
            },
            "text-transform": {
                "css": "shield-text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "justify-alignment": {
                "css": "shield-justify-alignment",
                "type": [
                    "left",
                    "center",
                    "right",
                    "auto"
                ],
                "doc": "Define how text in a shield's label is justified",
                "default-value": "auto"
            },
            "clip": {
                "css": "shield-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "shield-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line-pattern": {
            "file": {
                "css": "line-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "An image file to be repeated and warped along a line"
            },
            "clip": {
                "css": "line-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "line-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "polygon-pattern": {
            "file": {
                "css": "polygon-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "Image to use as a repeated pattern fill within a polygon"
            },
            "alignment": {
                "css": "polygon-pattern-alignment",
                "type": [
                    "local",
                    "global"
                ],
                "default-value": "local",
                "doc": "Specify whether to align pattern fills to the layer or to the map."
            },
            "gamma": {
                "css": "polygon-pattern-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon pattern edges"
            },
            "opacity": {
                "css": "polygon-pattern-opacity",
                "type": "float",
                "doc": "(Default 1.0) - Apply an opacity level to the image used for the pattern",
                "default-value": 1,
                "default-meaning": "The image is rendered without modifications"
            },
            "clip": {
                "css": "polygon-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "raster": {
            "opacity": {
                "css": "raster-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float",
                "doc": "The opacity of the raster symbolizer on top of other symbolizers."
            },
            "filter-factor": {
                "css": "raster-filter-factor",
                "default-value": -1,
                "default-meaning": "Allow the datasource to choose appropriate downscaling.",
                "type": "float",
                "doc": "This is used by the Raster or Gdal datasources to pre-downscale images using overviews. Higher numbers can sometimes cause much better scaled image output, at the cost of speed."
            },
            "scaling": {
                "css": "raster-scaling",
                "type": [
                    "near",
                    "fast",
                    "bilinear",
                    "bilinear8",
                    "bicubic",
                    "spline16",
                    "spline36",
                    "hanning",
                    "hamming",
                    "hermite",
                    "kaiser",
                    "quadric",
                    "catrom",
                    "gaussian",
                    "bessel",
                    "mitchell",
                    "sinc",
                    "lanczos",
                    "blackman"
                ],
                "default-value": "near",
                "doc": "The scaling algorithm used to making different resolution versions of this raster layer. Bilinear is a good compromise between speed and accuracy, while lanczos gives the highest quality."
            },
            "mesh-size": {
                "css": "raster-mesh-size",
                "default-value": 16,
                "default-meaning": "Reprojection mesh will be 1/16 of the resolution of the source image",
                "type": "unsigned",
                "doc": "A reduced resolution mesh is used for raster reprojection, and the total image size is divided by the mesh-size to determine the quality of that mesh. Values for mesh-size larger than the default will result in faster reprojection but might lead to distortion."
            },
            "comp-op": {
                "css": "raster-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "allow-overlap": {
                "css": "point-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping points are shown or hidden.",
                "default-meaning": "Do not allow points to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "point-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            },
            "placement": {
                "css": "point-placement",
                "type": [
                    "centroid",
                    "interior"
                ],
                "doc": "How this point should be placed. Centroid calculates the geometric center of a polygon, which can be outside of it, while interior always places inside of a polygon.",
                "default-value": "centroid"
            },
            "transform": {
                "css": "point-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "comp-op": {
                "css": "point-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "text": {
            "name": {
                "css": "text-name",
                "type": "string",
                "expression": true,
                "required": true,
                "default-value": "",
                "serialization": "content",
                "doc": "Value to use for a text label. Data columns are specified using brackets like [column_name]"
            },
            "face-name": {
                "css": "text-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to render a label in",
                "required": true
            },
            "size": {
                "css": "text-size",
                "type": "float",
                "default-value": 10,
                "doc": "Text size in pixels"
            },
            "text-ratio": {
                "css": "text-ratio",
                "doc": "Define the amount of text (of the total) present on successive lines when wrapping occurs",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-width": {
                "css": "text-wrap-width",
                "doc": "Length of a chunk of text in characters before wrapping text",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-before": {
                "css": "text-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "text-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long text."
            },
            "spacing": {
                "css": "text-spacing",
                "type": "unsigned",
                "doc": "Distance between repeated text labels on a line (aka. label-spacing)"
            },
            "character-spacing": {
                "css": "text-character-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "Horizontal spacing adjustment between characters in pixels"
            },
            "line-spacing": {
                "css": "text-line-spacing",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Vertical spacing adjustment between lines in pixels"
            },
            "label-position-tolerance": {
                "css": "text-label-position-tolerance",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Allows the label to be displaced from its ideal position by a number of pixels (only works with placement:line)"
            },
            "max-char-angle-delta": {
                "css": "text-max-char-angle-delta",
                "type": "float",
                "default-value": "22.5",
                "doc": "The maximum angle change, in degrees, allowed between adjacent characters in a label. This value internally is converted to radians to the default is 22.5*math.pi/180.0. The higher the value the fewer labels will be placed around around sharp corners."
            },
            "fill": {
                "css": "text-fill",
                "doc": "Specifies the color for the text",
                "default-value": "#000000",
                "type": "color"
            },
            "opacity": {
                "css": "text-opacity",
                "doc": "A number from 0 to 1 specifying the opacity for the text",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "type": "float"
            },
            "halo-fill": {
                "css": "text-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "text-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "dx": {
                "css": "text-dx",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "text-dy",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "vertical-alignment": {
                "css": "text-vertical-alignment",
                "type": [
                  "top",
                  "middle",
                  "bottom",
                  "auto"
                ],
                "doc": "Position of label relative to point position.",
                "default-value": "auto",
                "default-meaning": "Default affected by value of dy; \"bottom\" for dy>0, \"top\" for dy<0."
            },
            "avoid-edges": {
                "css": "text-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "default-value": false,
                "type": "boolean"
            },
            "minimum-distance": {
                "css": "text-min-distance",
                "doc": "Minimum permitted distance to the next text symbolizer.",
                "type": "float"
            },
            "minimum-padding": {
                "css": "text-min-padding",
                "doc": "Determines the minimum amount of padding that a text symbolizer gets relative to other text",
                "type": "float"
            },
            "minimum-path-length": {
                "css": "text-min-path-length",
                "type": "float",
                "default-value": 0,
                "default-meaning": "place labels on all paths",
                "doc": "Place labels only on paths longer than this value."
            },
            "allow-overlap": {
                "css": "text-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping text is shown or hidden.",
                "default-meaning": "Do not allow text to overlap with other text - overlapping markers will not be shown."
            },
            "orientation": {
                "css": "text-orientation",
                "type": "float",
                "expression": true,
                "doc": "Rotate the text."
            },
            "placement": {
                "css": "text-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "Control the style of placement of a point versus the geometry it is attached to."
            },
            "placement-type": {
                "css": "text-placement-type",
                "doc": "Re-position and/or re-size text to avoid overlaps. \"simple\" for basic algorithm (using text-placements string,) \"dummy\" to turn this feature off.",
                "type": [
                    "dummy",
                    "simple"
                ],
                "default-value": "dummy"
            },
            "placements": {
                "css": "text-placements",
                "type": "string",
                "default-value": "",
                "doc": "If \"placement-type\" is set to \"simple\", use this \"POSITIONS,[SIZES]\" string. An example is `text-placements: \"E,NE,SE,W,NW,SW\";` "
            },
            "text-transform": {
                "css": "text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "horizontal-alignment": {
                "css": "text-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The text's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "justify-alignment": {
                "css": "text-align",
                "type": [
                    "left",
                    "right",
                    "center",
                    "auto"
                ],
                "doc": "Define how text is justified",
                "default-value": "auto",
                "default-meaning": "Auto alignment means that text will be centered by default except when using the `placement-type` parameter - in that case either right or left justification will be used automatically depending on where the text could be fit given the `text-placements` directives"
            },
            "clip": {
                "css": "text-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "text-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "building": {
            "fill": {
                "css": "building-fill",
                "default-value": "#FFFFFF",
                "doc": "The color of the buildings walls.",
                "type": "color"
            },
            "fill-opacity": {
                "css": "building-fill-opacity",
                "type": "float",
                "doc": "The opacity of the building as a whole, including all walls.",
                "default-value": 1
            },
            "height": {
                "css": "building-height",
                "doc": "The height of the building in pixels.",
                "type": "float",
                "expression": true,
                "default-value": "0"
            }
        },
        "torque": {
          "-torque-clear-color": {
              "css": "-torque-clear-color",
              "type": "color",
              "default-value": "rgba(255, 255, 255, 0)",
              "default-meaning": "full clear",
              "doc": "color used to clear canvas on each frame"
          },
          "-torque-frame-count": {
              "css": "-torque-frame-count",
              "default-value": "128",
              "type":"float",
              "default-meaning": "the data is broken into 128 time frames",
              "doc": "Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used."
          },
          "-torque-resolution": {
              "css": "-torque-resolution",
              "default-value": "2",
              "type":"float",
              "default-meaning": "",
              "doc": "Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2"
          },
          "-torque-animation-duration": {
              "css": "-torque-animation-duration",
              "default-value": "30",
              "type":"float",
              "default-meaning": "the animation lasts 30 seconds",
              "doc": "Animation duration in seconds"
          },
          "-torque-aggregation-function": {
              "css": "-torque-aggregation-function",
              "default-value": "count(cartodb_id)",
              "type": "string",
              "default-meaning": "the value for each cell is the count of points in that cell",
              "doc": "A function used to calculate a value from the aggregate data for each cell. See -torque-resolution"
          },
          "-torque-time-attribute": {
              "css": "-torque-time-attribute",
              "default-value": "time",
              "type": "string",
              "default-meaning": "the data column in your table that is of a time based type",
              "doc": "The table column that contains the time information used create the animation"
          },
          "-torque-data-aggregation": {
              "css": "-torque-data-aggregation",
              "default-value": "linear",
              "type": [
                "linear",
                "cumulative"
              ],
              "default-meaning": "previous values are discarded",
              "doc": "A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts"
          }
        }
    },
    "colors": {
        "aliceblue":  [240, 248, 255],
        "antiquewhite":  [250, 235, 215],
        "aqua":  [0, 255, 255],
        "aquamarine":  [127, 255, 212],
        "azure":  [240, 255, 255],
        "beige":  [245, 245, 220],
        "bisque":  [255, 228, 196],
        "black":  [0, 0, 0],
        "blanchedalmond":  [255,235,205],
        "blue":  [0, 0, 255],
        "blueviolet":  [138, 43, 226],
        "brown":  [165, 42, 42],
        "burlywood":  [222, 184, 135],
        "cadetblue":  [95, 158, 160],
        "chartreuse":  [127, 255, 0],
        "chocolate":  [210, 105, 30],
        "coral":  [255, 127, 80],
        "cornflowerblue":  [100, 149, 237],
        "cornsilk":  [255, 248, 220],
        "crimson":  [220, 20, 60],
        "cyan":  [0, 255, 255],
        "darkblue":  [0, 0, 139],
        "darkcyan":  [0, 139, 139],
        "darkgoldenrod":  [184, 134, 11],
        "darkgray":  [169, 169, 169],
        "darkgreen":  [0, 100, 0],
        "darkgrey":  [169, 169, 169],
        "darkkhaki":  [189, 183, 107],
        "darkmagenta":  [139, 0, 139],
        "darkolivegreen":  [85, 107, 47],
        "darkorange":  [255, 140, 0],
        "darkorchid":  [153, 50, 204],
        "darkred":  [139, 0, 0],
        "darksalmon":  [233, 150, 122],
        "darkseagreen":  [143, 188, 143],
        "darkslateblue":  [72, 61, 139],
        "darkslategrey":  [47, 79, 79],
        "darkturquoise":  [0, 206, 209],
        "darkviolet":  [148, 0, 211],
        "deeppink":  [255, 20, 147],
        "deepskyblue":  [0, 191, 255],
        "dimgray":  [105, 105, 105],
        "dimgrey":  [105, 105, 105],
        "dodgerblue":  [30, 144, 255],
        "firebrick":  [178, 34, 34],
        "floralwhite":  [255, 250, 240],
        "forestgreen":  [34, 139, 34],
        "fuchsia":  [255, 0, 255],
        "gainsboro":  [220, 220, 220],
        "ghostwhite":  [248, 248, 255],
        "gold":  [255, 215, 0],
        "goldenrod":  [218, 165, 32],
        "gray":  [128, 128, 128],
        "grey":  [128, 128, 128],
        "green":  [0, 128, 0],
        "greenyellow":  [173, 255, 47],
        "honeydew":  [240, 255, 240],
        "hotpink":  [255, 105, 180],
        "indianred":  [205, 92, 92],
        "indigo":  [75, 0, 130],
        "ivory":  [255, 255, 240],
        "khaki":  [240, 230, 140],
        "lavender":  [230, 230, 250],
        "lavenderblush":  [255, 240, 245],
        "lawngreen":  [124, 252, 0],
        "lemonchiffon":  [255, 250, 205],
        "lightblue":  [173, 216, 230],
        "lightcoral":  [240, 128, 128],
        "lightcyan":  [224, 255, 255],
        "lightgoldenrodyellow":  [250, 250, 210],
        "lightgray":  [211, 211, 211],
        "lightgreen":  [144, 238, 144],
        "lightgrey":  [211, 211, 211],
        "lightpink":  [255, 182, 193],
        "lightsalmon":  [255, 160, 122],
        "lightseagreen":  [32, 178, 170],
        "lightskyblue":  [135, 206, 250],
        "lightslategray":  [119, 136, 153],
        "lightslategrey":  [119, 136, 153],
        "lightsteelblue":  [176, 196, 222],
        "lightyellow":  [255, 255, 224],
        "lime":  [0, 255, 0],
        "limegreen":  [50, 205, 50],
        "linen":  [250, 240, 230],
        "magenta":  [255, 0, 255],
        "maroon":  [128, 0, 0],
        "mediumaquamarine":  [102, 205, 170],
        "mediumblue":  [0, 0, 205],
        "mediumorchid":  [186, 85, 211],
        "mediumpurple":  [147, 112, 219],
        "mediumseagreen":  [60, 179, 113],
        "mediumslateblue":  [123, 104, 238],
        "mediumspringgreen":  [0, 250, 154],
        "mediumturquoise":  [72, 209, 204],
        "mediumvioletred":  [199, 21, 133],
        "midnightblue":  [25, 25, 112],
        "mintcream":  [245, 255, 250],
        "mistyrose":  [255, 228, 225],
        "moccasin":  [255, 228, 181],
        "navajowhite":  [255, 222, 173],
        "navy":  [0, 0, 128],
        "oldlace":  [253, 245, 230],
        "olive":  [128, 128, 0],
        "olivedrab":  [107, 142, 35],
        "orange":  [255, 165, 0],
        "orangered":  [255, 69, 0],
        "orchid":  [218, 112, 214],
        "palegoldenrod":  [238, 232, 170],
        "palegreen":  [152, 251, 152],
        "paleturquoise":  [175, 238, 238],
        "palevioletred":  [219, 112, 147],
        "papayawhip":  [255, 239, 213],
        "peachpuff":  [255, 218, 185],
        "peru":  [205, 133, 63],
        "pink":  [255, 192, 203],
        "plum":  [221, 160, 221],
        "powderblue":  [176, 224, 230],
        "purple":  [128, 0, 128],
        "red":  [255, 0, 0],
        "rosybrown":  [188, 143, 143],
        "royalblue":  [65, 105, 225],
        "saddlebrown":  [139, 69, 19],
        "salmon":  [250, 128, 114],
        "sandybrown":  [244, 164, 96],
        "seagreen":  [46, 139, 87],
        "seashell":  [255, 245, 238],
        "sienna":  [160, 82, 45],
        "silver":  [192, 192, 192],
        "skyblue":  [135, 206, 235],
        "slateblue":  [106, 90, 205],
        "slategray":  [112, 128, 144],
        "slategrey":  [112, 128, 144],
        "snow":  [255, 250, 250],
        "springgreen":  [0, 255, 127],
        "steelblue":  [70, 130, 180],
        "tan":  [210, 180, 140],
        "teal":  [0, 128, 128],
        "thistle":  [216, 191, 216],
        "tomato":  [255, 99, 71],
        "turquoise":  [64, 224, 208],
        "violet":  [238, 130, 238],
        "wheat":  [245, 222, 179],
        "white":  [255, 255, 255],
        "whitesmoke":  [245, 245, 245],
        "yellow":  [255, 255, 0],
        "yellowgreen":  [154, 205, 50],
        "transparent":  [0, 0, 0, 0]
    },
    "filter": {
        "value": [
            "true",
            "false",
            "null",
            "point",
            "linestring",
            "polygon",
            "collection"
        ]
    }
}

module.exports = {
  version: {
    latest: _mapnik_reference_latest,
    '2.1.1': _mapnik_reference_latest
  }
};

},{}],44:[function(require,module,exports){
/**
 * TODO: document this. What does this do?
 */
if(typeof(module) !== "undefined") {
  module.exports.find = function (obj, fun) {
      for (var i = 0, r; i < obj.length; i++) {
          if (r = fun.call(obj, obj[i])) { return r; }
      }
      return null;
  };
}

},{}],45:[function(require,module,exports){
(function (global){
(function(tree) {
var _ = global._ || require('underscore');
tree.Call = function Call(name, args, index) {
    this.name = name;
    this.args = args;
    this.index = index;
};

tree.Call.prototype = {
    is: 'call',
    // When evuating a function call,
    // we either find the function in `tree.functions` [1],
    // in which case we call it, passing the  evaluated arguments,
    // or we simply print it out as it appeared originally [2].
    // The *functions.js* file contains the built-in functions.
    // The reason why we evaluate the arguments, is in the case where
    // we try to pass a variable to a function, like: `saturate(@color)`.
    // The function should receive the value, not the variable.
    'ev': function(env) {
        var args = this.args.map(function(a) { return a.ev(env); });

        for (var i = 0; i < args.length; i++) {
            if (args[i].is === 'undefined') {
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        }

        if (this.name in tree.functions) {
            if (tree.functions[this.name].length <= args.length) {
                var val = tree.functions[this.name].apply(tree.functions, args);
                if (val === null) {
                    env.error({
                        message: 'incorrect arguments given to ' + this.name + '()',
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return { is: 'undefined', value: 'undefined' };
                }
                return val;
            } else {
                env.error({
                    message: 'incorrect number of arguments for ' + this.name +
                        '(). ' + tree.functions[this.name].length + ' expected.',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        } else {
            var fn = tree.Reference.mapnikFunctions[this.name];
            if (fn === undefined) {
                var functions = _.pairs(tree.Reference.mapnikFunctions);
                // cheap closest, needs improvement.
                var name = this.name;
                var mean = functions.map(function(f) {
                    return [f[0], tree.Reference.editDistance(name, f[0]), f[1]];
                }).sort(function(a, b) {
                    return a[1] - b[1];
                });
                env.error({
                    message: 'unknown function ' + this.name + '(), did you mean ' +
                        mean[0][0] + '(' + mean[0][2] + ')',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
            if (fn !== args.length &&
                !(Array.isArray(fn) && _.include(fn, args.length)) &&
                // support variable-arg functions like `colorize-alpha`
                fn !== -1) {
                env.error({
                    message: 'function ' + this.name + '() takes ' +
                        fn + ' arguments and was given ' + args.length,
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            } else {
                // Save the evaluated versions of arguments
                this.args = args;
                return this;
            }
        }
    },

    toString: function(env, format) {
        if (this.args.length) {
            return this.name + '(' + this.args.join(',') + ')';
        } else {
            return this.name;
        }
    }
};

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":44,"underscore":74}],46:[function(require,module,exports){
(function(tree) {
// RGB Colors - #ff0014, #eee
// can be initialized with a 3 or 6 char string or a 3 or 4 element
// numerical array
tree.Color = function Color(rgb, a) {
    // The end goal here, is to parse the arguments
    // into an integer triplet, such as `128, 255, 0`
    //
    // This facilitates operations and conversions.
    if (Array.isArray(rgb)) {
        this.rgb = rgb.slice(0, 3);
    } else if (rgb.length == 6) {
        this.rgb = rgb.match(/.{2}/g).map(function(c) {
            return parseInt(c, 16);
        });
    } else {
        this.rgb = rgb.split('').map(function(c) {
            return parseInt(c + c, 16);
        });
    }

    if (typeof(a) === 'number') {
        this.alpha = a;
    } else if (rgb.length === 4) {
        this.alpha = rgb[3];
    } else {
        this.alpha = 1;
    }
};

tree.Color.prototype = {
    is: 'color',
    'ev': function() { return this; },

    // If we have some transparency, the only way to represent it
    // is via `rgba`. Otherwise, we use the hex representation,
    // which has better compatibility with older browsers.
    // Values are capped between `0` and `255`, rounded and zero-padded.
    toString: function() {
        if (this.alpha < 1.0) {
            return 'rgba(' + this.rgb.map(function(c) {
                return Math.round(c);
            }).concat(this.alpha).join(', ') + ')';
        } else {
            return '#' + this.rgb.map(function(i) {
                i = Math.round(i);
                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);
                return i.length === 1 ? '0' + i : i;
            }).join('');
        }
    },

    // Operations have to be done per-channel, if not,
    // channels will spill onto each other. Once we have
    // our result, in the form of an integer triplet,
    // we create a new Color node to hold the result.
    operate: function(env, op, other) {
        var result = [];

        if (! (other instanceof tree.Color)) {
            other = other.toColor();
        }

        for (var c = 0; c < 3; c++) {
            result[c] = tree.operate(op, this.rgb[c], other.rgb[c]);
        }
        return new tree.Color(result);
    },

    toHSL: function() {
        var r = this.rgb[0] / 255,
            g = this.rgb[1] / 255,
            b = this.rgb[2] / 255,
            a = this.alpha;

        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2, d = max - min;

        if (max === min) {
            h = s = 0;
        } else {
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s: s, l: l, a: a };
    }
};

})(require('../tree'));

},{"../tree":44}],47:[function(require,module,exports){
(function(tree) {

tree.Comment = function Comment(value, silent) {
    this.value = value;
    this.silent = !!silent;
};

tree.Comment.prototype = {
    toString: function(env) {
        return '<!--' + this.value + '-->';
    },
    'ev': function() { return this; }
};

})(require('../tree'));

},{"../tree":44}],48:[function(require,module,exports){
(function (global){
(function(tree) {
var assert = require('assert'),
    _ = global._ || require('underscore');

// A definition is the combination of a selector and rules, like
// #foo {
//     polygon-opacity:1.0;
// }
//
// The selector can have filters
tree.Definition = function Definition(selector, rules) {
    this.elements = selector.elements;
    assert.ok(selector.filters instanceof tree.Filterset);
    this.rules = rules;
    this.ruleIndex = {};
    for (var i = 0; i < this.rules.length; i++) {
        if ('zoom' in this.rules[i]) this.rules[i] = this.rules[i].clone();
        this.rules[i].zoom = selector.zoom;
        this.ruleIndex[this.rules[i].updateID()] = true;
    }
    this.filters = selector.filters;
    this.zoom = selector.zoom;
    this.frame_offset = selector.frame_offset;
    this.attachment = selector.attachment || '__default__';
    this.specificity = selector.specificity();
};

tree.Definition.prototype.toString = function() {
    var str = this.filters.toString();
    for (var i = 0; i < this.rules.length; i++) {
        str += '\n    ' + this.rules[i];
    }
    return str;
};

tree.Definition.prototype.clone = function(filters) {
    if (filters) assert.ok(filters instanceof tree.Filterset);
    var clone = Object.create(tree.Definition.prototype);
    clone.rules = this.rules.slice();
    clone.ruleIndex = _.clone(this.ruleIndex);
    clone.filters = filters ? filters : this.filters.clone();
    clone.attachment = this.attachment;
    return clone;
};

tree.Definition.prototype.addRules = function(rules) {
    var added = 0;

    // Add only unique rules.
    for (var i = 0; i < rules.length; i++) {
        if (!this.ruleIndex[rules[i].id]) {
            this.rules.push(rules[i]);
            this.ruleIndex[rules[i].id] = true;
            added++;
        }
    }

    return added;
};

// Determine whether this selector matches a given id
// and array of classes, by determining whether
// all elements it contains match.
tree.Definition.prototype.appliesTo = function(id, classes) {
    for (var i = 0, l = this.elements.length; i < l; i++) {
        var elem = this.elements[i];
        if (!(elem.wildcard ||
            (elem.type === 'class' && classes[elem.clean]) ||
            (elem.type === 'id' && id === elem.clean))) return false;
    }
    return true;
};

function symbolizerName(symbolizer) {
    function capitalize(str) { return str[1].toUpperCase(); }
    return symbolizer.charAt(0).toUpperCase() +
           symbolizer.slice(1).replace(/\-./, capitalize) + 'Symbolizer';
}

// Get a simple list of the symbolizers, in order
function symbolizerList(sym_order) {
    return sym_order.sort(function(a, b) { return a[1] - b[1]; })
        .map(function(v) { return v[0]; });
}

tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
    var xml = zoom.toXML(env).join('') + this.filters.toXML(env);

    // Sort symbolizers by the index of their first property definition
    var sym_order = [], indexes = [];
    for (var key in symbolizers) {
        indexes = [];
        for (var prop in symbolizers[key]) {
            indexes.push(symbolizers[key][prop].index);
        }
        var min_idx = Math.min.apply(Math, indexes);
        sym_order.push([key, min_idx]);
    }

    sym_order = symbolizerList(sym_order);
    var sym_count = 0;

    for (var i = 0; i < sym_order.length; i++) {
        var attributes = symbolizers[sym_order[i]];
        var symbolizer = sym_order[i].split('/').pop();

        // Skip the magical * symbolizer which is used for universal properties
        // which are bubbled up to Style elements intead of Symbolizer elements.
        if (symbolizer === '*') continue;
        sym_count++;

        var fail = tree.Reference.requiredProperties(symbolizer, attributes);
        if (fail) {
            var rule = attributes[Object.keys(attributes).shift()];
            env.error({
                message: fail,
                index: rule.index,
                filename: rule.filename
            });
        }

        var name = symbolizerName(symbolizer);

        var selfclosing = true, tagcontent;
        xml += '    <' + name + ' ';
        for (var j in attributes) {
            if (symbolizer === 'map') env.error({
                message: 'Map properties are not permitted in other rules',
                index: attributes[j].index,
                filename: attributes[j].filename
            });
            var x = tree.Reference.selector(attributes[j].name);
            if (x && x.serialization && x.serialization === 'content') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else if (x && x.serialization && x.serialization === 'tag') {
                selfclosing = false;
                tagcontent = attributes[j].ev(env).toXML(env, true);
            } else {
                xml += attributes[j].ev(env).toXML(env) + ' ';
            }
        }
        if (selfclosing) {
            xml += '/>\n';
        } else if (typeof tagcontent !== "undefined") {
            if (tagcontent.indexOf('<') != -1) {
                xml += '>' + tagcontent + '</' + name + '>\n';
            } else {
                xml += '><![CDATA[' + tagcontent + ']]></' + name + '>\n';
            }
        }
    }
    if (!sym_count || !xml) return '';
    return '  <Rule>\n' + xml + '  </Rule>\n';
};

// Take a zoom range of zooms and 'i', the index of a rule in this.rules,
// and finds all applicable symbolizers
tree.Definition.prototype.collectSymbolizers = function(zooms, i) {
    var symbolizers = {}, child;

    for (var j = i; j < this.rules.length; j++) {
        child = this.rules[j];
        var key = child.instance + '/' + child.symbolizer;
        if (zooms.current & child.zoom &&
           (!(key in symbolizers) ||
           (!(child.name in symbolizers[key])))) {
            zooms.current &= child.zoom;
            if (!(key in symbolizers)) {
                symbolizers[key] = {};
            }
            symbolizers[key][child.name] = child;
        }
    }

    if (Object.keys(symbolizers).length) {
        zooms.rule &= (zooms.available &= ~zooms.current);
        return symbolizers;
    }
};

// The tree.Zoom.toString function ignores the holes in zoom ranges and outputs
// scaledenominators that cover the whole range from the first to last bit set.
// This algorithm can produces zoom ranges that may have holes. However,
// when using the filter-mode="first", more specific zoom filters will always
// end up before broader ranges. The filter-mode will pick those first before
// resorting to the zoom range with the hole and stop processing further rules.
tree.Definition.prototype.toXML = function(env, existing) {
    var filter = this.filters.toString();
    if (!(filter in existing)) existing[filter] = tree.Zoom.all;

    var available = tree.Zoom.all, xml = '', zoom, symbolizers,
        zooms = { available: tree.Zoom.all };
    for (var i = 0; i < this.rules.length && available; i++) {
        zooms.rule = this.rules[i].zoom;
        if (!(existing[filter] & zooms.rule)) continue;

        while (zooms.current = zooms.rule & available) {
            if (symbolizers = this.collectSymbolizers(zooms, i)) {
                if (!(existing[filter] & zooms.current)) continue;
                xml += this.symbolizersToXML(env, symbolizers,
                    (new tree.Zoom()).setZoom(existing[filter] & zooms.current));
                existing[filter] &= ~zooms.current;
            }
        }
    }

    return xml;
};

tree.Definition.prototype.toJS = function(env) {
  var shaderAttrs = {};

  // merge conditions from filters with zoom condition of the
  // definition
  var zoom = "(" + this.zoom + " & (1 << ctx.zoom))";
  var frame_offset = this.frame_offset;
  var _if = this.filters.toJS(env);
  var filters = [zoom];
  if(_if) filters.push(_if);
  if(frame_offset) filters.push('ctx["frame-offset"] === ' + frame_offset);
  _if = filters.join(" && ");
  _.each(this.rules, function(rule) {
      if(rule instanceof tree.Rule) {
        shaderAttrs[rule.name] = shaderAttrs[rule.name] || [];

        var r = {
          index: rule.index,
          symbolizer: rule.symbolizer
        };

        if (_if) {
          r.js = "if(" + _if + "){" + rule.value.toJS(env) + "}"
        } else {
          r.js = rule.value.toJS(env);
        }

        r.constant = rule.value.ev(env).is !== 'field';
        r.filtered = !!_if;

        shaderAttrs[rule.name].push(r);
      } else {
        throw new Error("Ruleset not supported");
        //if (rule instanceof tree.Ruleset) {
          //var sh = rule.toJS(env);
          //for(var v in sh) {
            //shaderAttrs[v] = shaderAttrs[v] || [];
            //for(var attr in sh[v]) {
              //shaderAttrs[v].push(sh[v][attr]);
            //}
          //}
        //}
      }
  });
  return shaderAttrs;
};


})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":44,"assert":3,"underscore":74}],49:[function(require,module,exports){
(function (global){
(function(tree) {
var _ = global._ || require('underscore');
//
// A number with a unit
//
tree.Dimension = function Dimension(value, unit, index) {
    this.value = parseFloat(value);
    this.unit = unit || null;
    this.index = index;
};

tree.Dimension.prototype = {
    is: 'float',
    physical_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc'],
    screen_units: ['px', '%'],
    all_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc', 'px', '%'],
    densities: {
        m: 0.0254,
        mm: 25.4,
        cm: 2.54,
        pt: 72,
        pc: 6
    },
    ev: function (env) {
        if (this.unit && !_.contains(this.all_units, this.unit)) {
            env.error({
                message: "Invalid unit: '" + this.unit + "'",
                index: this.index
            });
            return { is: 'undefined', value: 'undefined' };
        }

        // normalize units which are not px or %
        if (this.unit && _.contains(this.physical_units, this.unit)) {
            if (!env.ppi) {
                env.error({
                    message: "ppi is not set, so metric units can't be used",
                    index: this.index
                });
                return { is: 'undefined', value: 'undefined' };
            }
            // convert all units to inch
            // convert inch to px using ppi
            this.value = (this.value / this.densities[this.unit]) * env.ppi;
            this.unit = 'px';
        }

        return this;
    },
    round: function() {
        this.value = Math.round(this.value);
        return this;
    },
    toColor: function() {
        return new tree.Color([this.value, this.value, this.value]);
    },
    round: function() {
        this.value = Math.round(this.value);
        return this;
    },
    toString: function() {
        return this.value.toString();
    },
    operate: function(env, op, other) {
        if (this.unit === '%' && other.unit !== '%') {
            env.error({
                message: 'If two operands differ, the first must not be %',
                index: this.index
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        if (this.unit !== '%' && other.unit === '%') {
            if (op === '*' || op === '/' || op === '%') {
                env.error({
                    message: 'Percent values can only be added or subtracted from other values',
                    index: this.index
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            return new tree.Dimension(tree.operate(op,
                    this.value, this.value * other.value * 0.01),
                this.unit);
        }

        //here the operands are either the same (% or undefined or px), or one is undefined and the other is px
        return new tree.Dimension(tree.operate(op, this.value, other.value),
            this.unit || other.unit);
    }
};

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":44,"underscore":74}],50:[function(require,module,exports){
(function(tree) {

// An element is an id or class selector
tree.Element = function Element(value) {
    this.value = value.trim();
    if (this.value[0] === '#') {
        this.type = 'id';
        this.clean = this.value.replace(/^#/, '');
    }
    if (this.value[0] === '.') {
        this.type = 'class';
        this.clean = this.value.replace(/^\./, '');
    }
    if (this.value.indexOf('*') !== -1) {
        this.type = 'wildcard';
    }
};

// Determine the 'specificity matrix' of this
// specific selector
tree.Element.prototype.specificity = function() {
    return [
        (this.type === 'id') ? 1 : 0, // a
        (this.type === 'class') ? 1 : 0  // b
    ];
};

tree.Element.prototype.toString = function() { return this.value; };

})(require('../tree'));

},{"../tree":44}],51:[function(require,module,exports){
(function(tree) {

tree.Expression = function Expression(value) {
    this.value = value;
};

tree.Expression.prototype = {
    is: 'expression',
    ev: function(env) {
        if (this.value.length > 1) {
            return new tree.Expression(this.value.map(function(e) {
                return e.ev(env);
            }));
        } else {
            return this.value[0].ev(env);
        }
    },

    toString: function(env) {
        return this.value.map(function(e) {
            return e.toString(env);
        }).join(' ');
    }
};

})(require('../tree'));

},{"../tree":44}],52:[function(require,module,exports){
(function(tree) {

tree.Field = function Field(content) {
    this.value = content || '';
};

tree.Field.prototype = {
    is: 'field',
    toString: function() {
        return '[' + this.value + ']';
    },
    'ev': function() {
        return this;
    }
};

})(require('../tree'));

},{"../tree":44}],53:[function(require,module,exports){
(function(tree) {

tree.Filter = function Filter(key, op, val, index, filename) {
    this.key = key;
    this.op = op;
    this.val = val;
    this.index = index;
    this.filename = filename;

    this.id = this.key + this.op + this.val;
};

// xmlsafe, numeric, suffix
var ops = {
    '<': [' &lt; ', 'numeric'],
    '>': [' &gt; ', 'numeric'],
    '=': [' = ', 'both'],
    '!=': [' != ', 'both'],
    '<=': [' &lt;= ', 'numeric'],
    '>=': [' &gt;= ', 'numeric'],
    '=~': ['.match(', 'string', ')']
};

tree.Filter.prototype.ev = function(env) {
    this.key = this.key.ev(env);
    this.val = this.val.ev(env);
    return this;
};

tree.Filter.prototype.toXML = function(env) {
    if (tree.Reference.data.filter) {
        if (this.key.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.key.toString())) {
            env.error({
                message: this.key.toString() + ' is not a valid keyword in a filter expression',
                index: this.index,
                filename: this.filename
            });
        }
        if (this.val.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.val.toString())) {
            env.error({
                message: this.val.toString() + ' is not a valid keyword in a filter expression',
                index: this.index,
                filename: this.filename
            });
        }
    }
    var key = this.key.toString(false);
    var val = this.val.toString(this.val.is == 'string');

    if (
        (ops[this.op][1] == 'numeric' && isNaN(val) && this.val.is !== 'field') ||
        (ops[this.op][1] == 'string' && (val)[0] != "'")
    ) {
        env.error({
            message: 'Cannot use operator "' + this.op + '" with value ' + this.val,
            index: this.index,
            filename: this.filename
        });
    }

    return key + ops[this.op][0] + val + (ops[this.op][2] || '');
};

tree.Filter.prototype.toString = function() {
    return '[' + this.id + ']';
};

})(require('../tree'));

},{"../tree":44}],54:[function(require,module,exports){
(function (global){
var tree = require('../tree');
var _ = global._ || require('underscore');

tree.Filterset = function Filterset() {
    this.filters = {};
};

tree.Filterset.prototype.toXML = function(env) {
    var filters = [];
    for (var id in this.filters) {
        filters.push('(' + this.filters[id].toXML(env).trim() + ')');
    }
    if (filters.length) {
        return '    <Filter>' + filters.join(' and ') + '</Filter>\n';
    } else {
        return '';
    }
};

tree.Filterset.prototype.toString = function() {
    var arr = [];
    for (var id in this.filters) arr.push(this.filters[id].id);
    return arr.sort().join('\t');
};

tree.Filterset.prototype.ev = function(env) {
    for (var i in this.filters) {
        this.filters[i].ev(env);
    }
    return this;
};

tree.Filterset.prototype.clone = function() {
    var clone = new tree.Filterset();
    for (var id in this.filters) {
        clone.filters[id] = this.filters[id];
    }
    return clone;
};

// Note: other has to be a tree.Filterset.
tree.Filterset.prototype.cloneWith = function(other) {
    var additions = [];
    for (var id in other.filters) {
        var status = this.addable(other.filters[id]);
        // status is true, false or null. if it's null we don't fail this
        // clone nor do we add the filter.
        if (status === false) {
            return false;
        }
        if (status === true) {
            // Adding the filter will override another value.
            additions.push(other.filters[id]);
        }
    }

    // Adding the other filters doesn't make this filterset invalid, but it
    // doesn't add anything to it either.
    if (!additions.length) {
        return null;
    }

    // We can successfully add all filters. Now clone the filterset and add the
    // new rules.
    var clone = new tree.Filterset();

    // We can add the rules that are already present without going through the
    // add function as a Filterset is always in it's simplest canonical form.
    for (id in this.filters) {
        clone.filters[id] = this.filters[id];
    }

    // Only add new filters that actually change the filter.
    while (id = additions.shift()) {
        clone.add(id);
    }

    return clone;
};

tree.Filterset.prototype.toJS = function(env) {
  var opMap = {
    '=': '==='
  };
  return _.map(this.filters, function(filter) {
    var op = filter.op;
    if(op in opMap) {
      op = opMap[op];
    }
    var val = filter.val;
    if(filter._val !== undefined) {
      val = filter._val.toString(true);
    }
    var attrs = "data";
    return attrs + "." + filter.key.value  + " " + op + " " + (val.is === 'string' ? "'"+ val +"'" : val);
  }).join(' && ');
};

// Returns true when the new filter can be added, false otherwise.
// It can also return null, and on the other side we test for === true or
// false
tree.Filterset.prototype.addable = function(filter) {
    var key = filter.key.toString(),
        value = filter.val.toString();

    if (value.match(/^[0-9]+(\.[0-9]*)?$/)) value = parseFloat(value);

    switch (filter.op) {
        case '=':
            // if there is already foo= and we're adding foo=
            if (this.filters[key + '='] !== undefined) {
                if (this.filters[key + '='].val.toString() != value) {
                    return false;
                } else {
                    return null;
                }
            }
            if (this.filters[key + '!=' + value] !== undefined) return false;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return false;
            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val < value) return false;
            return true;

        case '=~':
            return true;

        case '!=':
            if (this.filters[key + '='] !== undefined) return (this.filters[key + '='].val == value) ? false : null;
            if (this.filters[key + '!=' + value] !== undefined) return null;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;
            return true;

        case '>':
            if (key + '=' in this.filters) {
                if (this.filters[key + '='].val <= value) {
                    return false;
                } else {
                    return null;
                }
            }
            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val <= value) return false;
            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return null;
            return true;

        case '>=':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val < value) ? false : null;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return false;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return false;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return null;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return null;
            return true;

        case '<':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val >= value) ? false : null;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return false;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;
            return true;

        case '<=':
            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val > value) ? false : null;
            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;
            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return false;
            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;
            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) return null;
            return true;
    }
};

// Does the new filter constitute a conflict?
tree.Filterset.prototype.conflict = function(filter) {
    var key = filter.key.toString(),
        value = filter.val.toString();

    if (!isNaN(parseFloat(value))) value = parseFloat(value);

    // if (a=b) && (a=c)
    // if (a=b) && (a!=b)
    // or (a!=b) && (a=b)
    if ((filter.op === '=' && this.filters[key + '='] !== undefined &&
        value != this.filters[key + '='].val.toString()) ||
        (filter.op === '!=' && this.filters[key + '='] !== undefined &&
        value == this.filters[key + '='].val.toString()) ||
        (filter.op === '=' && this.filters[key + '!='] !== undefined &&
        value == this.filters[key + '!='].val.toString())) {
        return filter.toString() + ' added to ' + this.toString() + ' produces an invalid filter';
    }

    return false;
};

// Only call this function for filters that have been cleared by .addable().
tree.Filterset.prototype.add = function(filter, env) {
    var key = filter.key.toString(),
        id,
        op = filter.op,
        conflict = this.conflict(filter),
        numval;

    if (conflict) return conflict;

    if (op === '=') {
        for (var i in this.filters) {
            if (this.filters[i].key == key) delete this.filters[i];
        }
        this.filters[key + '='] = filter;
    } else if (op === '!=') {
        this.filters[key + '!=' + filter.val] = filter;
    } else if (op === '=~') {
        this.filters[key + '=~' + filter.val] = filter;
    } else if (op === '>') {
        // If there are other filters that are also >
        // but are less than this one, they don't matter, so
        // remove them.
        for (var j in this.filters) {
            if (this.filters[j].key == key && this.filters[j].val <= filter.val) {
                delete this.filters[j];
            }
        }
        this.filters[key + '>'] = filter;
    } else if (op === '>=') {
        for (var k in this.filters) {
            numval = (+this.filters[k].val.toString());
            if (this.filters[k].key == key && numval < filter.val) {
                delete this.filters[k];
            }
        }
        if (this.filters[key + '!=' + filter.val] !== undefined) {
            delete this.filters[key + '!=' + filter.val];
            filter.op = '>';
            this.filters[key + '>'] = filter;
        }
        else {
            this.filters[key + '>='] = filter;
        }
    } else if (op === '<') {
        for (var l in this.filters) {
            numval = (+this.filters[l].val.toString());
            if (this.filters[l].key == key && numval >= filter.val) {
                delete this.filters[l];
            }
        }
        this.filters[key + '<'] = filter;
    } else if (op === '<=') {
        for (var m in this.filters) {
            numval = (+this.filters[m].val.toString());
            if (this.filters[m].key == key && numval > filter.val) {
                delete this.filters[m];
            }
        }
        if (this.filters[key + '!=' + filter.val] !== undefined) {
            delete this.filters[key + '!=' + filter.val];
            filter.op = '<';
            this.filters[key + '<'] = filter;
        }
        else {
            this.filters[key + '<='] = filter;
        }
    }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":44,"underscore":74}],55:[function(require,module,exports){
(function(tree) {

tree._getFontSet = function(env, fonts) {
    var fontKey = fonts.join('');
    if (env._fontMap && env._fontMap[fontKey]) {
        return env._fontMap[fontKey];
    }

    var new_fontset = new tree.FontSet(env, fonts);
    env.effects.push(new_fontset);
    if (!env._fontMap) env._fontMap = {};
    env._fontMap[fontKey] = new_fontset;
    return new_fontset;
};

tree.FontSet = function FontSet(env, fonts) {
    this.fonts = fonts;
    this.name = 'fontset-' + env.effects.length;
};

tree.FontSet.prototype.toXML = function(env) {
    return '<FontSet name="' +
        this.name +
        '">\n' +
        this.fonts.map(function(f) {
            return '  <Font face-name="' + f +'"/>';
        }).join('\n') +
        '\n</FontSet>';
};

})(require('../tree'));

},{"../tree":44}],56:[function(require,module,exports){
var tree = require('../tree');

// Storage for Frame offset value
// and stores them as bit-sequences so that they can be combined,
// inverted, and compared quickly.
tree.FrameOffset = function(op, value, index) {
    value = parseInt(value, 10);
    if (value > tree.FrameOffset.max || value <= 0) {
        throw {
            message: 'Only frame-offset levels between 1 and ' +
                tree.FrameOffset.max + ' supported.',
            index: index
        };
    }

    if (op !== '=') {
        throw {
            message: 'only = operator is supported for frame-offset',
            index: index
        };
    }
    return value;
};

tree.FrameOffset.max = 32;
tree.FrameOffset.none = 0;


},{"../tree":44}],57:[function(require,module,exports){
(function(tree) {

tree.ImageFilter = function ImageFilter(filter, args) {
    this.filter = filter;
    this.args = args || null;
};

tree.ImageFilter.prototype = {
    is: 'imagefilter',
    ev: function() { return this; },

    toString: function() {
        if (this.args) {
            return this.filter + '(' + this.args.join(',') + ')';
        } else {
            return this.filter;
        }
    }
};


})(require('../tree'));

},{"../tree":44}],58:[function(require,module,exports){
(function (tree) {
tree.Invalid = function Invalid(chunk, index, message) {
    this.chunk = chunk;
    this.index = index;
    this.type = 'syntax';
    this.message = message || "Invalid code: " + this.chunk;
};

tree.Invalid.prototype.is = 'invalid';

tree.Invalid.prototype.ev = function(env) {
    env.error({
        chunk: this.chunk,
        index: this.index,
        type: 'syntax',
        message: this.message || "Invalid code: " + this.chunk
    });
    return {
        is: 'undefined'
    };
};
})(require('../tree'));

},{"../tree":44}],59:[function(require,module,exports){
(function(tree) {

tree.Keyword = function Keyword(value) {
    this.value = value;
    var special = {
        'transparent': 'color',
        'true': 'boolean',
        'false': 'boolean'
    };
    this.is = special[value] ? special[value] : 'keyword';
};
tree.Keyword.prototype = {
    ev: function() { return this; },
    toString: function() { return this.value; }
};

})(require('../tree'));

},{"../tree":44}],60:[function(require,module,exports){
(function(tree) {

tree.LayerXML = function(obj, styles) {
    var dsoptions = [];
    for (var i in obj.Datasource) {
        dsoptions.push('<Parameter name="' + i + '"><![CDATA[' +
            obj.Datasource[i] + ']]></Parameter>');
    }

    var prop_string = '';
    for (var prop in obj.properties) {
        if (prop === 'minzoom') {
            prop_string += '  maxzoom="' + tree.Zoom.ranges[obj.properties[prop]] + '"\n';
        } else if (prop === 'maxzoom') {
            prop_string += '  minzoom="' + tree.Zoom.ranges[obj.properties[prop]+1] + '"\n';
        } else {
            prop_string += '  ' + prop + '="' + obj.properties[prop] + '"\n';
        }
    }

    return '<Layer' +
        ' name="' + obj.name + '"\n' +
        prop_string +
        ((typeof obj.status === 'undefined') ? '' : '  status="' + obj.status + '"\n') +
        ((typeof obj.srs === 'undefined') ? '' : '  srs="' + obj.srs + '"') + '>\n    ' +
        styles.reverse().map(function(s) {
            return '<StyleName>' + s + '</StyleName>';
        }).join('\n    ') +
        (dsoptions.length ?
        '\n    <Datasource>\n       ' +
        dsoptions.join('\n       ') +
        '\n    </Datasource>\n'
        : '') +
        '  </Layer>\n';
};

})(require('../tree'));

},{"../tree":44}],61:[function(require,module,exports){
// A literal is a literal string for Mapnik - the
// result of the combination of a `tree.Field` with any
// other type.
(function(tree) {

tree.Literal = function Field(content) {
    this.value = content || '';
    this.is = 'field';
};

tree.Literal.prototype = {
    toString: function() {
        return this.value;
    },
    'ev': function() {
        return this;
    }
};

})(require('../tree'));

},{"../tree":44}],62:[function(require,module,exports){
// An operation is an expression with an op in between two operands,
// like 2 + 1.
(function(tree) {

tree.Operation = function Operation(op, operands, index) {
    this.op = op.trim();
    this.operands = operands;
    this.index = index;
};

tree.Operation.prototype.is = 'operation';

tree.Operation.prototype.ev = function(env) {
    var a = this.operands[0].ev(env),
        b = this.operands[1].ev(env),
        temp;

    if (a.is === 'undefined' || b.is === 'undefined') {
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    if (a instanceof tree.Dimension && b instanceof tree.Color) {
        if (this.op === '*' || this.op === '+') {
            temp = b, b = a, a = temp;
        } else {
            env.error({
                name: "OperationError",
                message: "Can't substract or divide a color from a number",
                index: this.index
            });
        }
    }

    // Only concatenate plain strings, because this is easily
    // pre-processed
    if (a instanceof tree.Quoted && b instanceof tree.Quoted && this.op !== '+') {
        env.error({
           message: "Can't subtract, divide, or multiply strings.",
           index: this.index,
           type: 'runtime',
           filename: this.filename
        });
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    // Fields, literals, dimensions, and quoted strings can be combined.
    if (a instanceof tree.Field || b instanceof tree.Field ||
        a instanceof tree.Literal || b instanceof tree.Literal) {
        if (a.is === 'color' || b.is === 'color') {
            env.error({
               message: "Can't subtract, divide, or multiply colors in expressions.",
               index: this.index,
               type: 'runtime',
               filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        } else {
            return new tree.Literal(a.ev(env).toString(true) + this.op + b.ev(env).toString(true));
        }
    }

    if (a.operate === undefined) {
        env.error({
           message: 'Cannot do math with type ' + a.is + '.',
           index: this.index,
           type: 'runtime',
           filename: this.filename
        });
        return {
            is: 'undefined',
            value: 'undefined'
        };
    }

    return a.operate(env, this.op, b);
};

tree.operate = function(op, a, b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '%': return a % b;
        case '/': return a / b;
    }
};

})(require('../tree'));

},{"../tree":44}],63:[function(require,module,exports){
(function(tree) {

tree.Quoted = function Quoted(content) {
    this.value = content || '';
};

tree.Quoted.prototype = {
    is: 'string',

    toString: function(quotes) {
        var escapedValue = this.value
            .replace(/&/g, '&amp;')
        var xmlvalue = escapedValue
            .replace(/\'/g, '\\\'')
            .replace(/\"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/\>/g, '&gt;');
        return (quotes === true) ? "'" + xmlvalue + "'" : escapedValue;
    },

    'ev': function() {
        return this;
    },

    operate: function(env, op, other) {
        return new tree.Quoted(tree.operate(op, this.toString(), other.toString(this.contains_field)));
    }
};

})(require('../tree'));

},{"../tree":44}],64:[function(require,module,exports){
(function (global){
// Carto pulls in a reference from the `mapnik-reference`
// module. This file builds indexes from that file for its various
// options, and provides validation methods for property: value
// combinations.
(function(tree) {

var _ = global._ || require('underscore'),
    ref = {};

ref.setData = function(data) {
    ref.data = data;
    ref.selector_cache = generateSelectorCache(data);
    ref.mapnikFunctions = generateMapnikFunctions(data);

    ref.mapnikFunctions.matrix = [6];
    ref.mapnikFunctions.translate = [1, 2];
    ref.mapnikFunctions.scale = [1, 2];
    ref.mapnikFunctions.rotate = [1, 3];
    ref.mapnikFunctions.skewX = [1];
    ref.mapnikFunctions.skewY = [1];

    ref.required_cache = generateRequiredProperties(data);
};

ref.setVersion = function(version) {
    var mapnik_reference = require('mapnik-reference');
    if (mapnik_reference.version.hasOwnProperty(version)) {
        ref.setData(mapnik_reference.version[version]);
        return true;
    } else {
        return false;
    }
};

ref.selectorData = function(selector, i) {
    if (ref.selector_cache[selector]) return ref.selector_cache[selector][i];
};

ref.validSelector = function(selector) { return !!ref.selector_cache[selector]; };
ref.selectorName = function(selector) { return ref.selectorData(selector, 2); };
ref.selector = function(selector) { return ref.selectorData(selector, 0); };
ref.symbolizer = function(selector) { return ref.selectorData(selector, 1); };

function generateSelectorCache(data) {
    var index = {};
    for (var i in data.symbolizers) {
        for (var j in data.symbolizers[i]) {
            if (data.symbolizers[i][j].hasOwnProperty('css')) {
                index[data.symbolizers[i][j].css] = [data.symbolizers[i][j], i, j];
            }
        }
    }
    return index;
}

function generateMapnikFunctions(data) {
    var functions = {};
    for (var i in data.symbolizers) {
        for (var j in data.symbolizers[i]) {
            if (data.symbolizers[i][j].type === 'functions') {
                for (var k = 0; k < data.symbolizers[i][j].functions.length; k++) {
                    var fn = data.symbolizers[i][j].functions[k];
                    functions[fn[0]] = fn[1];
                }
            }
        }
    }
    return functions;
}

function generateRequiredProperties(data) {
    var cache = {};
    for (var symbolizer_name in data.symbolizers) {
        cache[symbolizer_name] = [];
        for (var j in data.symbolizers[symbolizer_name]) {
            if (data.symbolizers[symbolizer_name][j].required) {
                cache[symbolizer_name].push(data.symbolizers[symbolizer_name][j].css);
            }
        }
    }
    return cache;
}

ref.requiredProperties = function(symbolizer_name, rules) {
    var req = ref.required_cache[symbolizer_name];
    for (var i in req) {
        if (!(req[i] in rules)) {
            return 'Property ' + req[i] + ' required for defining ' +
                symbolizer_name + ' styles.';
        }
    }
};

// TODO: finish implementation - this is dead code
ref._validateValue = {
    'font': function(env, value) {
        if (env.validation_data && env.validation_data.fonts) {
            return env.validation_data.fonts.indexOf(value) != -1;
        } else {
            return true;
        }
    }
};

ref.isFont = function(selector) {
    return ref.selector(selector).validate == 'font';
};

// https://gist.github.com/982927
ref.editDistance = function(a, b){
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    var matrix = [];
    for (var i = 0; i <= b.length; i++) { matrix[i] = [i]; }
    for (var j = 0; j <= a.length; j++) { matrix[0][j] = j; }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i-1) == a.charAt(j-1)) {
                matrix[i][j] = matrix[i-1][j-1];
            } else {
                matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution
                    Math.min(matrix[i][j-1] + 1, // insertion
                    matrix[i-1][j] + 1)); // deletion
            }
        }
    }
    return matrix[b.length][a.length];
};

function validateFunctions(value, selector) {
    if (value.value[0].is === 'string') return true;
    for (var i in value.value) {
        for (var j in value.value[i].value) {
            if (value.value[i].value[j].is !== 'call') return false;
            var f = _.find(ref
                .selector(selector).functions, function(x) {
                    return x[0] == value.value[i].value[j].name;
                });
            if (!(f && f[1] == -1)) {
                // This filter is unknown or given an incorrect number of arguments
                if (!f || f[1] !== value.value[i].value[j].args.length) return false;
            }
        }
    }
    return true;
}

function validateKeyword(value, selector) {
    if (typeof ref.selector(selector).type === 'object') {
        return ref.selector(selector).type
            .indexOf(value.value[0].value) !== -1;
    } else {
        // allow unquoted keywords as strings
        return ref.selector(selector).type === 'string';
    }
}

ref.validValue = function(env, selector, value) {
    var i, j;
    // TODO: handle in reusable way
    if (!ref.selector(selector)) {
        return false;
    } else if (value.value[0].is == 'keyword') {
        return validateKeyword(value, selector);
    } else if (value.value[0].is == 'undefined') {
        // caught earlier in the chain - ignore here so that
        // error is not overridden
        return true;
    } else if (ref.selector(selector).type == 'numbers') {
        for (i in value.value) {
            if (value.value[i].is !== 'float') {
                return false;
            }
        }
        return true;
    } else if (ref.selector(selector).type == 'tags') {
        if (!value.value) return false;
        if (!value.value[0].value) {
            return value.value[0].is === 'tag';
        }
        for (i = 0; i < value.value[0].value.length; i++) {
            if (value.value[0].value[i].is !== 'tag') return false;
        }
        return true;
    } else if (ref.selector(selector).type == 'functions') {
        // For backwards compatibility, you can specify a string for `functions`-compatible
        // values, though they will not be validated.
        return validateFunctions(value, selector);
    } else if (ref.selector(selector).type === 'unsigned') {
        if (value.value[0].is === 'float') {
            value.value[0].round();
            return true;
        } else {
            return false;
        }
    } else if ((ref.selector(selector).expression)) {
        return true;
    } else {
        if (ref.selector(selector).validate) {
            var valid = false;
            for (i = 0; i < value.value.length; i++) {
                if (ref.selector(selector).type == value.value[i].is &&
                    ref
                        ._validateValue
                            [ref.selector(selector).validate]
                            (env, value.value[i].value)) {
                    return true;
                }
            }
            return valid;
        } else {
            return ref.selector(selector).type == value.value[0].is;
        }
    }
};

tree.Reference = ref;

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":44,"mapnik-reference":73,"underscore":74}],65:[function(require,module,exports){
(function(tree) {
// a rule is a single property and value combination, or variable
// name and value combination, like
// polygon-opacity: 1.0; or @opacity: 1.0;
tree.Rule = function Rule(name, value, index, filename) {
    var parts = name.split('/');
    this.name = parts.pop();
    this.instance = parts.length ? parts[0] : '__default__';
    this.value = (value instanceof tree.Value) ?
        value : new tree.Value([value]);
    this.index = index;
    this.symbolizer = tree.Reference.symbolizer(this.name);
    this.filename = filename;
    this.variable = (name.charAt(0) === '@');
};

tree.Rule.prototype.is = 'rule';

tree.Rule.prototype.clone = function() {
    var clone = Object.create(tree.Rule.prototype);
    clone.name = this.name;
    clone.value = this.value;
    clone.index = this.index;
    clone.instance = this.instance;
    clone.symbolizer = this.symbolizer;
    clone.filename = this.filename;
    clone.variable = this.variable;
    return clone;
};

tree.Rule.prototype.updateID = function() {
    return this.id = this.zoom + '#' + this.instance + '#' + this.name;
};

tree.Rule.prototype.toString = function() {
    return '[' + tree.Zoom.toString(this.zoom) + '] ' + this.name + ': ' + this.value;
};

function getMean(name) {
    return Object.keys(tree.Reference.selector_cache).map(function(f) {
        return [f, tree.Reference.editDistance(name, f)];
    }).sort(function(a, b) { return a[1] - b[1]; });
}

// second argument, if true, outputs the value of this
// rule without the usual attribute="content" wrapping. Right
// now this is just for the TextSymbolizer, but applies to other
// properties in reference.json which specify serialization=content
tree.Rule.prototype.toXML = function(env, content, sep, format) {
    if (!tree.Reference.validSelector(this.name)) {
        var mean = getMean(this.name);
        var mean_message = '';
        if (mean[0][1] < 3) {
            mean_message = '. Did you mean ' + mean[0][0] + '?';
        }
        return env.error({
            message: "Unrecognized rule: " + this.name + mean_message,
            index: this.index,
            type: 'syntax',
            filename: this.filename
        });
    }

    if ((this.value instanceof tree.Value) &&
        !tree.Reference.validValue(env, this.name, this.value)) {
        if (!tree.Reference.selector(this.name)) {
            return env.error({
                message: 'Unrecognized property: ' +
                    this.name,
                index: this.index,
                type: 'syntax',
                filename: this.filename
            });
        } else {
            var typename;
            if (tree.Reference.selector(this.name).validate) {
                typename = tree.Reference.selector(this.name).validate;
            } else if (typeof tree.Reference.selector(this.name).type === 'object') {
                typename = 'keyword (options: ' + tree.Reference.selector(this.name).type.join(', ') + ')';
            } else {
                typename = tree.Reference.selector(this.name).type;
            }
            return env.error({
                message: 'Invalid value for ' +
                    this.name +
                    ', the type ' + typename +
                    ' is expected. ' + this.value +
                    ' (of type ' + this.value.value[0].is + ') ' +
                    ' was given.',
                index: this.index,
                type: 'syntax',
                filename: this.filename
            });
        }
    }

    if (this.variable) {
        return '';
    } else if (tree.Reference.isFont(this.name) && this.value.value.length > 1) {
        var f = tree._getFontSet(env, this.value.value);
        return 'fontset-name="' + f.name + '"';
    } else if (content) {
        return this.value.toString(env, this.name, sep);
    } else {
        return tree.Reference.selectorName(this.name) +
            '="' +
            this.value.toString(env, this.name) +
            '"';
    }
};

// TODO: Rule ev chain should add fontsets to env.frames
tree.Rule.prototype.ev = function(context) {
    return new tree.Rule(this.name,
        this.value.ev(context),
        this.index,
        this.filename);
};

})(require('../tree'));

},{"../tree":44}],66:[function(require,module,exports){
(function(tree) {

tree.Ruleset = function Ruleset(selectors, rules) {
    this.selectors = selectors;
    this.rules = rules;
    // static cache of find() function
    this._lookups = {};
};
tree.Ruleset.prototype = {
    is: 'ruleset',
    'ev': function(env) {
        var i,
            ruleset = new tree.Ruleset(this.selectors, this.rules.slice(0));
        ruleset.root = this.root;

        // push the current ruleset to the frames stack
        env.frames.unshift(ruleset);

        // Evaluate everything else
        for (i = 0, rule; i < ruleset.rules.length; i++) {
            rule = ruleset.rules[i];
            ruleset.rules[i] = rule.ev ? rule.ev(env) : rule;
        }

        // Pop the stack
        env.frames.shift();

        return ruleset;
    },
    match: function(args) {
        return !args || args.length === 0;
    },
    variables: function() {
        if (this._variables) { return this._variables; }
        else {
            return this._variables = this.rules.reduce(function(hash, r) {
                if (r instanceof tree.Rule && r.variable === true) {
                    hash[r.name] = r;
                }
                return hash;
            }, {});
        }
    },
    variable: function(name) {
        return this.variables()[name];
    },
    rulesets: function() {
        if (this._rulesets) { return this._rulesets; }
        else {
            return this._rulesets = this.rules.filter(function(r) {
                return (r instanceof tree.Ruleset);
            });
        }
    },
    find: function(selector, self) {
        self = self || this;
        var rules = [], rule, match,
            key = selector.toString();

        if (key in this._lookups) { return this._lookups[key]; }

        this.rulesets().forEach(function(rule) {
            if (rule !== self) {
                for (var j = 0; j < rule.selectors.length; j++) {
                    match = selector.match(rule.selectors[j]);
                    if (match) {
                        if (selector.elements.length > 1) {
                            Array.prototype.push.apply(rules, rule.find(
                                new tree.Selector(null, null, null, selector.elements.slice(1)), self));
                        } else {
                            rules.push(rule);
                        }
                        break;
                    }
                }
            }
        });
        return this._lookups[key] = rules;
    },
    // Zooms can use variables. This replaces tree.Zoom objects on selectors
    // with simple bit-arrays that we can compare easily.
    evZooms: function(env) {
        for (var i = 0; i < this.selectors.length; i++) {
            var zval = tree.Zoom.all;
            for (var z = 0; z < this.selectors[i].zoom.length; z++) {
                zval = zval & this.selectors[i].zoom[z].ev(env).zoom;
            }
            this.selectors[i].zoom = zval;
        }
    },
    flatten: function(result, parents, env) {
        var selectors = [], i, j;
        if (this.selectors.length === 0) {
            env.frames = env.frames.concat(this.rules);
        }
        // evaluate zoom variables on this object.
        this.evZooms(env);
        for (i = 0; i < this.selectors.length; i++) {
            var child = this.selectors[i];

            if (!child.filters) {
                // TODO: is this internal inconsistency?
                // This is an invalid filterset.
                continue;
            }

            if (parents.length) {
                for (j = 0; j < parents.length; j++) {
                    var parent = parents[j];

                    var mergedFilters = parent.filters.cloneWith(child.filters);
                    if (mergedFilters === null) {
                        // Filters could be added, but they didn't change the
                        // filters. This means that we only have to clone when
                        // the zoom levels or the attachment is different too.
                        if (parent.zoom === (parent.zoom & child.zoom) &&
                            parent.frame_offset === child.frame_offset &&
                            parent.attachment === child.attachment &&
                            parent.elements.join() === child.elements.join()) {
                            selectors.push(parent);
                            continue;
                        } else {
                            mergedFilters = parent.filters;
                        }
                    } else if (!mergedFilters) {
                        // The merged filters are invalid, that means we don't
                        // have to clone.
                        continue;
                    }

                    var clone = Object.create(tree.Selector.prototype);
                    clone.filters = mergedFilters;
                    clone.zoom = parent.zoom & child.zoom;
                    clone.frame_offset = child.frame_offset;
                    clone.elements = parent.elements.concat(child.elements);
                    if (parent.attachment && child.attachment) {
                        clone.attachment = parent.attachment + '/' + child.attachment;
                    }
                    else clone.attachment = child.attachment || parent.attachment;
                    clone.conditions = parent.conditions + child.conditions;
                    clone.index = child.index;
                    selectors.push(clone);
                }
            } else {
                selectors.push(child);
            }
        }

        var rules = [];
        for (i = 0; i < this.rules.length; i++) {
            var rule = this.rules[i];

            // Recursively flatten any nested rulesets
            if (rule instanceof tree.Ruleset) {
                rule.flatten(result, selectors, env);
            } else if (rule instanceof tree.Rule) {
                rules.push(rule);
            } else if (rule instanceof tree.Invalid) {
                env.error(rule);
            }
        }

        var index = rules.length ? rules[0].index : false;
        for (i = 0; i < selectors.length; i++) {
            // For specificity sort, use the position of the first rule to allow
            // defining attachments that are under current element as a descendant
            // selector.
            if (index !== false) {
                selectors[i].index = index;
            }
            result.push(new tree.Definition(selectors[i], rules.slice()));
        }

        return result;
    }
};
})(require('../tree'));

},{"../tree":44}],67:[function(require,module,exports){
(function(tree) {

tree.Selector = function Selector(filters, zoom, frame_offset, elements, attachment, conditions, index) {
    this.elements = elements || [];
    this.attachment = attachment;
    this.filters = filters || {};
    this.frame_offset = frame_offset;
    this.zoom = typeof zoom !== 'undefined' ? zoom : tree.Zoom.all;
    this.conditions = conditions;
    this.index = index;
};

// Determine the specificity of this selector
// based on the specificity of its elements - calling
// Element.specificity() in order to do so
//
// [ID, Class, Filters, Position in document]
tree.Selector.prototype.specificity = function() {
    return this.elements.reduce(function(memo, e) {
        var spec = e.specificity();
        memo[0] += spec[0];
        memo[1] += spec[1];
        return memo;
    }, [0, 0, this.conditions, this.index]);
};

})(require('../tree'));

},{"../tree":44}],68:[function(require,module,exports){
(function (global){
(function(tree) {
var _ = global._ || require('underscore');

// Given a style's name, attachment, definitions, and an environment object,
// return a stringified style for Mapnik
tree.StyleXML = function(name, attachment, definitions, env) {
    var existing = {};
    var image_filters = [], image_filters_inflate = [], direct_image_filters = [], comp_op = [], opacity = [];

    for (var i = 0; i < definitions.length; i++) {
        for (var j = 0; j < definitions[i].rules.length; j++) {
            if (definitions[i].rules[j].name === 'image-filters') {
                image_filters.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'image-filters-inflate') {
                image_filters_inflate.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'direct-image-filters') {
                direct_image_filters.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'comp-op') {
                comp_op.push(definitions[i].rules[j]);
            }
            if (definitions[i].rules[j].name === 'opacity') {
                opacity.push(definitions[i].rules[j]);
            }
        }
    }

    var rules = definitions.map(function(definition) {
        return definition.toXML(env, existing);
    });

    var attrs_xml = '';

    if (image_filters.length) {
        attrs_xml += ' image-filters="' + _.chain(image_filters)
            // prevent identical filters from being duplicated in the style
            .uniq(function(i) { return i.id; }).map(function(f) {
            return f.ev(env).toXML(env, true, ',', 'image-filter');
        }).value().join(',') + '"';
    }

    if (image_filters_inflate.length) {
        attrs_xml += ' image-filters-inflate="' + image_filters_inflate[0].value.ev(env).toString() + '"';
    }

    if (direct_image_filters.length) {
        attrs_xml += ' direct-image-filters="' + _.chain(direct_image_filters)
            // prevent identical filters from being duplicated in the style
            .uniq(function(i) { return i.id; }).map(function(f) {
            return f.ev(env).toXML(env, true, ',', 'direct-image-filter');
        }).value().join(',') + '"';
    }

    if (comp_op.length && comp_op[0].value.ev(env).value != 'src-over') {
        attrs_xml += ' comp-op="' + comp_op[0].value.ev(env).toString() + '"';
    }

    if (opacity.length && opacity[0].value.ev(env).value != 1) {
        attrs_xml += ' opacity="' + opacity[0].value.ev(env).toString() + '"';
    }
    var rule_string = rules.join('');
    if (!attrs_xml && !rule_string) return '';
    return '<Style name="' + name + '" filter-mode="first"' + attrs_xml + '>\n' + rule_string + '</Style>';
};

})(require('../tree'));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tree":44,"underscore":74}],69:[function(require,module,exports){
(function(tree) {

tree.URL = function URL(val, paths) {
    this.value = val;
    this.paths = paths;
};

tree.URL.prototype = {
    is: 'uri',
    toString: function() {
        return this.value.toString();
    },
    ev: function(ctx) {
        return new tree.URL(this.value.ev(ctx), this.paths);
    }
};

})(require('../tree'));

},{"../tree":44}],70:[function(require,module,exports){
(function(tree) {

tree.Value = function Value(value) {
    this.value = value;
};

tree.Value.prototype = {
    is: 'value',
    ev: function(env) {
        if (this.value.length === 1) {
            return this.value[0].ev(env);
        } else {
            return new tree.Value(this.value.map(function(v) {
                return v.ev(env);
            }));
        }
    },
    toString: function(env, selector, sep, format) {
        return this.value.map(function(e) {
            return e.toString(env, format);
        }).join(sep || ', ');
    },
    clone: function() {
        var obj = Object.create(tree.Value.prototype);
        if (Array.isArray(obj)) obj.value = this.value.slice();
        else obj.value = this.value;
        obj.is = this.is;
        return obj;
    },

    toJS: function(env) {
      //var v = this.value[0].value[0];
      var val = this.ev(env);
      var v = val.toString();
      if(val.is === "color" || val.is === 'uri' || val.is === 'string' || val.is === 'keyword') {
        v = "'" + v + "'";
      } else if (val.is === 'field') {
        // replace [variable] by ctx['variable']
        v = v.replace(/\[(.*)\]/g, "data['$1']");
      }else if (val.is === 'call') {
        v = JSON.stringify({
            name: val.name,
            args: val.args
        })
      }
      return "_value = " + v + ";";
    }

};

})(require('../tree'));

},{"../tree":44}],71:[function(require,module,exports){
(function(tree) {

tree.Variable = function Variable(name, index, filename) {
    this.name = name;
    this.index = index;
    this.filename = filename;
};

tree.Variable.prototype = {
    is: 'variable',
    toString: function() {
        return this.name;
    },
    ev: function(env) {
        var variable,
            v,
            name = this.name;

        if (this._css) return this._css;

        var thisframe = env.frames.filter(function(f) {
            return f.name == this.name;
        }.bind(this));
        if (thisframe.length) {
            return thisframe[0].value.ev(env);
        } else {
            env.error({
                message: 'variable ' + this.name + ' is undefined',
                index: this.index,
                type: 'runtime',
                filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }
    }
};

})(require('../tree'));

},{"../tree":44}],72:[function(require,module,exports){
var tree = require('../tree');

// Storage for zoom ranges. Only supports continuous ranges,
// and stores them as bit-sequences so that they can be combined,
// inverted, and compared quickly.
tree.Zoom = function(op, value, index) {
    this.op = op;
    this.value = value;
    this.index = index;
};

tree.Zoom.prototype.setZoom = function(zoom) {
    this.zoom = zoom;
    return this;
};

tree.Zoom.prototype.ev = function(env) {
    var start = 0,
        end = Infinity,
        value = parseInt(this.value.ev(env).toString(), 10),
        zoom = 0;

    if (value > tree.Zoom.maxZoom || value < 0) {
        env.error({
            message: 'Only zoom levels between 0 and ' +
                tree.Zoom.maxZoom + ' supported.',
            index: this.index
        });
    }

    switch (this.op) {
        case '=':
            this.zoom = 1 << value;
            return this;
        case '>':
            start = value + 1;
            break;
        case '>=':
            start = value;
            break;
        case '<':
            end = value - 1;
            break;
        case '<=':
            end = value;
            break;
    }
    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
        if (i >= start && i <= end) {
            zoom |= (1 << i);
        }
    }
    this.zoom = zoom;
    return this;
};

tree.Zoom.prototype.toString = function() {
    return this.zoom;
};

// Covers all zoomlevels from 0 to 22
tree.Zoom.all = 0x7FFFFF;

tree.Zoom.maxZoom = 22;

tree.Zoom.ranges = {
     0: 1000000000,
     1: 500000000,
     2: 200000000,
     3: 100000000,
     4: 50000000,
     5: 25000000,
     6: 12500000,
     7: 6500000,
     8: 3000000,
     9: 1500000,
    10: 750000,
    11: 400000,
    12: 200000,
    13: 100000,
    14: 50000,
    15: 25000,
    16: 12500,
    17: 5000,
    18: 2500,
    19: 1500,
    20: 750,
    21: 500,
    22: 250,
    23: 100
};

// Only works for single range zooms. `[XXX....XXXXX.........]` is invalid.
tree.Zoom.prototype.toXML = function() {
    var conditions = [];
    if (this.zoom != tree.Zoom.all) {
        var start = null, end = null;
        for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
            if (this.zoom & (1 << i)) {
                if (start === null) start = i;
                end = i;
            }
        }
        if (start > 0) conditions.push('    <MaxScaleDenominator>' +
            tree.Zoom.ranges[start] + '</MaxScaleDenominator>\n');
        if (end < 22) conditions.push('    <MinScaleDenominator>' +
            tree.Zoom.ranges[end + 1] + '</MinScaleDenominator>\n');
    }
    return conditions;
};

tree.Zoom.prototype.toString = function() {
    var str = '';
    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {
        str += (this.zoom & (1 << i)) ? 'X' : '.';
    }
    return str;
};

},{"../tree":44}],73:[function(require,module,exports){
(function (__dirname){
var fs = require('fs'),
    path = require('path'),
    existsSync = require('fs').existsSync || require('path').existsSync;

// Load all stated versions into the module exports
module.exports.version = {};

var refs = [
 '2.0.0',
 '2.0.1',
 '2.0.2',
 '2.1.0',
 '2.1.1',
 '2.2.0',
 '2.3.0',
 '3.0.0'
];

refs.map(function(version) {
    module.exports.version[version] = require(path.join(__dirname, version, 'reference.json'));
    var ds_path = path.join(__dirname, version, 'datasources.json');
    if (existsSync(ds_path)) {
        module.exports.version[version].datasources = require(ds_path).datasources;
    }
});

}).call(this,"/node_modules/torque.js/node_modules/carto/node_modules/mapnik-reference")

},{"fs":2,"path":5}],74:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],75:[function(require,module,exports){
module.exports={
  "name": "carto",
  "version": "0.15.1-cdb1",
  "description": "CartoCSS Stylesheet Compiler",
  "url": "https://github.com/cartodb/carto",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/cartodb/carto.git"
  },
  "author": {
    "name": "CartoDB",
    "url": "http://cartodb.com/"
  },
  "keywords": [
    "maps",
    "css",
    "stylesheets"
  ],
  "contributors": [
    {
      "name": "Tom MacWright",
      "email": "macwright@gmail.com"
    },
    {
      "name": "Konstantin Kfer"
    },
    {
      "name": "Alexis Sellier",
      "email": "self@cloudhead.net"
    },
    {
      "name": "Raul Ochoa",
      "email": "rochoa@cartodb.com"
    },
    {
      "name": "Javi Santana",
      "email": "jsantana@cartodb.com"
    }
  ],
  "licenses": [
    {
      "type": "Apache"
    }
  ],
  "bin": {
    "carto": "./bin/carto"
  },
  "man": [
    "./man/carto.1"
  ],
  "main": "./lib/carto/index",
  "engines": {
    "node": ">=0.4.x"
  },
  "dependencies": {
    "underscore": "~1.6.0",
    "mapnik-reference": "~6.0.2",
    "optimist": "~0.6.0"
  },
  "devDependencies": {
    "mocha": "1.12.x",
    "jshint": "0.2.x",
    "sax": "0.1.x",
    "istanbul": "~0.2.14",
    "coveralls": "~2.10.1",
    "browserify": "~7.0.0",
    "uglify-js": "1.3.3"
  },
  "scripts": {
    "pretest": "npm install",
    "test": "mocha -R spec",
    "coverage": "istanbul cover ./node_modules/.bin/_mocha && coveralls < ./coverage/lcov.info"
  },
  "readme": "# CartoCSS\n\n[![Build Status](https://secure.travis-ci.org/mapbox/carto.png)](http://travis-ci.org/mapbox/carto)\n\nIs as stylesheet renderer for javascript, It's an evolution of the Mapnik renderer from Mapbox.\nPlease, see original [Mapbox repo](http://github.com/mapbox/carto) for more information and credits\n\n## Quick Start\n\n```javascript\n// shader is a CartoCSS object\n\nvar cartocss = [\n    '#layer {',\n    ' marker-width: [property]',\n    ' marker-fill: red',\n    '}'\n].join('')\nvar shader = new carto.RendererJS().render(cartocss);\nvar layers = shader.getLayers()\nfor (var i = 0; i < layers.length; ++i) {\n    var layer = layers[i];\n    console.log(\"layer name: \", layer.fullName())\n    console.log(\"- frames: \", layer.frames())\n    console.log(\"- attachment: \", layer.attachment())\n\n    var layerShader = layer.getStyle({ property: 1 }, { zoom: 10 })\n    console.log(layerShader['marker-width']) // 1\n    console.log(layerShader['marker-fill']) // #FF0000\n}\n\n```\n\n# API\n\n## RendererJS\n\n### render(cartocss)\n\n## CartoCSS\n\ncompiled cartocss object\n\n### getLayers\n\nreturn the layers, an array of ``CartoCSS.Layer`` object\n\n### getDefault\n\nreturn the default layer (``CartoCSS.Layer``), usually the Map layer\n\n\n### findLayer(where)\n\nfind a layer using where object.\n\n```\nshader.findLayer({ name: 'test' })\n```\n\n## CartoCSS.Layer\n\n### getStyle(props, context)\n\nreturn the evaluated style:\n    - props: object containing properties needed to render the style. If the cartocss style uses\n      some variables they should be passed in this object\n    - context: rendering context variables like ``zoom`` or animation ``frame``\n\n\n\n\n\n\n\n\n\n\n## Reference Documentation\n\n* [mapbox.com/carto](http://mapbox.com/carto/)\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/cartodb/carto/issues"
  },
  "homepage": "https://github.com/cartodb/carto#readme",
  "_id": "carto@0.15.1-cdb1",
  "_shasum": "62534c2975cbee073f10c6c14a0c7e889c9469e7",
  "_resolved": "https://github.com/CartoDB/carto/archive/master.tar.gz",
  "_from": "https://github.com/CartoDB/carto/archive/master.tar.gz"
}

},{}],76:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],77:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

/**
 * base layer for all google maps
 */
var GMapsLayerView = function(layerModel, gmapsLayer, gmapsMap) {
  this.gmapsLayer = gmapsLayer;
  this.map = this.gmapsMap = gmapsMap;
  this.model = layerModel;
  this.model.bind('change', this._update, this);

  this.type = layerModel.get('type') || layerModel.get('kind');
  this.type = this.type.toLowerCase();
};

_.extend(GMapsLayerView.prototype, Backbone.Events);
_.extend(GMapsLayerView.prototype, {

  // hack function to search layer inside google maps layers
  _searchLayerIndex: function() {
    var self = this;
    var index = -1;
    this.gmapsMap.overlayMapTypes.forEach(
      function(layer, i) {
        if (layer == self) {
          index = i;
        }
      }
    );
    return index;
  },

  /**
   * remove layer from the map and unbind events
   */
  remove: function() {
    if(!this.isBase) {
      var self = this;
      var idx = this._searchLayerIndex();
      if(idx >= 0) {
        this.gmapsMap.overlayMapTypes.removeAt(idx);
      } else if (this.gmapsLayer.setMap){
        this.gmapsLayer.setMap(null);
      }
      this.model.unbind(null, null, this);
      this.unbind();
    }
  },

  refreshView: function() {
    var self = this;
    //reset to update
    if(this.isBase) {
      var a = '_baseLayer';
      this.gmapsMap.setMapTypeId(null);
      this.gmapsMap.mapTypes.set(a, this.gmapsLayer);
      this.gmapsMap.setMapTypeId(a);
    } else {
      var idx = this._searchLayerIndex();
      if(idx >= 0) {
        this.gmapsMap.overlayMapTypes.setAt(idx, this);
      }
    }
  },

  reload: function() { this.refreshView() ; },
  _update: function() { this.refreshView(); }

});

module.exports = GMapsLayerView;

},{"backbone":1,"underscore":76}],78:[function(require,module,exports){
// Depends on cartodb standard bundle being loaded and present in global namespace
var torque = require('torque.js');
var cdb = window.cdb;
var _ = cdb._;
var Backbone = cdb.Backbone;

var GMapsLayerView = require('cdb/geo/gmaps/gmaps-layer-view');
var CartoDBLogo = cdb.geo.common.CartoDBLogo;

var GMapsTorqueLayerView = function(layerModel, gmapsMap) {

  var extra = layerModel.get('extra_params');
  GMapsLayerView.call(this, layerModel, this, gmapsMap);

  var query = this._getQuery(layerModel);
  torque.GMapsTorqueLayer.call(this, {
      table: layerModel.get('table_name'),
      user: layerModel.get('user_name'),
      column: layerModel.get('property'),
      blendmode: layerModel.get('torque-blend-mode'),
      resolution: 1,
      //TODO: manage time columns
      countby: 'count(cartodb_id)',
      sql_api_domain: layerModel.get('sql_api_domain'),
      sql_api_protocol: layerModel.get('sql_api_protocol'),
      sql_api_port: layerModel.get('sql_api_port'),
      tiler_protocol: layerModel.get('tiler_protocol'),
      tiler_domain: layerModel.get('tiler_domain'),
      tiler_port: layerModel.get('tiler_port'),
      maps_api_template: layerModel.get('maps_api_template'),
      stat_tag: layerModel.get('stat_tag'),
      animationDuration: layerModel.get('torque-duration'),
      steps: layerModel.get('torque-steps'),
      sql: query,
      visible: layerModel.get('visible'),
      extra_params: {
        api_key: extra ? extra.map_key: ''
      },
      map: gmapsMap,
      cartodb_logo: layerModel.get('cartodb_logo'),
      attribution: layerModel.get('attribution'),
      cartocss: layerModel.get('cartocss') || layerModel.get('tile_style'),
      named_map: layerModel.get('named_map'),
      auth_token: layerModel.get('auth_token'),
      no_cdn: layerModel.get('no_cdn'),
      loop: layerModel.get('loop') === false? false: true,
  });

  //this.setCartoCSS(this.model.get('tile_style'));
  if (layerModel.get('visible')) {
    this.play();
  }

  layerModel.initForTorqueLayerView(this);
};

_.extend(
  GMapsTorqueLayerView.prototype,
  GMapsLayerView.prototype,
  torque.GMapsTorqueLayer.prototype,
  {

  _update: function() {
    var changed = this.model.changedAttributes();
    if(changed === false) return;
    changed.tile_style && this.setCartoCSS(this.model.get('tile_style'));
    if ('query' in changed || 'query_wrapper' in changed) {
      this.setSQL(this._getQuery(this.model));
    }
    if ('visible' in changed)
      this.model.get('visible') ? this.show(): this.hide();
  },

  _getQuery: function(layerModel) {
    var query = layerModel.get('query');
    var qw = layerModel.get('query_wrapper');
    if(qw) {
      query = _.template(qw)({ sql: query || ('select * from ' + layerModel.get('table_name')) });
    }
    return query;
  },

  refreshView: function() {
    //TODO: update screen
  },

  onAdd: function() {
    torque.GMapsTorqueLayer.prototype.onAdd.apply(this);
    // Add CartoDB logo
    if (this.options.cartodb_logo != false)
      CartoDBLogo.addWadus({ left: 74, bottom:8 }, 2000, this.map.getDiv())
  },

  onTilesLoaded: function() {
    //this.trigger('load');
    Backbone.Events.trigger.call(this, 'load');
  },

  onTilesLoading: function() {
    Backbone.Events.trigger.call(this, 'loading');
  }

});

module.exports = GMapsTorqueLayerView;

},{"cdb/geo/gmaps/gmaps-layer-view":77,"torque.js":19}],79:[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

/**
 * base layer for all leaflet layers
 */
var LeafletLayerView = function(layerModel, leafletLayer, leafletMap) {
  this.leafletLayer = leafletLayer;
  this.leafletMap = leafletMap;
  this.model = layerModel;

  this.setModel(layerModel);

  this.type = layerModel.get('type') || layerModel.get('kind');
  this.type = this.type.toLowerCase();
};

_.extend(LeafletLayerView.prototype, Backbone.Events);
_.extend(LeafletLayerView.prototype, {

  setModel: function(model) {
    if (this.model) {
      this.model.unbind('change', this._modelUpdated, this);
    }
    this.model = model;
    this.model.bind('change', this._modelUpdated, this);
  },

  /**
   * remove layer from the map and unbind events
   */
  remove: function() {
    this.leafletMap.removeLayer(this.leafletLayer);
    this.trigger('remove', this);
    this.model.unbind(null, null, this);
    this.unbind();
  },

  reload: function() {
    this.leafletLayer.redraw();
  }

});

module.exports = LeafletLayerView;

},{"backbone":1,"underscore":76}],80:[function(require,module,exports){
// NOTE this is ONLY used for torque bundle AND the leaflet.spec.js, that assumed torque lib to be loaded)
// Depends on cartodb to be loaded and present in global namespace.
var cdb = window.cdb;
var L = cdb.L;
var _ = cdb._;
var util = cdb.core.util;
var LeafletLayerView = require('cdb/geo/leaflet/leaflet-layer-view');
var CartoDBLogo = cdb.geo.common.CartoDBLogo;

/**
 * leaflet torque layer
 */
var LeafletTorqueLayer = L.TorqueLayer.extend({

  initialize: function(layerModel, leafletMap) {
    var extra = layerModel.get('extra_params');

    var query = this._getQuery(layerModel);

    // initialize the base layers
    L.TorqueLayer.prototype.initialize.call(this, {
      table: layerModel.get('table_name'),
      user: layerModel.get('user_name'),
      column: layerModel.get('property'),
      blendmode: layerModel.get('torque-blend-mode'),
      resolution: 1,
      //TODO: manage time columns
      countby: 'count(cartodb_id)',
      sql_api_domain: layerModel.get('sql_api_domain'),
      sql_api_protocol: layerModel.get('sql_api_protocol'),
      sql_api_port: layerModel.get('sql_api_port'),
      tiler_protocol: layerModel.get('tiler_protocol'),
      tiler_domain: layerModel.get('tiler_domain'),
      tiler_port: layerModel.get('tiler_port'),
      maps_api_template: layerModel.get('maps_api_template'),
      stat_tag: layerModel.get('stat_tag'),
      animationDuration: layerModel.get('torque-duration'),
      steps: layerModel.get('torque-steps'),
      sql: query,
      visible: layerModel.get('visible'),
      extra_params: {
        api_key: extra ? extra.map_key: ''
      },
      cartodb_logo: layerModel.get('cartodb_logo'),
      attribution: layerModel.get('attribution'),
      cartocss: layerModel.get('cartocss') || layerModel.get('tile_style'),
      named_map: layerModel.get('named_map'),
      auth_token: layerModel.get('auth_token'),
      no_cdn: layerModel.get('no_cdn'),
      dynamic_cdn: layerModel.get('dynamic_cdn'),
      loop: layerModel.get('loop') === false? false: true,
      instanciateCallback: function() {
        var cartocss = layerModel.get('cartocss') || layerModel.get('tile_style');

        return '_cdbct_' + util.uniqueCallbackName(cartocss + query);
      }
    });

    LeafletLayerView.call(this, layerModel, this, leafletMap);

    // match leaflet events with backbone events
    this.fire = this.trigger;

    //this.setCartoCSS(layerModel.get('tile_style'));
    if (layerModel.get('visible')) {
      this.play();
    }

    this.bind('tilesLoaded', function() {
      this.trigger('load');
    }, this);

    this.bind('tilesLoading', function() {
      this.trigger('loading');
    }, this);

    layerModel.initForTorqueLayerView(this);
  },

  onAdd: function(map) {
    L.TorqueLayer.prototype.onAdd.apply(this, [map]);
    // Add CartoDB logo
    if (this.options.cartodb_logo != false)
      CartoDBLogo.addWadus({ left:8, bottom:8 }, 0, map._container)
  },

  _getQuery: function(layerModel) {
    var query = layerModel.get('query');
    var qw = layerModel.get('query_wrapper');
    if(qw) {
      query = _.template(qw)({ sql: query || ('select * from ' + layerModel.get('table_name')) });
    }
    return query;
  },

  _modelUpdated: function(model) {
    var changed = this.model.changedAttributes();
    if(changed === false) return;
    /*
    changed.tile_style && this.setCartoCSS(this.model.get('tile_style'));
    if ('query' in changed || 'query_wrapper' in changed) {
      this.setSQL(this._getQuery(this.model));
    }
    */

    if ('visible' in changed)
      this.model.get('visible') ? this.show(): this.hide();

    if ('urls' in changed) {
      // REAL HACK
      this.provider.templateUrl = this.model.get('urls').tiles[0];
      this.provider._setReady(true);
      this._reloadTiles();
    }
  }
});

_.extend(LeafletTorqueLayer.prototype, LeafletLayerView.prototype);

module.exports = LeafletTorqueLayer;

},{"cdb/geo/leaflet/leaflet-layer-view":79}],81:[function(require,module,exports){
var torque = window.torque = require('torque.js'); // standalone torque lib, required for gmaps/leaflet layer view

// Get and mutate the global cdb object, add expected objects for gmaps/leaflet if present:
var cdb = window.cdb;
if (!cdb) {
  throw new Error('cartodb.js is required for this lib to work, load it before this one');
}

if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
  cdb.geo.GMapsTorqueLayerView = require('./geo/gmaps/gmaps-torque-layer-view');
}

cdb.geo.LeafletTorqueLayer = require('./geo/leaflet/leaflet-torque-layer');

cdb.moduleLoad('torque', torque);

module.exports = torque;

},{"./geo/gmaps/gmaps-torque-layer-view":78,"./geo/leaflet/leaflet-torque-layer":80,"torque.js":19}]},{},[81])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2FuaW1hdG9yLXN0ZXBzLXJhbmdlLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2FuaW1hdG9yLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2NhcnRvY3NzX3JlZmVyZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9jb21tb24uanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9nbWFwcy9DYW52YXNMYXllci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9nbWFwcy9jYW52YXNfdGlsZV9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9nbWFwcy9nbWFwc190aWxlbG9hZGVyX21peGluLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2dtYXBzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2dtYXBzL3RvcnF1ZS5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9sZWFmbGV0L2NhbnZhc19sYXllci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9sZWFmbGV0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2xlYWZsZXQvbGVhZmxldF90aWxlbG9hZGVyX21peGluLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL2xlYWZsZXQvdG9ycXVlLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL21hdGguanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvbWVyY2F0b3IuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcHJvZmlsZXIuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcHJvdmlkZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcHJvdmlkZXIvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9wcm92aWRlci9qc29uYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcHJvdmlkZXIvdGlsZWpzb24uanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcHJvdmlkZXIvd2luZHNoYWZ0LmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9saWIvdG9ycXVlL3JlbmRlcmVyL2NhcnRvY3NzX3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9yZW5kZXJlci9wb2ludC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbGliL3RvcnF1ZS9yZW5kZXJlci9yZWN0YW5nbGUuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcmVuZGVyZXIvdG9ycXVlX2ZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL2xpYi90b3JxdWUvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3JlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3JlbmRlcmVyX2pzLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RvcnF1ZS1yZWZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2NhbGwuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2NvbW1lbnQuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9kZWZpbml0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZGltZW5zaW9uLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9maWVsZC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ZpbHRlcnNldC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ZvbnRzZXQuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9mcmFtZV9vZmZzZXQuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9pbWFnZWZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL2ludmFsaWQuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9rZXl3b3JkLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9saXRlcmFsLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvb3BlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvcXVvdGVkLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvcmVmZXJlbmNlLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvcnVsZS5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3J1bGVzZXQuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS9zZWxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3RvcnF1ZS5qcy9ub2RlX21vZHVsZXMvY2FydG8vbGliL2NhcnRvL3RyZWUvdmFsdWUuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9saWIvY2FydG8vdHJlZS92YXJpYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL2xpYi9jYXJ0by90cmVlL3pvb20uanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9ub2RlX21vZHVsZXMvbWFwbmlrLXJlZmVyZW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90b3JxdWUuanMvbm9kZV9tb2R1bGVzL2NhcnRvL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJub2RlX21vZHVsZXMvdG9ycXVlLmpzL25vZGVfbW9kdWxlcy9jYXJ0by9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwic3JjL2dlby9nbWFwcy9nbWFwcy1sYXllci12aWV3LmpzIiwic3JjL2dlby9nbWFwcy9nbWFwcy10b3JxdWUtbGF5ZXItdmlldy5qcyIsInNyYy9nZW8vbGVhZmxldC9sZWFmbGV0LWxheWVyLXZpZXcuanMiLCJzcmMvZ2VvL2xlYWZsZXQvbGVhZmxldC10b3JxdWUtbGF5ZXIuanMiLCJzcmMvdG9ycXVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0MkRBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3d0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNhcnRvZGIuanMgdmVyc2lvbjogMy4xNS44XG4vLyB1bmNvbXByZXNzZWQgdmVyc2lvbjogY2FydG9kYi5tb2QudG9ycXVlLnVuY29tcHJlc3NlZC5qc1xuLy8gc2hhOiAzZjE0NmU2YzcwZTM5OWE0NGYxNGUyNDU1OGUyMjhiMjkzMmExZjk2XG4oZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vICAgICBCYWNrYm9uZS5qcyAxLjIuM1xuXG4vLyAgICAgKGMpIDIwMTAtMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgLy8gV2UgdXNlIGBzZWxmYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICB2YXIgcm9vdCA9ICh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PSBnbG9iYWwgJiYgZ2xvYmFsKTtcblxuICAvLyBTZXQgdXAgQmFja2JvbmUgYXBwcm9wcmlhdGVseSBmb3IgdGhlIGVudmlyb25tZW50LiBTdGFydCB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xuICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICB9KTtcblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksICQ7XG4gICAgdHJ5IHsgJCA9IHJlcXVpcmUoJ2pxdWVyeScpOyB9IGNhdGNoKGUpIHt9XG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIHt9LCByb290Ll8sIChyb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKSk7XG4gIH1cblxufShmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYSBjb21tb24gYXJyYXkgbWV0aG9kIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LiBLZWVwIGluIHN5bmMgd2l0aCBgcGFja2FnZS5qc29uYC5cbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjIuMyc7XG5cbiAgLy8gRm9yIEJhY2tib25lJ3MgcHVycG9zZXMsIGpRdWVyeSwgWmVwdG8sIEVuZGVyLCBvciBNeSBMaWJyYXJ5IChraWRkaW5nKSBvd25zXG4gIC8vIHRoZSBgJGAgdmFyaWFibGUuXG4gIEJhY2tib25lLiQgPSAkO1xuXG4gIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxuICAvLyB0byBpdHMgcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBCYWNrYm9uZSBvYmplY3QuXG4gIEJhY2tib25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSFRUUGAgdG8gc3VwcG9ydCBsZWdhY3kgSFRUUCBzZXJ2ZXJzLiBTZXR0aW5nIHRoaXMgb3B0aW9uXG4gIC8vIHdpbGwgZmFrZSBgXCJQQVRDSFwiYCwgYFwiUFVUXCJgIGFuZCBgXCJERUxFVEVcImAgcmVxdWVzdHMgdmlhIHRoZSBgX21ldGhvZGAgcGFyYW1ldGVyIGFuZFxuICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICBCYWNrYm9uZS5lbXVsYXRlSFRUUCA9IGZhbHNlO1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxuICAvLyBgYXBwbGljYXRpb24vanNvbmAgcmVxdWVzdHMgLi4uIHRoaXMgd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBQcm94eSBCYWNrYm9uZSBjbGFzcyBtZXRob2RzIHRvIFVuZGVyc2NvcmUgZnVuY3Rpb25zLCB3cmFwcGluZyB0aGUgbW9kZWwnc1xuICAvLyBgYXR0cmlidXRlc2Agb2JqZWN0IG9yIGNvbGxlY3Rpb24ncyBgbW9kZWxzYCBhcnJheSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAgLy9cbiAgLy8gY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldCgnYWdlJykgPiAxMCB9KTtcbiAgLy8gY29sbGVjdGlvbi5lYWNoKHRoaXMuYWRkVmlldyk7XG4gIC8vXG4gIC8vIGBGdW5jdGlvbiNhcHBseWAgY2FuIGJlIHNsb3cgc28gd2UgdXNlIHRoZSBtZXRob2QncyBhcmcgY291bnQsIGlmIHdlIGtub3cgaXQuXG4gIHZhciBhZGRNZXRob2QgPSBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBkZWZhdWx0VmFsLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB2YXIgYWRkVW5kZXJzY29yZU1ldGhvZHMgPSBmdW5jdGlvbihDbGFzcywgbWV0aG9kcywgYXR0cmlidXRlKSB7XG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKGxlbmd0aCwgbWV0aG9kKSB7XG4gICAgICBpZiAoX1ttZXRob2RdKSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGFkZE1ldGhvZChsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGBjb2xsZWN0aW9uLnNvcnRCeSgnYXR0cicpYCBhbmQgYGNvbGxlY3Rpb24uZmluZFdoZXJlKHtpZDogMX0pYC5cbiAgdmFyIGNiID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGluc3RhbmNlKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHJldHVybiBpdGVyYXRlZTtcbiAgICBpZiAoXy5pc09iamVjdChpdGVyYXRlZSkgJiYgIWluc3RhbmNlLl9pc01vZGVsKGl0ZXJhdGVlKSkgcmV0dXJuIG1vZGVsTWF0Y2hlcihpdGVyYXRlZSk7XG4gICAgaWYgKF8uaXNTdHJpbmcoaXRlcmF0ZWUpKSByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldChpdGVyYXRlZSk7IH07XG4gICAgcmV0dXJuIGl0ZXJhdGVlO1xuICB9O1xuICB2YXIgbW9kZWxNYXRjaGVyID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGEgY3VzdG9tIGV2ZW50IGNoYW5uZWwuIFlvdSBtYXkgYmluZCBhIGNhbGxiYWNrIHRvIGFuIGV2ZW50IHdpdGggYG9uYCBvclxuICAvLyByZW1vdmUgd2l0aCBgb2ZmYDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHt9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGBcImNoYW5nZSBibHVyXCIsIGNhbGxiYWNrYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50XG4gIC8vIG1hcHMgYHtldmVudDogY2FsbGJhY2t9YCkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG4gICAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdm9pZCAwICYmICdjb250ZXh0JyBpbiBvcHRzICYmIG9wdHMuY29udGV4dCA9PT0gdm9pZCAwKSBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgIGZvciAobmFtZXMgPSBfLmtleXMobmFtZSk7IGkgPCBuYW1lcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzQXBpKGl0ZXJhdGVlLCBldmVudHMsIG5hbWVzW2ldLCBuYW1lW25hbWVzW2ldXSwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICYmIGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcyBieSBkZWxlZ2F0aW5nIHRoZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgZm9yIChuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWVzW2ldLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmFsbHksIHN0YW5kYXJkIGV2ZW50cy5cbiAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgLy8gdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGludGVybmFsT24odGhpcywgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEd1YXJkIHRoZSBgbGlzdGVuaW5nYCBhcmd1bWVudCBmcm9tIHRoZSBwdWJsaWMgQVBJLlxuICB2YXIgaW50ZXJuYWxPbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQsIGxpc3RlbmluZykge1xuICAgIG9iai5fZXZlbnRzID0gZXZlbnRzQXBpKG9uQXBpLCBvYmouX2V2ZW50cyB8fCB7fSwgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgY3R4OiBvYmosXG4gICAgICAgIGxpc3RlbmluZzogbGlzdGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gb2JqLl9saXN0ZW5lcnMgfHwgKG9iai5fbGlzdGVuZXJzID0ge30pO1xuICAgICAgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF0gPSBsaXN0ZW5pbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gLiBUZWxsICp0aGlzKiBvYmplY3QgdG8gbGlzdGVuIHRvXG4gIC8vIGFuIGV2ZW50IGluIGFub3RoZXIgb2JqZWN0Li4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzIGxpc3RlbmluZyB0b1xuICAvLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbiAgRXZlbnRzLmxpc3RlblRvID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGlkID0gb2JqLl9saXN0ZW5JZCB8fCAob2JqLl9saXN0ZW5JZCA9IF8udW5pcXVlSWQoJ2wnKSk7XG4gICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG8gfHwgKHRoaXMuX2xpc3RlbmluZ1RvID0ge30pO1xuICAgIHZhciBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF07XG5cbiAgICAvLyBUaGlzIG9iamVjdCBpcyBub3QgbGlzdGVuaW5nIHRvIGFueSBvdGhlciBldmVudHMgb24gYG9iamAgeWV0LlxuICAgIC8vIFNldHVwIHRoZSBuZWNlc3NhcnkgcmVmZXJlbmNlcyB0byB0cmFjayB0aGUgbGlzdGVuaW5nIGNhbGxiYWNrcy5cbiAgICBpZiAoIWxpc3RlbmluZykge1xuICAgICAgdmFyIHRoaXNJZCA9IHRoaXMuX2xpc3RlbklkIHx8ICh0aGlzLl9saXN0ZW5JZCA9IF8udW5pcXVlSWQoJ2wnKSk7XG4gICAgICBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF0gPSB7b2JqOiBvYmosIG9iaklkOiBpZCwgaWQ6IHRoaXNJZCwgbGlzdGVuaW5nVG86IGxpc3RlbmluZ1RvLCBjb3VudDogMH07XG4gICAgfVxuXG4gICAgLy8gQmluZCBjYWxsYmFja3Mgb24gb2JqLCBhbmQga2VlcCB0cmFjayBvZiB0aGVtIG9uIGxpc3RlbmluZy5cbiAgICBpbnRlcm5hbE9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIHRoaXMsIGxpc3RlbmluZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IGFkZHMgYSBjYWxsYmFjayB0byB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb25BcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV0gfHwgKGV2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBjdHggPSBvcHRpb25zLmN0eCwgbGlzdGVuaW5nID0gb3B0aW9ucy5saXN0ZW5pbmc7XG4gICAgICBpZiAobGlzdGVuaW5nKSBsaXN0ZW5pbmcuY291bnQrKztcblxuICAgICAgaGFuZGxlcnMucHVzaCh7IGNhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IGN0eCwgbGlzdGVuaW5nOiBsaXN0ZW5pbmcgfSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gIEV2ZW50cy5vZmYgPSAgZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzQXBpKG9mZkFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywge1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBsaXN0ZW5lcnM6IHRoaXMuX2xpc3RlbmVyc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRlbGwgdGhpcyBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZWl0aGVyIHNwZWNpZmljIGV2ZW50cyAuLi4gb3JcbiAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgRXZlbnRzLnN0b3BMaXN0ZW5pbmcgPSAgZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvO1xuICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGlkcyA9IG9iaiA/IFtvYmouX2xpc3RlbklkXSA6IF8ua2V5cyhsaXN0ZW5pbmdUbyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkc1tpXV07XG5cbiAgICAgIC8vIElmIGxpc3RlbmluZyBkb2Vzbid0IGV4aXN0LCB0aGlzIG9iamVjdCBpcyBub3QgY3VycmVudGx5XG4gICAgICAvLyBsaXN0ZW5pbmcgdG8gb2JqLiBCcmVhayBvdXQgZWFybHkuXG4gICAgICBpZiAoIWxpc3RlbmluZykgYnJlYWs7XG5cbiAgICAgIGxpc3RlbmluZy5vYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKF8uaXNFbXB0eShsaXN0ZW5pbmdUbykpIHRoaXMuX2xpc3RlbmluZ1RvID0gdm9pZCAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IHJlbW92ZXMgYSBjYWxsYmFjayBmcm9tIHRoZSBgZXZlbnRzYCBvYmplY3QuXG4gIHZhciBvZmZBcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFldmVudHMpIHJldHVybjtcblxuICAgIHZhciBpID0gMCwgbGlzdGVuaW5nO1xuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBsaXN0ZW5lcnMgPSBvcHRpb25zLmxpc3RlbmVycztcblxuICAgIC8vIERlbGV0ZSBhbGwgZXZlbnRzIGxpc3RlbmVycyBhbmQgXCJkcm9wXCIgZXZlbnRzLlxuICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgIHZhciBpZHMgPSBfLmtleXMobGlzdGVuZXJzKTtcbiAgICAgIGZvciAoOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmluZyA9IGxpc3RlbmVyc1tpZHNbaV1dO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5pbmcubGlzdGVuaW5nVG9bbGlzdGVuaW5nLm9iaklkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogXy5rZXlzKGV2ZW50cyk7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuXG4gICAgICAvLyBCYWlsIG91dCBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIHN0b3JlZC5cbiAgICAgIGlmICghaGFuZGxlcnMpIGJyZWFrO1xuXG4gICAgICAvLyBSZXBsYWNlIGV2ZW50cyBpZiB0aGVyZSBhcmUgYW55IHJlbWFpbmluZy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbal07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjayAmJlxuICAgICAgICAgICAgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2suX2NhbGxiYWNrIHx8XG4gICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dCAhPT0gaGFuZGxlci5jb250ZXh0XG4gICAgICAgICkge1xuICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RlbmluZyA9IGhhbmRsZXIubGlzdGVuaW5nO1xuICAgICAgICAgIGlmIChsaXN0ZW5pbmcgJiYgLS1saXN0ZW5pbmcuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbGlzdGVuaW5nLmlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5pbmcubGlzdGVuaW5nVG9bbGlzdGVuaW5nLm9iaklkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRhaWwgZXZlbnQgaWYgdGhlIGxpc3QgaGFzIGFueSBldmVudHMuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGgpIHtcbiAgICAgICAgZXZlbnRzW25hbWVdID0gcmVtYWluaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF8uc2l6ZShldmVudHMpKSByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0cyBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuIElmIG11bHRpcGxlIGV2ZW50c1xuICAvLyBhcmUgcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgaGFuZGxlciB3aWxsIGZpcmVcbiAgLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbiAgRXZlbnRzLm9uY2UgPSAgZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5vZmYsIHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIHZvaWQgMCwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uY2VgLlxuICBFdmVudHMubGlzdGVuVG9PbmNlID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5zdG9wTGlzdGVuaW5nLCB0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG4gIH07XG5cbiAgLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbiAgLy8gYG9mZmVyYCB1bmJpbmRzIHRoZSBgb25jZVdyYXBwZXJgIGFmdGVyIGl0IGhhcyBiZWVuIGNhbGxlZC5cbiAgdmFyIG9uY2VNYXAgPSBmdW5jdGlvbihtYXAsIG5hbWUsIGNhbGxiYWNrLCBvZmZlcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIG9uY2UgPSBtYXBbbmFtZV0gPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9mZmVyKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4gIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICBFdmVudHMudHJpZ2dlciA9ICBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2IsIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gVGhlIHByZWZpeCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY2xpZW50IGlkIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgbW9kZWxzIGxvY2FsbHkuXG4gICAgLy8gWW91IG1heSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3JlIGV4cGVyaWVuY2luZyBuYW1lIGNsYXNoZXMgd2l0aCBtb2RlbCBpZHMuXG4gICAgY2lkUHJlZml4OiAnYycsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNwZWNpYWwtY2FzZWQgcHJveHkgdG8gdW5kZXJzY29yZSdzIGBfLm1hdGNoZXNgIG1ldGhvZC5cbiAgICBtYXRjaGVzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuICEhXy5pdGVyYXRlZShhdHRycywgdGhpcykodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QsIGZpcmluZyBgXCJjaGFuZ2VcImAuIFRoaXMgaXNcbiAgICAvLyB0aGUgY29yZSBwcmltaXRpdmUgb3BlcmF0aW9uIG9mIGEgbW9kZWwsIHVwZGF0aW5nIHRoZSBkYXRhIGFuZCBub3RpZnlpbmdcbiAgICAvLyBhbnlvbmUgd2hvIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBpbiBzdGF0ZS4gVGhlIGhlYXJ0IG9mIHRoZSBiZWFzdC5cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdmFyIHVuc2V0ICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgdmFyIHNpbGVudCAgICAgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgIHZhciBjaGFuZ2VzICAgID0gW107XG4gICAgICB2YXIgY2hhbmdpbmcgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICB2YXIgcHJldiAgICA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gRm9yIGVhY2ggYHNldGAgYXR0cmlidXRlLCB1cGRhdGUgb3IgZGVsZXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgY2hhbmdlZFthdHRyXTtcbiAgICAgICAgfVxuICAgICAgICB1bnNldCA/IGRlbGV0ZSBjdXJyZW50W2F0dHJdIDogY3VycmVudFthdHRyXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBgaWRgLlxuICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0KHRoaXMuaWRBdHRyaWJ1dGUpO1xuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRpZmZbYXR0cl07XG4gICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCB2YWwpKSBjb250aW51ZTtcbiAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfLnNpemUoY2hhbmdlZCkgPyBjaGFuZ2VkIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudCB3YXMgZmlyZWQuXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCBhdCB0aGUgdGltZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBtb2RlbCBmcm9tIHRoZSBzZXJ2ZXIsIG1lcmdpbmcgdGhlIHJlc3BvbnNlIHdpdGggdGhlIG1vZGVsJ3NcbiAgICAvLyBsb2NhbCBhdHRyaWJ1dGVzLiBBbnkgY2hhbmdlZCBhdHRyaWJ1dGVzIHdpbGwgdHJpZ2dlciBhIFwiY2hhbmdlXCIgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7cGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKCFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZSwgcGFyc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YWl0ID0gb3B0aW9ucy53YWl0O1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgaWYgKGF0dHJzICYmICF3YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgc2VydmVyLXNpZGUgc2F2ZSwgdGhlIGNsaWVudCBpcyAob3B0aW9uYWxseSlcbiAgICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgc2VydmVyLXNpZGUgc3RhdGUuXG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgLy8gRW5zdXJlIGF0dHJpYnV0ZXMgYXJlIHJlc3RvcmVkIGR1cmluZyBzeW5jaHJvbm91cyBzYXZlcy5cbiAgICAgICAgbW9kZWwuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG9wdGlvbnMucGFyc2UgPyBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSA6IHJlc3A7XG4gICAgICAgIGlmICh3YWl0KSBzZXJ2ZXJBdHRycyA9IF8uZXh0ZW5kKHt9LCBhdHRycywgc2VydmVyQXR0cnMpO1xuICAgICAgICBpZiAoc2VydmVyQXR0cnMgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YCB0byBwcm9wZXJseSBmaW5kIG5ldyBpZHMuXG4gICAgICBpZiAoYXR0cnMgJiYgd2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcblxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJyAmJiAhb3B0aW9ucy5hdHRycykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgdmFyIHhociA9IHRoaXMuc3luYyhtZXRob2QsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBSZXN0b3JlIGF0dHJpYnV0ZXMuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgcmVtb3ZlcyB0aGUgbW9kZWwgZnJvbSBpdHMgY29sbGVjdGlvbiwgaWYgaXQgaGFzIG9uZS5cbiAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHdhaXQpIGRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHhociA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBfLmRlZmVyKG9wdGlvbnMuc3VjY2Vzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIXdhaXQpIGRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxuICAgIC8vIHVzaW5nIEJhY2tib25lJ3MgcmVzdGZ1bCBtZXRob2RzLCBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgY2FsbGVkLlxuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmFzZSA9XG4gICAgICAgIF8ucmVzdWx0KHRoaXMsICd1cmxSb290JykgfHxcbiAgICAgICAgXy5yZXN1bHQodGhpcy5jb2xsZWN0aW9uLCAndXJsJykgfHxcbiAgICAgICAgdXJsRXJyb3IoKTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHJldHVybiBiYXNlO1xuICAgICAgdmFyIGlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmRlZmF1bHRzKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmV4dCBjb21wbGV0ZSBzZXQgb2YgbW9kZWwgYXR0cmlidXRlcyxcbiAgICAvLyByZXR1cm5pbmcgYHRydWVgIGlmIGFsbCBpcyB3ZWxsLiBPdGhlcndpc2UsIGZpcmUgYW4gYFwiaW52YWxpZFwiYCBldmVudC5cbiAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudmFsaWRhdGUgfHwgIXRoaXMudmFsaWRhdGUpIHJldHVybiB0cnVlO1xuICAgICAgYXR0cnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHRoaXMudmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpIHx8IG51bGw7XG4gICAgICBpZiAoIWVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGVycm9yLCBfLmV4dGVuZChvcHRpb25zLCB7dmFsaWRhdGlvbkVycm9yOiBlcnJvcn0pKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLCBtYXBwZWQgdG8gdGhlXG4gIC8vIG51bWJlciBvZiBhcmd1bWVudHMgdGhleSB0YWtlLlxuICB2YXIgbW9kZWxNZXRob2RzID0geyBrZXlzOiAxLCB2YWx1ZXM6IDEsIHBhaXJzOiAxLCBpbnZlcnQ6IDEsIHBpY2s6IDAsXG4gICAgICBvbWl0OiAwLCBjaGFpbjogMSwgaXNFbXB0eTogMSB9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBhZGRVbmRlcnNjb3JlTWV0aG9kcyhNb2RlbCwgbW9kZWxNZXRob2RzLCAnYXR0cmlidXRlcycpO1xuXG4gIC8vIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBCYWNrYm9uZSBDb2xsZWN0aW9uIGlzXG4gIC8vIG1vcmUgYW5hbG9nb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuICAvLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cbiAgLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuICAvLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuICAvLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cblxuICAvLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbiAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4gIC8vIGl0cyBtb2RlbHMgaW4gc29ydCBvcmRlciwgYXMgdGhleSdyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgdmFyIENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XG4gIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZX07XG5cbiAgLy8gU3BsaWNlcyBgaW5zZXJ0YCBpbnRvIGBhcnJheWAgYXQgaW5kZXggYGF0YC5cbiAgdmFyIHNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LCBpbnNlcnQsIGF0KSB7XG4gICAgYXQgPSBNYXRoLm1pbihNYXRoLm1heChhdCwgMCksIGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIHRhaWwgPSBBcnJheShhcnJheS5sZW5ndGggLSBhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGluc2VydC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB0YWlsW2ldID0gYXJyYXlbaSArIGF0XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFycmF5W2kgKyBhdF0gPSBpbnNlcnRbaV07XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIGFycmF5W2kgKyBsZW5ndGggKyBhdF0gPSB0YWlsW2ldO1xuICB9O1xuXG4gIC8vIERlZmluZSB0aGUgQ29sbGVjdGlvbidzIGluaGVyaXRhYmxlIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgbW9kZWw6IE1vZGVsLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCkgeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC4gYG1vZGVsc2AgbWF5IGJlIEJhY2tib25lXG4gICAgLy8gTW9kZWxzIG9yIHJhdyBKYXZhU2NyaXB0IG9iamVjdHMgdG8gYmUgY29udmVydGVkIHRvIE1vZGVscywgb3IgYW55XG4gICAgLy8gY29tYmluYXRpb24gb2YgdGhlIHR3by5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xuICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlTW9kZWxzKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50ICYmIHJlbW92ZWQpIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2luZ3VsYXIgPyByZW1vdmVkWzBdIDogcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RlbHMgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0T3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSAmJiAhdGhpcy5faXNNb2RlbChtb2RlbHMpKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBtb2RlbHMuc2xpY2UoKTtcblxuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIGlmIChhdCAhPSBudWxsKSBhdCA9ICthdDtcbiAgICAgIGlmIChhdCA8IDApIGF0ICs9IHRoaXMubGVuZ3RoICsgMTtcblxuICAgICAgdmFyIHNldCA9IFtdO1xuICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgIHZhciBtb2RlbE1hcCA9IHt9O1xuXG4gICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQ7XG4gICAgICB2YXIgbWVyZ2UgPSBvcHRpb25zLm1lcmdlO1xuICAgICAgdmFyIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuXG4gICAgICB2YXIgc29ydCA9IGZhbHNlO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIChhdCA9PSBudWxsKSAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIHZhciBtb2RlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldO1xuXG4gICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KG1vZGVsKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgaWYgKG1lcmdlICYmIG1vZGVsICE9PSBleGlzdGluZykge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5faXNNb2RlbChtb2RlbCkgPyBtb2RlbC5hdHRyaWJ1dGVzIDogbW9kZWw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0KSBzb3J0ID0gZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSkge1xuICAgICAgICAgICAgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChleGlzdGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kZWxNYXBbbW9kZWwuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICBzZXQucHVzaChtb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBzdGFsZSBtb2RlbHMuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tpXTtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwW21vZGVsLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciByZXBsYWNlID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmU7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCAmJiByZXBsYWNlKSB7XG4gICAgICAgIG9yZGVyQ2hhbmdlZCA9IHRoaXMubGVuZ3RoICE9IHNldC5sZW5ndGggfHwgXy5zb21lKHRoaXMubW9kZWxzLCBmdW5jdGlvbihtb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWwgIT09IHNldFtpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICBzcGxpY2UodGhpcy5tb2RlbHMsIHNldCwgMCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCB0b0FkZCwgYXQgPT0gbnVsbCA/IHRoaXMubGVuZ3RoIDogYXQpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhdCAhPSBudWxsKSBvcHRpb25zLmluZGV4ID0gYXQgKyBpO1xuICAgICAgICAgIG1vZGVsID0gdG9BZGRbaV07XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0IHx8IG9yZGVyQ2hhbmdlZCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgdG9SZW1vdmUubGVuZ3RoKSB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICB1bnNoaWZ0OiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IDB9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBzaGlmdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCgwKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcy5tb2RlbHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhIG1vZGVsIGZyb20gdGhlIHNldCBieSBpZC5cbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKHRoaXMuX2lzTW9kZWwob2JqKSA/IG9iai5hdHRyaWJ1dGVzIDogb2JqKTtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHwgdGhpcy5fYnlJZFtpZF0gfHwgdGhpcy5fYnlJZFtvYmouY2lkXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCArPSB0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBtb2RlbHMgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlcyBvZlxuICAgIC8vIGBmaWx0ZXJgLlxuICAgIHdoZXJlOiBmdW5jdGlvbihhdHRycywgZmlyc3QpIHtcbiAgICAgIHJldHVybiB0aGlzW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKGF0dHJzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuY29tcGFyYXRvcjtcbiAgICAgIGlmICghY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbXBhcmF0b3IubGVuZ3RoO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb21wYXJhdG9yKSkgY29tcGFyYXRvciA9IF8uYmluZChjb21wYXJhdG9yLCB0aGlzKTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAobGVuZ3RoID09PSAxIHx8IF8uaXNTdHJpbmcoY29tcGFyYXRvcikpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeShjb21wYXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kZWxzLnNvcnQoY29tcGFyYXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQbHVjayBhbiBhdHRyaWJ1dGUgZnJvbSBlYWNoIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBsdWNrOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5pbnZva2UodGhpcy5tb2RlbHMsICdnZXQnLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIGRlZmF1bHQgc2V0IG9mIG1vZGVscyBmb3IgdGhpcyBjb2xsZWN0aW9uLCByZXNldHRpbmcgdGhlXG4gICAgLy8gY29sbGVjdGlvbiB3aGVuIHRoZXkgYXJyaXZlLiBJZiBgcmVzZXQ6IHRydWVgIGlzIHBhc3NlZCwgdGhlIHJlc3BvbnNlXG4gICAgLy8gZGF0YSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBgcmVzZXRgIG1ldGhvZCBpbnN0ZWFkIG9mIGBzZXRgLlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3BhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBjb2xsZWN0aW9uLnRyaWdnZXIoJ3N5bmMnLCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIGltbWVkaWF0ZWx5LCB1bmxlc3MgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gICAgY3JlYXRlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcbiAgICAgIG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghd2FpdCkgdGhpcy5hZGQobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihtb2RlbCwgcmVzcCwgY2FsbGJhY2tPcHRzKSB7XG4gICAgICAgIGlmICh3YWl0KSBjb2xsZWN0aW9uLmFkZChtb2RlbCwgY2FsbGJhY2tPcHRzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChjYWxsYmFja09wdHMuY29udGV4dCwgbW9kZWwsIHJlc3AsIGNhbGxiYWNrT3B0cyk7XG4gICAgICB9O1xuICAgICAgbW9kZWwuc2F2ZShudWxsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byBhIGxpc3Qgb2YgbW9kZWxzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyBpdCB0aHJvdWdoLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzLCB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBjb21wYXJhdG9yOiB0aGlzLmNvbXBhcmF0b3JcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEZWZpbmUgaG93IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IG1vZGVscyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBtb2RlbElkOiBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRyc1t0aGlzLm1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gUHJlcGFyZSBhIGhhc2ggb2YgYXR0cmlidXRlcyAob3Igb3RoZXIgbW9kZWwpIHRvIGJlIGFkZGVkIHRvIHRoaXNcbiAgICAvLyBjb2xsZWN0aW9uLlxuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5faXNNb2RlbChhdHRycykpIHtcbiAgICAgICAgaWYgKCFhdHRycy5jb2xsZWN0aW9uKSBhdHRycy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgYnkgYm90aCByZW1vdmUgYW5kIHNldC5cbiAgICBfcmVtb3ZlTW9kZWxzOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgbW9kZWwudHJpZ2dlcigncmVtb3ZlJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkLmxlbmd0aCA/IHJlbW92ZWQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gTWV0aG9kIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhIG1vZGVsIGZvclxuICAgIC8vIHRoZSBwdXJwb3NlcyBvZiBhZGRpbmcgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgX2lzTW9kZWw6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsIGluc3RhbmNlb2YgTW9kZWw7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9ieUlkW21vZGVsLmNpZF0gPSBtb2RlbDtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX3JlbW92ZVJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbaWRdO1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgICAgIHZhciBwcmV2SWQgPSB0aGlzLm1vZGVsSWQobW9kZWwucHJldmlvdXNBdHRyaWJ1dGVzKCkpO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChwcmV2SWQgIT09IGlkKSB7XG4gICAgICAgICAgaWYgKHByZXZJZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtwcmV2SWRdO1xuICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB0aGlzLl9ieUlkW2lkXSA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4gIC8vIHJpZ2h0IGhlcmU6XG4gIHZhciBjb2xsZWN0aW9uTWV0aG9kcyA9IHsgZm9yRWFjaDogMywgZWFjaDogMywgbWFwOiAzLCBjb2xsZWN0OiAzLCByZWR1Y2U6IDQsXG4gICAgICBmb2xkbDogNCwgaW5qZWN0OiA0LCByZWR1Y2VSaWdodDogNCwgZm9sZHI6IDQsIGZpbmQ6IDMsIGRldGVjdDogMywgZmlsdGVyOiAzLFxuICAgICAgc2VsZWN0OiAzLCByZWplY3Q6IDMsIGV2ZXJ5OiAzLCBhbGw6IDMsIHNvbWU6IDMsIGFueTogMywgaW5jbHVkZTogMywgaW5jbHVkZXM6IDMsXG4gICAgICBjb250YWluczogMywgaW52b2tlOiAwLCBtYXg6IDMsIG1pbjogMywgdG9BcnJheTogMSwgc2l6ZTogMSwgZmlyc3Q6IDMsXG4gICAgICBoZWFkOiAzLCB0YWtlOiAzLCBpbml0aWFsOiAzLCByZXN0OiAzLCB0YWlsOiAzLCBkcm9wOiAzLCBsYXN0OiAzLFxuICAgICAgd2l0aG91dDogMCwgZGlmZmVyZW5jZTogMCwgaW5kZXhPZjogMywgc2h1ZmZsZTogMSwgbGFzdEluZGV4T2Y6IDMsXG4gICAgICBpc0VtcHR5OiAxLCBjaGFpbjogMSwgc2FtcGxlOiAzLCBwYXJ0aXRpb246IDMsIGdyb3VwQnk6IDMsIGNvdW50Qnk6IDMsXG4gICAgICBzb3J0Qnk6IDMsIGluZGV4Qnk6IDN9O1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cbiAgYWRkVW5kZXJzY29yZU1ldGhvZHMoQ29sbGVjdGlvbiwgY29sbGVjdGlvbk1ldGhvZHMsICdtb2RlbHMnKTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIHNldCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIF8uYmluZChtZXRob2QsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogICdQQVRDSCcsXG4gICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxuICAgICdyZWFkJzogICAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgLy8gICAgICAgLi4uXG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkgcm91dGUgPSB0aGlzLl9yb3V0ZVRvUmVnRXhwKHJvdXRlKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB2YXIgcm91dGVyID0gdGhpcztcbiAgICAgIEJhY2tib25lLmhpc3Rvcnkucm91dGUocm91dGUsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAocm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MsIG5hbWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAvLyBleGNlbGxlbnQgcGxhY2UgdG8gZG8gcHJlLXJvdXRlIHNldHVwIG9yIHBvc3Qtcm91dGUgY2xlYW51cC5cbiAgICBleGVjdXRlOiBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgbmFtZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgdGhpcy5jaGVja1VybCA9IF8uYmluZCh0aGlzLmNoZWNrVXJsLCB0aGlzKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxuICB2YXIgcGF0aFN0cmlwcGVyID0gLyMuKiQvO1xuXG4gIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cbiAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLkhpc3RvcnkqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChIaXN0b3J5LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcbiAgICAvLyB0d2VudHkgdGltZXMgYSBzZWNvbmQuXG4gICAgaW50ZXJ2YWw6IDUwLFxuXG4gICAgLy8gQXJlIHdlIGF0IHRoZSBhcHAgcm9vdD9cbiAgICBhdFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJyk7XG4gICAgICByZXR1cm4gcGF0aCA9PT0gdGhpcy5yb290ICYmICF0aGlzLmdldFNlYXJjaCgpO1xuICAgIH0sXG5cbiAgICAvLyBEb2VzIHRoZSBwYXRobmFtZSBtYXRjaCB0aGUgcm9vdD9cbiAgICBtYXRjaFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KHRoaXMubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgdmFyIHJvb3QgPSBwYXRoLnNsaWNlKDAsIHRoaXMucm9vdC5sZW5ndGggLSAxKSArICcvJztcbiAgICAgIHJldHVybiByb290ID09PSB0aGlzLnJvb3Q7XG4gICAgfSxcblxuICAgIC8vIFVuaWNvZGUgY2hhcmFjdGVycyBpbiBgbG9jYXRpb24ucGF0aG5hbWVgIGFyZSBwZXJjZW50IGVuY29kZWQgc28gdGhleSdyZVxuICAgIC8vIGRlY29kZWQgZm9yIGNvbXBhcmlzb24uIGAlMjVgIHNob3VsZCBub3QgYmUgZGVjb2RlZCBzaW5jZSBpdCBtYXkgYmUgcGFydFxuICAgIC8vIG9mIGFuIGVuY29kZWQgcGFyYW1ldGVyLlxuICAgIGRlY29kZUZyYWdtZW50OiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSShmcmFnbWVudC5yZXBsYWNlKC8lMjUvZywgJyUyNTI1JykpO1xuICAgIH0sXG5cbiAgICAvLyBJbiBJRTYsIHRoZSBoYXNoIGZyYWdtZW50IGFuZCBzZWFyY2ggcGFyYW1zIGFyZSBpbmNvcnJlY3QgaWYgdGhlXG4gICAgLy8gZnJhZ21lbnQgY29udGFpbnMgYD9gLlxuICAgIGdldFNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qLywgJycpLm1hdGNoKC9cXD8uKy8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0cyB0aGUgdHJ1ZSBoYXNoIHZhbHVlLiBDYW5ub3QgdXNlIGxvY2F0aW9uLmhhc2ggZGlyZWN0bHkgZHVlIHRvIGJ1Z1xuICAgIC8vIGluIEZpcmVmb3ggd2hlcmUgbG9jYXRpb24uaGFzaCB3aWxsIGFsd2F5cyBiZSBkZWNvZGVkLlxuICAgIGdldEhhc2g6IGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICAgdmFyIG1hdGNoID0gKHdpbmRvdyB8fCB0aGlzKS5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcGF0aG5hbWUgYW5kIHNlYXJjaCBwYXJhbXMsIHdpdGhvdXQgdGhlIHJvb3QuXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZGVjb2RlRnJhZ21lbnQoXG4gICAgICAgIHRoaXMubG9jYXRpb24ucGF0aG5hbWUgKyB0aGlzLmdldFNlYXJjaCgpXG4gICAgICApLnNsaWNlKHRoaXMucm9vdC5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zbGljZSgxKSA6IHBhdGg7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgY3Jvc3MtYnJvd3NlciBub3JtYWxpemVkIFVSTCBmcmFnbWVudCBmcm9tIHRoZSBwYXRoIG9yIGhhc2guXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0UGF0aCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlKHJvdXRlU3RyaXBwZXIsICcnKTtcbiAgICB9LFxuXG4gICAgLy8gU3RhcnQgdGhlIGhhc2ggY2hhbmdlIGhhbmRsaW5nLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBjdXJyZW50IFVSTCBtYXRjaGVzXG4gICAgLy8gYW4gZXhpc3Rpbmcgcm91dGUsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKEhpc3Rvcnkuc3RhcnRlZCkgdGhyb3cgbmV3IEVycm9yKCdCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uLiBEbyB3ZSBuZWVkIGFuIGlmcmFtZT9cbiAgICAgIC8vIElzIHB1c2hTdGF0ZSBkZXNpcmVkIC4uLiBpcyBpdCBhdmFpbGFibGU/XG4gICAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgPSBfLmV4dGVuZCh7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMucm9vdCAgICAgICAgICAgICA9IHRoaXMub3B0aW9ucy5yb290O1xuICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xuICAgICAgdGhpcy5faGFzSGFzaENoYW5nZSAgID0gJ29uaGFzaGNoYW5nZScgaW4gd2luZG93ICYmIChkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IHZvaWQgMCB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA3KTtcbiAgICAgIHRoaXMuX3VzZUhhc2hDaGFuZ2UgICA9IHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl9oYXNIYXNoQ2hhbmdlO1xuICAgICAgdGhpcy5fd2FudHNQdXNoU3RhdGUgID0gISF0aGlzLm9wdGlvbnMucHVzaFN0YXRlO1xuICAgICAgdGhpcy5faGFzUHVzaFN0YXRlICAgID0gISEodGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgdGhpcy5fdXNlUHVzaFN0YXRlICAgID0gdGhpcy5fd2FudHNQdXNoU3RhdGUgJiYgdGhpcy5faGFzUHVzaFN0YXRlO1xuICAgICAgdGhpcy5mcmFnbWVudCAgICAgICAgID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgcm9vdCB0byBhbHdheXMgaW5jbHVkZSBhIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgdGhpcy5yb290ID0gKCcvJyArIHRoaXMucm9vdCArICcvJykucmVwbGFjZShyb290U3RyaXBwZXIsICcvJyk7XG5cbiAgICAgIC8vIFRyYW5zaXRpb24gZnJvbSBoYXNoQ2hhbmdlIHRvIHB1c2hTdGF0ZSBvciB2aWNlIHZlcnNhIGlmIGJvdGggYXJlXG4gICAgICAvLyByZXF1ZXN0ZWQuXG4gICAgICBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzUHVzaFN0YXRlKSB7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgc3RhcnRlZCBvZmYgd2l0aCBhIHJvdXRlIGZyb20gYSBgcHVzaFN0YXRlYC1lbmFibGVkXG4gICAgICAgIC8vIGJyb3dzZXIsIGJ1dCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0Li4uXG4gICAgICAgIGlmICghdGhpcy5faGFzUHVzaFN0YXRlICYmICF0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2Uocm9vdCArICcjJyArIHRoaXMuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0ZSh0aGlzLmdldEhhc2goKSwge3JlcGxhY2U6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFByb3h5IGFuIGlmcmFtZSB0byBoYW5kbGUgbG9jYXRpb24gZXZlbnRzIGlmIHRoZSBicm93c2VyIGRvZXNuJ3RcbiAgICAgIC8vIHN1cHBvcnQgdGhlIGBoYXNoY2hhbmdlYCBldmVudCwgSFRNTDUgaGlzdG9yeSwgb3IgdGhlIHVzZXIgd2FudHNcbiAgICAgIC8vIGBoYXNoQ2hhbmdlYCBidXQgbm90IGBwdXNoU3RhdGVgLlxuICAgICAgaWYgKCF0aGlzLl9oYXNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiAhdGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIHRoaXMuaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgICAgICB0aGlzLmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIC8vIFVzaW5nIGBhcHBlbmRDaGlsZGAgd2lsbCB0aHJvdyBvbiBJRSA8IDkgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCByZWFkeS5cbiAgICAgICAgdmFyIGlXaW5kb3cgPSBib2R5Lmluc2VydEJlZm9yZSh0aGlzLmlmcmFtZSwgYm9keS5maXJzdENoaWxkKS5jb250ZW50V2luZG93O1xuICAgICAgICBpV2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICBpV2luZG93LmxvY2F0aW9uLmhhc2ggPSAnIycgKyB0aGlzLmZyYWdtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgYWRkRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gRGlzYWJsZSBCYWNrYm9uZS5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXG4gICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBBZGQgYSBjcm9zcy1wbGF0Zm9ybSBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIHx8IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBkZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBSZW1vdmUgd2luZG93IGxpc3RlbmVycy5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZUhhc2hDaGFuZ2UgJiYgIXRoaXMuaWZyYW1lKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFuIHVwIHRoZSBpZnJhbWUgaWYgbmVjZXNzYXJ5LlxuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5pZnJhbWUpO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHdpbGwgdGhyb3cgd2hlbiBjbGVhcmluZyBhbiB1bmRlZmluZWQgaW50ZXJ2YWwuXG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcblxuICAgICAgLy8gSWYgdGhlIHVzZXIgcHJlc3NlZCB0aGUgYmFjayBidXR0b24sIHRoZSBpZnJhbWUncyBoYXNoIHdpbGwgaGF2ZVxuICAgICAgLy8gY2hhbmdlZCBhbmQgd2Ugc2hvdWxkIHVzZSB0aGF0IGZvciBjb21wYXJpc29uLlxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcbiAgICAgIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIGN1cnJlbnQgVVJMIGZyYWdtZW50LiBJZiBhIHJvdXRlIHN1Y2NlZWRzIHdpdGggYVxuICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgIGxvYWRVcmw6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAvLyBJZiB0aGUgcm9vdCBkb2Vzbid0IG1hdGNoLCBubyByb3V0ZXMgY2FuIG1hdGNoIGVpdGhlci5cbiAgICAgIGlmICghdGhpcy5tYXRjaFJvb3QoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCk7XG4gICAgICByZXR1cm4gXy5zb21lKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoYXNoIGhpc3RvcnksIG9yIHJlcGxhY2UgdGhlIFVSTCBzdGF0ZSBpZiB0aGVcbiAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgLy9cbiAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAvLyB5b3Ugd2lzaCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgYWRkaW5nIGFuIGVudHJ5IHRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSBvcHRpb25zID0ge3RyaWdnZXI6ICEhb3B0aW9uc307XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZnJhZ21lbnQuXG4gICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQgfHwgJycpO1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdCA9IHJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciB1cmwgPSByb290ICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGFuZCBkZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmRlY29kZUZyYWdtZW50KGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJykpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykpKSB7XG4gICAgICAgICAgdmFyIGlXaW5kb3cgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuICAgICAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2goaVdpbmRvdy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBmb3Igc3ViY2xhc3Nlcy5cbiAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKXsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAvLyBpZiBzdXBwbGllZC5cbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcblxufSkpO1xuIixudWxsLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8qKlxuICogQWJzdHJhY3QgaGFuZGxlciBmb3IgYW5pbWF0b3Igc3RlcHNcbiAqL1xudmFyIEFuaW1hdG9yU3RlcHNSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIGlmIChzdGFydCA+PSBlbmQpIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gZW5kJyk7XG5cbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IGVuZDtcbn07XG5cbkFuaW1hdG9yU3RlcHNSYW5nZS5wcm90b3R5cGUgPSB7XG5cbiAgZGlmZjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcbiAgfSxcblxuICBpc0xhc3Q6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAvLyByb3VuZCBzdGVwIGludG8gYW4gaW50ZWdlciwgdG8gYmUgYWJsZSB0byBjb21wYXJlIG51bWJlciBhcyBleHBlY3RlZCAoYWxzbyBjb252ZXJ0cyBiYWQgaW5wdXQgdG8gMClcbiAgICByZXR1cm4gKHN0ZXAgfCAwKSA9PT0gdGhpcy5lbmQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0b3JTdGVwc1JhbmdlO1xuIiwidmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4vJyk7XG52YXIgQW5pbWF0b3JTdGVwc1JhbmdlID0gcmVxdWlyZSgnLi9hbmltYXRvci1zdGVwcy1yYW5nZScpO1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIHx8IGdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB8fCBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgfHwgZ2xvYmFsLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgfHwgZnVuY3Rpb24oY2FsbGJhY2spIHsgcmV0dXJuIGdsb2JhbC5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApOyB9O1xuXG52YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgICB8fCBnbG9iYWwubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgICB8fCBnbG9iYWwud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgICB8fCBnbG9iYWwubXNDYW5jZWxBbmltYXRpb25GcmFtZVxuICAgIHx8IGZ1bmN0aW9uKGlkKSB7IGNsZWFyVGltZW91dChpZCk7IH07XG5cbiAgLyoqXG4gICAqIG9wdGlvbnM6XG4gICAqICAgIGFuaW1hdGlvbkR1cmF0aW9uIGluIHNlY29uZHNcbiAgICogICAgYW5pbWF0aW9uRGVsYXkgaW4gc2Vjb25kc1xuICAgKi9cbiAgZnVuY3Rpb24gQW5pbWF0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZighb3B0aW9ucy5zdGVwcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RlcHMgb3B0aW9uIG1pc3NpbmdcIilcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl90aWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3QwID0gK25ldyBEYXRlKCk7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSAwLjA7XG4gICAgdGhpcy5pdGVtc1JlYWR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB0b3JxdWUuZXh0ZW5kKHtcbiAgICAgICAgYW5pbWF0aW9uRGVsYXk6IDAsXG4gICAgICAgIG1heERlbHRhOiAwLjIsXG4gICAgICAgIGxvb3A6IG9wdGlvbnMubG9vcCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubG9vcFxuICAgIH0sIHRoaXMub3B0aW9ucyk7XG5cbiAgICB0aGlzLnN0ZXBzKG9wdGlvbnMuc3RlcHMpO1xuICB9XG5cbiAgQW5pbWF0b3IucHJvdG90eXBlID0ge1xuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN0YXJ0ICYmIHRoaXMub3B0aW9ucy5vblN0YXJ0KCk7XG4gICAgICAgIGlmICh0aGlzLnN0ZXBzUmFuZ2UoKS5kaWZmKCkgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1J1bm5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLnRpbWUodGhpcy5zdGVwc1JhbmdlKCkuc3RhcnQpO1xuICAgICAgdGhpcy5vcHRpb25zLm9uU3RvcCAmJiB0aGlzLm9wdGlvbnMub25TdG9wKCk7XG4gICAgfSxcblxuICAgIC8vIHJlYWwgYW5pbWF0aW9uIHRpbWVcbiAgICB0aW1lOiBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5fdGltZSA9IF87XG4gICAgICB2YXIgdCA9IHRoaXMucmFuZ2UodGhpcy5kb21haW4odGhpcy5fdGltZSkpO1xuICAgICAgdGhpcy5jYWxsYmFjayh0KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0KClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbWFpbkludiA9IHRvcnF1ZS5tYXRoLmxpbmVhcih0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRGVsYXksIHRoaXMub3B0aW9ucy5hbmltYXRpb25EZWxheSArIHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZG9tYWluSW52LmludmVydCgpO1xuICAgICAgdGhpcy5yYW5nZSA9IHRvcnF1ZS5tYXRoLmxpbmVhcigwLCB0aGlzLl9kZWZhdWx0U3RlcHNSYW5nZS5lbmQpO1xuICAgICAgdGhpcy5yYW5nZUludiA9IHRoaXMucmFuZ2UuaW52ZXJ0KCk7XG4gICAgICB0aGlzLnRpbWUodGhpcy5fdGltZSk7XG4gICAgICB0aGlzLnJ1bm5pbmc/IHRoaXMuc3RhcnQoKTogdGhpcy5wYXVzZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGR1cmF0aW9uOiBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpICByZXR1cm4gdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uID0gXztcbiAgICAgIGlmICh0aGlzLnRpbWUoKSA+IF8pIHtcbiAgICAgICAgdGhpcy50aW1lKDApO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNjYWxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RlcHM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zdGVwcyA9IF87XG4gICAgICB0aGlzLl9kZWZhdWx0U3RlcHNSYW5nZSA9IG5ldyBBbmltYXRvclN0ZXBzUmFuZ2UoMCwgXyk7XG4gICAgICByZXR1cm4gdGhpcy5yZXNjYWxlKCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgb3Igc2V0cyBhIChjdXN0b20pIHN0ZXBzIHJhbmdlXG4gICAgLy8gU2V0dGluZyBhIHN0ZXBzIHJhbmdlIG11c3QgYmUgd2l0aGluIHRoZSBmdWxsIHJhbmdlXG4gICAgc3RlcHNSYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fZGVmYXVsdFN0ZXBzUmFuZ2Uuc3RhcnQpIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSB3aXRoaW4gZGVmYXVsdCBzdGVwcyByYW5nZScpO1xuICAgICAgICBpZiAoZW5kID4gdGhpcy5fZGVmYXVsdFN0ZXBzUmFuZ2UuZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBtdXN0IGJlIHdpdGhpbiBkZWZhdWx0IHN0ZXBzIHJhbmdlJyk7XG5cbiAgICAgICAgdGhpcy5fY3VzdG9tU3RlcHNSYW5nZSA9IG5ldyBBbmltYXRvclN0ZXBzUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN0ZXBzUmFuZ2UgJiYgdGhpcy5vcHRpb25zLm9uU3RlcHNSYW5nZSgpO1xuXG4gICAgICAgIC8vIENoYW5nZSBjdXJyZW50IHN0ZXAgaWYgaXQncyBvdXRzaWRlIHRoZSBuZXcgY3VzdG9tIHJhbmdlXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwKCkgfCAwOyAvLyByb3VuZCB0byBhbiBpbnRlZ2VyXG4gICAgICAgIGlmIChzdGVwIDwgc3RhcnQgfHwgc3RlcCA+IGVuZCkge1xuICAgICAgICAgIHRoaXMuc3RlcChzdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jdXN0b21TdGVwc1JhbmdlIHx8IHRoaXMuX2RlZmF1bHRTdGVwc1JhbmdlO1xuICAgIH0sXG5cbiAgICByZW1vdmVDdXN0b21TdGVwc1JhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1c3RvbVN0ZXBzUmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9wdGlvbnMub25TdGVwc1JhbmdlICYmIHRoaXMub3B0aW9ucy5vblN0ZXBzUmFuZ2UoKTtcbiAgICB9LFxuXG4gICAgc3RlcDogZnVuY3Rpb24ocykge1xuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMucmFuZ2UodGhpcy5kb21haW4odGhpcy5fdGltZSkpO1xuICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZG9tYWluSW52KHRoaXMucmFuZ2VJbnYocykpO1xuICAgIH0sXG5cbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgICAgdGhpcy5vcHRpb25zLm9uUGF1c2UgJiYgdGhpcy5vcHRpb25zLm9uUGF1c2UoKTtcbiAgICB9LFxuXG4gICAgX3RpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHQxID0gK25ldyBEYXRlKCk7XG4gICAgICB2YXIgZGVsdGEgPSAodDEgLSB0aGlzLl90MCkqMC4wMDE7XG4gICAgICAvLyBpZiBkZWx0YSBpcyByZWFsbHkgYmlnIG1lYW5zIHRoZSB0YWIgbG9zdCB0aGUgZm9jdXNcbiAgICAgIC8vIGF0IHNvbWUgcG9pbnQsIHNvIGxpbWl0IGRlbHRhIGNoYW5nZVxuICAgICAgZGVsdGEgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMubWF4RGVsdGEsIGRlbHRhKTtcbiAgICAgIHRoaXMuX3QwID0gdDE7XG4gICAgICB0aGlzLl90aW1lICs9IGRlbHRhO1xuXG4gICAgICB2YXIgc3RlcHNSYW5nZSA9IHRoaXMuc3RlcHNSYW5nZSgpO1xuICAgICAgaWYgKHN0ZXBzUmFuZ2UuaXNMYXN0KHRoaXMuc3RlcCgpKSkge1xuICAgICAgICBpZighdGhpcy5vcHRpb25zLmxvb3Ape1xuICAgICAgICAgIC8vIHNldCB0aW1lIHRvIG1heCB0aW1lXG4gICAgICAgICAgdGhpcy50aW1lKHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RlcChzdGVwc1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMudGltZSh0aGlzLl90aW1lKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdG9yO1xuIiwidmFyIF90b3JxdWVfcmVmZXJlbmNlX2xhdGVzdCA9IHtcbiAgICBcInZlcnNpb25cIjogXCIxLjAuMFwiLFxuICAgIFwic3R5bGVcIjoge1xuICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCJjb21wLW9wXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgbGF5ZXIgb24gdG9wIG9mIG90aGVyIGxheWVyc1wiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgbGF5ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBsYXllcnMgYXRvcCBvciBiZWxvdyBpdC5cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgXCJzcmNcIiwgLy9cbiAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsIC8vXG4gICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLCAvL1xuICAgICAgICAgICAgICAgIFwic3JjLWluXCIsIC8vXG4gICAgICAgICAgICAgICAgXCJkc3QtaW5cIiwgLy9cbiAgICAgICAgICAgICAgICBcInNyYy1vdXRcIiwgLy9cbiAgICAgICAgICAgICAgICBcImRzdC1vdXRcIiwgLy9cbiAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsIC8vXG4gICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLCAvL1xuICAgICAgICAgICAgICAgIFwieG9yXCIsIC8vXG4gICAgICAgICAgICAgICAgXCJkYXJrZW5cIiwgLy9cbiAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIiAvL1xuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImxheWVyXCIgOiB7XG4gICAgICAgIFwiYnVmZmVyLXNpemVcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBidWZmZXIgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkV4dHJhIHRvbGVyYW5jZSBhcm91bmQgdGhlIExheWVyIGV4dGVudCAoaW4gcGl4ZWxzKSB1c2VkIHRvIHdoZW4gcXVlcnlpbmcgYW5kIChwb3RlbnRpYWxseSkgY2xpcHBpbmcgdGhlIGxheWVyIGRhdGEgZHVyaW5nIHJlbmRlcmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiLXRvcnF1ZS1jbGVhci1jb2xvclwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtY2xlYXItY29sb3JcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImZ1bGwgY2xlYXJcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiY29sb3IgdXNlZCB0byBjbGVhciBjYW52YXMgb24gZWFjaCBmcmFtZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiLXRvcnF1ZS1mcmFtZS1jb3VudFwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtZnJhbWUtY291bnRcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjEyOFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJudW1iZXJcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIGRhdGEgaXMgYnJva2VuIGludG8gMTI4IHRpbWUgZnJhbWVzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIk51bWJlciBvZiBhbmltYXRpb24gc3RlcHMvZnJhbWVzIHVzZWQgaW4gdGhlIGFuaW1hdGlvbi4gSWYgdGhlIGRhdGEgY29udGFpbnMgYSBmZXdlcmUgbnVtYmVyIG9mIHRvdGFsIGZyYW1lcywgdGhlIGxlc3NlciB2YWx1ZSB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCItdG9ycXVlLXJlc29sdXRpb25cIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLXJlc29sdXRpb25cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwibnVtYmVyXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJTcGF0aWFsIHJlc29sdXRpb24gaW4gcGl4ZWxzLiBBIHJlc29sdXRpb24gb2YgMSBtZWFucyBubyBzcGF0aWFsIGFnZ3JlZ2F0aW9uIG9mIHRoZSBkYXRhLiBBbnkgb3RoZXIgcmVzb2x1dGlvbiBvZiBOIHJlc3VsdHMgaW4gc3BhdGlhbCBhZ2dyZWdhdGlvbiBpbnRvIGNlbGxzIG9mIE54TiBwaXhlbHMuIFRoZSB2YWx1ZSBOIG11c3QgYmUgcG93ZXIgb2YgMlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiLXRvcnF1ZS1hbmltYXRpb24tZHVyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLWFuaW1hdGlvbi1kdXJhdGlvblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMzBcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwibnVtYmVyXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSBhbmltYXRpb24gbGFzdHMgMzAgc2Vjb25kc1wiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJBbmltYXRpb24gZHVyYXRpb24gaW4gc2Vjb25kc1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiLXRvcnF1ZS1hZ2dyZWdhdGlvbi1mdW5jdGlvblwiOiB7XG4gICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtYWdncmVnYXRpb24tZnVuY3Rpb25cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImNvdW50KGNhcnRvZGJfaWQpXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIHZhbHVlIGZvciBlYWNoIGNlbGwgaXMgdGhlIGNvdW50IG9mIHBvaW50cyBpbiB0aGF0IGNlbGxcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBmdW5jdGlvbiB1c2VkIHRvIGNhbGN1bGF0ZSBhIHZhbHVlIGZyb20gdGhlIGFnZ3JlZ2F0ZSBkYXRhIGZvciBlYWNoIGNlbGwuIFNlZSAtdG9ycXVlLXJlc29sdXRpb25cIlxuICAgICAgICB9LFxuICAgICAgICBcIi10b3JxdWUtdGltZS1hdHRyaWJ1dGVcIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLXRpbWUtYXR0cmlidXRlXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJ0aW1lXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIGRhdGEgY29sdW1uIGluIHlvdXIgdGFibGUgdGhhdCBpcyBvZiBhIHRpbWUgYmFzZWQgdHlwZVwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGFibGUgY29sdW1uIHRoYXQgY29udGFpbnMgdGhlIHRpbWUgaW5mb3JtYXRpb24gdXNlZCBjcmVhdGUgdGhlIGFuaW1hdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJsaW5lYXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgIFwiY3VtdWxhdGl2ZVwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJwcmV2aW91cyB2YWx1ZXMgYXJlIGRpc2NhcmRlZFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJBIGxpbmVhciBhbmltYXRpb24gd2lsbCBkaXNjYXJkIHByZXZpb3VzIHZhbHVlcyB3aGlsZSBhIGN1bXVsYXRpdmUgYW5pbWF0aW9uIHdpbGwgYWNjdW11bGF0ZSB0aGVtIHVudGlsIGl0IHJlc3RhcnRzXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJzeW1ib2xpemVyc1wiIDoge1xuICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IGxheWVyIG9uIHRvcCBvZiBvdGhlciBsYXllcnNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBsYXllciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIGxheWVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICBcInNyY1wiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIiwgLy9cbiAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIiwgLy9cbiAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLCAvL1xuICAgICAgICAgICAgICAgICAgXCJ4b3JcIiwgLy9cbiAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsIC8vXG4gICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIiAvL1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwib3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBhbHBoYSB2YWx1ZSBmb3IgdGhlIHN0eWxlICh3aGljaCBtZWFucyBhbiBhbHBoYSBhcHBsaWVkIHRvIGFsbCBmZWF0dXJlcyBpbiBzZXBhcmF0ZSBidWZmZXIgYW5kIHRoZW4gY29tcG9zaXRlZCBiYWNrIHRvIG1haW4gYnVmZmVyKVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc2VwYXJhdGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhbmQgbm8gYWxwaGEgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBzdHlsZSBhZnRlciByZW5kZXJpbmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRyYWlsXCI6IHtcbiAgICAgICAgICBcInN0ZXBzXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwidHJhaWwtc3RlcHNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gdHJhaWwgc3RlcHNcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiSG93IG1hbnkgc3RlcHMgb2YgdHJhaWxzIGFyZSBnb2luZyB0byBiZSByZW5kZXJlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvbHlnb25cIjoge1xuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwicmdiYSgxMjgsMTI4LDEyOCwxKVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ3JheSBhbmQgZnVsbHkgb3BhcXVlIChhbHBoYSA9IDEpLCBzYW1lIGFzIHJnYigxMjgsMTI4LDEyOClcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkZpbGwgY29sb3IgdG8gYXNzaWduIHRvIGEgcG9seWdvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBwb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImxpbmVcIjoge1xuICAgICAgICAgICAgXCJzdHJva2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1jb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInJnYmEoMCwwLDAsMSlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYmxhY2sgYW5kIGZ1bGx5IG9wYXF1ZSAoYWxwaGEgPSAxKSwgc2FtZSBhcyByZ2IoMCwwLDApXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgYSBkcmF3biBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLXdpZHRoXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiBhIGxpbmUgaW4gcGl4ZWxzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIGEgbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1qb2luXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibWl0ZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIm1pdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiZXZlbFwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBiZWhhdmlvciBvZiBsaW5lcyB3aGVuIGpvaW5pbmdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1jYXBcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJidXR0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJidXR0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcXVhcmVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lIGVuZGluZ3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1hcmtlcnNcIjoge1xuICAgICAgICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBTVkcgZmlsZSB0aGF0IHRoaXMgbWFya2VyIHNob3dzIGF0IGVhY2ggcGxhY2VtZW50LiBJZiBubyBmaWxlIGlzIGdpdmVuLCB0aGUgbWFya2VyIHdpbGwgc2hvdyBhbiBlbGxpcHNlLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQW4gZWxsaXBzZSBvciBjaXJjbGUsIGlmIHdpZHRoIGVxdWFscyBoZWlnaHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG92ZXJhbGwgb3BhY2l0eSBvZiB0aGUgbWFya2VyLCBpZiBzZXQsIG92ZXJyaWRlcyBib3RoIHRoZSBvcGFjaXR5IG9mIGJvdGggdGhlIGZpbGwgYW5kIHN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIHN0cm9rZS1vcGFjaXR5IGFuZCBmaWxsLW9wYWNpdHkgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxsLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBmaWxsIG9wYWNpdHkgb2YgdGhlIG1hcmtlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwib3BhcXVlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLWNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHN0cm9rZSBhcm91bmQgYSBtYXJrZXIgc2hhcGUuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmxhY2tcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWxpbmUtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlIGFyb3VuZCBhIG1hcmtlciBzaGFwZSwgaW4gcGl4ZWxzLiBUaGlzIGlzIHBvc2l0aW9uZWQgb24gdGhlIGJvdW5kYXJ5LCBzbyBoaWdoIHZhbHVlcyBjYW4gY292ZXIgdGhlIGFyZWEgaXRzZWxmLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImJsdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgYXJlYSBvZiB0aGUgbWFya2VyLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1hcmtlci10eXBlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci10eXBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJyZWN0YW5nbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJlbGxpcHNlXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBkZWZhdWx0IG1hcmtlci10eXBlLiBJZiBhIFNWRyBmaWxlIGlzIG5vdCBnaXZlbiBhcyB0aGUgbWFya2VyLWZpbGUgcGFyYW1ldGVyLCB0aGUgcmVuZGVyZXIgcHJvdmlkZXMgZWl0aGVyIGFuIHJlY3RhbmdsZSBvciBhbiBlbGxpcHNlIChhIGNpcmNsZSBpZiBoZWlnaHQgaXMgZXF1YWwgdG8gd2lkdGgpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgXCJ3aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgaWYgdXNpbmcgb25lIG9mIHRoZSBkZWZhdWx0IHR5cGVzLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb2ludFwiOiB7XG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVyaVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgZmlsZSB0byByZXByZXNlbnQgYSBwb2ludFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLjAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJGdWxseSBvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkEgdmFsdWUgZnJvbSAwIHRvIDEgdG8gY29udHJvbCB0aGUgb3BhY2l0eSBvZiB0aGUgcG9pbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImNvbG9yc1wiOiB7XG4gICAgICAgIFwiYWxpY2VibHVlXCI6ICBbMjQwLCAyNDgsIDI1NV0sXG4gICAgICAgIFwiYW50aXF1ZXdoaXRlXCI6ICBbMjUwLCAyMzUsIDIxNV0sXG4gICAgICAgIFwiYXF1YVwiOiAgWzAsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJhcXVhbWFyaW5lXCI6ICBbMTI3LCAyNTUsIDIxMl0sXG4gICAgICAgIFwiYXp1cmVcIjogIFsyNDAsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJiZWlnZVwiOiAgWzI0NSwgMjQ1LCAyMjBdLFxuICAgICAgICBcImJpc3F1ZVwiOiAgWzI1NSwgMjI4LCAxOTZdLFxuICAgICAgICBcImJsYWNrXCI6ICBbMCwgMCwgMF0sXG4gICAgICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogIFsyNTUsMjM1LDIwNV0sXG4gICAgICAgIFwiYmx1ZVwiOiAgWzAsIDAsIDI1NV0sXG4gICAgICAgIFwiYmx1ZXZpb2xldFwiOiAgWzEzOCwgNDMsIDIyNl0sXG4gICAgICAgIFwiYnJvd25cIjogIFsxNjUsIDQyLCA0Ml0sXG4gICAgICAgIFwiYnVybHl3b29kXCI6ICBbMjIyLCAxODQsIDEzNV0sXG4gICAgICAgIFwiY2FkZXRibHVlXCI6ICBbOTUsIDE1OCwgMTYwXSxcbiAgICAgICAgXCJjaGFydHJldXNlXCI6ICBbMTI3LCAyNTUsIDBdLFxuICAgICAgICBcImNob2NvbGF0ZVwiOiAgWzIxMCwgMTA1LCAzMF0sXG4gICAgICAgIFwiY29yYWxcIjogIFsyNTUsIDEyNywgODBdLFxuICAgICAgICBcImNvcm5mbG93ZXJibHVlXCI6ICBbMTAwLCAxNDksIDIzN10sXG4gICAgICAgIFwiY29ybnNpbGtcIjogIFsyNTUsIDI0OCwgMjIwXSxcbiAgICAgICAgXCJjcmltc29uXCI6ICBbMjIwLCAyMCwgNjBdLFxuICAgICAgICBcImN5YW5cIjogIFswLCAyNTUsIDI1NV0sXG4gICAgICAgIFwiZGFya2JsdWVcIjogIFswLCAwLCAxMzldLFxuICAgICAgICBcImRhcmtjeWFuXCI6ICBbMCwgMTM5LCAxMzldLFxuICAgICAgICBcImRhcmtnb2xkZW5yb2RcIjogIFsxODQsIDEzNCwgMTFdLFxuICAgICAgICBcImRhcmtncmF5XCI6ICBbMTY5LCAxNjksIDE2OV0sXG4gICAgICAgIFwiZGFya2dyZWVuXCI6ICBbMCwgMTAwLCAwXSxcbiAgICAgICAgXCJkYXJrZ3JleVwiOiAgWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICBcImRhcmtraGFraVwiOiAgWzE4OSwgMTgzLCAxMDddLFxuICAgICAgICBcImRhcmttYWdlbnRhXCI6ICBbMTM5LCAwLCAxMzldLFxuICAgICAgICBcImRhcmtvbGl2ZWdyZWVuXCI6ICBbODUsIDEwNywgNDddLFxuICAgICAgICBcImRhcmtvcmFuZ2VcIjogIFsyNTUsIDE0MCwgMF0sXG4gICAgICAgIFwiZGFya29yY2hpZFwiOiAgWzE1MywgNTAsIDIwNF0sXG4gICAgICAgIFwiZGFya3JlZFwiOiAgWzEzOSwgMCwgMF0sXG4gICAgICAgIFwiZGFya3NhbG1vblwiOiAgWzIzMywgMTUwLCAxMjJdLFxuICAgICAgICBcImRhcmtzZWFncmVlblwiOiAgWzE0MywgMTg4LCAxNDNdLFxuICAgICAgICBcImRhcmtzbGF0ZWJsdWVcIjogIFs3MiwgNjEsIDEzOV0sXG4gICAgICAgIFwiZGFya3NsYXRlZ3JleVwiOiAgWzQ3LCA3OSwgNzldLFxuICAgICAgICBcImRhcmt0dXJxdW9pc2VcIjogIFswLCAyMDYsIDIwOV0sXG4gICAgICAgIFwiZGFya3Zpb2xldFwiOiAgWzE0OCwgMCwgMjExXSxcbiAgICAgICAgXCJkZWVwcGlua1wiOiAgWzI1NSwgMjAsIDE0N10sXG4gICAgICAgIFwiZGVlcHNreWJsdWVcIjogIFswLCAxOTEsIDI1NV0sXG4gICAgICAgIFwiZGltZ3JheVwiOiAgWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICBcImRpbWdyZXlcIjogIFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgICAgXCJkb2RnZXJibHVlXCI6ICBbMzAsIDE0NCwgMjU1XSxcbiAgICAgICAgXCJmaXJlYnJpY2tcIjogIFsxNzgsIDM0LCAzNF0sXG4gICAgICAgIFwiZmxvcmFsd2hpdGVcIjogIFsyNTUsIDI1MCwgMjQwXSxcbiAgICAgICAgXCJmb3Jlc3RncmVlblwiOiAgWzM0LCAxMzksIDM0XSxcbiAgICAgICAgXCJmdWNoc2lhXCI6ICBbMjU1LCAwLCAyNTVdLFxuICAgICAgICBcImdhaW5zYm9yb1wiOiAgWzIyMCwgMjIwLCAyMjBdLFxuICAgICAgICBcImdob3N0d2hpdGVcIjogIFsyNDgsIDI0OCwgMjU1XSxcbiAgICAgICAgXCJnb2xkXCI6ICBbMjU1LCAyMTUsIDBdLFxuICAgICAgICBcImdvbGRlbnJvZFwiOiAgWzIxOCwgMTY1LCAzMl0sXG4gICAgICAgIFwiZ3JheVwiOiAgWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgICBcImdyZXlcIjogIFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJncmVlblwiOiAgWzAsIDEyOCwgMF0sXG4gICAgICAgIFwiZ3JlZW55ZWxsb3dcIjogIFsxNzMsIDI1NSwgNDddLFxuICAgICAgICBcImhvbmV5ZGV3XCI6ICBbMjQwLCAyNTUsIDI0MF0sXG4gICAgICAgIFwiaG90cGlua1wiOiAgWzI1NSwgMTA1LCAxODBdLFxuICAgICAgICBcImluZGlhbnJlZFwiOiAgWzIwNSwgOTIsIDkyXSxcbiAgICAgICAgXCJpbmRpZ29cIjogIFs3NSwgMCwgMTMwXSxcbiAgICAgICAgXCJpdm9yeVwiOiAgWzI1NSwgMjU1LCAyNDBdLFxuICAgICAgICBcImtoYWtpXCI6ICBbMjQwLCAyMzAsIDE0MF0sXG4gICAgICAgIFwibGF2ZW5kZXJcIjogIFsyMzAsIDIzMCwgMjUwXSxcbiAgICAgICAgXCJsYXZlbmRlcmJsdXNoXCI6ICBbMjU1LCAyNDAsIDI0NV0sXG4gICAgICAgIFwibGF3bmdyZWVuXCI6ICBbMTI0LCAyNTIsIDBdLFxuICAgICAgICBcImxlbW9uY2hpZmZvblwiOiAgWzI1NSwgMjUwLCAyMDVdLFxuICAgICAgICBcImxpZ2h0Ymx1ZVwiOiAgWzE3MywgMjE2LCAyMzBdLFxuICAgICAgICBcImxpZ2h0Y29yYWxcIjogIFsyNDAsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJsaWdodGN5YW5cIjogIFsyMjQsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiAgWzI1MCwgMjUwLCAyMTBdLFxuICAgICAgICBcImxpZ2h0Z3JheVwiOiAgWzIxMSwgMjExLCAyMTFdLFxuICAgICAgICBcImxpZ2h0Z3JlZW5cIjogIFsxNDQsIDIzOCwgMTQ0XSxcbiAgICAgICAgXCJsaWdodGdyZXlcIjogIFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgXCJsaWdodHBpbmtcIjogIFsyNTUsIDE4MiwgMTkzXSxcbiAgICAgICAgXCJsaWdodHNhbG1vblwiOiAgWzI1NSwgMTYwLCAxMjJdLFxuICAgICAgICBcImxpZ2h0c2VhZ3JlZW5cIjogIFszMiwgMTc4LCAxNzBdLFxuICAgICAgICBcImxpZ2h0c2t5Ymx1ZVwiOiAgWzEzNSwgMjA2LCAyNTBdLFxuICAgICAgICBcImxpZ2h0c2xhdGVncmF5XCI6ICBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgIFwibGlnaHRzbGF0ZWdyZXlcIjogIFsxMTksIDEzNiwgMTUzXSxcbiAgICAgICAgXCJsaWdodHN0ZWVsYmx1ZVwiOiAgWzE3NiwgMTk2LCAyMjJdLFxuICAgICAgICBcImxpZ2h0eWVsbG93XCI6ICBbMjU1LCAyNTUsIDIyNF0sXG4gICAgICAgIFwibGltZVwiOiAgWzAsIDI1NSwgMF0sXG4gICAgICAgIFwibGltZWdyZWVuXCI6ICBbNTAsIDIwNSwgNTBdLFxuICAgICAgICBcImxpbmVuXCI6ICBbMjUwLCAyNDAsIDIzMF0sXG4gICAgICAgIFwibWFnZW50YVwiOiAgWzI1NSwgMCwgMjU1XSxcbiAgICAgICAgXCJtYXJvb25cIjogIFsxMjgsIDAsIDBdLFxuICAgICAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogIFsxMDIsIDIwNSwgMTcwXSxcbiAgICAgICAgXCJtZWRpdW1ibHVlXCI6ICBbMCwgMCwgMjA1XSxcbiAgICAgICAgXCJtZWRpdW1vcmNoaWRcIjogIFsxODYsIDg1LCAyMTFdLFxuICAgICAgICBcIm1lZGl1bXB1cnBsZVwiOiAgWzE0NywgMTEyLCAyMTldLFxuICAgICAgICBcIm1lZGl1bXNlYWdyZWVuXCI6ICBbNjAsIDE3OSwgMTEzXSxcbiAgICAgICAgXCJtZWRpdW1zbGF0ZWJsdWVcIjogIFsxMjMsIDEwNCwgMjM4XSxcbiAgICAgICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiAgWzAsIDI1MCwgMTU0XSxcbiAgICAgICAgXCJtZWRpdW10dXJxdW9pc2VcIjogIFs3MiwgMjA5LCAyMDRdLFxuICAgICAgICBcIm1lZGl1bXZpb2xldHJlZFwiOiAgWzE5OSwgMjEsIDEzM10sXG4gICAgICAgIFwibWlkbmlnaHRibHVlXCI6ICBbMjUsIDI1LCAxMTJdLFxuICAgICAgICBcIm1pbnRjcmVhbVwiOiAgWzI0NSwgMjU1LCAyNTBdLFxuICAgICAgICBcIm1pc3R5cm9zZVwiOiAgWzI1NSwgMjI4LCAyMjVdLFxuICAgICAgICBcIm1vY2Nhc2luXCI6ICBbMjU1LCAyMjgsIDE4MV0sXG4gICAgICAgIFwibmF2YWpvd2hpdGVcIjogIFsyNTUsIDIyMiwgMTczXSxcbiAgICAgICAgXCJuYXZ5XCI6ICBbMCwgMCwgMTI4XSxcbiAgICAgICAgXCJvbGRsYWNlXCI6ICBbMjUzLCAyNDUsIDIzMF0sXG4gICAgICAgIFwib2xpdmVcIjogIFsxMjgsIDEyOCwgMF0sXG4gICAgICAgIFwib2xpdmVkcmFiXCI6ICBbMTA3LCAxNDIsIDM1XSxcbiAgICAgICAgXCJvcmFuZ2VcIjogIFsyNTUsIDE2NSwgMF0sXG4gICAgICAgIFwib3JhbmdlcmVkXCI6ICBbMjU1LCA2OSwgMF0sXG4gICAgICAgIFwib3JjaGlkXCI6ICBbMjE4LCAxMTIsIDIxNF0sXG4gICAgICAgIFwicGFsZWdvbGRlbnJvZFwiOiAgWzIzOCwgMjMyLCAxNzBdLFxuICAgICAgICBcInBhbGVncmVlblwiOiAgWzE1MiwgMjUxLCAxNTJdLFxuICAgICAgICBcInBhbGV0dXJxdW9pc2VcIjogIFsxNzUsIDIzOCwgMjM4XSxcbiAgICAgICAgXCJwYWxldmlvbGV0cmVkXCI6ICBbMjE5LCAxMTIsIDE0N10sXG4gICAgICAgIFwicGFwYXlhd2hpcFwiOiAgWzI1NSwgMjM5LCAyMTNdLFxuICAgICAgICBcInBlYWNocHVmZlwiOiAgWzI1NSwgMjE4LCAxODVdLFxuICAgICAgICBcInBlcnVcIjogIFsyMDUsIDEzMywgNjNdLFxuICAgICAgICBcInBpbmtcIjogIFsyNTUsIDE5MiwgMjAzXSxcbiAgICAgICAgXCJwbHVtXCI6ICBbMjIxLCAxNjAsIDIyMV0sXG4gICAgICAgIFwicG93ZGVyYmx1ZVwiOiAgWzE3NiwgMjI0LCAyMzBdLFxuICAgICAgICBcInB1cnBsZVwiOiAgWzEyOCwgMCwgMTI4XSxcbiAgICAgICAgXCJyZWRcIjogIFsyNTUsIDAsIDBdLFxuICAgICAgICBcInJvc3licm93blwiOiAgWzE4OCwgMTQzLCAxNDNdLFxuICAgICAgICBcInJveWFsYmx1ZVwiOiAgWzY1LCAxMDUsIDIyNV0sXG4gICAgICAgIFwic2FkZGxlYnJvd25cIjogIFsxMzksIDY5LCAxOV0sXG4gICAgICAgIFwic2FsbW9uXCI6ICBbMjUwLCAxMjgsIDExNF0sXG4gICAgICAgIFwic2FuZHlicm93blwiOiAgWzI0NCwgMTY0LCA5Nl0sXG4gICAgICAgIFwic2VhZ3JlZW5cIjogIFs0NiwgMTM5LCA4N10sXG4gICAgICAgIFwic2Vhc2hlbGxcIjogIFsyNTUsIDI0NSwgMjM4XSxcbiAgICAgICAgXCJzaWVubmFcIjogIFsxNjAsIDgyLCA0NV0sXG4gICAgICAgIFwic2lsdmVyXCI6ICBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgICAgIFwic2t5Ymx1ZVwiOiAgWzEzNSwgMjA2LCAyMzVdLFxuICAgICAgICBcInNsYXRlYmx1ZVwiOiAgWzEwNiwgOTAsIDIwNV0sXG4gICAgICAgIFwic2xhdGVncmF5XCI6ICBbMTEyLCAxMjgsIDE0NF0sXG4gICAgICAgIFwic2xhdGVncmV5XCI6ICBbMTEyLCAxMjgsIDE0NF0sXG4gICAgICAgIFwic25vd1wiOiAgWzI1NSwgMjUwLCAyNTBdLFxuICAgICAgICBcInNwcmluZ2dyZWVuXCI6ICBbMCwgMjU1LCAxMjddLFxuICAgICAgICBcInN0ZWVsYmx1ZVwiOiAgWzcwLCAxMzAsIDE4MF0sXG4gICAgICAgIFwidGFuXCI6ICBbMjEwLCAxODAsIDE0MF0sXG4gICAgICAgIFwidGVhbFwiOiAgWzAsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJ0aGlzdGxlXCI6ICBbMjE2LCAxOTEsIDIxNl0sXG4gICAgICAgIFwidG9tYXRvXCI6ICBbMjU1LCA5OSwgNzFdLFxuICAgICAgICBcInR1cnF1b2lzZVwiOiAgWzY0LCAyMjQsIDIwOF0sXG4gICAgICAgIFwidmlvbGV0XCI6ICBbMjM4LCAxMzAsIDIzOF0sXG4gICAgICAgIFwid2hlYXRcIjogIFsyNDUsIDIyMiwgMTc5XSxcbiAgICAgICAgXCJ3aGl0ZVwiOiAgWzI1NSwgMjU1LCAyNTVdLFxuICAgICAgICBcIndoaXRlc21va2VcIjogIFsyNDUsIDI0NSwgMjQ1XSxcbiAgICAgICAgXCJ5ZWxsb3dcIjogIFsyNTUsIDI1NSwgMF0sXG4gICAgICAgIFwieWVsbG93Z3JlZW5cIjogIFsxNTQsIDIwNSwgNTBdLFxuICAgICAgICBcInRyYW5zcGFyZW50XCI6ICBbMCwgMCwgMCwgMF1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvbjoge1xuICAgIGxhdGVzdDogX3RvcnF1ZV9yZWZlcmVuY2VfbGF0ZXN0LFxuICAgICcxLjAuMCc6IF90b3JxdWVfcmVmZXJlbmNlX2xhdGVzdFxuICB9XG59O1xuIiwiLy9cbi8vIGNvbW1vbiBmdW5jdGlvbmFsbGl0eSBmb3IgdG9ycXVlIGxheWVyc1xuLy9cbnZhciBjYXJ0byA9IGdsb2JhbC5jYXJ0byB8fCByZXF1aXJlKCdjYXJ0bycpO1xuXG5mdW5jdGlvbiBUb3JxdWVMYXllcigpIHt9XG5cblRvcnF1ZUxheWVyLnByb3RvdHlwZSA9IHtcbn07XG5cblRvcnF1ZUxheWVyLm9wdGlvbnNGcm9tTGF5ZXIgPSBmdW5jdGlvbihtYXBDb25maWcpIHtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgaWYgKCFtYXBDb25maWcpIHJldHVybiBvcHRzO1xuICB2YXIgYXR0cnMgPSB7XG4gICAgJ2J1ZmZlci1zaXplJzogJ2J1ZmZlci1zaXplJyxcbiAgICAnLXRvcnF1ZS1mcmFtZS1jb3VudCc6ICdzdGVwcycsXG4gICAgJy10b3JxdWUtcmVzb2x1dGlvbic6ICdyZXNvbHV0aW9uJyxcbiAgICAnLXRvcnF1ZS1hbmltYXRpb24tZHVyYXRpb24nOiAnYW5pbWF0aW9uRHVyYXRpb24nLFxuICAgICctdG9ycXVlLWFnZ3JlZ2F0aW9uLWZ1bmN0aW9uJzogJ2NvdW50YnknLFxuICAgICctdG9ycXVlLXRpbWUtYXR0cmlidXRlJzogJ2NvbHVtbicsXG4gICAgJy10b3JxdWUtZGF0YS1hZ2dyZWdhdGlvbic6ICdkYXRhX2FnZ3JlZ2F0aW9uJ1xuICB9O1xuICBmb3IgKHZhciBpIGluIGF0dHJzKSB7XG4gICAgdmFyIHYgPSBtYXBDb25maWcuZXZhbChpKTtcbiAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgYSA9IGF0dHJzW2ldO1xuICAgICAgb3B0c1thXSA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRzO1xufTtcblxuVG9ycXVlTGF5ZXIub3B0aW9uc0Zyb21DYXJ0b0NTUyA9IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gIHZhciBzaGFkZXIgPSBuZXcgY2FydG8uUmVuZGVyZXJKUygpLnJlbmRlcihjYXJ0b2Nzcyk7XG4gIHZhciBtYXBDb25maWcgPSBzaGFkZXIuZmluZExheWVyKHsgbmFtZTogJ01hcCcgfSk7XG4gIHJldHVybiBUb3JxdWVMYXllci5vcHRpb25zRnJvbUxheWVyKG1hcENvbmZpZyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub3JxdWVMYXllciA9IFRvcnF1ZUxheWVyO1xuIiwiICB2YXIgRXZlbnQgPSB7fTtcbiAgRXZlbnQub24gPSBmdW5jdGlvbihldnQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgY2IgPSB0aGlzLl9ldnRfY2FsbGJhY2tzID0gdGhpcy5fZXZ0X2NhbGxiYWNrcyB8fCB7fTtcbiAgICAgIHZhciBsID0gY2JbZXZ0XSB8fCAoY2JbZXZ0XSA9IFtdKTtcbiAgICAgIGwucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudC50cmlnZ2VyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2V2dF9jYWxsYmFja3MgJiYgdGhpcy5fZXZ0X2NhbGxiYWNrc1tldnRdO1xuICAgICAgZm9yKHZhciBpID0gMDsgYyAmJiBpIDwgYy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNbaV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudC5maXJlID0gRXZlbnQudHJpZ2dlcjtcblxuICBFdmVudC5vZmYgPSBmdW5jdGlvbiAoZXZ0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGMgPSB0aGlzLl9ldnRfY2FsbGJhY2tzICYmIHRoaXMuX2V2dF9jYWxsYmFja3NbZXZ0XTtcbiAgICAgIGlmIChjICYmICFjYWxsYmFjaykge1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZ0X2NhbGxiYWNrc1tldnRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgfVxuICAgICB2YXIgcmVtb3ZlID0gW107XG4gICAgIGZvcih2YXIgaSA9IDA7IGMgJiYgaSA8IGMubGVuZ3RoOyArK2kpIHtcbiAgICAgICBpZihjW2ldID09PSBjYWxsYmFjaykgcmVtb3ZlLnB1c2goaSk7XG4gICAgIH1cbiAgICAgd2hpbGUoKGkgPSByZW1vdmUucG9wKCkpICE9PSB1bmRlZmluZWQpIGMuc3BsaWNlKGksIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50LmNhbGxiYWNrcyA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHJldHVybiAodGhpcy5fZXZ0X2NhbGxiYWNrcyAmJiB0aGlzLl9ldnRfY2FsbGJhY2tzW2V2dF0pIHx8IFtdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICAgIHZhciBvYmpzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGEgPSBvYmpzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvYmpzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmpzW2ldO1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gYikge1xuICAgICAgICAgICAgICBhW2tdID0gYltrXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24oZikge1xuICAgIHJldHVybiB0eXBlb2YgZiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH1cblxuICAvLyB0eXBlc1xuICB2YXIgdHlwZXMgPSB7XG4gICAgVWludDhBcnJheTogdHlwZW9mKGdsb2JhbFsnVWludDhBcnJheSddKSAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwuVWludDhBcnJheSA6IEFycmF5LFxuICAgIFVpbnQ4Q2xhbXBlZEFycmF5OiB0eXBlb2YoZ2xvYmFsWydVaW50OENsYW1wZWRBcnJheSddKSAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwuVWludDhDbGFtcGVkQXJyYXk6IEFycmF5LFxuICAgIFVpbnQzMkFycmF5OiB0eXBlb2YoZ2xvYmFsWydVaW50MzJBcnJheSddKSAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwuVWludDMyQXJyYXkgOiBBcnJheSxcbiAgICBJbnQxNkFycmF5OiB0eXBlb2YoZ2xvYmFsWydJbnQxNkFycmF5J10pICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC5JbnQxNkFycmF5IDogQXJyYXksXG4gICAgSW50MzJBcnJheTogdHlwZW9mKGdsb2JhbFsnSW50MzJBcnJheSddKSAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwuSW50MzJBcnJheTogQXJyYXlcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Jyb3dzZXJTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VyQWdlbnQoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJyc7XG4gIH1cblxuICB2YXIgZmxhZ3MgPSB7XG4gICAgc3ByaXRlc190b19pbWFnZXM6IHVzZXJBZ2VudCgpLmluZGV4T2YoJ1NhZmFyaScpID09PSAtMSAmJiB1c2VyQWdlbnQoKS5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xXG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEV2ZW50OiBFdmVudCxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIHR5cGVzOiB0eXBlcyxcbiAgICBpc0Jyb3dzZXJTdXBwb3J0ZWQ6IGlzQnJvd3NlclN1cHBvcnRlZCxcbiAgICBmbGFnczogZmxhZ3Ncbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXh0ZW5kcyBPdmVybGF5VmlldyB0byBwcm92aWRlIGEgY2FudmFzIFwiTGF5ZXJcIi5cbiAqIEBhdXRob3IgQnJlbmRhbiBLZW5ueVxuICovXG5cbi8qKlxuICogQSBtYXAgbGF5ZXIgdGhhdCBwcm92aWRlcyBhIGNhbnZhcyBvdmVyIHRoZSBzbGlwcHkgbWFwIGFuZCBhIGNhbGxiYWNrXG4gKiBzeXN0ZW0gZm9yIGVmZmljaWVudCBhbmltYXRpb24uIFJlcXVpcmVzIGNhbnZhcyBhbmQgQ1NTIDJEIHRyYW5zZm9ybVxuICogc3VwcG9ydC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXdcbiAqIEBwYXJhbSB7Q2FudmFzTGF5ZXJPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucyB0byBzZXQgaW4gdGhpcyBDYW52YXNMYXllci5cbiAqL1xuXG5mdW5jdGlvbiBDYW52YXNMYXllcihvcHRfb3B0aW9ucykge1xuICAvKipcbiAgICogSWYgdHJ1ZSwgY2FudmFzIGlzIGluIGEgbWFwIHBhbmUgYW5kIHRoZSBPdmVybGF5VmlldyBpcyBmdWxseSBmdW5jdGlvbmFsLlxuICAgKiBTZWUgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcub25BZGQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc0FkZGVkXyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBlYWNoIHVwZGF0ZSB3aWxsIGltbWVkaWF0ZWx5IHNjaGVkdWxlIHRoZSBuZXh0LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuaXNBbmltYXRlZF8gPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIE1hcFBhbmUgaW4gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucGFuZU5hbWVfID0gQ2FudmFzTGF5ZXIuREVGQVVMVF9QQU5FX05BTUVfO1xuXG4gIC8qKlxuICAgKiBBIHVzZXItc3VwcGxpZWQgZnVuY3Rpb24gY2FsbGVkIHdoZW5ldmVyIGFuIHVwZGF0ZSBpcyByZXF1aXJlZC4gTnVsbCBvclxuICAgKiB1bmRlZmluZWQgaWYgYSBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWQuXG4gICAqIEB0eXBlIHs/ZnVuY3Rpb249fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy51cGRhdGVIYW5kbGVyXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdXNlci1zdXBwbGllZCBmdW5jdGlvbiBjYWxsZWQgd2hlbmV2ZXIgYW4gdXBkYXRlIGlzIHJlcXVpcmVkIGFuZCB0aGVcbiAgICogbWFwIGhhcyBiZWVuIHJlc2l6ZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlLiBOdWxsIG9yIHVuZGVmaW5lZCBpZiBhXG4gICAqIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZC5cbiAgICogQHR5cGUgez9mdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVzaXplSGFuZGxlcl8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgTGF0TG5nIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IG9mIHRoZSBjdXJyZW50IHZpZXcgb2YgdGhlIG1hcC4gV2lsbFxuICAgKiBiZSBudWxsIHdoZW4gdGhpcy5pc0FkZGVkXyBpcyBmYWxzZS5cbiAgICogQHR5cGUge2dvb2dsZS5tYXBzLkxhdExuZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudG9wTGVmdF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWFwLXBhbiBldmVudCBsaXN0ZW5lci4gV2lsbCBiZSBudWxsIHdoZW4gdGhpcy5pc0FkZGVkXyBpcyBmYWxzZS4gV2lsbFxuICAgKiBiZSBudWxsIHdoZW4gdGhpcy5pc0FkZGVkXyBpcyBmYWxzZS5cbiAgICogQHR5cGUgez9mdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2VudGVyTGlzdGVuZXJfID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1hcC1yZXNpemUgZXZlbnQgbGlzdGVuZXIuIFdpbGwgYmUgbnVsbCB3aGVuIHRoaXMuaXNBZGRlZF8gaXMgZmFsc2UuXG4gICAqIEB0eXBlIHs/ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJlc2l6ZUxpc3RlbmVyXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZSBtYXAgc2l6ZSBoYXMgY2hhbmdlZCBhbmQgdGhpcy5yZXNpemVIYW5kbGVyXyBtdXN0IGJlIGNhbGxlZFxuICAgKiBvbiB0aGUgbmV4dCB1cGRhdGUuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5uZWVkc1Jlc2l6ZV8gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBBIGJyb3dzZXItZGVmaW5lZCBpZCBmb3IgdGhlIGN1cnJlbnRseSByZXF1ZXN0ZWQgY2FsbGJhY2suIE51bGwgd2hlbiBub1xuICAgKiBjYWxsYmFjayBpcyBxdWV1ZWQuXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJZF8gPSBudWxsO1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gIGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcbiAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBjYW52YXMgZWxlbWVudC5cbiAgICogQHR5cGUgeyFIVE1MQ2FudmFzRWxlbWVudH1cbiAgICovXG4gIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgYmluZCBmb3IgZnVuY3Rpb25zIHdpdGggbm8gYXJncyBmb3IgYmluZC1sZXNzIGJyb3dzZXJzIChTYWZhcmkpLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgdGhpcyB2YWx1ZSB1c2VkIGZvciB0aGUgdGFyZ2V0IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiZSBib3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIHNpbXBsZUJpbmRTaGltKHRoaXNBcmcsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodGhpc0FyZyk7IH07XG4gIH1cblxuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdGhpcy5yZXBvc2l0aW9uQ2FudmFzXyB3aXRoIHRoaXMgYm91bmQgYXMgaXRzIHRoaXMgdmFsdWUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVwb3NpdGlvbkZ1bmN0aW9uXyA9IHNpbXBsZUJpbmRTaGltKHRoaXMsIHRoaXMucmVwb3NpdGlvbkNhbnZhc18pO1xuXG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGlzLnJlc2l6ZV8gd2l0aCB0aGlzIGJvdW5kIGFzIGl0cyB0aGlzIHZhbHVlLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJlc2l6ZUZ1bmN0aW9uXyA9IHNpbXBsZUJpbmRTaGltKHRoaXMsIHRoaXMucmVzaXplXyk7XG5cbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoaXMudXBkYXRlXyB3aXRoIHRoaXMgYm91bmQgYXMgaXRzIHRoaXMgdmFsdWUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmVxdWVzdFVwZGF0ZUZ1bmN0aW9uXyA9IHNpbXBsZUJpbmRTaGltKHRoaXMsIHRoaXMudXBkYXRlXyk7XG5cbiAgLy8gc2V0IHByb3ZpZGVkIG9wdGlvbnMsIGlmIGFueVxuICBpZiAob3B0X29wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0X29wdGlvbnMpO1xuICB9XG59XG5cbkNhbnZhc0xheWVyLnByb3RvdHlwZSA9IG5ldyBnb29nbGUubWFwcy5PdmVybGF5VmlldygpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IE1hcFBhbmUgdG8gY29udGFpbiB0aGUgY2FudmFzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzTGF5ZXIuREVGQVVMVF9QQU5FX05BTUVfID0gJ292ZXJsYXlMYXllcic7XG5cbi8qKlxuICogVHJhbnNmb3JtIENTUyBwcm9wZXJ0eSBuYW1lLCB3aXRoIHZlbmRvciBwcmVmaXggaWYgcmVxdWlyZWQuIElmIGJyb3dzZXJcbiAqIGRvZXMgbm90IHN1cHBvcnQgdHJhbnNmb3JtcywgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzTGF5ZXIuQ1NTX1RSQU5TRk9STV8gPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHRyYW5zZm9ybVByb3BzID0gW1xuICAgICd0cmFuc2Zvcm0nLFxuICAgICdXZWJraXRUcmFuc2Zvcm0nLFxuICAgICdNb3pUcmFuc2Zvcm0nLFxuICAgICdPVHJhbnNmb3JtJyxcbiAgICAnbXNUcmFuc2Zvcm0nXG4gIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHRyYW5zZm9ybVByb3BzW2ldO1xuICAgIGlmIChkaXYuc3R5bGVbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuIHVucHJlZml4ZWQgdmVyc2lvbiBieSBkZWZhdWx0XG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9wc1swXTtcbn0pKCk7XG5cbi8qKlxuICogVGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbiwgd2l0aCB2ZW5kb3ItcHJlZml4ZWQgb3Igc2V0VGltZW91dC1iYXNlZFxuICogZmFsbGJhY2tzLiBNVVNUIGJlIGNhbGxlZCB3aXRoIHdpbmRvdyBhcyB0aGlzQXJnLlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGFkZCB0byB0aGUgZnJhbWUgcmVxdWVzdCBxdWV1ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJyb3dzZXItZGVmaW5lZCBpZCBmb3IgdGhlIHJlcXVlc3RlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5yZXF1ZXN0QW5pbUZyYW1lXyA9XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgIH07XG5cbi8qKlxuICogVGhlIGNhbmNlbEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9uLCB3aXRoIHZlbmRvci1wcmVmaXhlZCBmYWxsYmFjay4gRG9lcyBub3RcbiAqIGZhbGwgYmFjayB0byBjbGVhclRpbWVvdXQgYXMgc29tZSBwbGF0Zm9ybXMgaW1wbGVtZW50IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICogYnV0IG5vdCBjYW5jZWxBbmltYXRpb25GcmFtZSwgYW5kIHRoZSBjb3N0IGlzIGFuIGV4dHJhIGZyYW1lIG9uIG9uUmVtb3ZlLlxuICogTVVTVCBiZSBjYWxsZWQgd2l0aCB3aW5kb3cgYXMgdGhpc0FyZy5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmVxdWVzdElkIFRoZSBpZCBvZiB0aGUgZnJhbWUgcmVxdWVzdCB0byBjYW5jZWwuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuY2FuY2VsQW5pbUZyYW1lXyA9XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24ocmVxdWVzdElkKSB7fTtcblxuLyoqXG4gKiBTZXRzIGFueSBvcHRpb25zIHByb3ZpZGVkLiBTZWUgQ2FudmFzTGF5ZXJPcHRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtDYW52YXNMYXllck9wdGlvbnN9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gc2V0LlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRBbmltYXRlKG9wdGlvbnMuYW5pbWF0ZSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wYW5lTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRQYW5lKG9wdGlvbnMucGFuZU5hbWUpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudXBkYXRlSGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRVcGRhdGVIYW5kbGVyKG9wdGlvbnMudXBkYXRlSGFuZGxlcik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZXNpemVIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFJlc2l6ZUhhbmRsZXIob3B0aW9ucy5yZXNpemVIYW5kbGVyKTtcbiAgfVxuXG4gIGlmKG9wdGlvbnMucmVhZHlIYW5kbGVyKSB7XG4gICAgdGhpcy5yZWFkeUhhbmRsZXIgPSBvcHRpb25zLnJlYWR5SGFuZGxlcjtcbiAgfVxuXG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5pbWF0ZWQgc3RhdGUgb2YgdGhlIGxheWVyLiBJZiB0cnVlLCB1cGRhdGVIYW5kbGVyIHdpbGwgYmUgY2FsbGVkXG4gKiByZXBlYXRlZGx5LCBvbmNlIHBlciBmcmFtZS4gSWYgZmFsc2UsIHVwZGF0ZUhhbmRsZXIgd2lsbCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiBhIG1hcCBwcm9wZXJ0eSBjaGFuZ2VzIHRoYXQgY291bGQgcmVxdWlyZSB0aGUgY2FudmFzIGNvbnRlbnQgdG8gYmUgcmVkcmF3bi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSBXaGV0aGVyIHRoZSBjYW52YXMgaXMgYW5pbWF0ZWQuXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5zZXRBbmltYXRlID0gZnVuY3Rpb24oYW5pbWF0ZSkge1xuICB0aGlzLmlzQW5pbWF0ZWRfID0gISFhbmltYXRlO1xuXG4gIGlmICh0aGlzLmlzQW5pbWF0ZWRfKSB7XG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNhbnZhcyBpcyBhbmltYXRlZC5cbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLmlzQW5pbWF0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNBbmltYXRlZF87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgTWFwUGFuZSBpbiB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkLCBieSBuYW1lLiBTZWVcbiAqIHtAY29kZSBnb29nbGUubWFwcy5NYXBQYW5lc30gZm9yIHRoZSBwYW5lcyBhdmFpbGFibGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFuZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlc2lyZWQgTWFwUGFuZS5cbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnNldFBhbmVOYW1lID0gZnVuY3Rpb24ocGFuZU5hbWUpIHtcbiAgdGhpcy5wYW5lTmFtZV8gPSBwYW5lTmFtZTtcblxuICB0aGlzLnNldFBhbmVfKCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3BhY2l0eSBmb3IgdGhlIGNhbnZhcy5cbiAqIFxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgVGhlIG9wYWNpdHkgb2YgdGhlIGNhbnZhc1xuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIHRoaXMuY2FudmFzLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNhbnZhc2VzIG9wYWNpdHkuXG4gKiBcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGNhbnZhc1xuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLnN0eWxlLm9wYWNpdHk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgY29udGFpbmVyIHBhbmUuXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5nZXRQYW5lTmFtZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYW5lTmFtZV87XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lciBwYW5lLiBTaW5jZSB0aGlzIGlzIGd1YXJhbnRlZWQgdG9cbiAqIGV4ZWN1dGUgb25seSBhZnRlciBvbkFkZCBpcyBjYWxsZWQsIHRoaXMgaXMgd2hlbiBwYW5lTmFtZSdzIGV4aXN0ZW5jZSBpc1xuICogY2hlY2tlZCAoYW5kIGFuIGVycm9yIGlzIHRocm93biBpZiBpdCBkb2Vzbid0IGV4aXN0KS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5zZXRQYW5lXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNBZGRlZF8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBvbkFkZCBoYXMgYmVlbiBjYWxsZWQsIHNvIHBhbmVzIGNhbiBiZSB1c2VkXG4gIHZhciBwYW5lcyA9IHRoaXMuZ2V0UGFuZXMoKTtcbiAgaWYgKCFwYW5lc1t0aGlzLnBhbmVOYW1lX10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHRoaXMucGFuZU5hbWVfICsgJ1wiIGlzIG5vdCBhIHZhbGlkIE1hcFBhbmUgbmFtZS4nKTtcbiAgfVxuXG4gIHBhbmVzW3RoaXMucGFuZU5hbWVfXS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG59O1xuXG4vKipcbiAqIFNldCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBhcmVudCBtYXAgYW5kIHRoZSBvdmVybGF5J3NcbiAqIGNhbnZhcyBoYXZlIGJlZW4gcmVzaXplZC4gSWYgb3B0X3Jlc2l6ZUhhbmRsZXIgaXMgbnVsbCBvciB1bnNwZWNpZmllZCwgYW55XG4gKiBleGlzdGluZyBjYWxsYmFjayBpcyByZW1vdmVkLlxuICogQHBhcmFtIHs/ZnVuY3Rpb249fSBvcHRfcmVzaXplSGFuZGxlciBUaGUgcmVzaXplIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuc2V0UmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uKG9wdF9yZXNpemVIYW5kbGVyKSB7XG4gIHRoaXMucmVzaXplSGFuZGxlcl8gPSBvcHRfcmVzaXplSGFuZGxlcjtcbn07XG5cbi8qKlxuICogU2V0IGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgcmVwYWludCBvZiB0aGUgY2FudmFzIGlzIHJlcXVpcmVkLlxuICogSWYgb3B0X3VwZGF0ZUhhbmRsZXIgaXMgbnVsbCBvciB1bnNwZWNpZmllZCwgYW55IGV4aXN0aW5nIGNhbGxiYWNrIGlzXG4gKiByZW1vdmVkLlxuICogQHBhcmFtIHs/ZnVuY3Rpb249fSBvcHRfdXBkYXRlSGFuZGxlciBUaGUgdXBkYXRlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuc2V0VXBkYXRlSGFuZGxlciA9IGZ1bmN0aW9uKG9wdF91cGRhdGVIYW5kbGVyKSB7XG4gIHRoaXMudXBkYXRlSGFuZGxlcl8gPSBvcHRfdXBkYXRlSGFuZGxlcjtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzQWRkZWRfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5pc0FkZGVkXyA9IHRydWU7XG4gIHRoaXMuc2V0UGFuZV8oKTtcblxuICB0aGlzLnJlc2l6ZUxpc3RlbmVyXyA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZ2V0TWFwKCksXG4gICAgICAncmVzaXplJywgdGhpcy5yZXNpemVGdW5jdGlvbl8pO1xuICB0aGlzLmNlbnRlckxpc3RlbmVyXyA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZ2V0TWFwKCksXG4gICAgICAnY2VudGVyX2NoYW5nZWQnLCB0aGlzLnJlcG9zaXRpb25GdW5jdGlvbl8pO1xuXG4gIHRoaXMucmVzaXplXygpO1xuICB0aGlzLnJlcG9zaXRpb25DYW52YXNfKCk7XG4gIHRoaXMucmVhZHlIYW5kbGVyICYmIHRoaXMucmVhZHlIYW5kbGVyKCk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cbkNhbnZhc0xheWVyLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNBZGRlZF8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzQWRkZWRfID0gZmFsc2U7XG4gIHRoaXMudG9wTGVmdF8gPSBudWxsO1xuXG4gIC8vIHJlbW92ZSBjYW52YXMgYW5kIGxpc3RlbmVycyBmb3IgcGFuIGFuZCByZXNpemUgZnJvbSBtYXBcbiAgdGhpcy5jYW52YXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gIGlmICh0aGlzLmNlbnRlckxpc3RlbmVyXykge1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY2VudGVyTGlzdGVuZXJfKTtcbiAgICB0aGlzLmNlbnRlckxpc3RlbmVyXyA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMucmVzaXplTGlzdGVuZXJfKSB7XG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNpemVMaXN0ZW5lcl8pO1xuICAgIHRoaXMucmVzaXplTGlzdGVuZXJfID0gbnVsbDtcbiAgfVxuXG4gIC8vIGNlYXNlIGNhbnZhcyB1cGRhdGUgY2FsbGJhY2tzXG4gIGlmICh0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlkXykge1xuICAgIHRoaXMuY2FuY2VsQW5pbUZyYW1lXy5jYWxsKHdpbmRvdywgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJZF8pO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSWRfID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgaW50ZXJuYWwgY2FsbGJhY2sgZm9yIHJlc2l6ZSBldmVudHMgdGhhdCByZXNpemVzIHRoZSBjYW52YXMgdG8ga2VlcCB0aGVcbiAqIG1hcCBwcm9wZXJseSBjb3ZlcmVkLlxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnJlc2l6ZV8gPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETyhiY2tlbm55KTogaXQncyBjb21tb24gdG8gdXNlIGEgc21hbGxlciBjYW52YXMgYnV0IHVzZSBDU1MgdG8gc2NhbGVcbiAgLy8gd2hhdCBpcyBkcmF3biBieSB0aGUgYnJvd3NlciB0byBzYXZlIG9uIGZpbGwgcmF0ZS4gQWRkIGFuIG9wdGlvbiB0byBkb1xuICAvLyB0aGlzLlxuXG4gIGlmICghdGhpcy5pc0FkZGVkXykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICB2YXIgd2lkdGggPSBtYXAuZ2V0RGl2KCkub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBtYXAuZ2V0RGl2KCkub2Zmc2V0SGVpZ2h0O1xuICB2YXIgb2xkV2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgdmFyIG9sZEhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcblxuICAvLyByZXNpemluZyBtYXkgYWxsb2NhdGUgYSBuZXcgYmFjayBidWZmZXIsIHNvIGRvIHNvIGNvbnNlcnZhdGl2ZWx5XG4gIGlmIChvbGRXaWR0aCAhPT0gd2lkdGggfHwgb2xkSGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgdGhpcy5uZWVkc1Jlc2l6ZV8gPSB0cnVlO1xuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlcG9zaXRpb25DYW52YXNfKCk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGNhbGxiYWNrIGZvciBtYXAgdmlldyBjaGFuZ2VzLiBTaW5jZSB0aGUgTWFwcyBBUEkgbW92ZXMgdGhlIG92ZXJsYXlcbiAqIGFsb25nIHdpdGggdGhlIG1hcCwgdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBvcHBvc2l0ZSB0cmFuc2xhdGlvbiB0b1xuICoga2VlcCB0aGUgY2FudmFzIGluIHBsYWNlLlxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnJlcG9zaXRpb25DYW52YXNfID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8oYmNrZW5ueSk6ICpzaG91bGQqIG9ubHkgYmUgZXhlY3V0ZWQgb24gUkFGLCBidXQgaW4gY3VycmVudCBicm93c2Vyc1xuICAvLyAgICAgdGhpcyBjYXVzZXMgbm90aWNlYWJsZSBoaXRjaGVzIGluIG1hcCBhbmQgb3ZlcmxheSByZWxhdGl2ZVxuICAvLyAgICAgcG9zaXRpb25pbmcuXG5cbiAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TWFwKCkuZ2V0Qm91bmRzKCk7XG4gIHRoaXMudG9wTGVmdF8gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sYXQoKSxcbiAgICAgIGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sbmcoKSk7XG5cbiAgLy8gY2FudmFzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGRyYWdnYWJsZSBtYXAncyBjb25hdGFpbmVyIGRlcGVuZHMgb25cbiAgLy8gb3ZlcmxheVZpZXcncyBwcm9qZWN0aW9uLCBub3QgdGhlIG1hcCdzXG4gIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gIHZhciBkaXZUb3BMZWZ0ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbCh0aGlzLnRvcExlZnRfKTtcblxuICAvLyB3aGVuIHRoZSB6b29tIGxldmVsIGlzIGxvdywgbW9yZSB0aGFuIG9uZSBtYXAgY2FuIGJlIHNob3duIGluIHRoZSBzY3JlZW5cbiAgLy8gc28gdGhlIGNhbnZhcyBzaG91bGQgYmUgYXR0YWNoIHRvIHRoZSBtYXAgd2l0aCBtb3JlIGFyZSBpbiB0aGUgc2NyZWVuXG4gIHZhciBtYXBTaXplID0gKDEgPDwgdGhpcy5nZXRNYXAoKS5nZXRab29tKCkpKjI1NjtcbiAgaWYgKE1hdGguYWJzKGRpdlRvcExlZnQueCkgPiBtYXBTaXplKSB7XG4gICAgZGl2VG9wTGVmdC54IC09IG1hcFNpemU7XG4gIH1cbiAgdGhpcy5jYW52YXMuc3R5bGVbQ2FudmFzTGF5ZXIuQ1NTX1RSQU5TRk9STV9dID0gJ3RyYW5zbGF0ZSgnICtcbiAgICAgIE1hdGgucm91bmQoZGl2VG9wTGVmdC54KSArICdweCwnICsgTWF0aC5yb3VuZChkaXZUb3BMZWZ0LnkpICsgJ3B4KSc7XG5cbiAgdGhpcy5zY2hlZHVsZVVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBjYWxsYmFjayB0aGF0IHNlcnZlcyBhcyBtYWluIGFuaW1hdGlvbiBzY2hlZHVsZXIgdmlhXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIENhbGxzIHJlc2l6ZSBhbmQgdXBkYXRlIGNhbGxiYWNrcyBpZiBzZXQsIGFuZFxuICogc2NoZWR1bGVzIHRoZSBuZXh0IGZyYW1lIGlmIG92ZXJsYXkgaXMgYW5pbWF0ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNMYXllci5wcm90b3R5cGUudXBkYXRlXyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlkXyA9IG51bGw7XG5cbiAgaWYgKCF0aGlzLmlzQWRkZWRfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuaXNBbmltYXRlZF8pIHtcbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAodGhpcy5uZWVkc1Jlc2l6ZV8gJiYgdGhpcy5yZXNpemVIYW5kbGVyXykge1xuICAgIHRoaXMubmVlZHNSZXNpemVfID0gZmFsc2U7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXygpO1xuICB9XG5cbiAgaWYgKHRoaXMudXBkYXRlSGFuZGxlcl8pIHtcbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IExhdExuZyBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGVmdCBvZlxuICogdGhlIGN1cnJlbnQgdmlldyBvZiB0aGUgbWFwLlxuICogQHJldHVybiB7Z29vZ2xlLm1hcHMuTGF0TG5nfSBUaGUgdG9wIGxlZnQgY29vcmRpbmF0ZS5cbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLmdldFRvcExlZnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9wTGVmdF87XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrIHRvIHVwZGF0ZUhhbmRsZXIuIElmIG9uZSBpc1xuICogYWxyZWFkeSBzY2hlZHVsZWQsIHRoZXJlIGlzIG5vIGVmZmVjdC5cbiAqL1xuQ2FudmFzTGF5ZXIucHJvdG90eXBlLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzQWRkZWRfICYmICF0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlkXykge1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSWRfID1cbiAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbUZyYW1lXy5jYWxsKHdpbmRvdywgdGhpcy5yZXF1ZXN0VXBkYXRlRnVuY3Rpb25fKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNMYXllcjtcbiIsIi8qXG4gPT09PT09PT09PT09PT09PT09PT1cbiBjYW52YXMgc2V0dXAgZm9yIGRyYXdpbmcgdGlsZXNcbiA9PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmZ1bmN0aW9uIENhbnZhc1RpbGVMYXllcihjYW52YXNfc2V0dXAsIHJlbmRlcikge1xuICB0aGlzLnRpbGVTaXplID0gbmV3IGdvb2dsZS5tYXBzLlNpemUoMjU2LCAyNTYpO1xuICB0aGlzLm1heFpvb20gPSAxOTtcbiAgdGhpcy5uYW1lID0gXCJUaWxlICNzXCI7XG4gIHRoaXMuYWx0ID0gXCJDYW52YXMgdGlsZSBsYXllclwiO1xuICB0aGlzLnRpbGVzID0ge307XG4gIHRoaXMuY2FudmFzX3NldHVwID0gY2FudmFzX3NldHVwO1xuICB0aGlzLnJlbmRlciA9IHJlbmRlcjtcbiAgaWYgKCFyZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyID0gY2FudmFzX3NldHVwO1xuICB9XG59XG5cblxuLy8gY3JlYXRlIGEgdGlsZSB3aXRoIGEgY2FudmFzIGVsZW1lbnRcbkNhbnZhc1RpbGVMYXllci5wcm90b3R5cGUuY3JlYXRlX3RpbGVfY2FudmFzID0gZnVuY3Rpb24gKGNvb3JkLCB6b29tLCBvd25lckRvY3VtZW50KSB7XG5cbiAgLy8gY3JlYXRlIGNhbnZhcyBhbmQgcmVzZXQgc3R5bGVcbiAgdmFyIGNhbnZhcyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIHZhciBoaXRfY2FudmFzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLnN0eWxlLmJvcmRlciA9IGhpdF9jYW52YXMuc3R5bGUuYm9yZGVyID0gXCJub25lXCI7XG4gIGNhbnZhcy5zdHlsZS5tYXJnaW4gPSBoaXRfY2FudmFzLnN0eWxlLm1hcmdpbiA9IFwiMFwiO1xuICBjYW52YXMuc3R5bGUucGFkZGluZyA9IGhpdF9jYW52YXMuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xuXG4gIC8vIHByZXBhcmUgY2FudmFzIGFuZCBjb250ZXh0IHNpemVzXG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LndpZHRoID0gY2FudmFzLndpZHRoID0gdGhpcy50aWxlU2l6ZS53aWR0aDtcbiAgY3R4LmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSB0aGlzLnRpbGVTaXplLmhlaWdodDtcblxuICB2YXIgaGl0X2N0eCA9IGhpdF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgaGl0X2NhbnZhcy53aWR0aCA9IGhpdF9jdHgud2lkdGggPSB0aGlzLnRpbGVTaXplLndpZHRoO1xuICBoaXRfY2FudmFzLmhlaWdodCA9IGhpdF9jdHguaGVpZ2h0ID0gdGhpcy50aWxlU2l6ZS5oZWlnaHQ7XG5cbiAgLy9zZXQgdW5pcXVlIGlkXG4gIHZhciB0aWxlX2lkID0gY29vcmQueCArICdfJyArIGNvb3JkLnkgKyAnXycgKyB6b29tO1xuXG4gIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlsZV9pZCk7XG4gIGhpdF9jYW52YXMuc2V0QXR0cmlidXRlKCdpZCcsIHRpbGVfaWQpO1xuXG4gIGlmICh0aWxlX2lkIGluIHRoaXMudGlsZXMpXG4gICAgICBkZWxldGUgdGhpcy50aWxlc1t0aWxlX2lkXTtcblxuICB0aGlzLnRpbGVzW3RpbGVfaWRdID0ge2NhbnZhczpjYW52YXMsIGN0eDpjdHgsIGhpdF9jYW52YXM6aGl0X2NhbnZhcywgaGl0X2N0eDpoaXRfY3R4LCBjb29yZDpjb29yZCwgem9vbTp6b29tLCBwcmltaXRpdmVzOm51bGx9O1xuXG4gIC8vIGN1c3RvbSBzZXR1cFxuICAvL2lmICh0aWxlX2lkID09ICcxOTI5NV8yNDY1NF8xNicpe1xuICBpZiAodGhpcy5jYW52YXNfc2V0dXApXG4gICAgICB0aGlzLmNhbnZhc19zZXR1cCh0aGlzLnRpbGVzW3RpbGVfaWRdLCBjb29yZCwgem9vbSk7XG4gIC8vfVxuICByZXR1cm4gY2FudmFzO1xuXG59XG5cblxuQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW3RdO1xuICAgICAgY2FsbGJhY2sodGlsZSk7XG4gIH1cbn1cblxuQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZS5yZWNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICB0aGlzLmNhbnZhc19zZXR1cCh0aWxlLCB0aWxlLmNvb3JkLCB0aWxlLnpvb20pO1xuICB9XG59O1xuXG5DYW52YXNUaWxlTGF5ZXIucHJvdG90eXBlLnJlZHJhd190aWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgdGhpcy5yZW5kZXIodGlsZSwgdGlsZS5jb29yZCwgdGlsZS56b29tKTtcbn07XG5cbkNhbnZhc1RpbGVMYXllci5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1t0XTtcbiAgICAgIHRoaXMucmVuZGVyKHRpbGUsIHRpbGUuY29vcmQsIHRpbGUuem9vbSk7XG4gIH1cbn07XG5cbi8vIGNvdWxkIGJlIGNhbGxlZCBkaXJlY3RseS4uLlxuQ2FudmFzVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKGNvb3JkLCB6b29tLCBvd25lckRvY3VtZW50KSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZV90aWxlX2NhbnZhcyhjb29yZCwgem9vbSwgb3duZXJEb2N1bWVudCk7XG59O1xuXG5DYW52YXNUaWxlTGF5ZXIucHJvdG90eXBlLnJlbGVhc2VUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgdmFyIGlkID0gdGlsZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gIGRlbGV0ZSB0aGlzLnRpbGVzW2lkXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzVGlsZUxheWVyO1xuIiwiZnVuY3Rpb24gR01hcHNUaWxlTG9hZGVyKCkge1xufVxuXG5cbkdNYXBzVGlsZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgX2luaXRUaWxlTG9hZGVyOiBmdW5jdGlvbihtYXAsIHByb2plY3Rpb24pIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgdGhpcy5fdGlsZXMgPSB7fTtcbiAgICB0aGlzLl90aWxlc0xvYWRpbmcgPSB7fTtcbiAgICB0aGlzLl90aWxlc1RvTG9hZCA9IDA7XG4gICAgdGhpcy5fdXBkYXRlVGlsZXMgPSB0aGlzLl91cGRhdGVUaWxlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKFxuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fbWFwLCAnZHJhZ2VuZCcsIHRoaXMuX3VwZGF0ZVRpbGVzKSxcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuX21hcCwgJ3pvb21fY2hhbmdlZCcsIHRoaXMuX3VwZGF0ZVRpbGVzKVxuICAgICk7XG4gICAgdGhpcy50aWxlU2l6ZSA9IDI1NjtcbiAgICB0aGlzLl91cGRhdGVUaWxlcygpO1xuICB9LFxuXG4gIF9yZW1vdmVUaWxlTG9hZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLl9yZW1vdmVUaWxlcygpO1xuICB9LFxuXG4gIF9yZW1vdmVUaWxlczogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICAgICAgdGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfcmVsb2FkVGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JlbW92ZVRpbGVzKCk7XG4gICAgdGhpcy5fdXBkYXRlVGlsZXMoKTtcbiAgfSxcblxuICBfdXBkYXRlVGlsZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0Qm91bmRzKCk7XG4gICAgICB2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICB2YXIgdGlsZVNpemUgPSB0aGlzLnRpbGVTaXplO1xuICAgICAgdmFyIG16b29tID0gKDEgPDwgem9vbSk7XG5cbiAgICAgIHZhciB0b3BMZWZ0ID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhcbiAgICAgICAgYm91bmRzLmdldE5vcnRoRWFzdCgpLmxhdCgpLFxuICAgICAgICBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKClcbiAgICAgICk7XG5cbiAgICAgIHZhciBib3R0b21SaWd0aCA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoXG4gICAgICAgIGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sYXQoKSxcbiAgICAgICAgYm91bmRzLmdldE5vcnRoRWFzdCgpLmxuZygpXG4gICAgICApO1xuXG5cbiAgICAgIHRoaXMuX3Byb2plY3Rpb24gPSB0aGlzLl9tYXAuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgdmFyIGRpdlRvcExlZnQgPSB0aGlzLl9wcm9qZWN0aW9uLmZyb21MYXRMbmdUb1BvaW50KHRvcExlZnQpO1xuICAgICAgdmFyIGRpdkJvdHRvbVJpZ2h0ID0gdGhpcy5fcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Qb2ludChib3R0b21SaWd0aCk7XG5cblxuICAgICAgdmFyIG53VGlsZVBvaW50ID0gbmV3IGdvb2dsZS5tYXBzLlBvaW50KFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKGRpdlRvcExlZnQueCptem9vbSAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihkaXZUb3BMZWZ0LnkqbXpvb20gLyB0aWxlU2l6ZSkpLFxuICAgICAgICAgIHNlVGlsZVBvaW50ID0gbmV3IGdvb2dsZS5tYXBzLlBvaW50KFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKGRpdkJvdHRvbVJpZ2h0LngqbXpvb20gLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoZGl2Qm90dG9tUmlnaHQueSptem9vbSAvIHRpbGVTaXplKSk7XG5cblxuICAgICAgdGhpcy5fYWRkVGlsZXNGcm9tQ2VudGVyT3V0KG53VGlsZVBvaW50LCBzZVRpbGVQb2ludCk7XG4gICAgICB0aGlzLl9yZW1vdmVPdGhlclRpbGVzKG53VGlsZVBvaW50LCBzZVRpbGVQb2ludCk7XG4gIH0sXG5cbiAgX3JlbW92ZU90aGVyVGlsZXM6IGZ1bmN0aW9uIChud1RpbGVQb2ludCwgc2VUaWxlUG9pbnQpIHtcbiAgICAgIHZhciBrQXJyLCB4LCB5LCBrZXk7XG5cbiAgICAgIHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgIGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpbGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAga0FyciA9IGtleS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICB4ID0gcGFyc2VJbnQoa0FyclswXSwgMTApO1xuICAgICAgICAgICAgICB5ID0gcGFyc2VJbnQoa0FyclsxXSwgMTApO1xuICAgICAgICAgICAgICB6ID0gcGFyc2VJbnQoa0FyclsyXSwgMTApO1xuXG4gICAgICAgICAgICAgIC8vIHJlbW92ZSB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kc1xuICAgICAgICAgICAgICBpZiAoeiAhPT0gem9vbSB8fCB4IDwgbndUaWxlUG9pbnQueCB8fCB4ID4gc2VUaWxlUG9pbnQueCB8fCB5IDwgbndUaWxlUG9pbnQueSB8fCB5ID4gc2VUaWxlUG9pbnQueSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9LFxuXG4gIF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0aGlzLm9uVGlsZVJlbW92ZWQgJiYgdGhpcy5vblRpbGVSZW1vdmVkKHRoaXMuX3RpbGVzW2tleV0pOyBcbiAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzTG9hZGluZ1trZXldO1xuICB9LFxuXG4gIF90aWxlS2V5OiBmdW5jdGlvbih0aWxlUG9pbnQpIHtcbiAgICByZXR1cm4gdGlsZVBvaW50LnggKyAnOicgKyB0aWxlUG9pbnQueSArICc6JyArIHRpbGVQb2ludC56b29tO1xuICB9LFxuXG4gIF90aWxlU2hvdWxkQmVMb2FkZWQ6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcbiAgICAgIHZhciBrID0gdGhpcy5fdGlsZUtleSh0aWxlUG9pbnQpO1xuICAgICAgcmV0dXJuICEoayBpbiB0aGlzLl90aWxlcykgJiYgIShrIGluIHRoaXMuX3RpbGVzTG9hZGluZyk7XG4gIH0sXG5cbiAgX3RpbGVMb2FkZWQ6IGZ1bmN0aW9uKHRpbGVQb2ludCwgdGlsZURhdGEpIHtcbiAgICB0aGlzLl90aWxlc1RvTG9hZC0tO1xuICAgIHZhciBrID0gdGlsZVBvaW50LnggKyAnOicgKyB0aWxlUG9pbnQueSArICc6JyArIHRpbGVQb2ludC56b29tXG4gICAgdGhpcy5fdGlsZXNba10gPSB0aWxlRGF0YTtcbiAgICBkZWxldGUgdGhpcy5fdGlsZXNMb2FkaW5nW2tdO1xuICAgIGlmKHRoaXMuX3RpbGVzVG9Mb2FkID09PSAwKSB7XG4gICAgICB0aGlzLm9uVGlsZXNMb2FkZWQgJiYgdGhpcy5vblRpbGVzTG9hZGVkKCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFRpbGVQb3M6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcbiAgICB2YXIgbGltaXQgPSAoMSA8PCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICAvLyB3cmFwIHRpbGVcbiAgICB0aWxlUG9pbnQgPSB7XG4gICAgICB4OiAoKHRpbGVQb2ludC54ICUgbGltaXQpICsgbGltaXQpICUgbGltaXQsXG4gICAgICB5OiB0aWxlUG9pbnQueVxuICAgIH07XG5cbiAgICB0aWxlUG9pbnQgPSBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoXG4gICAgICB0aWxlUG9pbnQueCAqIHRoaXMudGlsZVNpemUsIFxuICAgICAgdGlsZVBvaW50LnkgKiB0aGlzLnRpbGVTaXplXG4gICAgKTtcblxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0Qm91bmRzKCk7XG4gICAgdmFyIHRvcExlZnQgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKFxuICAgICAgYm91bmRzLmdldE5vcnRoRWFzdCgpLmxhdCgpLFxuICAgICAgYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZygpXG4gICAgKTtcblxuICAgIHZhciBkaXZUb3BMZWZ0ID0gdGhpcy5fbWFwLmdldFByb2plY3Rpb24oKS5mcm9tTGF0TG5nVG9Qb2ludCh0b3BMZWZ0KTtcbiAgICB6b29tID0gKDEgPDwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG4gICAgZGl2VG9wTGVmdC54ID0gZGl2VG9wTGVmdC54ICogem9vbTtcbiAgICBkaXZUb3BMZWZ0LnkgPSBkaXZUb3BMZWZ0LnkgKiB6b29tO1xuXG4gICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5Qb2ludChcbiAgICAgIHRpbGVQb2ludC54IC0gZGl2VG9wTGVmdC54LFxuICAgICAgdGlsZVBvaW50LnkgLSBkaXZUb3BMZWZ0LnlcbiAgICApO1xuICB9LFxuXG4gIF9hZGRUaWxlc0Zyb21DZW50ZXJPdXQ6IGZ1bmN0aW9uIChud1RpbGVQb2ludCwgc2VUaWxlUG9pbnQpIHtcbiAgICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICAgIGNlbnRlciA9IG5ldyBnb29nbGUubWFwcy5Qb2ludChcbiAgICAgICAgICAgIChud1RpbGVQb2ludC54ICsgc2VUaWxlUG9pbnQueCkgKiAwLjUsXG4gICAgICAgICAgICAobndUaWxlUG9pbnQueSArIHNlVGlsZVBvaW50LnkpICogMC41XG4gICAgICAgICAgKSxcbiAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblxuICAgICAgdmFyIGosIGksIHBvaW50O1xuXG4gICAgICBmb3IgKGogPSBud1RpbGVQb2ludC55OyBqIDw9IHNlVGlsZVBvaW50Lnk7IGorKykge1xuICAgICAgICAgIGZvciAoaSA9IG53VGlsZVBvaW50Lng7IGkgPD0gc2VUaWxlUG9pbnQueDsgaSsrKSB7XG4gICAgICAgICAgICAgIHBvaW50ID0gbmV3IGdvb2dsZS5tYXBzLlBvaW50IChpLCBqKTtcbiAgICAgICAgICAgICAgcG9pbnQuem9vbSA9IHpvb207XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3RpbGVTaG91bGRCZUxvYWRlZChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGlsZXNUb0xvYWQgPSBxdWV1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICh0aWxlc1RvTG9hZCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgZnVuY3Rpb24gZGlzdGFuY2VUb0NlbnRlclNxKHBvaW50KSB7XG4gICAgICAgIHZhciBkeCA9IHBvaW50LnggLSBjZW50ZXIueDtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnQueSAtIGNlbnRlci55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gICAgICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGRpc3RhbmNlVG9DZW50ZXJTcShhKSAtIGRpc3RhbmNlVG9DZW50ZXJTcShiKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl90aWxlc1RvTG9hZCArPSB0aWxlc1RvTG9hZDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGlsZXNUb0xvYWQ7IGkrKykge1xuICAgICAgICAgIHZhciB0ID0gcXVldWVbaV07XG4gICAgICAgICAgdmFyIGsgPSB0aGlzLl90aWxlS2V5KHQpO1xuICAgICAgICAgIHRoaXMuX3RpbGVzTG9hZGluZ1trXSA9IHQ7XG4gICAgICAgICAgLy8gZXZlbnRzXG4gICAgICAgICAgaWYgKHRoaXMub25UaWxlQWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25UaWxlQWRkZWQodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHRoaXMub25UaWxlc0xvYWRpbmcgJiYgdGhpcy5vblRpbGVzTG9hZGluZygpO1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHTWFwc1RpbGVMb2FkZXI7XG4iLCJ2YXIgZ21hcHMgPSB7fTtcbmlmICh0eXBlb2YgZ29vZ2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ29vZ2xlLm1hcHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ21hcHMgPSByZXF1aXJlKCcuL3RvcnF1ZScpO1xuICAgIGdtYXBzLkdNYXBzVGlsZUxvYWRlciA9IHJlcXVpcmUoJy4vZ21hcHNfdGlsZWxvYWRlcl9taXhpbicpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnbWFwcztcbiIsInZhciBjYXJ0byA9IGdsb2JhbC5jYXJ0byB8fCByZXF1aXJlKCdjYXJ0bycpO1xudmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4uLycpO1xudmFyIENhbnZhc0xheWVyID0gcmVxdWlyZSgnLi9DYW52YXNMYXllcicpO1xudmFyIENhbnZhc1RpbGVMYXllciA9IHJlcXVpcmUoJy4vY2FudmFzX3RpbGVfbGF5ZXInKTtcbnZhciBHTWFwc1RpbGVMb2FkZXIgPSByZXF1aXJlKCcuL2dtYXBzX3RpbGVsb2FkZXJfbWl4aW4nKTtcblxuZnVuY3Rpb24gR01hcHNUb3JxdWVMYXllcihvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKCF0b3JxdWUuaXNCcm93c2VyU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdG9ycXVlXCIpO1xuICB9XG4gIHRoaXMua2V5ID0gMDtcbiAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMub3B0aW9ucyA9IHRvcnF1ZS5leHRlbmQoe30sIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMgPSB0b3JxdWUuZXh0ZW5kKHtcbiAgICBwcm92aWRlcjogJ3dpbmRzaGFmdCcsXG4gICAgcmVuZGVyZXI6ICdwb2ludCcsXG4gICAgcmVzb2x1dGlvbjogMixcbiAgICBzdGVwczogMTAwLFxuICAgIHZpc2libGU6IHRydWVcbiAgfSwgdGhpcy5vcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuY2FydG9jc3MpIHtcbiAgICB0b3JxdWUuZXh0ZW5kKHRoaXMub3B0aW9ucyxcbiAgICAgICAgdG9ycXVlLmNvbW1vbi5Ub3JxdWVMYXllci5vcHRpb25zRnJvbUNhcnRvQ1NTKG9wdGlvbnMuY2FydG9jc3MpKTtcbiAgfVxuXG4gIGlmKG9wdGlvbnMudGlsZUpTT04pIHRoaXMub3B0aW9ucy5wcm92aWRlciA9IFwidGlsZUpTT05cIjtcblxuICB0aGlzLmhpZGRlbiA9ICF0aGlzLm9wdGlvbnMudmlzaWJsZTtcblxuICB0aGlzLmFuaW1hdG9yID0gbmV3IHRvcnF1ZS5BbmltYXRvcihmdW5jdGlvbih0aW1lKSB7XG4gICAgdmFyIGsgPSB0aW1lIHwgMDtcbiAgICBpZihzZWxmLmtleSAhPT0gaykge1xuICAgICAgc2VsZi5zZXRLZXkoayk7XG4gICAgfVxuICB9LCB0b3JxdWUuZXh0ZW5kKHRvcnF1ZS5jbG9uZSh0aGlzLm9wdGlvbnMpLCB7XG4gICAgb25QYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZpcmUoJ3BhdXNlJyk7XG4gICAgfSxcbiAgICBvblN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5maXJlKCdzdG9wJyk7XG4gICAgfSxcbiAgICBvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZmlyZSgncGxheScpO1xuICAgIH0sXG4gICAgb25TdGVwc1JhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZmlyZSgnY2hhbmdlOnN0ZXBzUmFuZ2UnLCBzZWxmLmFuaW1hdG9yLnN0ZXBzUmFuZ2UoKSk7XG4gICAgfVxuICB9KSk7XG5cbiAgdGhpcy5wbGF5ID0gdGhpcy5hbmltYXRvci5zdGFydC5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICB0aGlzLnN0b3AgPSB0aGlzLmFuaW1hdG9yLnN0b3AuYmluZCh0aGlzLmFuaW1hdG9yKTtcbiAgdGhpcy5wYXVzZSA9IHRoaXMuYW5pbWF0b3IucGF1c2UuYmluZCh0aGlzLmFuaW1hdG9yKTtcbiAgdGhpcy50b2dnbGUgPSB0aGlzLmFuaW1hdG9yLnRvZ2dsZS5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICB0aGlzLnNldER1cmF0aW9uID0gdGhpcy5hbmltYXRvci5kdXJhdGlvbi5iaW5kKHRoaXMuYW5pbWF0b3IpO1xuICB0aGlzLmlzUnVubmluZyA9IHRoaXMuYW5pbWF0b3IuaXNSdW5uaW5nLmJpbmQodGhpcy5hbmltYXRvcik7XG5cblxuICBDYW52YXNMYXllci5jYWxsKHRoaXMsIHtcbiAgICBtYXA6IHRoaXMub3B0aW9ucy5tYXAsXG4gICAgLy9yZXNpemVIYW5kbGVyOiB0aGlzLnJlZHJhdyxcbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICB1cGRhdGVIYW5kbGVyOiB0aGlzLnJlbmRlcixcbiAgICByZWFkeUhhbmRsZXI6IHRoaXMuaW5pdGlhbGl6ZVxuICB9KTtcblxufVxuXG4vKipcbiAqIHRvcnF1ZSBsYXllclxuICovXG5HTWFwc1RvcnF1ZUxheWVyLnByb3RvdHlwZSA9IHRvcnF1ZS5leHRlbmQoe30sXG4gIENhbnZhc0xheWVyLnByb3RvdHlwZSxcbiAgR01hcHNUaWxlTG9hZGVyLnByb3RvdHlwZSxcbiAgdG9ycXVlLkV2ZW50LFxuICB7XG5cbiAgcHJvdmlkZXJzOiB7XG4gICAgJ3NxbF9hcGknOiB0b3JxdWUucHJvdmlkZXJzLmpzb24sXG4gICAgJ3VybF90ZW1wbGF0ZSc6IHRvcnF1ZS5wcm92aWRlcnMuSnNvbkFycmF5LFxuICAgICd3aW5kc2hhZnQnOiB0b3JxdWUucHJvdmlkZXJzLndpbmRzaGFmdCxcbiAgICAndGlsZUpTT04nOiB0b3JxdWUucHJvdmlkZXJzLnRpbGVKU09OXG4gIH0sXG5cbiAgcmVuZGVyZXJzOiB7XG4gICAgJ3BvaW50JzogdG9ycXVlLnJlbmRlcmVyLlBvaW50LFxuICAgICdwaXhlbCc6IHRvcnF1ZS5yZW5kZXJlci5SZWN0YW5nbGVcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLm9uVGlsZUFkZGVkID0gdGhpcy5vblRpbGVBZGRlZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5vcHRpb25zLnJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZpcmUoXCJjaGFuZ2U6Ym91bmRzXCIsIHtcbiAgICAgICAgYm91bmRzOiBzZWxmLnByb3ZpZGVyLmdldEJvdW5kcygpXG4gICAgICB9KTtcbiAgICAgIHNlbGYuYW5pbWF0b3Iuc3RlcHMoc2VsZi5wcm92aWRlci5nZXRTdGVwcygpKTtcbiAgICAgIHNlbGYuYW5pbWF0b3IucmVzY2FsZSgpO1xuICAgICAgc2VsZi5maXJlKCdjaGFuZ2U6c3RlcHMnLCB7XG4gICAgICAgIHN0ZXBzOiBzZWxmLnByb3ZpZGVyLmdldFN0ZXBzKClcbiAgICAgIH0pO1xuICAgICAgc2VsZi5zZXRLZXkoc2VsZi5rZXkpO1xuICAgIH07XG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IHRoaXMucHJvdmlkZXJzW3RoaXMub3B0aW9ucy5wcm92aWRlcl0odGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IHRoaXMucmVuZGVyZXJzW3RoaXMub3B0aW9ucy5yZW5kZXJlcl0odGhpcy5nZXRDYW52YXMoKSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMuZXJyb3JDYWxsYmFjayA9IHRoaXMub3B0aW9ucy5lcnJvckNhbGxiYWNrO1xuXG4gICAgLy8gdGhpcyBsaXN0ZW5lciBzaG91bGQgYmUgYmVmb3JlIHRpbGUgbG9hZGVyXG4gICAgdGhpcy5fY2FjaGVMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMub3B0aW9ucy5tYXAsICd6b29tX2NoYW5nZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyZXIgJiYgc2VsZi5yZW5kZXJlci5jbGVhclNwcml0ZUNhY2hlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0VGlsZUxvYWRlcih0aGlzLm9wdGlvbnMubWFwLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG5cbiAgICBpZiAodGhpcy5zaGFkZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2hhZGVyKHRoaXMuc2hhZGVyKTtcbiAgICB9XG5cbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLmhpZGRlbikgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgaWYoIXRoaXMuaGlkZGVuKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMucGxheSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcHMgPT09IDEpe1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0U1FMOiBmdW5jdGlvbihzcWwpIHtcbiAgICBpZiAodGhpcy5wcm92aWRlci5vcHRpb25zLm5hbWVkX21hcCkgdGhyb3cgbmV3IEVycm9yKFwiU1FMIHF1ZXJpZXMgb24gbmFtZWQgbWFwcyBhcmUgcmVhZC1vbmx5XCIpO1xuICAgIGlmICghdGhpcy5wcm92aWRlciB8fCAhdGhpcy5wcm92aWRlci5zZXRTUUwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRoaXMgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBTUUxcIik7XG4gICAgfVxuICAgIHRoaXMucHJvdmlkZXIuc2V0U1FMKHNxbCk7XG4gICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uKF8pIHtcbiAgICB0aGlzLnJlbmRlcmVyICYmIHRoaXMucmVuZGVyZXIuc2V0QmxlbmRNb2RlKF8pO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH0sXG5cbiAgc2V0U3RlcHM6IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgdGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLnNldFN0ZXBzKHN0ZXBzKTtcbiAgICB0aGlzLmFuaW1hdG9yICYmIHRoaXMuYW5pbWF0b3Iuc3RlcHMoc3RlcHMpO1xuICAgIHRoaXMuX3JlbG9hZFRpbGVzKCk7XG4gIH0sXG5cbiAgc2V0Q29sdW1uOiBmdW5jdGlvbihjb2x1bW4sIGlzVGltZSkge1xuICAgIHRoaXMucHJvdmlkZXIgJiYgdGhpcy5wcm92aWRlci5zZXRDb2x1bW4oY29sdW1uLCBpc1RpbWUpO1xuICAgIHRoaXMuX3JlbG9hZFRpbGVzKCk7XG4gIH0sXG5cbiAgZ2V0VGltZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIgJiYgdGhpcy5wcm92aWRlci5nZXRLZXlTcGFuKCk7XG4gIH0sXG5cbiAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gIH0sXG5cbiAgICAvLyBmb3IgZWFjaCB0aWxlIHNob3duIG9uIHRoZSBtYXAgcmVxdWVzdCB0aGUgZGF0YVxuICBvblRpbGVBZGRlZDogZnVuY3Rpb24odCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnByb3ZpZGVyLmdldFRpbGVEYXRhKHQsIHQuem9vbSwgZnVuY3Rpb24odGlsZURhdGEpIHtcbiAgICAgIC8vIGRvbid0IGxvYWQgdGlsZXMgdGhhdCBhcmUgbm90IGJlaW5nIHNob3duXG4gICAgICBpZiAodC56b29tICE9PSBzZWxmLm9wdGlvbnMubWFwLmdldFpvb20oKSkgcmV0dXJuO1xuICAgICAgc2VsZi5fdGlsZUxvYWRlZCh0LCB0aWxlRGF0YSk7XG4gICAgICBzZWxmLmZpcmUoJ3RpbGVMb2FkZWQnKTtcbiAgICAgIGlmICh0aWxlRGF0YSkge1xuICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZW5kZXIgdGhlIHNlbGVjdGVmIGtleVxuICAgKiBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHksIGl0J3MgY2FsbGVkIGJ5XG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVXNlIHJlZHJhdyB0byByZWZyZXNoIGl0XG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuaGlkZGVuKSByZXR1cm47XG4gICAgdmFyIHQsIHRpbGUsIHBvcztcbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgdGhpcy5yZW5kZXJlci5jbGVhckNhbnZhcygpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIHJlbmRlcnMgb25seSBhIFwiZnJhbWVcIlxuICAgIGZvcih0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBpZiAodGlsZSkge1xuICAgICAgICBwb3MgPSB0aGlzLmdldFRpbGVQb3ModGlsZS5jb29yZCk7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUaWxlKHRpbGUsIHRoaXMua2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5hcHBseUZpbHRlcnMoKTtcbiAgfSxcblxuICBnZXRBY3RpdmVQb2ludHNCQm94OiBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciB0aWxlTWF4ID0gdGhpcy5vcHRpb25zLnJlc29sdXRpb24gKiAoMjU2L3RoaXMub3B0aW9ucy5yZXNvbHV0aW9uIC0gMSk7XG4gICAgZm9yKHZhciB0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgcG9zaXRpb25zID0gcG9zaXRpb25zLmNvbmNhdCh0aGlzLnJlbmRlcmVyLmdldEFjdGl2ZVBvaW50c0JCb3godGlsZSwgc3RlcCkpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25zO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQga2V5IHRvIGJlIHNob3duLiBJZiBpdCdzIGEgc2luZ2xlIHZhbHVlXG4gICAqIGl0IHJlbmRlcnMgZGlyZWN0bHksIGlmIGl0J3MgYW4gYXJyYXkgaXQgcmVuZGVyc1xuICAgKiBhY2N1bXVsYXRlZFxuICAgKi9cbiAgc2V0S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmFuaW1hdG9yLnN0ZXAoa2V5KTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlOnRpbWUnLCB7IHRpbWU6IHRoaXMuZ2V0VGltZSgpLCBzdGVwOiB0aGlzLmtleSB9KTtcbiAgfSxcblxuICAvKipcbiAgICogaGVscGVyIGZ1bmN0aW9uLCBkb2VzIHRoZSBzYW1lIHRoYW4gYGBzZXRLZXlgYCBidXQgb25seVxuICAgKiBhY2NlcHRzIHNjYWxhcnMuXG4gICAqL1xuICBzZXRTdGVwOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgaWYodGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFRpbWUgb25seSBhY2NlcHQgc2NhbGFyc1wiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRLZXkodGltZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRyYW5zZm9ybSBmcm9tIGFuaW1hdGlvbiBzdGVwIHRvIERhdGUgb2JqZWN0XG4gICAqIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aW1lXG4gICAqXG4gICAqIGBgc3RlcGBgIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIGBgc3RlcHMgLSAxYGBcbiAgICovXG4gIHN0ZXBUb1RpbWU6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHJldHVybiAwO1xuICAgIHZhciB0aW1lcyA9IHRoaXMucHJvdmlkZXIuZ2V0S2V5U3BhbigpO1xuICAgIHZhciB0aW1lID0gdGltZXMuc3RhcnQgKyAodGltZXMuZW5kIC0gdGltZXMuc3RhcnQpKihzdGVwL3RoaXMucHJvdmlkZXIuZ2V0U3RlcHMoKSk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWUpO1xuICB9LFxuXG4gIHRpbWVUb1N0ZXA6IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSBcIkRhdGVcIikgdGltZXN0YW1wID0gdGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHJldHVybiAwO1xuICAgIHZhciB0aW1lcyA9IHRoaXMucHJvdmlkZXIuZ2V0S2V5U3BhbigpO1xuICAgIHZhciBzdGVwID0gKHRoaXMucHJvdmlkZXIuZ2V0U3RlcHMoKSAqICh0aW1lc3RhbXAgLSB0aW1lcy5zdGFydCkpIC8gKHRpbWVzLmVuZCAtIHRpbWVzLnN0YXJ0KTtcbiAgICByZXR1cm4gc3RlcDtcbiAgfSxcblxuICBnZXRTdGVwOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIGFuaW1hdGlvbiB0aW1lIGRlZmluZWQgYnkgdGhlIGRhdGFcbiAgICogaW4gdGhlIGRlZmluZWQgY29sdW1uLiBEYXRlIG9iamVjdFxuICAgKi9cbiAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcFRvVGltZSh0aGlzLmtleSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCB0aGUgY2FydG9jc3MgZm9yIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBzZXRDYXJ0b0NTUzogZnVuY3Rpb24oY2FydG9jc3MpIHtcbiAgICBpZiAodGhpcy5wcm92aWRlciAmJiB0aGlzLnByb3ZpZGVyLm9wdGlvbnMubmFtZWRfbWFwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYXJ0b0NTUyBzdHlsZSBvbiBuYW1lZCBtYXBzIGlzIHJlYWQtb25seVwiKTtcbiAgICB2YXIgc2hhZGVyID0gbmV3IGNhcnRvLlJlbmRlcmVySlMoKS5yZW5kZXIoY2FydG9jc3MpO1xuICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFNoYWRlcihzaGFkZXIpO1xuICAgIH1cblxuICAgIC8vIHByb3ZpZGVyIG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IHRvcnF1ZS5jb21tb24uVG9ycXVlTGF5ZXIub3B0aW9uc0Zyb21MYXllcihzaGFkZXIuZmluZExheWVyKHsgbmFtZTogJ01hcCcgfSkpO1xuICAgIHRoaXMucHJvdmlkZXIgJiYgdGhpcy5wcm92aWRlci5zZXRDYXJ0b0NTUyAmJiB0aGlzLnByb3ZpZGVyLnNldENhcnRvQ1NTKGNhcnRvY3NzKTtcbiAgICBpZih0aGlzLnByb3ZpZGVyICYmIHRoaXMucHJvdmlkZXIuc2V0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgICB9XG4gICAgdG9ycXVlLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gYW5pbWF0b3Igb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmFuaW1hdG9yLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMucmVkcmF3KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVkcmF3OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlKCk7XG4gIH0sXG5cbiAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlyZSgncmVtb3ZlJyk7XG4gICAgQ2FudmFzTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5hbmltYXRvci5zdG9wKCk7XG4gICAgdGhpcy5fcmVtb3ZlVGlsZUxvYWRlcigpO1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2NhY2hlTGlzdGVuZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgdmFsdWVzIGZvciBhbGwgdGhlIHBpeGVscyBhY3RpdmUgZm9yIHRoZSBzdGVwXG4gICAqL1xuICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5OiBzdGVwO1xuICAgIHZhciB0LCB0aWxlO1xuICAgIGZvcih0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICB0aGlzLnJlbmRlcmVyLmdldFZhbHVlcyh0aWxlLCBzdGVwLCB2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuXG4gIGdldFZhbHVlRm9yUG9zOiBmdW5jdGlvbih4LCB5LCBzdGVwKSB7XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5OiBzdGVwO1xuICAgIHZhciB0LCB0aWxlLCBwb3MsIHZhbHVlID0gbnVsbCwgeHgsIHl5O1xuICAgIGZvcih0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBwb3MgPSB0aGlzLmdldFRpbGVQb3ModGlsZS5jb29yZCk7XG4gICAgICB4eCA9IHggLSBwb3MueDtcbiAgICAgIHl5ID0geSAtIHBvcy55O1xuICAgICAgaWYgKHh4ID49IDAgJiYgeXkgPj0gMCAmJiB4eCA8IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFICYmIHl5IDw9IHRoaXMucmVuZGVyZXIuVElMRV9TSVpFKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5yZW5kZXJlci5nZXRWYWx1ZUZvcih0aWxlLCBzdGVwLCB4eCwgeXkpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGdldFZhbHVlRm9yQkJveDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgIHZhciB4ZiA9IHggKyB3LCB5ZiA9IHkgKyBoO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvcihfeSA9IHk7IHk8eWY7IHkrPXRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgIGZvcihfeCA9IHg7IHg8eGY7IHgrPXRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgICAgdmFyIHRoaXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JQb3MoX3gsX3kpO1xuICAgICAgICBpZiAodGhpc1ZhbHVlKXtcbiAgICAgICAgICB2YXIgYmIgPSB0aGlzVmFsdWUuYmJveDtcbiAgICAgICAgICB2YXIgcHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpXG4gICAgICAgICAgdmFyIHh5ID0gcHJvai5mcm9tTGF0TG5nVG9Db250YWluZXJQaXhlbChuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJiWzFdLmxhdCwgYmJbMV0ubG9uKSk7XG4gICAgICAgICAgaWYoeHkueCA8IHhmICYmIHh5LnkgPCB5Zil7XG4gICAgICAgICAgICBzdW0gKz0gdGhpc1ZhbHVlLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9LFxuXG4gIGVycm9yOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9wdGlvbnMuZXJyb3JDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuXG5cblxuZnVuY3Rpb24gR01hcHNUaWxlZFRvcnF1ZUxheWVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdG9ycXVlLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIENhbnZhc1RpbGVMYXllci5jYWxsKHRoaXMsIHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksIHRoaXMuZHJhd1RpbGUuYmluZCh0aGlzKSk7XG4gIHRoaXMuaW5pdGlhbGl6ZShvcHRpb25zKTtcbn1cblxuR01hcHNUaWxlZFRvcnF1ZUxheWVyLnByb3RvdHlwZSA9IHRvcnF1ZS5leHRlbmQoe30sIENhbnZhc1RpbGVMYXllci5wcm90b3R5cGUsIHtcblxuICBwcm92aWRlcnM6IHtcbiAgICAnc3FsX2FwaSc6IHRvcnF1ZS5wcm92aWRlcnMuanNvbixcbiAgICAndXJsX3RlbXBsYXRlJzogdG9ycXVlLnByb3ZpZGVycy5Kc29uQXJyYXlcbiAgfSxcblxuICByZW5kZXJlcnM6IHtcbiAgICAncG9pbnQnOiB0b3JxdWUucmVuZGVyZXIuUG9pbnQsXG4gICAgJ3BpeGVsJzogdG9ycXVlLnJlbmRlcmVyLlJlY3RhbmdsZVxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5rZXkgPSAwO1xuXG4gICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8ICdwaXhlbCc7XG4gICAgdGhpcy5vcHRpb25zLnByb3ZpZGVyID0gdGhpcy5vcHRpb25zLnByb3ZpZGVyIHx8ICdzcWxfYXBpJztcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgdGhpcy5wcm92aWRlcnNbdGhpcy5vcHRpb25zLnByb3ZpZGVyXShvcHRpb25zKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IHRoaXMucmVuZGVyZXJzW3RoaXMub3B0aW9ucy5yZW5kZXJlcl0obnVsbCwgb3B0aW9ucyk7XG5cbiAgfSxcblxuICBfdGlsZUxvYWRlZDogZnVuY3Rpb24odGlsZSwgdGlsZURhdGEpIHtcbiAgICB0aWxlLmRhdGEgPSB0aWxlRGF0YTtcbiAgICB0aGlzLmRyYXdUaWxlKHRpbGUpO1xuICB9LFxuXG4gIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSwgY29vcmQsIHpvb20pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxpbWl0ID0gMSA8PCB6b29tO1xuICAgIC8vIHdyYXAgdGlsZVxuICAgIHZhciB3cmFwcGVkQ29vcmQgPSB7XG4gICAgICB4OiAoKGNvb3JkLnggJSBsaW1pdCkgKyBsaW1pdCkgJSBsaW1pdCxcbiAgICAgIHk6IGNvb3JkLnlcbiAgICB9O1xuXG4gICAgdGhpcy5wcm92aWRlci5nZXRUaWxlRGF0YSh3cmFwcGVkQ29vcmQsIHpvb20sIGZ1bmN0aW9uKHRpbGVEYXRhKSB7XG4gICAgICBzZWxmLl90aWxlTG9hZGVkKHRpbGUsIHRpbGVEYXRhKTtcbiAgICB9KTtcbiAgfSxcblxuICBkcmF3VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcbiAgICB2YXIgY2FudmFzID0gdGlsZS5jYW52YXM7XG4gICAgaWYoIXRpbGUuZGF0YSkgcmV0dXJuO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2FudmFzKGNhbnZhcyk7XG5cbiAgICB2YXIgYWNjdW0gPSB0aGlzLnJlbmRlcmVyLmFjY3VtdWxhdGUodGlsZS5kYXRhLCB0aGlzLmtleSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUaWxlQWNjdW0oYWNjdW0sIDAsIDApO1xuICB9LFxuXG4gIHNldEtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IHRoZSBjYXJ0b2NzcyBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICovXG4gIHNldENhcnRvQ1NTOiBmdW5jdGlvbihjYXJ0b2Nzcykge1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikgdGhyb3cgbmV3IEVycm9yKCdyZW5kZXJlciBpcyBub3QgdmFsaWQnKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5zZXRDYXJ0b0NTUyhjYXJ0b2Nzcyk7XG4gIH0sXG5cbiAgc2V0U3RlcHNSYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuYW5pbWF0b3Iuc3RlcHNSYW5nZShzdGFydCwgZW5kKTtcbiAgfSxcblxuICByZW1vdmVTdGVwc1JhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFuaW1hdG9yLnJlbW92ZUN1c3RvbVN0ZXBzUmFuZ2UoKTtcbiAgfSxcblxuICBnZXRTdGVwc1JhbmdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRvci5zdGVwc1JhbmdlKCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEdNYXBzVGlsZWRUb3JxdWVMYXllcjogR01hcHNUaWxlZFRvcnF1ZUxheWVyLFxuICAgIEdNYXBzVG9ycXVlTGF5ZXI6IEdNYXBzVG9ycXVlTGF5ZXJcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cy5BbmltYXRvciA9IHJlcXVpcmUoJy4vYW5pbWF0b3InKTtcbm1vZHVsZS5leHBvcnRzLmNhcnRvY3NzX3JlZmVyZW5jZSA9IHJlcXVpcmUoJy4vY2FydG9jc3NfcmVmZXJlbmNlJyk7XG5tb2R1bGUuZXhwb3J0cy5jb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xubW9kdWxlLmV4cG9ydHMubWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xubW9kdWxlLmV4cG9ydHMuTWVyY2F0b3IgPSByZXF1aXJlKCcuL21lcmNhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cy5uZXQgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcbm1vZHVsZS5leHBvcnRzLnJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xubW9kdWxlLmV4cG9ydHMucHJvdmlkZXJzID0gcmVxdWlyZSgnLi9wcm92aWRlcicpO1xuXG5yZXF1aXJlKCcuL2xlYWZsZXQnKTtcblxudmFyIGdtYXBzID0gcmVxdWlyZSgnLi9nbWFwcycpO1xubW9kdWxlLmV4cG9ydHMuR01hcHNUaWxlTG9hZGVyID0gZ21hcHMuR01hcHNUaWxlTG9hZGVyO1xubW9kdWxlLmV4cG9ydHMuR01hcHNUb3JxdWVMYXllciA9IGdtYXBzLkdNYXBzVG9ycXVlTGF5ZXI7XG5tb2R1bGUuZXhwb3J0cy5HTWFwc1RpbGVkVG9ycXVlTGF5ZXIgPSBnbWFwcy5HTWFwc1RpbGVkVG9ycXVlTGF5ZXI7XG4iLCJyZXF1aXJlKCcuL2xlYWZsZXRfdGlsZWxvYWRlcl9taXhpbicpO1xuXG4vKipcbiAqIGZ1bGwgY2FudmFzIGxheWVyIGltcGxlbWVudGF0aW9uIGZvciBMZWFmbGV0XG4gKi9cblxuTC5DYW52YXNMYXllciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblxuICBpbmNsdWRlczogW0wuTWl4aW4uRXZlbnRzLCBMLk1peGluLlRpbGVMb2FkZXJdLFxuXG4gIG9wdGlvbnM6IHtcbiAgICAgIG1pblpvb206IDAsXG4gICAgICBtYXhab29tOiAyOCxcbiAgICAgIHRpbGVTaXplOiAyNTYsXG4gICAgICBzdWJkb21haW5zOiAnYWJjJyxcbiAgICAgIGVycm9yVGlsZVVybDogJycsXG4gICAgICBhdHRyaWJ1dGlvbjogJycsXG4gICAgICB6b29tT2Zmc2V0OiAwLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHVubG9hZEludmlzaWJsZVRpbGVzOiBMLkJyb3dzZXIubW9iaWxlLFxuICAgICAgdXBkYXRlV2hlbklkbGU6IEwuQnJvd3Nlci5tb2JpbGUsXG4gICAgICB0aWxlTG9hZGVyOiBmYWxzZSwgLy8gaW5zdGFsbHMgdGlsZSBsb2FkaW5nIGV2ZW50c1xuICAgICAgem9vbUFuaW1hdGlvbjogdHJ1ZVxuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vdGhpcy5wcm9qZWN0ID0gdGhpcy5fcHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMoKTtcbiAgICAvLyBiYWNrQ2FudmFzIGZvciB6b29tIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fYmFja0NhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcygpO1xuICAgIH1cbiAgICB0aGlzLl9jdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IC0xO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGlkKSB7IGNsZWFyVGltZW91dChpZCk7IH07XG4gIH0sXG5cbiAgX2NyZWF0ZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbnZhcztcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcbiAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4IHx8IDA7XG4gICAgdmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXRpbGUtY29udGFpbmVyJztcbiAgICBpZiAodGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnIGxlYWZsZXQtem9vbS1hbmltYXRlZCc7XG4gICAgfVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgLy8gYWRkIGNvbnRhaW5lciB3aXRoIHRoZSBjYW52YXMgdG8gdGhlIHRpbGUgcGFuZVxuICAgIC8vIHRoZSBjb250YWluZXIgaXMgbW92ZWQgaW4gdGhlIG9wb3NpdGUgZGlyZWN0aW9uIG9mIHRoZSBcbiAgICAvLyBtYXAgcGFuZSB0byBrZWVwIHRoZSBjYW52YXMgYWx3YXlzIGluICgwLCAwKVxuICAgIHZhciB0aWxlUGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XG4gICAgdmFyIF9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllcicpO1xuICAgIF9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgICAgIF9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fYmFja0NhbnZhcyk7XG4gICAgICB0aGlzLl9iYWNrQ2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIHRpbGVQYW5lLmFwcGVuZENoaWxkKF9jb250YWluZXIpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyID0gX2NvbnRhaW5lcjtcblxuICAgIC8vIGhhY2s6IGxpc3RlbiB0byBwcmVkcmFnIGV2ZW50IGxhdW5jaGVkIGJ5IGRyYWdnaW5nIHRvXG4gICAgLy8gc2V0IGNvbnRhaW5lciBpbiBwb3NpdGlvbiAoMCwgMCkgaW4gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgbWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkID0gbWFwLmRyYWdnaW5nLl9kcmFnZ2FibGU7XG4gICAgICBMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY2FudmFzLCB7IHg6IC1kLl9uZXdQb3MueCwgeTogLWQuX25ld1Bvcy55IH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgbWFwLm9uKHsgJ3ZpZXdyZXNldCc6IHRoaXMuX3Jlc2V0IH0sIHRoaXMpO1xuICAgIG1hcC5vbignbW92ZScsIHRoaXMucmVkcmF3LCB0aGlzKTtcbiAgICBtYXAub24oJ3Jlc2l6ZScsIHRoaXMuX3Jlc2V0LCB0aGlzKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuICAgICAgbWFwLm9uKHtcbiAgICAgICAgJ3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXG4gICAgICAgICd6b29tZW5kJzogdGhpcy5fZW5kWm9vbUFuaW0sXG4gICAgICAgICdtb3ZlZW5kJzogdGhpcy5fcmVzZXRcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy50aWxlTG9hZGVyKSB7XG4gICAgICB0aGlzLl9pbml0VGlsZUxvYWRlcigpO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc2V0KCk7XG4gIH0sXG5cbiAgX2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBiYWNrID0gdGhpcy5fYmFja0NhbnZhcztcblxuICAgIGJhY2sud2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGg7XG4gICAgYmFjay5oZWlnaHQgPSB0aGlzLl9jYW52YXMuaGVpZ2h0O1xuXG4gICAgLy8gcGFpbnQgY3VycmVudCBjYW52YXMgaW4gYmFjayBjYW52YXMgd2l0aCB0cmFzbmZvcm1hdGlvblxuICAgIHZhciBwb3MgPSB0aGlzLl9jYW52YXMuX2xlYWZsZXRfcG9zIHx8IHsgeDogMCwgeTogMCB9O1xuICAgIGJhY2suZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5fY2FudmFzLCAwLCAwKTtcblxuICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbihiYWNrLCBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY2FudmFzKSk7XG5cbiAgICAvLyBoaWRlIG9yaWdpbmFsXG4gICAgdGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYmFjay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgIHZhciBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUoZS56b29tKTtcbiAgICB2YXIgbmV3Q2VudGVyID0gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQobWFwLmdldENlbnRlcigpLCBlLnpvb20sIGUuY2VudGVyKTtcbiAgICB2YXIgb2xkQ2VudGVyID0gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQoZS5jZW50ZXIsIGUuem9vbSwgZS5jZW50ZXIpO1xuXG4gICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgIHg6ICBuZXdDZW50ZXIueCAtIG9sZENlbnRlci54ICsgcG9zLngsXG4gICAgICB5OiAgbmV3Q2VudGVyLnkgLSBvbGRDZW50ZXIueSArIHBvcy55LFxuICAgIH07XG5cbiAgICB2YXIgYmcgPSBiYWNrO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBMLkRvbVV0aWwuVFJBTlNGT1JNO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBiZy5zdHlsZVt0cmFuc2Zvcm1dID0gTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhvcmlnaW4pICsgJyBzY2FsZSgnICsgZS5zY2FsZSArICcpICc7XG4gICAgfSwgMClcbiAgfSxcblxuICBfZW5kWm9vbUFuaW06IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5fYmFja0NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuX2JhY2tDYW52YXMuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPSAnJztcbiAgfSxcblxuICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gIH0sXG5cbiAgZ2V0QXR0cmlidXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2V0KCk7XG4gIH0sXG5cbiAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICB0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgIG1hcC5vZmYoe1xuICAgICAgJ3ZpZXdyZXNldCc6IHRoaXMuX3Jlc2V0LFxuICAgICAgJ21vdmUnOiB0aGlzLl9yZW5kZXIsXG4gICAgICAnbW92ZWVuZCc6IHRoaXMuX3Jlc2V0LFxuICAgICAgJ3Jlc2l6ZSc6IHRoaXMuX3Jlc2V0LFxuICAgICAgJ3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXG4gICAgICAnem9vbWVuZCc6IHRoaXMuX2VuZFpvb21BbmltXG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgYWRkVG86IGZ1bmN0aW9uIChtYXApIHtcbiAgICBtYXAuYWRkTGF5ZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMucHJvdmlkZXIub3B0aW9ucy5lcnJvckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldFpJbmRleDogZnVuY3Rpb24oekluZGV4KSB7XG4gICAgdGhpcy5fY2FudmFzLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgICAgIHRoaXMuX2JhY2tDYW52YXMuc3R5bGUuekluZGV4ID0gekluZGV4O1xuICAgIH1cbiAgfSxcblxuICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKTtcbiAgICB0aGlzLl9jYW52YXMud2lkdGggPSBzaXplLng7XG4gICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IHNpemUueTtcblxuICAgIC8vIGZpeCBwb3NpdGlvblxuICAgIHZhciBwb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwLmdldFBhbmVzKCkubWFwUGFuZSk7XG4gICAgaWYgKHBvcykge1xuICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NhbnZhcywgeyB4OiAtcG9zLngsIHk6IC1wb3MueSB9KTtcbiAgICB9XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9LFxuXG4gIC8qXG4gIF9wcm9qZWN0OiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChuZXcgTC5MYXRMbmcoeFsxXSwgeFswXSkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH0sXG4gICovXG5cbiAgX3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHsgfSxcblxuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPj0gMCkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCB0aGlzLnJlbmRlcik7XG4gIH0sXG5cbiAgLy8gdXNlIGRpcmVjdDogdHJ1ZSBpZiB5b3UgYXJlIGluc2lkZSBhbiBhbmltYXRpb24gZnJhbWUgY2FsbFxuICByZWRyYXc6IGZ1bmN0aW9uKGRpcmVjdCkge1xuICAgIHZhciBkb21Qb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXAuZ2V0UGFuZXMoKS5tYXBQYW5lKTtcbiAgICBpZiAoZG9tUG9zaXRpb24pIHtcbiAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jYW52YXMsIHsgeDogLWRvbVBvc2l0aW9uLngsIHk6IC1kb21Qb3NpdGlvbi55IH0pO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0KSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW5kZXIgZnVuY3Rpb24gc2hvdWxkIGJlIGltcGxlbWVudGVkJyk7XG4gIH1cblxufSk7XG4iLCJpZiAodHlwZW9mIEwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVxdWlyZSgnLi90b3JxdWUnKTtcbn1cbiIsIkwuTWl4aW4uVGlsZUxvYWRlciA9IHtcblxuICBfaW5pdFRpbGVMb2FkZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RpbGVzID0ge31cbiAgICB0aGlzLl90aWxlc0xvYWRpbmcgPSB7fTtcbiAgICB0aGlzLl90aWxlc1RvTG9hZCA9IDA7XG4gICAgdGhpcy5fbWFwLm9uKHtcbiAgICAgICAgJ21vdmVlbmQnOiB0aGlzLl91cGRhdGVUaWxlc1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZVRpbGVzKCk7XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGVMb2FkZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcC5vZmYoe1xuICAgICAgICAnbW92ZWVuZCc6IHRoaXMuX3VwZGF0ZVRpbGVzXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fcmVtb3ZlVGlsZXMoKTtcbiAgfSxcblxuICBfdXBkYXRlVGlsZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICB0aWxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblxuICAgICAgaWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBud1RpbGVQb2ludCA9IG5ldyBMLlBvaW50KFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAvIHRpbGVTaXplKSxcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWluLnkgLyB0aWxlU2l6ZSkpLFxuXG4gICAgICAgICAgc2VUaWxlUG9pbnQgPSBuZXcgTC5Qb2ludChcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLyB0aWxlU2l6ZSksXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1heC55IC8gdGlsZVNpemUpKSxcblxuICAgICAgICAgIHRpbGVCb3VuZHMgPSBuZXcgTC5Cb3VuZHMobndUaWxlUG9pbnQsIHNlVGlsZVBvaW50KTtcblxuICAgICAgdGhpcy5fYWRkVGlsZXNGcm9tQ2VudGVyT3V0KHRpbGVCb3VuZHMpO1xuICAgICAgdGhpcy5fcmVtb3ZlT3RoZXJUaWxlcyh0aWxlQm91bmRzKTtcbiAgfSxcblxuICBfcmVtb3ZlVGlsZXM6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICB9XG4gIH0sXG5cbiAgX3JlbG9hZFRpbGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZW1vdmVUaWxlcygpO1xuICAgIHRoaXMuX3VwZGF0ZVRpbGVzKCk7XG4gIH0sXG5cbiAgX3JlbW92ZU90aGVyVGlsZXM6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgIHZhciBrQXJyLCB4LCB5LCB6LCBrZXk7XG4gICAgICB2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgIGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpbGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAga0FyciA9IGtleS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICB4ID0gcGFyc2VJbnQoa0FyclswXSwgMTApO1xuICAgICAgICAgICAgICB5ID0gcGFyc2VJbnQoa0FyclsxXSwgMTApO1xuICAgICAgICAgICAgICB6ID0gcGFyc2VJbnQoa0FyclsyXSwgMTApO1xuXG4gICAgICAgICAgICAgIC8vIHJlbW92ZSB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kc1xuICAgICAgICAgICAgICBpZiAoem9vbSAhPT0geiB8fCB4IDwgYm91bmRzLm1pbi54IHx8IHggPiBib3VuZHMubWF4LnggfHwgeSA8IGJvdW5kcy5taW4ueSB8fCB5ID4gYm91bmRzLm1heC55KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0sXG5cbiAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRoaXMuZmlyZSgndGlsZVJlbW92ZWQnLCB0aGlzLl90aWxlc1trZXldKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzTG9hZGluZ1trZXldO1xuICB9LFxuXG4gIF90aWxlS2V5OiBmdW5jdGlvbih0aWxlUG9pbnQpIHtcbiAgICByZXR1cm4gdGlsZVBvaW50LnggKyAnOicgKyB0aWxlUG9pbnQueSArICc6JyArIHRpbGVQb2ludC56b29tO1xuICB9LFxuXG4gIF90aWxlU2hvdWxkQmVMb2FkZWQ6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcbiAgICAgIHZhciBrID0gdGhpcy5fdGlsZUtleSh0aWxlUG9pbnQpO1xuICAgICAgcmV0dXJuICEoayBpbiB0aGlzLl90aWxlcykgJiYgIShrIGluIHRoaXMuX3RpbGVzTG9hZGluZyk7XG4gIH0sXG5cbiAgX3RpbGVMb2FkZWQ6IGZ1bmN0aW9uKHRpbGVQb2ludCwgdGlsZURhdGEpIHtcbiAgICB0aGlzLl90aWxlc1RvTG9hZC0tO1xuICAgIHZhciBrID0gdGlsZVBvaW50LnggKyAnOicgKyB0aWxlUG9pbnQueSArICc6JyArIHRpbGVQb2ludC56b29tXG4gICAgdGhpcy5fdGlsZXNba10gPSB0aWxlRGF0YTtcbiAgICBkZWxldGUgdGhpcy5fdGlsZXNMb2FkaW5nW2tdO1xuICAgIGlmKHRoaXMuX3RpbGVzVG9Mb2FkID09PSAwKSB7XG4gICAgICB0aGlzLmZpcmUoXCJ0aWxlc0xvYWRlZFwiKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VGlsZVBvczogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xuICAgIHRpbGVQb2ludCA9IG5ldyBMLlBvaW50KHRpbGVQb2ludC54LCB0aWxlUG9pbnQueSk7XG4gICAgdmFyIG9yaWdpbiA9IHRoaXMuX21hcC5fZ2V0TmV3VG9wTGVmdFBvaW50KHRoaXMuX21hcC5nZXRDZW50ZXIoKSksXG4gICAgICAgIHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXG4gICAgcmV0dXJuIHRpbGVQb2ludC5tdWx0aXBseUJ5KHRpbGVTaXplKS5zdWJ0cmFjdChvcmlnaW4pO1xuICB9LFxuXG4gIF9hZGRUaWxlc0Zyb21DZW50ZXJPdXQ6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICAgIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcbiAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblxuICAgICAgdmFyIGosIGksIHBvaW50O1xuXG4gICAgICBmb3IgKGogPSBib3VuZHMubWluLnk7IGogPD0gYm91bmRzLm1heC55OyBqKyspIHtcbiAgICAgICAgICBmb3IgKGkgPSBib3VuZHMubWluLng7IGkgPD0gYm91bmRzLm1heC54OyBpKyspIHtcbiAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgTC5Qb2ludChpLCBqKTtcbiAgICAgICAgICAgICAgcG9pbnQuem9vbSA9ICB6b29tO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl90aWxlU2hvdWxkQmVMb2FkZWQocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRpbGVzVG9Mb2FkID0gcXVldWUubGVuZ3RoO1xuXG4gICAgICBpZiAodGlsZXNUb0xvYWQgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIC8vIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gICAgICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuZGlzdGFuY2VUbyhjZW50ZXIpIC0gYi5kaXN0YW5jZVRvKGNlbnRlcik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdGlsZXNUb0xvYWQgKz0gdGlsZXNUb0xvYWQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aWxlc1RvTG9hZDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gcXVldWVbaV07XG4gICAgICAgIHZhciBrID0gdGhpcy5fdGlsZUtleSh0KTtcbiAgICAgICAgdGhpcy5fdGlsZXNMb2FkaW5nW2tdID0gdDtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlQWRkZWQnLCB0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZShcInRpbGVzTG9hZGluZ1wiKTtcblxuICB9XG5cbn1cbiIsInZhciBjYXJ0byA9IGdsb2JhbC5jYXJ0byB8fCByZXF1aXJlKCdjYXJ0bycpO1xudmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4uLycpO1xuXG5yZXF1aXJlKCcuL2NhbnZhc19sYXllcicpO1xuXG4vKipcbiAqIHRvcnF1ZSBsYXllclxuICovXG5MLlRvcnF1ZUxheWVyID0gTC5DYW52YXNMYXllci5leHRlbmQoe1xuXG4gIHByb3ZpZGVyczoge1xuICAgICdzcWxfYXBpJzogdG9ycXVlLnByb3ZpZGVycy5qc29uLFxuICAgICd1cmxfdGVtcGxhdGUnOiB0b3JxdWUucHJvdmlkZXJzLkpzb25BcnJheSxcbiAgICAnd2luZHNoYWZ0JzogdG9ycXVlLnByb3ZpZGVycy53aW5kc2hhZnQsXG4gICAgJ3RpbGVKU09OJzogdG9ycXVlLnByb3ZpZGVycy50aWxlSlNPTlxuICB9LFxuXG4gIHJlbmRlcmVyczoge1xuICAgICdwb2ludCc6IHRvcnF1ZS5yZW5kZXJlci5Qb2ludCxcbiAgICAncGl4ZWwnOiB0b3JxdWUucmVuZGVyZXIuUmVjdGFuZ2xlXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXRvcnF1ZS5pc0Jyb3dzZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRvcnF1ZVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucy50aWxlTG9hZGVyID0gdHJ1ZTtcbiAgICB0aGlzLmtleSA9IDA7XG4gICAgdGhpcy5wcmV2UmVuZGVyZWRLZXkgPSAwO1xuICAgIGlmIChvcHRpb25zLmNhcnRvY3NzKSB7XG4gICAgICB0b3JxdWUuZXh0ZW5kKG9wdGlvbnMsIHRvcnF1ZS5jb21tb24uVG9ycXVlTGF5ZXIub3B0aW9uc0Zyb21DYXJ0b0NTUyhvcHRpb25zLmNhcnRvY3NzKSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uIHx8IDI7XG4gICAgb3B0aW9ucy5zdGVwcyA9IG9wdGlvbnMuc3RlcHMgfHwgMTAwO1xuICAgIG9wdGlvbnMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZTogb3B0aW9ucy52aXNpYmxlO1xuICAgIHRoaXMuaGlkZGVuID0gIW9wdGlvbnMudmlzaWJsZTtcblxuICAgIHRoaXMuYW5pbWF0b3IgPSBuZXcgdG9ycXVlLkFuaW1hdG9yKGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgIHZhciBrID0gdGltZSB8IDA7XG4gICAgICBpZihzZWxmLmtleSAhPT0gaykge1xuICAgICAgICBzZWxmLnNldEtleShrLCB7IGRpcmVjdDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9LCB0b3JxdWUuZXh0ZW5kKHRvcnF1ZS5jbG9uZShvcHRpb25zKSwge1xuICAgICAgb25QYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZmlyZSgncGF1c2UnKTtcbiAgICAgIH0sXG4gICAgICBvblN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmZpcmUoJ3N0b3AnKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5maXJlKCdwbGF5Jyk7XG4gICAgICB9LFxuICAgICAgb25TdGVwc1JhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5maXJlKCdjaGFuZ2U6c3RlcHNSYW5nZScsIHNlbGYuYW5pbWF0b3Iuc3RlcHNSYW5nZSgpKTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICB0aGlzLnBsYXkgPSB0aGlzLmFuaW1hdG9yLnN0YXJ0LmJpbmQodGhpcy5hbmltYXRvcik7XG4gICAgdGhpcy5zdG9wID0gdGhpcy5hbmltYXRvci5zdG9wLmJpbmQodGhpcy5hbmltYXRvcik7XG4gICAgdGhpcy5wYXVzZSA9IHRoaXMuYW5pbWF0b3IucGF1c2UuYmluZCh0aGlzLmFuaW1hdG9yKTtcbiAgICB0aGlzLnRvZ2dsZSA9IHRoaXMuYW5pbWF0b3IudG9nZ2xlLmJpbmQodGhpcy5hbmltYXRvcik7XG4gICAgdGhpcy5zZXREdXJhdGlvbiA9IHRoaXMuYW5pbWF0b3IuZHVyYXRpb24uYmluZCh0aGlzLmFuaW1hdG9yKTtcbiAgICB0aGlzLmlzUnVubmluZyA9IHRoaXMuYW5pbWF0b3IuaXNSdW5uaW5nLmJpbmQodGhpcy5hbmltYXRvcik7XG5cblxuICAgIEwuQ2FudmFzTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCAncG9pbnQnO1xuICAgIHRoaXMub3B0aW9ucy5wcm92aWRlciA9IHRoaXMub3B0aW9ucy5wcm92aWRlciB8fCAnd2luZHNoYWZ0JztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGlsZUpTT04pIHRoaXMub3B0aW9ucy5wcm92aWRlciA9ICd0aWxlSlNPTic7XG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IHRoaXMucHJvdmlkZXJzW3RoaXMub3B0aW9ucy5wcm92aWRlcl0ob3B0aW9ucyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyB0aGlzLnJlbmRlcmVyc1t0aGlzLm9wdGlvbnMucmVuZGVyZXJdKHRoaXMuZ2V0Q2FudmFzKCksIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucy5yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5maXJlKFwiY2hhbmdlOmJvdW5kc1wiLCB7XG4gICAgICAgIGJvdW5kczogc2VsZi5wcm92aWRlci5nZXRCb3VuZHMoKVxuICAgICAgfSk7XG4gICAgICBzZWxmLmFuaW1hdG9yLnN0ZXBzKHNlbGYucHJvdmlkZXIuZ2V0U3RlcHMoKSk7XG4gICAgICBzZWxmLmFuaW1hdG9yLnJlc2NhbGUoKTtcbiAgICAgIHNlbGYuZmlyZSgnY2hhbmdlOnN0ZXBzJywge1xuICAgICAgICBzdGVwczogc2VsZi5wcm92aWRlci5nZXRTdGVwcygpXG4gICAgICB9KTtcbiAgICAgIHNlbGYuc2V0S2V5KHNlbGYua2V5KTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJlci5vbihcImFsbEljb25zTG9hZGVkXCIsIHRoaXMucmVuZGVyLmJpbmQodGhpcykpO1xuXG5cbiAgICAvLyBmb3IgZWFjaCB0aWxlIHNob3duIG9uIHRoZSBtYXAgcmVxdWVzdCB0aGUgZGF0YVxuICAgIHRoaXMub24oJ3RpbGVBZGRlZCcsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciB0aWxlRGF0YSA9IHRoaXMucHJvdmlkZXIuZ2V0VGlsZURhdGEodCwgdC56b29tLCBmdW5jdGlvbih0aWxlRGF0YSkge1xuICAgICAgICAvLyBkb24ndCBsb2FkIHRpbGVzIHRoYXQgYXJlIG5vdCBiZWluZyBzaG93blxuICAgICAgICBpZiAodC56b29tICE9PSBzZWxmLl9tYXAuZ2V0Wm9vbSgpKSByZXR1cm47XG4gICAgICAgIHNlbGYuX3RpbGVMb2FkZWQodCwgdGlsZURhdGEpO1xuICAgICAgICBzZWxmLl9jbGVhclRpbGVDYWNoZXMoKTtcbiAgICAgICAgaWYgKHRpbGVEYXRhKSB7XG4gICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZpcmUoJ3RpbGVMb2FkZWQnKTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gIH0sXG5cbiAgX2NsZWFyVGlsZUNhY2hlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQsIHRpbGU7XG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIGlmICh0aWxlICYmIHRpbGUuX3RpbGVDYWNoZSkge1xuICAgICAgICB0aWxlLl90aWxlQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfY2xlYXJDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVuZGVyZXIgJiYgdGhpcy5yZW5kZXJlci5jbGVhclNwcml0ZUNhY2hlKCk7XG4gICAgdGhpcy5fY2xlYXJUaWxlQ2FjaGVzKCk7XG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICBtYXAub24oe1xuICAgICAgJ3pvb21lbmQnOiB0aGlzLl9jbGVhckNhY2hlcyxcbiAgICAgICd6b29tc3RhcnQnOiB0aGlzLl9wYXVzZU9uWm9vbSxcbiAgICB9LCB0aGlzKTtcblxuICAgIG1hcC5vbih7XG4gICAgICAnem9vbWVuZCc6IHRoaXMuX3Jlc3VtZU9uWm9vbVxuICAgIH0sIHRoaXMpO1xuICAgIEwuQ2FudmFzTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgfSxcblxuICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgdGhpcy5maXJlKCdyZW1vdmUnKTtcbiAgICB0aGlzLl9yZW1vdmVUaWxlTG9hZGVyKCk7XG4gICAgbWFwLm9mZih7XG4gICAgICAnem9vbWVuZCc6IHRoaXMuX2NsZWFyQ2FjaGVzLFxuICAgICAgJ3pvb21zdGFydCc6IHRoaXMuX3BhdXNlT25ab29tLFxuICAgIH0sIHRoaXMpO1xuICAgIG1hcC5vZmYoe1xuICAgICAgJ3pvb21lbmQnOiB0aGlzLl9yZXN1bWVPblpvb21cbiAgICB9LCB0aGlzKTtcbiAgICBMLkNhbnZhc0xheWVyLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gIH0sXG5cbiAgX3BhdXNlT25ab29tOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLndhc1J1bm5pbmcgPSB0aGlzLmlzUnVubmluZygpO1xuICAgIGlmICh0aGlzLndhc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgX3Jlc3VtZU9uWm9vbTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMud2FzUnVubmluZykge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICB9LFxuXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuaGlkZGVuKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLnBhdXNlKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICBpZighdGhpcy5oaWRkZW4pIHJldHVybiB0aGlzO1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5wbGF5KCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwcyA9PT0gMSl7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRTUUw6IGZ1bmN0aW9uKHNxbCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVyLm9wdGlvbnMubmFtZWRfbWFwKSB0aHJvdyBuZXcgRXJyb3IoXCJTUUwgcXVlcmllcyBvbiBuYW1lZCBtYXBzIGFyZSByZWFkLW9ubHlcIik7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyIHx8ICF0aGlzLnByb3ZpZGVyLnNldFNRTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhpcyBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IFNRTFwiKTtcbiAgICB9XG4gICAgdGhpcy5wcm92aWRlci5zZXRTUUwoc3FsKTtcbiAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEJsZW5kTW9kZTogZnVuY3Rpb24oXykge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0QmxlbmRNb2RlKF8pO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH0sXG5cbiAgc2V0U3RlcHM6IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgdGhpcy5wcm92aWRlci5zZXRTdGVwcyhzdGVwcyk7XG4gICAgdGhpcy5fcmVsb2FkVGlsZXMoKTtcbiAgfSxcblxuICBzZXRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbiwgaXNUaW1lKSB7XG4gICAgdGhpcy5wcm92aWRlci5zZXRDb2x1bW4oY29sdW1uLCBpc1RpbWUpO1xuICAgIHRoaXMuX3JlbG9hZFRpbGVzKCk7XG4gIH0sXG5cbiAgZ2V0VGltZUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIgJiYgdGhpcy5wcm92aWRlci5nZXRLZXlTcGFuKCk7XG4gIH0sXG5cbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgfSxcblxuICAvKipcbiAgICogcmVuZGVyIHRoZSBzZWxlY3RlZiBrZXlcbiAgICogZG9uJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5LCBpdCdzIGNhbGxlZCBieVxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFVzZSByZWRyYXcgdG8gcmVmcmVzaCBpdFxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLmhpZGRlbikgcmV0dXJuO1xuICAgIHZhciB0LCB0aWxlLCBwb3M7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgdGhpcy5yZW5kZXJlci5jbGVhckNhbnZhcygpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGZvcih0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICBpZiAodGlsZSkge1xuICAgICAgICAvLyBjbGVhciBjYWNoZVxuICAgICAgICBpZiAodGhpcy5hbmltYXRvci5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgIHRpbGUuX3RpbGVDYWNoZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSB0aGlzLmdldFRpbGVQb3ModGlsZS5jb29yZCk7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgcG9zLngsIHBvcy55KTtcblxuICAgICAgICBpZiAodGlsZS5fdGlsZUNhY2hlKSB7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgdGlsZSBoYXMgYSBjYWNoZWQgaW1hZ2UganVzdCByZW5kZXIgaXQgYW5kIGF2b2lkIHRvIHJlbmRlclxuICAgICAgICAgIC8vIGFsbCB0aGUgcG9pbnRzXG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5fY3R4LmRyYXdJbWFnZSh0aWxlLl90aWxlQ2FjaGUsIDAsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGlsZSh0aWxlLCB0aGlzLmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5hcHBseUZpbHRlcnMoKTtcblxuICAgIC8vIHByZXBhcmUgY2FjaGVzIGlmIHRoZSBhbmltYXRpb24gaXMgbm90IHJ1bm5pbmdcbiAgICAvLyBkb24ndCBjYWNoZSBpZiB0aGUga2V5IGhhcyBqdXN0IGNoYW5nZWQsIHRoaXMgYXZvaWRzIHRvIGNhY2hlXG4gICAgLy8gd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZywgaXQgb25seSBjYWNoZSB3aGVuIHRoZSBtYXAgaXMgc3RpbGxcbiAgICBpZiAoIXRoaXMuYW5pbWF0b3IuaXNSdW5uaW5nKCkgJiYgdGhpcy5rZXkgPT09IHRoaXMucHJldlJlbmRlcmVkS2V5KSB7XG4gICAgICB2YXIgdGlsZV9zaXplID0gdGhpcy5yZW5kZXJlci5USUxFX1NJWkU7XG4gICAgICBmb3IodCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgIGlmICh0aWxlICYmICF0aWxlLl90aWxlQ2FjaGUpIHtcbiAgICAgICAgICB2YXIgYyA9IHRpbGUuX3RpbGVDYWNoZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGMud2lkdGggPSBjLmhlaWdodCA9IHRpbGVfc2l6ZTtcbiAgICAgICAgICBwb3MgPSB0aGlzLmdldFRpbGVQb3ModGlsZS5jb29yZCk7XG4gICAgICAgICAgLy8gY2xpcCBib3VuZHMsIGZpcmVmb3ggcmFpc2UgYW4gZXhjZXB0aW9uIHdoZW4gdHJ5IHRvIGdldCBkYXRhIGZyb20gb3V0c2lkZSBjYW52YXNcbiAgICAgICAgICB2YXIgeCA9IE1hdGgubWF4KDAsIHBvcy54KVxuICAgICAgICAgIHZhciB5ID0gTWF0aC5tYXgoMCwgcG9zLnkpXG4gICAgICAgICAgdmFyIHcgPSBNYXRoLm1pbih0aWxlX3NpemUsIHRoaXMuZ2V0Q2FudmFzKCkud2lkdGggLSB4KTtcbiAgICAgICAgICB2YXIgaCA9IE1hdGgubWluKHRpbGVfc2l6ZSwgdGhpcy5nZXRDYW52YXMoKS5oZWlnaHQgLSB5KTtcbiAgICAgICAgICBpZiAodyA+IDAgJiYgaCA+IDApIHtcbiAgICAgICAgICAgIGMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgeCwgeSwgdywgaCwgeCAtIHBvcy54LCB5IC0gcG9zLnksIHcsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJldlJlbmRlcmVkS2V5ID0gdGhpcy5rZXk7XG5cbiAgfSxcblxuICAvKipcbiAgICogc2V0IGtleSB0byBiZSBzaG93bi4gSWYgaXQncyBhIHNpbmdsZSB2YWx1ZVxuICAgKiBpdCByZW5kZXJzIGRpcmVjdGx5LCBpZiBpdCdzIGFuIGFycmF5IGl0IHJlbmRlcnNcbiAgICogYWNjdW11bGF0ZWRcbiAgICovXG4gIHNldEtleTogZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5hbmltYXRvci5zdGVwKGtleSk7XG4gICAgdGhpcy5fY2xlYXJUaWxlQ2FjaGVzKCk7XG4gICAgdGhpcy5yZWRyYXcob3B0aW9ucyAmJiBvcHRpb25zLmRpcmVjdCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2U6dGltZScsIHsgdGltZTogdGhpcy5nZXRUaW1lKCksIHN0ZXA6IHRoaXMua2V5IH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZnVuY3Rpb24sIGRvZXMgdGhlIHNhbWUgdGhhbiBgYHNldEtleWBgIGJ1dCBvbmx5XG4gICAqIGFjY2VwdHMgc2NhbGFycy5cbiAgICovXG4gIHNldFN0ZXA6IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICBpZih0aW1lID09PSB1bmRlZmluZWQgfHwgdGltZS5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0VGltZSBvbmx5IGFjY2VwdCBzY2FsYXJzXCIpO1xuICAgIH1cbiAgICB0aGlzLnNldEtleSh0aW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogdHJhbnNmb3JtIGZyb20gYW5pbWF0aW9uIHN0ZXAgdG8gRGF0ZSBvYmplY3RcbiAgICogdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRpbWVcbiAgICpcbiAgICogYGBzdGVwYGAgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgYGBzdGVwcyAtIDFgYFxuICAgKi9cbiAgc3RlcFRvVGltZTogZnVuY3Rpb24oc3RlcCkge1xuICAgIHZhciB0aW1lcyA9IHRoaXMucHJvdmlkZXIuZ2V0S2V5U3BhbigpO1xuICAgIHZhciB0aW1lID0gdGltZXMuc3RhcnQgKyAodGltZXMuZW5kIC0gdGltZXMuc3RhcnQpKihzdGVwL3RoaXMucHJvdmlkZXIuZ2V0U3RlcHMoKSk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWUpO1xuICB9LFxuXG4gIHRpbWVUb1N0ZXA6IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSBcIkRhdGVcIikgdGltZXN0YW1wID0gdGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHJldHVybiAwO1xuICAgIHZhciB0aW1lcyA9IHRoaXMucHJvdmlkZXIuZ2V0S2V5U3BhbigpO1xuICAgIHZhciBzdGVwID0gKHRoaXMucHJvdmlkZXIuZ2V0U3RlcHMoKSAqICh0aW1lc3RhbXAgLSB0aW1lcy5zdGFydCkpIC8gKHRpbWVzLmVuZCAtIHRpbWVzLnN0YXJ0KTtcbiAgICByZXR1cm4gc3RlcDtcbiAgfSxcblxuICBnZXRTdGVwOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIGFuaW1hdGlvbiB0aW1lIGRlZmluZWQgYnkgdGhlIGRhdGFcbiAgICogaW4gdGhlIGRlZmluZWQgY29sdW1uLiBEYXRlIG9iamVjdFxuICAgKi9cbiAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcFRvVGltZSh0aGlzLmtleSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHN0YXJ0IGFuZCBlbmQgdGltZXNcbiAgICovXG4gIGdldFRpbWVTcGFuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRLZXlTcGFuKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCB0aGUgY2FydG9jc3MgZm9yIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gICAqL1xuICBzZXRDYXJ0b0NTUzogZnVuY3Rpb24oY2FydG9jc3MpIHtcbiAgICBpZiAodGhpcy5wcm92aWRlci5vcHRpb25zLm5hbWVkX21hcCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FydG9DU1Mgc3R5bGUgb24gbmFtZWQgbWFwcyBpcyByZWFkLW9ubHlcIik7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlcmVyIGlzIG5vdCB2YWxpZCcpO1xuICAgIHZhciBzaGFkZXIgPSBuZXcgY2FydG8uUmVuZGVyZXJKUygpLnJlbmRlcihjYXJ0b2Nzcyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaGFkZXIoc2hhZGVyKTtcblxuICAgIC8vIHByb3ZpZGVyIG9wdGlvbnNcbiAgICB2YXIgb3B0aW9ucyA9IHRvcnF1ZS5jb21tb24uVG9ycXVlTGF5ZXIub3B0aW9uc0Zyb21MYXllcihzaGFkZXIuZmluZExheWVyKHsgbmFtZTogJ01hcCcgfSkpO1xuICAgIHRoaXMucHJvdmlkZXIuc2V0Q2FydG9DU1MgJiYgdGhpcy5wcm92aWRlci5zZXRDYXJ0b0NTUyhjYXJ0b2Nzcyk7XG4gICAgaWYodGhpcy5wcm92aWRlci5zZXRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICAgIH1cblxuICAgIHRvcnF1ZS5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIGFuaW1hdG9yIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgdGhpcy5hbmltYXRvci5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJDYWNoZXMoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgYWN0aXZlIHBvaW50cyBmb3IgYSBzdGVwIGluIGFjdGl2ZSB6b29tXG4gICAqIHJldHVybnMgYSBsaXN0IG9mIGJvdW5kaW5nIGJveGVzIFtbXSAsIFtdLCBbXV1cbiAgICogZW1wdHkgbGlzdCBpZiB0aGVyZSBpcyBubyBhY3RpdmUgcGl4ZWxzXG4gICAqL1xuICBnZXRBY3RpdmVQb2ludHNCQm94OiBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIGZvcih2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5jb25jYXQodGhpcy5yZW5kZXJlci5nZXRBY3RpdmVQb2ludHNCQm94KHRpbGUsIHN0ZXApKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfSxcblxuICAvKipcbiAgICogcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIHZhbHVlcyBmb3IgYWxsIHRoZSBwaXhlbHMgYWN0aXZlIGZvciB0aGUgc3RlcFxuICAgKi9cbiAgZ2V0VmFsdWVzOiBmdW5jdGlvbihzdGVwKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyB0aGlzLmtleTogc3RlcDtcbiAgICB2YXIgdCwgdGlsZTtcbiAgICBmb3IodCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgdGhpcy5yZW5kZXJlci5nZXRWYWx1ZXModGlsZSwgc3RlcCwgdmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSxcblxuICAvKipcbiAgICogcmV0dXJuIHRoZSB2YWx1ZSBmb3IgcG9zaXRpb24gcmVsYXRpdmUgdG8gbWFwIGNvb3JkaW5hdGVzLiBudWxsIGZvciBubyB2YWx1ZVxuICAgKi9cbiAgZ2V0VmFsdWVGb3JQb3M6IGZ1bmN0aW9uKHgsIHksIHN0ZXApIHtcbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gdGhpcy5rZXk6IHN0ZXA7XG4gICAgdmFyIHQsIHRpbGUsIHBvcywgdmFsdWUgPSBudWxsLCB4eCwgeXk7XG4gICAgZm9yKHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1t0XTtcbiAgICAgIHBvcyA9IHRoaXMuZ2V0VGlsZVBvcyh0aWxlLmNvb3JkKTtcbiAgICAgIHh4ID0geCAtIHBvcy54O1xuICAgICAgeXkgPSB5IC0gcG9zLnk7XG4gICAgICBpZiAoeHggPj0gMCAmJiB5eSA+PSAwICYmIHh4IDwgdGhpcy5yZW5kZXJlci5USUxFX1NJWkUgJiYgeXkgPD0gdGhpcy5yZW5kZXJlci5USUxFX1NJWkUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnJlbmRlcmVyLmdldFZhbHVlRm9yKHRpbGUsIHN0ZXAsIHh4LCB5eSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBnZXRWYWx1ZUZvckJCb3g6IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgICB2YXIgeGYgPSB4ICsgdywgeWYgPSB5ICsgaCwgX3g9eDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IoX3kgPSB5OyBfeTx5ZjsgX3krPXRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKXtcbiAgICAgIGZvcihfeCA9IHg7IF94PHhmOyBfeCs9dGhpcy5vcHRpb25zLnJlc29sdXRpb24pe1xuICAgICAgICB2YXIgdGhpc1ZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvclBvcyhfeCxfeSk7XG4gICAgICAgIGlmICh0aGlzVmFsdWUpe1xuICAgICAgICAgIHZhciBiYiA9IHRoaXNWYWx1ZS5iYm94O1xuICAgICAgICAgIHZhciB4eSA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KFtiYlsxXS5sYXQsIGJiWzFdLmxvbl0pO1xuICAgICAgICAgIGlmKHh5LnggPCB4ZiAmJiB4eS55IDwgeWYpe1xuICAgICAgICAgICAgc3VtICs9IHRoaXNWYWx1ZS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfSxcblxuICBpbnZhbGlkYXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnByb3ZpZGVyLnJlbG9hZCgpO1xuICB9LFxuXG4gIHNldFN0ZXBzUmFuZ2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLmFuaW1hdG9yLnN0ZXBzUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gIH0sXG5cbiAgcmVtb3ZlU3RlcHNSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hbmltYXRvci5yZW1vdmVDdXN0b21TdGVwc1JhbmdlKCk7XG4gIH0sXG5cbiAgZ2V0U3RlcHNSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0b3Iuc3RlcHNSYW5nZSgpO1xuICB9XG59KTtcbiIsIiAgZnVuY3Rpb24gY2xhbXAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odCwgYiksIGEpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnZMaW5lYXIoYSwgYikge1xuICAgIHZhciBjID0gY2xhbXAoMCwgMS4wKTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGMoKHQgLSBhKS8oYiAtIGEpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZWFyKGEsIGIpIHtcbiAgICB2YXIgYyA9IGNsYW1wKGEsIGIpO1xuICAgIGZ1bmN0aW9uIF9saW5lYXIodCkge1xuICAgICAgcmV0dXJuIGMoYSooMS4wIC0gdCkgKyB0KmIpO1xuICAgIH1cblxuICAgIF9saW5lYXIuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW52TGluZWFyKGEsIGIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX2xpbmVhcjtcbiAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgbGluZWFyOiBsaW5lYXIsXG4gICAgaW52TGluZWFyOiBpbnZMaW5lYXJcbn07XG4iLCJ2YXIgUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xufTtcblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG9wdE1pbiwgb3B0TWF4KSB7XG4gIGlmIChvcHRNaW4gIT09IG51bGwpIHZhbHVlID0gTWF0aC5tYXgodmFsdWUsIG9wdE1pbik7XG4gIGlmIChvcHRNYXggIT09IG51bGwpIHZhbHVlID0gTWF0aC5taW4odmFsdWUsIG9wdE1heCk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWcpIHtcbiAgcmV0dXJuIGRlZyAqIChNYXRoLlBJIC8gMTgwKTtcbn1cblxuZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyhyYWQpIHtcbiAgcmV0dXJuIHJhZCAvIChNYXRoLlBJIC8gMTgwKTtcbn1cblxuXG52YXIgTWVyY2F0b3JQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4vLyAgdGhpcy5fdGlsZVNpemUgPSBMLkJyb3dzZXIucmV0aW5hID8gNTEyIDogMjU2O1xuICB0aGlzLl90aWxlU2l6ZSA9IDI1NjtcbiAgdGhpcy5fcGl4ZWxPcmlnaW4gPSBuZXcgUG9pbnQodGhpcy5fdGlsZVNpemUgLyAyLCB0aGlzLl90aWxlU2l6ZSAvIDIpO1xuICB0aGlzLl9waXhlbHNQZXJMb25EZWdyZWUgPSB0aGlzLl90aWxlU2l6ZSAvIDM2MDtcbiAgdGhpcy5fcGl4ZWxzUGVyTG9uUmFkaWFuID0gdGhpcy5fdGlsZVNpemUgLyAoMiAqIE1hdGguUEkpO1xufTtcblxuTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS5fZnJvbUxhdExvblRvUG9pbnQgPSBmdW5jdGlvbihsYXQsIGxvbikge1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBvcmlnaW4gPSB0aGlzLl9waXhlbE9yaWdpbjtcblxuICBwb2ludC54ID0gb3JpZ2luLnggKyBsb24gKiB0aGlzLl9waXhlbHNQZXJMb25EZWdyZWU7XG5cbiAgLy8gTk9URShhcHBsZXRvbik6IFRydW5jYXRpbmcgdG8gMC45OTk5IGVmZmVjdGl2ZWx5IGxpbWl0cyBsYXRpdHVkZSB0b1xuICAvLyA4OS4xODkuICBUaGlzIGlzIGFib3V0IGEgdGhpcmQgb2YgYSB0aWxlIHBhc3QgdGhlIGVkZ2Ugb2YgdGhlIHdvcmxkXG4gIC8vIHRpbGUuXG4gIHZhciBzaW55ID0gY2xhbXAoTWF0aC5zaW4oZGVncmVlc1RvUmFkaWFucyhsYXQpKSwgLTAuOTk5OSwgMC45OTk5KTtcbiAgcG9pbnQueSA9IG9yaWdpbi55ICsgMC41ICogTWF0aC5sb2coKDEgKyBzaW55KSAvICgxIC0gc2lueSkpICogLXRoaXMuX3BpeGVsc1BlckxvblJhZGlhbjtcbiAgcmV0dXJuIHBvaW50O1xufTtcblxuTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS5fZnJvbVBvaW50VG9MYXRMb24gPSBmdW5jdGlvbihwb2ludCkge1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgb3JpZ2luID0gbWUuX3BpeGVsT3JpZ2luO1xuICB2YXIgbG9uID0gKHBvaW50LnggLSBvcmlnaW4ueCkgLyBtZS5fcGl4ZWxzUGVyTG9uRGVncmVlO1xuICB2YXIgbGF0UmFkaWFucyA9IChwb2ludC55IC0gb3JpZ2luLnkpIC8gLW1lLl9waXhlbHNQZXJMb25SYWRpYW47XG4gIHZhciBsYXQgPSByYWRpYW5zVG9EZWdyZWVzKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAobGF0UmFkaWFucykpIC0gTWF0aC5QSSAvIDIpO1xuICByZXR1cm4geyBsYXQ6bGF0LCBsb246bG9uIH07XG59O1xuXG5NZXJjYXRvclByb2plY3Rpb24ucHJvdG90eXBlLl90aWxlUGl4ZWxQb3MgPSBmdW5jdGlvbih0aWxlWCwgdGlsZVkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB0aWxlWCp0aGlzLl90aWxlU2l6ZSxcbiAgICB5OiB0aWxlWSp0aGlzLl90aWxlU2l6ZVxuICB9O1xufTtcblxuTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS50aWxlUGl4ZWxCQm94ID0gZnVuY3Rpb24oeCwgeSwgem9vbSwgcHgsIHB5LCByZXMpIHtcbiAgcmVzID0gcmVzIHx8IDEuMDtcbiAgdmFyIG51bVRpbGVzID0gMSA8PHpvb207XG4gIHZhciBpbmMgPSByZXMvbnVtVGlsZXM7XG4gIHB4ID0gKHgqdGhpcy5fdGlsZVNpemUgKyBweCkvbnVtVGlsZXM7XG4gIHB5ID0gKHkqdGhpcy5fdGlsZVNpemUgKyBweSkvbnVtVGlsZXM7XG4gIHJldHVybiBbXG4gICAgdGhpcy5fZnJvbVBvaW50VG9MYXRMb24obmV3IFBvaW50KHB4LCBweSArIGluYykpLFxuICAgIHRoaXMuX2Zyb21Qb2ludFRvTGF0TG9uKG5ldyBQb2ludChweCArIGluYywgcHkpKVxuICBdO1xufTtcblxuTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS50aWxlQkJveCA9IGZ1bmN0aW9uKHgsIHksIHpvb20sIGJ1ZmZlclNpemUpIHtcbiAgdmFyIG51bVRpbGVzID0gMSA8PHpvb207XG4gIGJ1ZmZlclNpemUgPSBidWZmZXJTaXplIHx8IDA7XG4gIHZhciBpbmMgPSAgKHRoaXMuX3RpbGVTaXplICsgYnVmZmVyU2l6ZSoyKS9udW1UaWxlcztcbiAgdmFyIHB4ID0gKHgqdGhpcy5fdGlsZVNpemUgLSBidWZmZXJTaXplICApL251bVRpbGVzO1xuICB2YXIgcHkgPSAoeSp0aGlzLl90aWxlU2l6ZSAtIGJ1ZmZlclNpemUgICkvbnVtVGlsZXM7XG4gIHJldHVybiBbXG4gICAgdGhpcy5fZnJvbVBvaW50VG9MYXRMb24obmV3IFBvaW50KHB4LCBweSArIGluYykpLFxuICAgIHRoaXMuX2Zyb21Qb2ludFRvTGF0TG9uKG5ldyBQb2ludChweCArIGluYywgcHkpKVxuICBdO1xufTtcblxuTWVyY2F0b3JQcm9qZWN0aW9uLnByb3RvdHlwZS5sYXRMb25Ub1RpbGVQb2ludCA9IGZ1bmN0aW9uKGxhdCwgbG9uLCB0aWxlWCwgdGlsZVksIHpvb20pIHtcbiAgdmFyIG51bVRpbGVzID0gMSA8PHpvb207XG4gIHZhciB3b3JsZENvb3JkaW5hdGUgPSB0aGlzLl9mcm9tTGF0TG9uVG9Qb2ludChsYXQsIGxvbik7XG4gIHZhciBwaXhlbENvb3JkaW5hdGUgPSBuZXcgUG9pbnQod29ybGRDb29yZGluYXRlLngqbnVtVGlsZXMsIHdvcmxkQ29vcmRpbmF0ZS55Km51bVRpbGVzKTtcbiAgdmFyIHRpbGVQaXhlbFBvcyAgICA9IHRoaXMuX3RpbGVQaXhlbFBvcyh0aWxlWCwgdGlsZVkpO1xuICByZXR1cm4gbmV3IFBvaW50KE1hdGgucm91bmQocGl4ZWxDb29yZGluYXRlLngtdGlsZVBpeGVsUG9zLngpLCBNYXRoLnJvdW5kKHBpeGVsQ29vcmRpbmF0ZS55LXRpbGVQaXhlbFBvcy55KSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmNhdG9yUHJvamVjdGlvbjtcbiIsIi8qXG4jIG1ldHJpY3MgcHJvZmlsZXJcblxuIyMgdGltaW5nXG5cbmBgYFxuIHZhciB0aW1lciA9IFByb2ZpbGVyLm1ldHJpYygncmVzb3VyY2U6bG9hZCcpXG4gdGltZS5zdGFydCgpO1xuIC4uLlxuIHRpbWUuZW5kKCk7XG5gYGBcblxuIyMgY291bnRlcnNcblxuYGBgXG4gdmFyIGNvdW50ZXIgPSBQcm9maWxlci5tZXRyaWMoJ3JlcXVlc3RzJylcbiBjb3VudGVyLmluYygpOyAgIC8vIDFcbiBjb3VudGVyLmluYygxMCk7IC8vIDExXG4gY291bnRlci5kZWMoKSAgICAvLyAxMFxuIGNvdW50ZXIuZGVjKDEwKSAgLy8gMFxuYGBgXG5cbiMjIENhbGxzIHBlciBzZWNvbmRcbmBgYFxuICB2YXIgZnBzID0gUHJvZmlsZXIubWV0cmljKCdmcHMnKVxuICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgZnBzLm1hcmsoKTtcbiAgfVxuYGBgXG4qL1xudmFyIE1BWF9ISVNUT1JZID0gMTAyNDtcbmZ1bmN0aW9uIFByb2ZpbGVyKCkge31cblByb2ZpbGVyLm1ldHJpY3MgPSB7fTtcblxuUHJvZmlsZXIuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gUHJvZmlsZXIubWV0cmljc1tuYW1lXSB8fCB7XG4gICAgbWF4OiAwLFxuICAgIG1pbjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICBhdmc6IDAsXG4gICAgdG90YWw6IDAsXG4gICAgY291bnQ6IDAsXG4gICAgaGlzdG9yeTogdHlwZW9mKEZsb2F0MzJBcnJheSkgIT09ICd1bmRlZmluZWQnID8gbmV3IEZsb2F0MzJBcnJheShNQVhfSElTVE9SWSkgOiBbXVxuICB9O1xufTtcblxuUHJvZmlsZXIubmV3X3ZhbHVlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0ID0gUHJvZmlsZXIubWV0cmljc1tuYW1lXSA9IFByb2ZpbGVyLmdldChuYW1lKTtcblxuICB0Lm1heCA9IE1hdGgubWF4KHQubWF4LCB2YWx1ZSk7XG4gIHQubWluID0gTWF0aC5taW4odC5taW4sIHZhbHVlKTtcbiAgdC50b3RhbCArPSB2YWx1ZTtcbiAgKyt0LmNvdW50O1xuICB0LmF2ZyA9IHQudG90YWwgLyB0LmNvdW50O1xuICB0Lmhpc3RvcnlbdC5jb3VudCVNQVhfSElTVE9SWV0gPSB2YWx1ZTtcbn07XG5cblByb2ZpbGVyLnByaW50X3N0YXRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKGsgaW4gUHJvZmlsZXIubWV0cmljcykge1xuICAgIHZhciB0ID0gUHJvZmlsZXIubWV0cmljc1trXTtcbiAgICBjb25zb2xlLmxvZyhcIiA9PT0gXCIgKyBrICsgXCIgPT09IFwiKTtcbiAgICBjb25zb2xlLmxvZyhcIiBtYXg6IFwiICsgdC5tYXgpO1xuICAgIGNvbnNvbGUubG9nKFwiIG1pbjogXCIgKyB0Lm1pbik7XG4gICAgY29uc29sZS5sb2coXCIgYXZnOiBcIiArIHQuYXZnKTtcbiAgICBjb25zb2xlLmxvZyhcIiBjb3VudDogXCIgKyB0LmNvdW50KTtcbiAgICBjb25zb2xlLmxvZyhcIiB0b3RhbDogXCIgKyB0LnRvdGFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gTWV0cmljKG5hbWUpIHtcbiAgdGhpcy50MCA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuXG5NZXRyaWMucHJvdG90eXBlID0ge1xuXG4gIC8vXG4gIC8vIHN0YXJ0IGEgdGltZSBtZWFzdXJlbWVudFxuICAvL1xuICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50MCA9ICtuZXcgRGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIGVsYXBzZWQgdGltZSBzaW5jZSBzdGFydCB3YXMgY2FsbGVkXG4gIF9lbGFwc2VkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlKCkgLSB0aGlzLnQwO1xuICB9LFxuXG4gIC8vXG4gIC8vIGZpbmlzaCBhIHRpbWUgbWVhc3VyZW1lbnQgYW5kIHJlZ2lzdGVyIGl0XG4gIC8vIGBgc3RhcnRgYCBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCBpZiBub3QgdGhpcyBcbiAgLy8gZnVuY3Rpb24gZG9lcyBub3QgdGFrZSBlZmZlY3RcbiAgLy9cbiAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50MCAhPT0gbnVsbCkge1xuICAgICAgUHJvZmlsZXIubmV3X3ZhbHVlKHRoaXMubmFtZSwgdGhpcy5fZWxhcHNlZCgpKTtcbiAgICAgIHRoaXMudDAgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvL1xuICAvLyBpbmNyZW1lbnRzIHRoZSB2YWx1ZSBcbiAgLy8gcXR5OiBob3cgbWFueSwgZGVmYXVsdCA9IDFcbiAgLy9cbiAgaW5jOiBmdW5jdGlvbihxdHkpIHtcbiAgICBxdHkgPSBxdHkgPT09IHVuZGVmaW5lZCA/IDE6IHF0eTtcbiAgICBQcm9maWxlci5uZXdfdmFsdWUodGhpcy5uYW1lLCBQcm9maWxlci5nZXQodGhpcy5uYW1lKS5jb3VudCArIChxdHkgPyBxdHk6IDApKTtcbiAgfSxcblxuICAvL1xuICAvLyBkZWNyZW1lbnRzIHRoZSB2YWx1ZSBcbiAgLy8gcXR5OiBob3cgbWFueSwgZGVmYXVsdCA9IDFcbiAgLy9cbiAgZGVjOiBmdW5jdGlvbihxdHkpIHtcbiAgICBxdHkgPSBxdHkgPT09IHVuZGVmaW5lZCA/IDE6IHF0eTtcbiAgICB0aGlzLmluYygtcXR5KTtcbiAgfSxcblxuICAvL1xuICAvLyBtZWFzdXJlcyBob3cgbWFueSB0aW1lcyBwZXIgc2Vjb25kIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gIC8vXG4gIG1hcms6IGZ1bmN0aW9uKCkge1xuICAgICsrdGhpcy5jb3VudDtcbiAgICBpZih0aGlzLnQwID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbGFwc2VkID0gdGhpcy5fZWxhcHNlZCgpO1xuICAgIGlmKGVsYXBzZWQgPiAxKSB7XG4gICAgICBQcm9maWxlci5uZXdfdmFsdWUodGhpcy5uYW1lLCB0aGlzLmNvdW50KTtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxufTtcblxuUHJvZmlsZXIubWV0cmljID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gbmV3IE1ldHJpYyhuYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZmlsZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBqc29uOiByZXF1aXJlKCcuL2pzb24nKSxcbiAgICBKc29uQXJyYXk6IHJlcXVpcmUoJy4vanNvbmFycmF5JyksXG4gICAgd2luZHNoYWZ0OiByZXF1aXJlKCcuL3dpbmRzaGFmdCcpLFxuICAgIHRpbGVKU09OOiByZXF1aXJlKCcuL3RpbGVqc29uJylcbn07XG4iLCJ2YXIgdG9ycXVlID0gcmVxdWlyZSgnLi4vJyk7XG52YXIgUHJvZmlsZXIgPSByZXF1aXJlKCcuLi9wcm9maWxlcicpO1xuXG4gIHZhciBVaW50OEFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQ4QXJyYXk7XG4gIHZhciBJbnQzMkFycmF5ID0gdG9ycXVlLnR5cGVzLkludDMyQXJyYXk7XG4gIHZhciBVaW50MzJBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50MzJBcnJheTtcblxuICAvLyBmb3JtYXQoJ2hlbGxvLCB7MH0nLCAncmFtYm8nKSAtPiBcImhlbGxvLCByYW1ib1wiXG4gIGZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKCdcXFxceycgKyBhdHRyICsgJ1xcXFx9JywgJ2cnKSwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGpzb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdGlsZVF1ZXVlID0gW107XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMub3B0aW9ucy5pc190aW1lID0gdGhpcy5vcHRpb25zLmlzX3RpbWUgPT09IHVuZGVmaW5lZCA/IHRydWU6IHRoaXMub3B0aW9ucy5pc190aW1lO1xuICAgIHRoaXMub3B0aW9ucy50aWxlcl9wcm90b2NvbCA9IG9wdGlvbnMudGlsZXJfcHJvdG9jb2wgfHwgJ2h0dHAnO1xuICAgIHRoaXMub3B0aW9ucy50aWxlcl9kb21haW4gPSBvcHRpb25zLnRpbGVyX2RvbWFpbiB8fCAnY2FydG9kYi5jb20nO1xuICAgIHRoaXMub3B0aW9ucy50aWxlcl9wb3J0ID0gb3B0aW9ucy50aWxlcl9wb3J0IHx8IDgwO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhX2FnZ3JlZ2F0aW9uKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA9IHRoaXMub3B0aW9ucy5kYXRhX2FnZ3JlZ2F0aW9uID09PSAnY3VtdWxhdGl2ZSc7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvcihcInJlc29sdXRpb24gc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xuICAgIGlmIChvcHRpb25zLnN0ZXBzID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGVwcyBzaG91bGQgYmUgcHJvdmlkZWRcIik7XG4gICAgaWYob3B0aW9ucy5zdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9mZXRjaEtleVNwYW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0UmVhZHkodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGpzb24ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSB0b3JxdWUgdGlsZSBlbmNvZGVkIGluIGFuIGVmZmljaWVudCBqYXZhc2NyaXB0XG4gICAgICogc3RydWN0dXJlOlxuICAgICAqIHtcbiAgICAgKiAgIHg6VWludDhBcnJheSB4IGNvb3JkaW5hdGVzIGluIHRpbGUgcmVmZXJlbmNlIHN5c3RlbSwgbm9ybWFsbHkgZnJvbSAwLTI1NVxuICAgICAqICAgeTpVaW50OEFycmF5IHkgY29vcmRpbmF0ZXMgaW4gdGlsZSByZWZlcmVuY2Ugc3lzdGVtXG4gICAgICogICBJbmRleDogQXJyYXkgaW5kZXggdG8gdGhlIHByb3BlcnRpZXNcbiAgICAgKiB9XG4gICAgICovXG4gICAgcHJvY2Nlc3NUaWxlOiBmdW5jdGlvbihyb3dzLCBjb29yZCwgem9vbSkge1xuICAgICAgdmFyIHI7XG4gICAgICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KHJvd3MubGVuZ3RoKTtcbiAgICAgIHZhciB5ID0gbmV3IFVpbnQ4QXJyYXkocm93cy5sZW5ndGgpO1xuXG4gICAgICB2YXIgcHJvZl9tZW0gPSBQcm9maWxlci5tZXRyaWMoJ1Byb3ZpZGVySlNPTjptZW0nKTtcbiAgICAgIHZhciBwcm9mX3BvaW50X2NvdW50ID0gUHJvZmlsZXIubWV0cmljKCdQcm92aWRlckpTT046cG9pbnRfY291bnQnKTtcbiAgICAgIHZhciBwcm9mX3Byb2Nlc3NfdGltZSA9IFByb2ZpbGVyLm1ldHJpYygnUHJvdmlkZXJKU09OOnByb2Nlc3NfdGltZScpLnN0YXJ0KClcblxuICAgICAgLy8gY291bnQgbnVtYmVyIG9mIGRhdGVzXG4gICAgICB2YXIgZGF0ZXMgPSAwO1xuICAgICAgdmFyIG1heERhdGVTbG90cyA9IC0xO1xuICAgICAgZm9yIChyID0gMDsgciA8IHJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcl07XG4gICAgICAgIGRhdGVzICs9IHJvdy5kYXRlc19fdWludDE2Lmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBkID0gMDsgZCA8IHJvdy5kYXRlc19fdWludDE2Lmxlbmd0aDsgKytkKSB7XG4gICAgICAgICAgbWF4RGF0ZVNsb3RzID0gTWF0aC5tYXgobWF4RGF0ZVNsb3RzLCByb3cuZGF0ZXNfX3VpbnQxNltkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgZGF0ZXMgPSAoMSArIG1heERhdGVTbG90cykgKiByb3dzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA/IFVpbnQzMkFycmF5OiBVaW50OEFycmF5O1xuXG4gICAgICAvLyByZXNlcnZlIG1lbW9yeSBmb3IgYWxsIHRoZSBkYXRlc1xuICAgICAgdmFyIHRpbWVJbmRleCA9IG5ldyBJbnQzMkFycmF5KG1heERhdGVTbG90cyArIDEpOyAvL2luZGV4LXNpemVcbiAgICAgIHZhciB0aW1lQ291bnQgPSBuZXcgSW50MzJBcnJheShtYXhEYXRlU2xvdHMgKyAxKTtcbiAgICAgIHZhciByZW5kZXJEYXRhID0gbmV3ICh0aGlzLm9wdGlvbnMudmFsdWVEYXRhVHlwZSB8fCB0eXBlKShkYXRlcyk7XG4gICAgICB2YXIgcmVuZGVyRGF0YVBvcyA9IG5ldyBVaW50MzJBcnJheShkYXRlcyk7XG5cbiAgICAgIHByb2ZfbWVtLmluYyhcbiAgICAgICAgNCAqIG1heERhdGVTbG90cyArIC8vIHRpbWVJbmRleFxuICAgICAgICA0ICogbWF4RGF0ZVNsb3RzICsgLy8gdGltZUNvdW50XG4gICAgICAgIGRhdGVzICsgLy9yZW5kZXJEYXRhXG4gICAgICAgIGRhdGVzICogNFxuICAgICAgKTsgLy9yZW5kZXJEYXRhUG9zXG5cbiAgICAgIHByb2ZfcG9pbnRfY291bnQuaW5jKHJvd3MubGVuZ3RoKTtcblxuICAgICAgdmFyIHJvd3NQZXJTbG90ID0ge307XG5cbiAgICAgIC8vIHByZWNhY2hlIHBpeGVsIHBvc2l0aW9uc1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICB4W3JdID0gcm93LnhfX3VpbnQ4ICogdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG4gICAgICAgIC8vIGZpeCB2YWx1ZSB3aGVuIGl0J3MgaW4gdGhlIHRpbGUgRURHRVxuICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBmaXhlZCBpbiBTUUwgcXVlcnlcbiAgICAgICAgaWYgKHJvdy55X191aW50OCA9PT0gLTEpIHtcbiAgICAgICAgICB5W3JdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5W3JdID0gcm93LnlfX3VpbnQ4ICogdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZXMgPSByb3cuZGF0ZXNfX3VpbnQxNjtcbiAgICAgICAgdmFyIHZhbHMgPSByb3cudmFsc19fdWludDg7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gZGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIHJyID0gcm93c1BlclNsb3RbZGF0ZXNbal1dIHx8IChyb3dzUGVyU2xvdFtkYXRlc1tqXV0gPSBbXSk7XG4gICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICB2YWxzW2pdICs9IHByZXZfdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXZfdmFsID0gdmFsc1tqXTtcbiAgICAgICAgICAgICAgcnIucHVzaChbciwgdmFsc1tqXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsQnlEYXRlID0ge31cbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gZGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgIHZhbEJ5RGF0ZVtkYXRlc1tqXV0gPSB2YWxzW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYWNjdW0gPSAwO1xuXG4gICAgICAgICAgLy8gZXh0ZW5kIHRoZSBsYXRlc3QgdG8gdGhlIGVuZFxuICAgICAgICAgIGZvciAodmFyIGogPSBkYXRlc1swXTsgaiA8PSBtYXhEYXRlU2xvdHM7ICsraikge1xuICAgICAgICAgICAgICB2YXIgcnIgPSByb3dzUGVyU2xvdFtqXSB8fCAocm93c1BlclNsb3Rbal0gPSBbXSk7XG4gICAgICAgICAgICAgIHZhciB2ID0gdmFsQnlEYXRlW2pdO1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIGFjY3VtICs9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnIucHVzaChbciwgYWNjdW1dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKnZhciBsYXN0RGF0ZVNsb3QgPSBkYXRlc1tkYXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gbGFzdERhdGVTbG90ICsgMTsgaiA8PSBtYXhEYXRlU2xvdHM7ICsraikge1xuICAgICAgICAgICAgdmFyIHJyID0gcm93c1BlclNsb3Rbal0gfHwgKHJvd3NQZXJTbG90W2pdID0gW10pO1xuICAgICAgICAgICAgcnIucHVzaChbciwgcHJldl92YWxdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKi9cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIGZvciBlYWNoIHRpbWVzbG90IHNlYXJjaCBhY3RpdmUgYnVja2V0c1xuICAgICAgdmFyIHJlbmRlckRhdGFJbmRleCA9IDA7XG4gICAgICB2YXIgdGltZVNsb3RJbmRleCA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDw9IG1heERhdGVTbG90czsgKytpKSB7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgdmFyIHNsb3RSb3dzID0gcm93c1BlclNsb3RbaV1cbiAgICAgICAgaWYoc2xvdFJvd3MpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHNsb3RSb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICB2YXIgcnIgPSBzbG90Um93c1tyXTtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIHJlbmRlckRhdGFQb3NbcmVuZGVyRGF0YUluZGV4XSA9IHJyWzBdXG4gICAgICAgICAgICByZW5kZXJEYXRhW3JlbmRlckRhdGFJbmRleF0gPSByclsxXTtcbiAgICAgICAgICAgICsrcmVuZGVyRGF0YUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aW1lSW5kZXhbaV0gPSB0aW1lU2xvdEluZGV4O1xuICAgICAgICB0aW1lQ291bnRbaV0gPSBjO1xuICAgICAgICB0aW1lU2xvdEluZGV4ICs9IGM7XG4gICAgICB9XG5cbiAgICAgIHByb2ZfcHJvY2Vzc190aW1lLmVuZCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB6OiB6b29tLFxuICAgICAgICBjb29yZDoge1xuICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICB6OiB6b29tXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVDb3VudDogdGltZUNvdW50LFxuICAgICAgICB0aW1lSW5kZXg6IHRpbWVJbmRleCxcbiAgICAgICAgcmVuZGVyRGF0YVBvczogcmVuZGVyRGF0YVBvcyxcbiAgICAgICAgcmVuZGVyRGF0YTogcmVuZGVyRGF0YSxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZVNsb3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBfaG9zdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBwb3J0ID0gb3B0cy5zcWxfYXBpX3BvcnQ7XG4gICAgICB2YXIgZG9tYWluID0gKChvcHRzLnVzZXJfbmFtZSB8fCBvcHRzLnVzZXIpICsgJy4nICsgKG9wdHMuc3FsX2FwaV9kb21haW4gfHwgJ2NhcnRvZGIuY29tJykpICsgKHBvcnQgPyAnOicgKyBwb3J0OiAnJyk7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBvcHRzLnNxbF9hcGlfcHJvdG9jb2wgfHwgJ2h0dHAnO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy51cmwgfHwgcHJvdG9jb2wgKyAnOi8vJyArIGRvbWFpbiArICcvYXBpL3YyL3NxbCc7XG4gICAgfSxcblxuICAgIHVybDogZnVuY3Rpb24oc3ViaG9zdCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBvcHRzLnNxbF9hcGlfcHJvdG9jb2wgfHwgJ2h0dHAnO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2RuX3VybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9zdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBwcm90b2NvbCsgXCI6Ly9cIjtcbiAgICAgIGlmIChzdWJob3N0KSB7XG4gICAgICAgIGggKz0gc3ViaG9zdCArIFwiLlwiO1xuICAgICAgfVxuICAgICAgdmFyIGNkbl9ob3N0ID0gb3B0cy5jZG5fdXJsO1xuICAgICAgaWYoIWNkbl9ob3N0Lmh0dHAgJiYgIWNkbl9ob3N0Lmh0dHBzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNkbl9ob3N0IHNob3VsZCBjb250YWluIGh0dHAgYW5kL29yIGh0dHBzIGVudHJpZXNcIik7XG4gICAgICB9XG4gICAgICBoICs9IGNkbl9ob3N0W3Byb3RvY29sXSArIFwiL1wiICsgKG9wdHMudXNlcl9uYW1lIHx8IG9wdHMudXNlcikgKyAnL2FwaS92Mi9zcWwnO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfSxcblxuICAgIF9oYXNoOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBoYXNoID0gMDtcbiAgICAgIGlmICghc3RyIHx8IHN0ci5sZW5ndGggPT0gMCkgcmV0dXJuIGhhc2g7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBoYXNoID0gKCggKGhhc2ggPDwgNSApIC0gaGFzaCApICsgc3RyLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH0sXG5cbiAgICBfZXh0cmFQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXMpIHtcbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgZm9yKHZhciBrIGluIHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXMpIHtcbiAgICAgICAgICB2YXIgdiA9IHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXNba107XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHAucHVzaChrICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgaXNIdHRwczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNxbF9hcGlfcHJvdG9jb2wgJiYgdGhpcy5vcHRpb25zLnNxbF9hcGlfcHJvdG9jb2wgPT09ICdodHRwcyc7XG4gICAgfSxcblxuICAgIC8vIGV4ZWN1dGUgYWN0dWFsIHF1ZXJ5XG4gICAgc3FsOiBmdW5jdGlvbihzcWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBzdWJkb21haW5zID0gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMgfHwgJzAxMjMnO1xuICAgICAgaWYodGhpcy5pc0h0dHBzKCkpIHtcbiAgICAgICAgc3ViZG9tYWlucyA9IFtudWxsXTsgLy8gbm8gc3ViZG9tYWluXG4gICAgICB9XG5cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmIChvcHRpb25zLm5vX2Nkbikge1xuICAgICAgICB1cmwgPSB0aGlzLl9ob3N0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwgPSB0aGlzLnVybChzdWJkb21haW5zW01hdGguYWJzKHRoaXMuX2hhc2goc3FsKSklc3ViZG9tYWlucy5sZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHRyYSA9IHRoaXMuX2V4dHJhUGFyYW1zKCk7XG4gICAgICB0b3JxdWUubmV0LmdldCggdXJsICsgXCI/cT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzcWwpICsgKGV4dHJhID8gXCImXCIgKyBleHRyYTogJycpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGlmKG9wdGlvbnMucGFyc2VKU09OKSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhICYmIGRhdGEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZGF0YSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZURhdGE6IGZ1bmN0aW9uKGNvb3JkLCB6b29tLCBjYWxsYmFjaykge1xuICAgICAgaWYoIXRoaXMuX3JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpbGVRdWV1ZS5wdXNoKFtjb29yZCwgem9vbSwgY2FsbGJhY2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2dldFRpbGVEYXRhKGNvb3JkLCB6b29tLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRSZWFkeTogZnVuY3Rpb24ocmVhZHkpIHtcbiAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgICAgdGhpcy5vcHRpb25zLnJlYWR5ICYmIHRoaXMub3B0aW9ucy5yZWFkeSgpO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVtO1xuICAgICAgd2hpbGUgKGl0ZW0gPSB0aGlzLl90aWxlUXVldWUucG9wKCkpIHtcbiAgICAgICAgdGhpcy5fZ2V0VGlsZURhdGEuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGBjb29yZGAgb2JqZWN0IGxpa2Uge3ggOiB0aWxleCwgeTogdGlsZXkgfVxuICAgICAqIGB6b29tYCBxdWFkdHJlZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgX2dldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBwcm9mX2ZldGNoX3RpbWUgPSBQcm9maWxlci5tZXRyaWMoJ1Byb3ZpZGVySlNPTjp0aWxlX2ZldGNoX3RpbWUnKS5zdGFydCgpXG4gICAgICB0aGlzLnRhYmxlID0gdGhpcy5vcHRpb25zLnRhYmxlO1xuICAgICAgdmFyIG51bVRpbGVzID0gMSA8PCB6b29tO1xuXG4gICAgICB2YXIgY29sdW1uX2NvbnYgPSB0aGlzLm9wdGlvbnMuY29sdW1uO1xuXG4gICAgICBpZih0aGlzLm9wdGlvbnMuaXNfdGltZSkge1xuICAgICAgICBjb2x1bW5fY29udiA9IGZvcm1hdChcImRhdGVfcGFydCgnZXBvY2gnLCB7Y29sdW1ufSlcIiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNxbCA9IFwiXCIgK1xuICAgICAgICBcIldJVEggXCIgK1xuICAgICAgICBcInBhciBBUyAoXCIgK1xuICAgICAgICBcIiAgU0VMRUNUIENEQl9YWVpfUmVzb2x1dGlvbih7em9vbX0pKntyZXNvbHV0aW9ufSBhcyByZXNcIiArXG4gICAgICAgIFwiLCAgMjU2L3tyZXNvbHV0aW9ufSBhcyB0aWxlX3NpemVcIiArXG4gICAgICAgIFwiLCBDREJfWFlaX0V4dGVudCh7eH0sIHt5fSwge3pvb219KSBhcyBleHQgXCIgICtcbiAgICAgICAgXCIpLFwiICtcbiAgICAgICAgXCJjdGUgQVMgKCBcIitcbiAgICAgICAgXCIgIFNFTEVDVCBTVF9TbmFwVG9HcmlkKGkudGhlX2dlb21fd2VibWVyY2F0b3IsIHAucmVzKSBnXCIgK1xuICAgICAgICBcIiwge2NvdW50Ynl9IGNcIiArXG4gICAgICAgIFwiLCBmbG9vcigoe2NvbHVtbl9jb252fSAtIHtzdGFydH0pL3tzdGVwfSkgZFwiICtcbiAgICAgICAgXCIgIEZST00gKHtfc3FsfSkgaSwgcGFyIHAgXCIgK1xuICAgICAgICBcIiAgV0hFUkUgaS50aGVfZ2VvbV93ZWJtZXJjYXRvciAmJiBwLmV4dCBcIiArXG4gICAgICAgIFwiICBHUk9VUCBCWSBnLCBkXCIgK1xuICAgICAgICBcIikgXCIgK1xuICAgICAgICBcIlwiICtcbiAgICAgICAgXCJTRUxFQ1QgKHN0X3goZyktc3RfeG1pbihwLmV4dCkpL3AucmVzIHhfX3VpbnQ4LCBcIiArXG4gICAgICAgIFwiICAgICAgIChzdF95KGcpLXN0X3ltaW4ocC5leHQpKS9wLnJlcyB5X191aW50OCxcIiArXG4gICAgICAgIFwiIGFycmF5X2FnZyhjKSB2YWxzX191aW50OCxcIiArXG4gICAgICAgIFwiIGFycmF5X2FnZyhkKSBkYXRlc19fdWludDE2XCIgK1xuICAgICAgICAvLyB0aGUgdGlsZV9zaXplIHdoZXJlIGFyZSBuZWVkZWQgYmVjYXVzZSB0aGUgb3ZlcmxhcHMgcXVlcnkgaW4gY3RlIHN1YnF1ZXJ5IGluY2x1ZGVzIHRoZSBwb2ludHNcbiAgICAgICAgLy8gaW4gdGhlIGxlZnQgYW5kIGJvdHRvbSBib3JkZXJzIG9mIHRoZSB0aWxlXG4gICAgICAgIFwiIEZST00gY3RlLCBwYXIgcCB3aGVyZSAoc3RfeShnKS1zdF95bWluKHAuZXh0KSkvcC5yZXMgPCB0aWxlX3NpemUgYW5kIChzdF94KGcpLXN0X3htaW4ocC5leHQpKS9wLnJlcyA8IHRpbGVfc2l6ZSBHUk9VUCBCWSB4X191aW50OCwgeV9fdWludDhcIjtcblxuXG4gICAgICB2YXIgcXVlcnkgPSBmb3JtYXQoc3FsLCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgeDogY29vcmQueCxcbiAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgY29sdW1uX2NvbnY6IGNvbHVtbl9jb252LFxuICAgICAgICBfc3FsOiB0aGlzLmdldFNRTCgpXG4gICAgICB9KTtcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5zcWwocXVlcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgdmFyIHJvd3MgPSBKU09OLnBhcnNlKGRhdGEucmVzcG9uc2VUZXh0KS5yb3dzO1xuICAgICAgICAgIGNhbGxiYWNrKHNlbGYucHJvY2Nlc3NUaWxlKHJvd3MsIGNvb3JkLCB6b29tKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvZl9mZXRjaF90aW1lLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldEtleVNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHRoaXMub3B0aW9ucy5zdGFydCAqIDEwMDAsXG4gICAgICAgIGVuZDogdGhpcy5vcHRpb25zLmVuZCAqIDEwMDAsXG4gICAgICAgIHN0ZXA6IHRoaXMub3B0aW9ucy5zdGVwLFxuICAgICAgICBzdGVwczogdGhpcy5vcHRpb25zLnN0ZXBzLFxuICAgICAgICBjb2x1bW5UeXBlOiB0aGlzLm9wdGlvbnMuaXNfdGltZSA/ICdkYXRlJzogJ251bWJlcidcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHNldENvbHVtbjogZnVuY3Rpb24oY29sdW1uLCBpc1RpbWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB0aGlzLm9wdGlvbnMuaXNfdGltZSA9IGlzVGltZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZTogZmFsc2U7XG4gICAgICB0aGlzLnJlbG9hZCgpO1xuICAgIH0sXG5cbiAgICBzZXRSZXNvbHV0aW9uOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uID0gcmVzO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiB0aWxlcyBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0KSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IGZhbHNlO1xuXG4gICAgICBpZihvcHQucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkICYmIG9wdC5yZXNvbHV0aW9uICE9PSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiA9IG9wdC5yZXNvbHV0aW9uO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LnN0ZXBzICE9PSB1bmRlZmluZWQgJiYgb3B0LnN0ZXBzICE9PSB0aGlzLm9wdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgdGhpcy5zZXRTdGVwcyhvcHQuc3RlcHMsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIG9wdC5jb2x1bW4gIT09IHRoaXMub3B0aW9ucy5jb2x1bW4pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbHVtbiA9IG9wdC5jb2x1bW47XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuY291bnRieSAhPT0gdW5kZWZpbmVkICYmIG9wdC5jb3VudGJ5ICE9PSB0aGlzLm9wdGlvbnMuY291bnRieSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnRieSA9IG9wdC5jb3VudGJ5O1xuICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYob3B0LmRhdGFfYWdncmVnYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYyA9IG9wdC5kYXRhX2FnZ3JlZ2F0aW9uID09PSAnY3VtdWxhdGl2ZSc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSAhPT0gYykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jdW11bGF0aXZlID0gYztcbiAgICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVmcmVzaCkgdGhpcy5yZWxvYWQoKTtcbiAgICAgIHJldHVybiByZWZyZXNoO1xuXG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmV0Y2hLZXlTcGFuKCk7XG4gICAgfSxcblxuICAgIHNldFNRTDogZnVuY3Rpb24oc3FsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNxbCAhPSBzcWwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNxbCA9IHNxbDtcbiAgICAgICAgdGhpcy5yZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0U3RlcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMub3B0aW9ucy5zdGVwcywgdGhpcy5vcHRpb25zLmRhdGFfc3RlcHMpO1xuICAgIH0sXG5cbiAgICBzZXRTdGVwczogZnVuY3Rpb24oc3RlcHMsIG9wdCkge1xuICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwcyAhPT0gc3RlcHMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwID0gKHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpL3RoaXMuZ2V0U3RlcHMoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcCB8fCAxO1xuICAgICAgICBpZiAoIW9wdC5zaWxlbnQpIHRoaXMucmVsb2FkKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvdW5kcztcbiAgICB9LFxuXG4gICAgZ2V0U1FMOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3FsIHx8IFwic2VsZWN0ICogZnJvbSBcIiArIHRoaXMub3B0aW9ucy50YWJsZTtcbiAgICB9LFxuXG4gICAgX3RpbGVySG9zdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciB1c2VyID0gKG9wdHMudXNlcl9uYW1lIHx8IG9wdHMudXNlcik7XG4gICAgICByZXR1cm4gb3B0cy50aWxlcl9wcm90b2NvbCArXG4gICAgICAgICAgIFwiOi8vXCIgKyAodXNlciA/IHVzZXIgKyBcIi5cIiA6IFwiXCIpICArXG4gICAgICAgICAgIG9wdHMudGlsZXJfZG9tYWluICtcbiAgICAgICAgICAgKChvcHRzLnRpbGVyX3BvcnQgIT0gXCJcIikgPyAoXCI6XCIgKyBvcHRzLnRpbGVyX3BvcnQpIDogXCJcIik7XG4gICAgfSxcblxuICAgIF9mZXRjaFVwZGF0ZUF0OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGxheWVyZ3JvdXAgPSB7XG4gICAgICAgIFwidmVyc2lvblwiOiBcIjEuMC4xXCIsXG4gICAgICAgIFwic3RhdF90YWdcIjogdGhpcy5vcHRpb25zLnN0YXRfdGFnIHx8ICd0b3JxdWUnLFxuICAgICAgICBcImxheWVyc1wiOiBbe1xuICAgICAgICAgIFwidHlwZVwiOiBcImNhcnRvZGJcIixcbiAgICAgICAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJjYXJ0b2Nzc192ZXJzaW9uXCI6IFwiMi4xLjFcIiwgXG4gICAgICAgICAgICBcImNhcnRvY3NzXCI6IFwiI2xheWVyIHt9XCIsXG4gICAgICAgICAgICBcInNxbFwiOiB0aGlzLmdldFNRTCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIHZhciB1cmwgPSB0aGlzLl90aWxlckhvc3QoKSArIFwiL3RpbGVzL2xheWVyZ3JvdXBcIjtcbiAgICAgIHZhciBleHRyYSA9IHRoaXMuX2V4dHJhUGFyYW1zKCk7XG5cbiAgICAgIC8vIHRpbGVyIG5lZWRzIG1hcF9rZXkgaW5zdGVhZCBvZiBhcGlfa2V5XG4gICAgICAvLyBzbyByZXBsYWNlIGl0XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgZXh0cmEgPSBleHRyYS5yZXBsYWNlKCdhcGlfa2V5PScsICdtYXBfa2V5PScpO1xuICAgICAgfVxuXG4gICAgICB1cmwgPSB1cmwgK1xuICAgICAgICBcIj9jb25maWc9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobGF5ZXJncm91cCkpICtcbiAgICAgICAgXCImY2FsbGJhY2s9P1wiICsgKGV4dHJhID8gXCImXCIgKyBleHRyYTogJycpO1xuXG4gICAgICB0b3JxdWUubmV0Lmpzb25wKHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gZm9ybWF0KFwic2VsZWN0ICogZnJvbSAoe3NxbH0pIF9fdG9ycXVlX3dyYXBfc3FsIGxpbWl0IDBcIiwgeyBzcWw6IHNlbGYuZ2V0U1FMKCkgfSk7XG4gICAgICAgIHNlbGYuc3FsKHF1ZXJ5LCBmdW5jdGlvbiAocXVlcnlEYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGEgJiYgcXVlcnlEYXRhKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IGRhdGEubGFzdF91cGRhdGVkLFxuICAgICAgICAgICAgICBmaWVsZHM6IHF1ZXJ5RGF0YS5maWVsZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBwYXJzZUpTT046IHRydWUgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy9cbiAgICAvLyB0aGUgZGF0YSByYW5nZSBjb3VsZCBiZSBzZXQgYnkgdGhlIHVzZXIgdGhvdWdoIGBgc3RhcnRgYFxuICAgIC8vIG9wdGlvbi4gSXQgY2FuIGJlIGZlY3RoZWQgZnJvbSB0aGUgdGFibGUgd2hlbiB0aGUgc3RhcnRcbiAgICAvLyBpcyBub3Qgc3BlY2lmaWVkLlxuICAgIC8vXG4gICAgX2ZldGNoS2V5U3BhbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbWF4X2NvbCwgbWluX2NvbCwgbWF4X3RtcGwsIG1pbl90bXBsO1xuXG4gICAgICB0aGlzLl9mZXRjaFVwZGF0ZUF0KGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICAgIHNlbGYub3B0aW9ucy5leHRyYV9wYXJhbXMgPSBzZWxmLm9wdGlvbnMuZXh0cmFfcGFyYW1zIHx8IHt9O1xuICAgICAgICBzZWxmLm9wdGlvbnMuZXh0cmFfcGFyYW1zLmxhc3RfdXBkYXRlZCA9IGRhdGEudXBkYXRlZF9hdCB8fCAwO1xuICAgICAgICBzZWxmLm9wdGlvbnMuZXh0cmFfcGFyYW1zLmNhY2hlX3BvbGljeSA9ICdwZXJzaXN0JztcbiAgICAgICAgc2VsZi5vcHRpb25zLmlzX3RpbWUgPSBkYXRhLmZpZWxkc1tzZWxmLm9wdGlvbnMuY29sdW1uXS50eXBlID09PSAnZGF0ZSc7XG5cbiAgICAgICAgdmFyIGNvbHVtbl9jb252ID0gc2VsZi5vcHRpb25zLmNvbHVtbjtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5pc190aW1lKXtcbiAgICAgICAgICBtYXhfdG1wbCA9IFwiZGF0ZV9wYXJ0KCdlcG9jaCcsIG1heCh7Y29sdW1ufSkpXCI7XG4gICAgICAgICAgbWluX3RtcGwgPSBcImRhdGVfcGFydCgnZXBvY2gnLCBtaW4oe2NvbHVtbn0pKVwiO1xuICAgICAgICAgIGNvbHVtbl9jb252ID0gZm9ybWF0KFwiZGF0ZV9wYXJ0KCdlcG9jaCcsIHtjb2x1bW59KVwiLCBzZWxmLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heF90bXBsID0gXCJtYXgoe2NvbHVtbn0pXCI7XG4gICAgICAgICAgbWluX3RtcGwgPSBcIm1pbih7Y29sdW1ufSlcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heF9jb2wgPSBmb3JtYXQobWF4X3RtcGwsIHsgY29sdW1uOiBzZWxmLm9wdGlvbnMuY29sdW1uIH0pO1xuICAgICAgICBtaW5fY29sID0gZm9ybWF0KG1pbl90bXBsLCB7IGNvbHVtbjogc2VsZi5vcHRpb25zLmNvbHVtbiB9KTtcblxuICAgICAgICAvKnZhciBzcWxfc3RhdHMgPSBcIlwiICtcbiAgICAgICAgXCJXSVRIIHN1bW1hcnlfZ3JvdXBzIGFzICggXCIgK1xuICAgICAgICAgIFwiV0lUSCBzdW1tYXJ5IGFzICggXCIgK1xuICAgICAgICAgICBcInNlbGVjdCAgIChyb3dfbnVtYmVyKCkgb3ZlciAob3JkZXIgYnkgX190aW1lX2NvbCBhc2MgbnVsbHMgbGFzdCkrMSkvMiBhcyByb3dudW0sIF9fdGltZV9jb2wgXCIgK1xuICAgICAgICAgICAgXCJmcm9tIChzZWxlY3QgKiwge2NvbHVtbn0gYXMgX190aW1lX2NvbCBmcm9tICh7c3FsfSkgX19zKSBfX3RvcnF1ZV93cmFwX3NxbCBcIiArXG4gICAgICAgICAgICBcIm9yZGVyIGJ5IF9fdGltZV9jb2wgYXNjIFwiICtcbiAgICAgICAgICBcIikgXCIgK1xuICAgICAgICAgIFwiU0VMRUNUIFwiICtcbiAgICAgICAgICBcIm1heChfX3RpbWVfY29sKSBPVkVSKFBBUlRJVElPTiBCWSByb3dudW0pIC0gIFwiICtcbiAgICAgICAgICBcIm1pbihfX3RpbWVfY29sKSBPVkVSKFBBUlRJVElPTiBCWSByb3dudW0pIGRpZmYgXCIgK1xuICAgICAgICAgIFwiRlJPTSBzdW1tYXJ5IFwiICtcbiAgICAgICAgXCIpLCBzdWJxIGFzICggXCIgK1xuICAgICAgICBcIiBTRUxFQ1QgXCIgK1xuICAgICAgICAgICAgXCJzdF94bWF4KHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeG1heCwgXCIgK1xuICAgICAgICAgICAgXCJzdF95bWF4KHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeW1heCwgXCIgK1xuICAgICAgICAgICAgXCJzdF94bWluKHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeG1pbiwgXCIgK1xuICAgICAgICAgICAgXCJzdF95bWluKHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeW1pbiwgXCIgK1xuICAgICAgICAgICAgXCJ7bWF4X2NvbH0gbWF4LCBcIiArXG4gICAgICAgICAgICBcInttaW5fY29sfSBtaW4gRlJPTSAgKHtzcWx9KSBfX3RvcnF1ZV93cmFwX3NxbCBcIiArXG4gICAgICAgIFwiKVwiICtcbiAgICAgICAgXCJTRUxFQ1QgXCIgK1xuICAgICAgICBcInhtYXgsIHhtaW4sIHltYXgsIHltaW4sIGEubWF4IGFzIG1heF9kYXRlLCBhLm1pbiBhcyBtaW5fZGF0ZSwgXCIgK1xuICAgICAgICBcImF2ZyhkaWZmKSBhcyBkaWZmYXZnLFwiICtcbiAgICAgICAgXCIoYS5tYXggLSBhLm1pbikvYXZnKGRpZmYpIGFzIG51bV9zdGVwcyBcIiArXG4gICAgICAgIFwiRlJPTSBzdW1tYXJ5X2dyb3Vwcywgc3VicSBhICBcIiArXG4gICAgICAgIFwiV0hFUkUgZGlmZiA+IDAgZ3JvdXAgYnkgeG1heCwgeG1pbiwgeW1heCwgeW1pbiwgbWF4X2RhdGUsIG1pbl9kYXRlXCI7XG4gICAgICAgICovXG4gICAgICAgIHZhciBzcWxfc3RhdHMgPSBcIiBTRUxFQ1QgXCIgK1xuICAgICAgICAgICAgXCJzdF94bWF4KHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeG1heCwgXCIgK1xuICAgICAgICAgICAgXCJzdF95bWF4KHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeW1heCwgXCIgK1xuICAgICAgICAgICAgXCJzdF94bWluKHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeG1pbiwgXCIgK1xuICAgICAgICAgICAgXCJzdF95bWluKHN0X2VudmVsb3BlKHN0X2NvbGxlY3QodGhlX2dlb20pKSkgeW1pbiwgXCIgK1xuICAgICAgICAgICAgXCJjb3VudCgqKSBhcyBudW1fc3RlcHMsIFwiICtcbiAgICAgICAgICAgIFwie21heF9jb2x9IG1heF9kYXRlLCBcIiArXG4gICAgICAgICAgICBcInttaW5fY29sfSBtaW5fZGF0ZSBGUk9NICAoe3NxbH0pIF9fdG9ycXVlX3dyYXBfc3FsIFwiO1xuXG4gICAgICAgIHZhciBzcWwgPSBmb3JtYXQoc3FsX3N0YXRzLCB7XG4gICAgICAgICAgbWF4X2NvbDogbWF4X2NvbCxcbiAgICAgICAgICBtaW5fY29sOiBtaW5fY29sLFxuICAgICAgICAgIGNvbHVtbjogY29sdW1uX2NvbnYsXG4gICAgICAgICAgc3FsOiBzZWxmLmdldFNRTCgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYuc3FsKHNxbCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIC8vVE9ETzogbWFuYWdlIGJvdW5kc1xuICAgICAgICAgIGRhdGEgPSBkYXRhLnJvd3NbMF07XG4gICAgICAgICAgc2VsZi5vcHRpb25zLnN0YXJ0ID0gZGF0YS5taW5fZGF0ZTtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuZW5kID0gZGF0YS5tYXhfZGF0ZTtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuc3RlcCA9IChkYXRhLm1heF9kYXRlIC0gZGF0YS5taW5fZGF0ZSkvTWF0aC5taW4oc2VsZi5vcHRpb25zLnN0ZXBzLCBkYXRhLm51bV9zdGVwcz4+MCk7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLmRhdGFfc3RlcHMgPSBkYXRhLm51bV9zdGVwcyA+PiAwO1xuICAgICAgICAgIC8vIHN0ZXAgY2FuJ3QgYmUgMFxuICAgICAgICAgIHNlbGYub3B0aW9ucy5zdGVwID0gc2VsZi5vcHRpb25zLnN0ZXAgfHwgMTtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuYm91bmRzID0gW1xuICAgICAgICAgICAgW2RhdGEueW1pbiwgZGF0YS54bWluXSxcbiAgICAgICAgICAgIFtkYXRhLnltYXgsIGRhdGEueG1heF1cbiAgICAgICAgICBdO1xuICAgICAgICAgIHNlbGYuX3NldFJlYWR5KHRydWUpO1xuICAgICAgICB9LCB7IHBhcnNlSlNPTjogdHJ1ZSwgbm9fY2RuOiB0cnVlIH0pO1xuICAgICAgfSwgeyBwYXJzZUpTT046IHRydWUsIG5vX2NkbjogdHJ1ZX0pXG4gICAgfVxuXG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbjtcbiIsInZhciB0b3JxdWUgPSByZXF1aXJlKCcuLi8nKTtcbnZhciBQcm9maWxlciA9IHJlcXVpcmUoJy4uL3Byb2ZpbGVyJyk7XG5cbiAgdmFyIFVpbnQ4QXJyYXkgPSB0b3JxdWUudHlwZXMuVWludDhBcnJheTtcbiAgdmFyIEludDMyQXJyYXkgPSB0b3JxdWUudHlwZXMuSW50MzJBcnJheTtcbiAgdmFyIFVpbnQzMkFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQzMkFycmF5O1xuXG4gIC8vIGZvcm1hdCgnaGVsbG8sIHswfScsICdyYW1ibycpIC0+IFwiaGVsbG8sIHJhbWJvXCJcbiAgZnVuY3Rpb24gZm9ybWF0KHN0ciwgYXR0cnMpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoUmVnRXhwKCdcXFxceycgKyBhdHRyICsgJ1xcXFx9JywgJ2cnKSwgYXR0cnNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGpzb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGNoZWNrIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9O1xuXG5cbiAganNvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvL1xuICAgIC8vIHJldHVybiB0aGUgZGF0YSBhZ2dyZWdhdGVkIGJ5IGtleTpcbiAgICAvLyB7XG4gICAgLy8gIGtleTA6IDEyLFxuICAgIC8vICBrZXkxOiAzMlxuICAgIC8vICBrZXkyOiAyNVxuICAgIC8vIH1cbiAgICAvL1xuICAgIGFnZ3JlZ2F0ZUJ5S2V5OiBmdW5jdGlvbihyb3dzKSB7XG4gICAgICBmdW5jdGlvbiBnZXRLZXlzKHJvdykge1xuICAgICAgICB2YXIgSEVBREVSX1NJWkUgPSAzO1xuICAgICAgICB2YXIgdmFsdWVzQ291bnQgPSByb3cuZGF0YVsyXTtcbiAgICAgICAgdmFyIGtleXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB2YWx1ZXNDb3VudDsgKytzKSB7XG4gICAgICAgICAga2V5c1tyb3cuZGF0YVtIRUFERVJfU0laRSArIHNdXSA9IHJvdy5kYXRhW0hFQURFUl9TSVpFICsgdmFsdWVzQ291bnQgKyBzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH1cbiAgICAgIHZhciBrZXlzID0ge307XG4gICAgICBmb3IgKHIgPSAwOyByIDwgcm93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICB2YXIgcm93S2V5cyA9IGdldEtleXMocm93c1tyXSk7XG4gICAgICAgIGZvcih2YXIgayBpbiByb3dLZXlzKSB7XG4gICAgICAgICAga2V5c1trXSA9IGtleXNba10gfHwgMDtcbiAgICAgICAgICBrZXlzW2tdICs9IHJvd0tleXNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0sXG4gICAgXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm9jY2Vzc1RpbGU6IGZ1bmN0aW9uKHJvd3MsIGNvb3JkLCB6b29tKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkocm93cy5sZW5ndGgpO1xuICAgICAgdmFyIHkgPSBuZXcgVWludDhBcnJheShyb3dzLmxlbmd0aCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIGRlY29kZSBpbnRvIGEgamF2YXNjcmlwdCBzdHJjdXR1cmUgdGhlIGFycmF5XG4gICAgICBmdW5jdGlvbiBkZWNvZGVfcm93KHJvdykge1xuICAgICAgICB2YXIgSEVBREVSX1NJWkUgPSAzO1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICB4OiByb3cuZGF0YVswXSAqIHNlbGYub3B0aW9ucy5yZXNvbHV0aW9uLFxuICAgICAgICAgIHk6IHJvdy5kYXRhWzFdICogc2VsZi5vcHRpb25zLnJlc29sdXRpb24sXG4gICAgICAgICAgdmFsdWVzQ291bnQ6IHJvdy5kYXRhWzJdLFxuICAgICAgICAgIHRpbWVzOiBbXSxcbiAgICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgby52YWx1ZXNDb3VudDsgKytzKSB7XG4gICAgICAgICAgIG8udGltZXMucHVzaChyb3cuZGF0YVtIRUFERVJfU0laRSArIHNdKTtcbiAgICAgICAgICAgby52YWx1ZXMucHVzaChyb3cuZGF0YVtIRUFERVJfU0laRSArIG8udmFsdWVzQ291bnQgKyBzXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VsZi5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBzID0gMTsgcyA8IG8udmFsdWVzQ291bnQ7ICsrcykge1xuICAgICAgICAgICBvLnZhbHVlc1tzXSArPSBvLnZhbHVlc1tzIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvXG4gICAgICB9XG5cbiAgICAgIC8vIGRlY29kZSBhbGwgdGhlIHJvd3NcbiAgICAgIGZvciAociA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHJvd3Nbcl0gPSBkZWNvZGVfcm93KHJvd3Nbcl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBjb3VudCBudW1iZXIgb2YgZGF0ZXNcbiAgICAgIHZhciBkYXRlcyA9IDA7XG4gICAgICB2YXIgbWF4RGF0ZVNsb3RzID0gMDtcbiAgICAgIGZvciAociA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICBkYXRlcyArPSByb3cudGltZXMubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGQgPSAwOyBkIDwgcm93LnRpbWVzLmxlbmd0aDsgKytkKSB7XG4gICAgICAgICAgbWF4RGF0ZVNsb3RzID0gTWF0aC5tYXgobWF4RGF0ZVNsb3RzLCByb3cudGltZXNbZF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2VydmUgbWVtb3J5IGZvciBhbGwgdGhlIGRhdGVzXG4gICAgICB2YXIgdGltZUluZGV4ID0gbmV3IEludDMyQXJyYXkobWF4RGF0ZVNsb3RzICsgMSk7IC8vaW5kZXgtc2l6ZVxuICAgICAgdmFyIHRpbWVDb3VudCA9IG5ldyBJbnQzMkFycmF5KG1heERhdGVTbG90cyArIDEpO1xuICAgICAgdmFyIHJlbmRlckRhdGEgPSBuZXcgKHRoaXMub3B0aW9ucy52YWx1ZURhdGFUeXBlIHx8IFVpbnQ4QXJyYXkpKGRhdGVzKTtcbiAgICAgIHZhciByZW5kZXJEYXRhUG9zID0gbmV3IFVpbnQzMkFycmF5KGRhdGVzKTtcblxuICAgICAgdmFyIHJvd3NQZXJTbG90ID0ge307XG5cbiAgICAgIC8vIHByZWNhY2hlIHBpeGVsIHBvc2l0aW9uc1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW3JdO1xuICAgICAgICB4W3JdID0gcm93Lng7XG4gICAgICAgIHlbcl0gPSByb3cueTtcblxuICAgICAgICB2YXIgZGF0ZXMgPSByb3cudGltZXM7XG4gICAgICAgIHZhciB2YWxzID0gcm93LnZhbHVlcztcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcnIgPSByb3dzUGVyU2xvdFtkYXRlc1tqXV0gfHwgKHJvd3NQZXJTbG90W2RhdGVzW2pdXSA9IFtdKTtcbiAgICAgICAgICAgIHJyLnB1c2goW3IsIHZhbHNbal1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZWFjaCB0aW1lc2xvdCBzZWFyY2ggYWN0aXZlIGJ1Y2tldHNcbiAgICAgIHZhciByZW5kZXJEYXRhSW5kZXggPSAwO1xuICAgICAgdmFyIHRpbWVTbG90SW5kZXggPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSBtYXhEYXRlU2xvdHM7ICsraSkge1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBzbG90Um93cyA9IHJvd3NQZXJTbG90W2ldXG4gICAgICAgIGlmKHNsb3RSb3dzKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzbG90Um93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgdmFyIHJyID0gc2xvdFJvd3Nbcl07XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICByZW5kZXJEYXRhUG9zW3JlbmRlckRhdGFJbmRleF0gPSByclswXVxuICAgICAgICAgICAgcmVuZGVyRGF0YVtyZW5kZXJEYXRhSW5kZXhdID0gcnJbMV07XG4gICAgICAgICAgICArK3JlbmRlckRhdGFJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGltZUluZGV4W2ldID0gdGltZVNsb3RJbmRleDtcbiAgICAgICAgdGltZUNvdW50W2ldID0gYztcbiAgICAgICAgdGltZVNsb3RJbmRleCArPSBjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBjb29yZDoge1xuICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICB6OiB6b29tXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVDb3VudDogdGltZUNvdW50LFxuICAgICAgICB0aW1lSW5kZXg6IHRpbWVJbmRleCxcbiAgICAgICAgcmVuZGVyRGF0YVBvczogcmVuZGVyRGF0YVBvcyxcbiAgICAgICAgcmVuZGVyRGF0YTogcmVuZGVyRGF0YVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXJsO1xuICAgIH0sXG5cblxuICAgIHRpbGVVcmw6IGZ1bmN0aW9uKGNvb3JkLCB6b29tKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnVybCgpO1xuICAgICAgdmFyIHMgPSAodGhpcy5vcHRpb25zLnN1YmRvbWFpbnMgfHwgJ2FiY2QnKVsoY29vcmQueCArIGNvb3JkLnkgKyB6b29tKSAlIDRdO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb29yZC54KVxuICAgICAgICAucmVwbGFjZSgne3l9JywgY29vcmQueSlcbiAgICAgICAgLnJlcGxhY2UoJ3t6fScsIHpvb20pXG4gICAgICAgIC5yZXBsYWNlKCd7c30nLCBzKTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24oY29vcmQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnRpbGVVcmwoY29vcmQsIHpvb20pO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZmV0Y2hUaW1lID0gUHJvZmlsZXIubWV0cmljKCdqc29uYXJyYXk6ZmV0Y2ggdGltZScpO1xuICAgICAgZmV0Y2hUaW1lLnN0YXJ0KCk7XG4gICAgICB0b3JxdWUubmV0LmdldCh0ZW1wbGF0ZSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZmV0Y2hUaW1lLmVuZCgpO1xuICAgICAgICBpZihkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5yZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGBjb29yZGAgb2JqZWN0IGxpa2Uge3ggOiB0aWxleCwgeTogdGlsZXkgfSBcbiAgICAgKiBgem9vbWAgcXVhZHRyZWUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIGdldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGlsZVVybChjb29yZCwgem9vbSk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBmZXRjaFRpbWUgPSBQcm9maWxlci5tZXRyaWMoJ2pzb25hcnJheTpmZXRjaCB0aW1lJyk7XG4gICAgICBmZXRjaFRpbWUuc3RhcnQoKTtcbiAgICAgIHRvcnF1ZS5uZXQuZ2V0KHRlbXBsYXRlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBmZXRjaFRpbWUuZW5kKCk7XG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgdmFyIHByb2Nlc3NpbmdUaW1lID0gUHJvZmlsZXIubWV0cmljKCdqc29uYXJyYXk6cHJvY2Vzc2luZyB0aW1lJyk7XG4gICAgICAgIHZhciBwYXJzaW5nVGltZSA9IFByb2ZpbGVyLm1ldHJpYygnanNvbmFycmF5OnBhcnNpbmcgdGltZScpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLnN0YXJ0KCk7XG4gICAgICAgICAgcGFyc2luZ1RpbWUuc3RhcnQoKTtcbiAgICAgICAgICB2YXIgcm93cyA9IEpTT04ucGFyc2UoZGF0YS5yZXNwb25zZVRleHQgfHwgZGF0YS5yZXNwb25zZSkucm93cztcbiAgICAgICAgICBwYXJzaW5nVGltZS5lbmQoKTtcbiAgICAgICAgICBwcm9jZXNzZWQgPSBzZWxmLnByb2NjZXNzVGlsZShyb3dzLCBjb29yZCwgem9vbSk7XG4gICAgICAgICAgcHJvY2Vzc2luZ1RpbWUuZW5kKCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJwcm9ibGVtIHBhcnNpbmcgSlNPTiBvbiBcIiwgY29vcmQsIHpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2socHJvY2Vzc2VkKTtcblxuICAgICAgfSk7XG4gICAgfVxuXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBqc29uO1xuIiwiICB2YXIgdG9ycXVlID0gcmVxdWlyZSgnLi4vJyk7XG5cbiAgdmFyIFVpbnQ4QXJyYXkgPSB0b3JxdWUudHlwZXMuVWludDhBcnJheTtcbiAgdmFyIEludDMyQXJyYXkgPSB0b3JxdWUudHlwZXMuSW50MzJBcnJheTtcbiAgdmFyIFVpbnQzMkFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQzMkFycmF5O1xuICB2YXIgVWludDhDbGFtcGVkQXJyYXkgPSB0b3JxdWUudHlwZXMuVWludDhDbGFtcGVkQXJyYXk7XG5cbiAgLy8gZm9ybWF0KCdoZWxsbywgezB9JywgJ3JhbWJvJykgLT4gXCJoZWxsbywgcmFtYm9cIlxuICBmdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFJlZ0V4cCgnXFxcXHsnICsgYXR0ciArICdcXFxcfScsICdnJyksIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciB0aWxlSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl90aWxlUXVldWUgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZSA9IHRoaXMub3B0aW9ucy5jb29yZGluYXRlc19kYXRhX3R5cGUgfHwgVWludDhBcnJheTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YV9hZ2dyZWdhdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPSB0aGlzLm9wdGlvbnMuZGF0YV9hZ2dyZWdhdGlvbiA9PT0gJ2N1bXVsYXRpdmUnO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dGhfdG9rZW4pIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLmV4dHJhX3BhcmFtcyB8fCAodGhpcy5vcHRpb25zLmV4dHJhX3BhcmFtcyA9IHt9KTtcbiAgICAgIGUuYXV0aF90b2tlbiA9IHRoaXMub3B0aW9ucy5hdXRoX3Rva2VuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ub19mZXRjaF9tYXApIHtcbiAgICAgIHRoaXMuX2ZldGNoTWFwKCk7XG4gICAgfVxuICB9O1xuXG4gIHRpbGVKU09OLnByb3RvdHlwZSA9IHtcblxuICAgIE5BTUU6IFwidGlsZUpTT05cIixcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgdG9ycXVlIHRpbGUgZW5jb2RlZCBpbiBhbiBlZmZpY2llbnQgamF2YXNjcmlwdFxuICAgICAqIHN0cnVjdHVyZTpcbiAgICAgKiB7XG4gICAgICogICB4OlVpbnQ4QXJyYXkgeCBjb29yZGluYXRlcyBpbiB0aWxlIHJlZmVyZW5jZSBzeXN0ZW0sIG5vcm1hbGx5IGZyb20gMC0yNTVcbiAgICAgKiAgIHk6VWludDhBcnJheSB5IGNvb3JkaW5hdGVzIGluIHRpbGUgcmVmZXJlbmNlIHN5c3RlbVxuICAgICAqICAgSW5kZXg6IEFycmF5IGluZGV4IHRvIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogfVxuICAgICAqL1xuICAgIHByb2NjZXNzVGlsZTogZnVuY3Rpb24ocm93cywgY29vcmQsIHpvb20pIHtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIHggPSBuZXcgdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZShyb3dzLmxlbmd0aCk7XG4gICAgICB2YXIgeSA9IG5ldyB0aGlzLm9wdGlvbnMuY29vcmRpbmF0ZXNfZGF0YV90eXBlKHJvd3MubGVuZ3RoKTtcblxuICAgICAgLy8gY291bnQgbnVtYmVyIG9mIGRhdGVzXG4gICAgICB2YXIgZGF0ZXMgPSAwO1xuICAgICAgdmFyIG1heERhdGVTbG90cyA9IC0xO1xuICAgICAgZm9yIChyID0gMDsgciA8IHJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcl07XG4gICAgICAgIGRhdGVzICs9IHJvdy5kYXRlc19fdWludDE2Lmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBkID0gMDsgZCA8IHJvdy5kYXRlc19fdWludDE2Lmxlbmd0aDsgKytkKSB7XG4gICAgICAgICAgbWF4RGF0ZVNsb3RzID0gTWF0aC5tYXgobWF4RGF0ZVNsb3RzLCByb3cuZGF0ZXNfX3VpbnQxNltkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgZGF0ZXMgPSAoMSArIG1heERhdGVTbG90cykgKiByb3dzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA/IFVpbnQzMkFycmF5OiBVaW50OENsYW1wZWRBcnJheTtcblxuICAgICAgLy8gcmVzZXJ2ZSBtZW1vcnkgZm9yIGFsbCB0aGUgZGF0ZXNcbiAgICAgIHZhciB0aW1lSW5kZXggPSBuZXcgSW50MzJBcnJheShtYXhEYXRlU2xvdHMgKyAxKTsgLy9pbmRleC1zaXplXG4gICAgICB2YXIgdGltZUNvdW50ID0gbmV3IEludDMyQXJyYXkobWF4RGF0ZVNsb3RzICsgMSk7XG4gICAgICB2YXIgcmVuZGVyRGF0YSA9IG5ldyAodGhpcy5vcHRpb25zLnZhbHVlRGF0YVR5cGUgfHwgdHlwZSkoZGF0ZXMpO1xuICAgICAgdmFyIHJlbmRlckRhdGFQb3MgPSBuZXcgVWludDMyQXJyYXkoZGF0ZXMpO1xuXG4gICAgICB2YXIgcm93c1BlclNsb3QgPSB7fTtcblxuICAgICAgLy8gcHJlY2FjaGUgcGl4ZWwgcG9zaXRpb25zXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcl07XG4gICAgICAgIHhbcl0gPSByb3cueF9fdWludDggKiB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgICAgeVtyXSA9IHJvdy55X191aW50OCAqIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHZhciBkYXRlcyA9IHJvdy5kYXRlc19fdWludDE2O1xuICAgICAgICB2YXIgdmFscyA9IHJvdy52YWxzX191aW50ODtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkYXRlcy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgICB2YXIgcnIgPSByb3dzUGVyU2xvdFtkYXRlc1tqXV0gfHwgKHJvd3NQZXJTbG90W2RhdGVzW2pdXSA9IFtdKTtcbiAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHNbal0gKz0gcHJldl92YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJldl92YWwgPSB2YWxzW2pdO1xuICAgICAgICAgICAgICByci5wdXNoKFtyLCB2YWxzW2pdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWxCeURhdGUgPSB7fVxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkYXRlcy5sZW5ndGg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgdmFsQnlEYXRlW2RhdGVzW2pdXSA9IHZhbHNbal07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhY2N1bSA9IDA7XG5cbiAgICAgICAgICAvLyBleHRlbmQgdGhlIGxhdGVzdCB0byB0aGUgZW5kXG4gICAgICAgICAgZm9yICh2YXIgaiA9IGRhdGVzWzBdOyBqIDw9IG1heERhdGVTbG90czsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciByciA9IHJvd3NQZXJTbG90W2pdIHx8IChyb3dzUGVyU2xvdFtqXSA9IFtdKTtcbiAgICAgICAgICAgICAgdmFyIHYgPSB2YWxCeURhdGVbal07XG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByci5wdXNoKFtyLCBhY2N1bV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZWFjaCB0aW1lc2xvdCBzZWFyY2ggYWN0aXZlIGJ1Y2tldHNcbiAgICAgIHZhciByZW5kZXJEYXRhSW5kZXggPSAwO1xuICAgICAgdmFyIHRpbWVTbG90SW5kZXggPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSBtYXhEYXRlU2xvdHM7ICsraSkge1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBzbG90Um93cyA9IHJvd3NQZXJTbG90W2ldXG4gICAgICAgIGlmKHNsb3RSb3dzKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzbG90Um93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgdmFyIHJyID0gc2xvdFJvd3Nbcl07XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICByZW5kZXJEYXRhUG9zW3JlbmRlckRhdGFJbmRleF0gPSByclswXVxuICAgICAgICAgICAgcmVuZGVyRGF0YVtyZW5kZXJEYXRhSW5kZXhdID0gcnJbMV07XG4gICAgICAgICAgICArK3JlbmRlckRhdGFJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGltZUluZGV4W2ldID0gdGltZVNsb3RJbmRleDtcbiAgICAgICAgdGltZUNvdW50W2ldID0gYztcbiAgICAgICAgdGltZVNsb3RJbmRleCArPSBjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB6OiB6b29tLFxuICAgICAgICBjb29yZDoge1xuICAgICAgICAgIHg6IGNvb3JkLngsXG4gICAgICAgICAgeTogY29vcmQueSxcbiAgICAgICAgICB6OiB6b29tXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVDb3VudDogdGltZUNvdW50LFxuICAgICAgICB0aW1lSW5kZXg6IHRpbWVJbmRleCxcbiAgICAgICAgcmVuZGVyRGF0YVBvczogcmVuZGVyRGF0YVBvcyxcbiAgICAgICAgcmVuZGVyRGF0YTogcmVuZGVyRGF0YSxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZVNsb3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRTdGVwczogZnVuY3Rpb24oc3RlcHMsIG9wdCkgeyBcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcHMgIT09IHN0ZXBzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcCA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KS90aGlzLmdldFN0ZXBzKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAgfHwgMTtcbiAgICAgICAgaWYgKCFvcHQuc2lsZW50KSB0aGlzLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgIHZhciByZWZyZXNoID0gZmFsc2U7XG5cbiAgICAgIGlmKG9wdC5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgJiYgb3B0LnJlc29sdXRpb24gIT09IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uID0gb3B0LnJlc29sdXRpb247XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuc3RlcHMgIT09IHVuZGVmaW5lZCAmJiBvcHQuc3RlcHMgIT09IHRoaXMub3B0aW9ucy5zdGVwcykge1xuICAgICAgICB0aGlzLnNldFN0ZXBzKG9wdC5zdGVwcywgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgb3B0LmNvbHVtbiAhPT0gdGhpcy5vcHRpb25zLmNvbHVtbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY29sdW1uID0gb3B0LmNvbHVtbjtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKG9wdC5jb3VudGJ5ICE9PSB1bmRlZmluZWQgJiYgb3B0LmNvdW50YnkgIT09IHRoaXMub3B0aW9ucy5jb3VudGJ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudGJ5ID0gb3B0LmNvdW50Ynk7XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuZGF0YV9hZ2dyZWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjID0gb3B0LmRhdGFfYWdncmVnYXRpb24gPT09ICdjdW11bGF0aXZlJztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlICE9PSBjKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPSBjO1xuICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWZyZXNoKSB0aGlzLnJlbG9hZCgpO1xuICAgICAgcmV0dXJuIHJlZnJlc2g7XG4gICAgfSxcblxuICAgIF9leHRyYVBhcmFtczogZnVuY3Rpb24oZSkge1xuICAgICAgZSA9IHRvcnF1ZS5leHRlbmQodG9ycXVlLmV4dGVuZCh7fSwgZSksIHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXMpO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgZm9yKHZhciBrIGluIGUpIHtcbiAgICAgICAgICB2YXIgdiA9IGVba107XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGlmICh0b3JxdWUuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHAucHVzaChrICsgXCJbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2W2ldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucHVzaChrICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZURhdGE6IGZ1bmN0aW9uKGNvb3JkLCB6b29tLCBjYWxsYmFjaykge1xuICAgICAgaWYoIXRoaXMuX3JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpbGVRdWV1ZS5wdXNoKFtjb29yZCwgem9vbSwgY2FsbGJhY2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2dldFRpbGVEYXRhKGNvb3JkLCB6b29tLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRSZWFkeTogZnVuY3Rpb24ocmVhZHkpIHtcbiAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgICAgdGhpcy5vcHRpb25zLnJlYWR5ICYmIHRoaXMub3B0aW9ucy5yZWFkeSgpO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVtO1xuICAgICAgd2hpbGUgKGl0ZW0gPSB0aGlzLl90aWxlUXVldWUucG9wKCkpIHtcbiAgICAgICAgdGhpcy5fZ2V0VGlsZURhdGEuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGBjb29yZGAgb2JqZWN0IGxpa2Uge3ggOiB0aWxleCwgeTogdGlsZXkgfVxuICAgICAqIGB6b29tYCBxdWFkdHJlZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgX2dldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzdWJkb21haW5zID0gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMgfHwgJzAxMjMnO1xuICAgICAgdmFyIGxpbWl0X3ggPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAgIHZhciBjb3JyZWN0ZWRfeCA9ICgoY29vcmQueCAlIGxpbWl0X3gpICsgbGltaXRfeCkgJSBsaW1pdF94O1xuICAgICAgdmFyIGluZGV4ID0gTWF0aC5hYnMoY29ycmVjdGVkX3ggKyBjb29yZC55KSAlIHN1YmRvbWFpbnMubGVuZ3RoO1xuICAgICAgdmFyIGV4dHJhID0gdGhpcy5fZXh0cmFQYXJhbXMoKTtcbiAgICAgIHZhciB1cmwgPSB0aGlzLnRlbXBsYXRlVXJsXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t4fScsIGNvcnJlY3RlZF94KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7eX0nLCBjb29yZC55KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7en0nLCB6b29tKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7c30nLCBzdWJkb21haW5zW2luZGV4XSlcbiAgICAgIHVybCArPSBleHRyYTtcbiAgICAgIHRvcnF1ZS5uZXQuZ2V0KCB1cmwgLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgIHZhciByb3dzID0gSlNPTi5wYXJzZShkYXRhLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgY2FsbGJhY2soc2VsZi5wcm9jY2Vzc1RpbGUocm93cywgY29vcmQsIHpvb20pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldEtleVNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHRoaXMub3B0aW9ucy5zdGFydCxcbiAgICAgICAgZW5kOiB0aGlzLm9wdGlvbnMuZW5kLFxuICAgICAgICBzdGVwOiB0aGlzLm9wdGlvbnMuc3RlcCxcbiAgICAgICAgc3RlcHM6IHRoaXMub3B0aW9ucy5zdGVwcyxcbiAgICAgICAgY29sdW1uVHlwZTogdGhpcy5vcHRpb25zLmNvbHVtbl90eXBlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbiwgaXNUaW1lKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy5vcHRpb25zLmlzX3RpbWUgPSBpc1RpbWUgPT09IHVuZGVmaW5lZCA/IHRydWU6IGZhbHNlO1xuICAgICAgdGhpcy5yZWxvYWQoKTtcbiAgICB9LFxuXG4gICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9mZXRjaE1hcCgpO1xuICAgIH0sXG5cbiAgICBnZXRTdGVwczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5vcHRpb25zLnN0ZXBzLCB0aGlzLm9wdGlvbnMuZGF0YV9zdGVwcyk7XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvdW5kcztcbiAgICB9LFxuXG4gICAgZ2V0U1FMOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3FsIHx8IFwic2VsZWN0ICogZnJvbSBcIiArIHRoaXMub3B0aW9ucy50YWJsZTtcbiAgICB9LFxuXG4gICAgc2V0U1FMOiBmdW5jdGlvbihzcWwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3FsICE9IHNxbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3FsID0gc3FsO1xuICAgICAgICB0aGlzLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaXNVc2VyVGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIHQuaW5kZXhPZigne3VzZXJ9JykgIT09IC0xO1xuICAgIH0sXG5cbiAgICBpc0h0dHBzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWFwc19hcGlfdGVtcGxhdGUuaW5kZXhPZignaHR0cHMnKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2ZldGNoTWFwOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdG9ycXVlLm5ldC5nZXQodGhpcy5vcHRpb25zLnRpbGVKU09OLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhLnJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5lcnJvcnMpe1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLmVycm9yQ2FsbGJhY2sgJiYgc2VsZi5vcHRpb25zLmVycm9yQ2FsbGJhY2soZGF0YS5lcnJvcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IodmFyIGsgaW4gZGF0YSkge1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zW2tdID0gZGF0YVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi50ZW1wbGF0ZVVybCA9IGRhdGEudGlsZXNbMF07XG4gICAgICAgICAgaWYgKHNlbGYudGVtcGxhdGVVcmwuaW5kZXhPZihcImh0dHBcIikgIT09IDApe1xuICAgICAgICAgICAgc2VsZi50ZW1wbGF0ZVVybCA9IHNlbGYub3B0aW9ucy50aWxlSlNPTi5zdWJzdHJpbmcoMCwgc2VsZi5vcHRpb25zLnRpbGVKU09OLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgc2VsZi50ZW1wbGF0ZVVybDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fc2V0UmVhZHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHRpbGVKU09OOyIsIiAgdmFyIHRvcnF1ZSA9IHJlcXVpcmUoJy4uLycpO1xuICB2YXIgUHJvZmlsZXIgPSByZXF1aXJlKCcuLi9wcm9maWxlcicpO1xuXG4gIHZhciBVaW50OEFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQ4QXJyYXk7XG4gIHZhciBJbnQzMkFycmF5ID0gdG9ycXVlLnR5cGVzLkludDMyQXJyYXk7XG4gIHZhciBVaW50MzJBcnJheSA9IHRvcnF1ZS50eXBlcy5VaW50MzJBcnJheTtcbiAgdmFyIFVpbnQ4Q2xhbXBlZEFycmF5ID0gdG9ycXVlLnR5cGVzLlVpbnQ4Q2xhbXBlZEFycmF5O1xuXG4gIC8vIGZvcm1hdCgnaGVsbG8sIHswfScsICdyYW1ibycpIC0+IFwiaGVsbG8sIHJhbWJvXCJcbiAgZnVuY3Rpb24gZm9ybWF0KHN0cikge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvcih2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoJ1xcXFx7JyArIGF0dHIgKyAnXFxcXH0nLCAnZycpLCBhdHRyc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgd2luZHNoYWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3RpbGVRdWV1ZSA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLm9wdGlvbnMuaXNfdGltZSA9IHRoaXMub3B0aW9ucy5pc190aW1lID09PSB1bmRlZmluZWQgPyB0cnVlOiB0aGlzLm9wdGlvbnMuaXNfdGltZTtcbiAgICB0aGlzLm9wdGlvbnMudGlsZXJfcHJvdG9jb2wgPSBvcHRpb25zLnRpbGVyX3Byb3RvY29sIHx8ICdodHRwJztcbiAgICB0aGlzLm9wdGlvbnMudGlsZXJfZG9tYWluID0gb3B0aW9ucy50aWxlcl9kb21haW4gfHwgJ2NhcnRvZGIuY29tJztcbiAgICB0aGlzLm9wdGlvbnMudGlsZXJfcG9ydCA9IG9wdGlvbnMudGlsZXJfcG9ydCB8fCA4MDtcblxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXG4gICAgaWYgKCFvcHRpb25zLm1hcHNfYXBpX3RlbXBsYXRlKSB7XG4gICAgICB0aGlzLl9idWlsZE1hcHNBcGlUZW1wbGF0ZSh0aGlzLm9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMubWFwc19hcGlfdGVtcGxhdGUgPSAgb3B0aW9ucy5tYXBzX2FwaV90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuY29vcmRpbmF0ZXNfZGF0YV90eXBlID0gdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZSB8fCBVaW50OEFycmF5O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhX2FnZ3JlZ2F0aW9uKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA9IHRoaXMub3B0aW9ucy5kYXRhX2FnZ3JlZ2F0aW9uID09PSAnY3VtdWxhdGl2ZSc7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0aF90b2tlbikge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zIHx8ICh0aGlzLm9wdGlvbnMuZXh0cmFfcGFyYW1zID0ge30pO1xuICAgICAgZS5hdXRoX3Rva2VuID0gdGhpcy5vcHRpb25zLmF1dGhfdG9rZW47XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLm5vX2ZldGNoX21hcCkge1xuICAgICAgdGhpcy5fZmV0Y2hNYXAoKTtcbiAgICB9XG4gIH07XG5cbiAgd2luZHNoYWZ0LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgdG9ycXVlIHRpbGUgZW5jb2RlZCBpbiBhbiBlZmZpY2llbnQgamF2YXNjcmlwdFxuICAgICAqIHN0cnVjdHVyZTpcbiAgICAgKiB7XG4gICAgICogICB4OlVpbnQ4QXJyYXkgeCBjb29yZGluYXRlcyBpbiB0aWxlIHJlZmVyZW5jZSBzeXN0ZW0sIG5vcm1hbGx5IGZyb20gMC0yNTVcbiAgICAgKiAgIHk6VWludDhBcnJheSB5IGNvb3JkaW5hdGVzIGluIHRpbGUgcmVmZXJlbmNlIHN5c3RlbVxuICAgICAqICAgSW5kZXg6IEFycmF5IGluZGV4IHRvIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogfVxuICAgICAqL1xuICAgIHByb2NjZXNzVGlsZTogZnVuY3Rpb24ocm93cywgY29vcmQsIHpvb20pIHtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIHggPSBuZXcgdGhpcy5vcHRpb25zLmNvb3JkaW5hdGVzX2RhdGFfdHlwZShyb3dzLmxlbmd0aCk7XG4gICAgICB2YXIgeSA9IG5ldyB0aGlzLm9wdGlvbnMuY29vcmRpbmF0ZXNfZGF0YV90eXBlKHJvd3MubGVuZ3RoKTtcblxuICAgICAgdmFyIHByb2ZfbWVtID0gUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0Lm1lbScpO1xuICAgICAgdmFyIHByb2ZfcG9pbnRfY291bnQgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5wcm92aWRlci53aW5kc2hhZnQucG9pbnRzJyk7XG4gICAgICB2YXIgcHJvZl9wcm9jZXNzX3RpbWUgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5wcm92aWRlci53aW5kc2hhZnQucHJvY2Vzc190aW1lJykuc3RhcnQoKTtcblxuICAgICAgLy8gY291bnQgbnVtYmVyIG9mIGRhdGVzXG4gICAgICB2YXIgZGF0ZXMgPSAwO1xuICAgICAgdmFyIG1heERhdGVTbG90cyA9IC0xO1xuICAgICAgZm9yIChyID0gMDsgciA8IHJvd3MubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcl07XG4gICAgICAgIGRhdGVzICs9IHJvdy5kYXRlc19fdWludDE2Lmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBkID0gMDsgZCA8IHJvdy5kYXRlc19fdWludDE2Lmxlbmd0aDsgKytkKSB7XG4gICAgICAgICAgbWF4RGF0ZVNsb3RzID0gTWF0aC5tYXgobWF4RGF0ZVNsb3RzLCByb3cuZGF0ZXNfX3VpbnQxNltkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5vcHRpb25zLmN1bXVsYXRpdmUpIHtcbiAgICAgICAgZGF0ZXMgPSAoMSArIG1heERhdGVTbG90cykgKiByb3dzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA/IFVpbnQzMkFycmF5OiBVaW50OENsYW1wZWRBcnJheTtcblxuICAgICAgLy8gcmVzZXJ2ZSBtZW1vcnkgZm9yIGFsbCB0aGUgZGF0ZXNcbiAgICAgIHZhciB0aW1lSW5kZXggPSBuZXcgSW50MzJBcnJheShtYXhEYXRlU2xvdHMgKyAxKTsgLy9pbmRleC1zaXplXG4gICAgICB2YXIgdGltZUNvdW50ID0gbmV3IEludDMyQXJyYXkobWF4RGF0ZVNsb3RzICsgMSk7XG4gICAgICB2YXIgcmVuZGVyRGF0YSA9IG5ldyAodGhpcy5vcHRpb25zLnZhbHVlRGF0YVR5cGUgfHwgdHlwZSkoZGF0ZXMpO1xuICAgICAgdmFyIHJlbmRlckRhdGFQb3MgPSBuZXcgVWludDMyQXJyYXkoZGF0ZXMpO1xuXG4gICAgICBwcm9mX21lbS5pbmMoXG4gICAgICAgIDQgKiBtYXhEYXRlU2xvdHMgKyAvLyB0aW1lSW5kZXhcbiAgICAgICAgNCAqIG1heERhdGVTbG90cyArIC8vIHRpbWVDb3VudFxuICAgICAgICBkYXRlcyArIC8vcmVuZGVyRGF0YVxuICAgICAgICBkYXRlcyAqIDRcbiAgICAgICk7IC8vcmVuZGVyRGF0YVBvc1xuXG4gICAgICBwcm9mX3BvaW50X2NvdW50LmluYyhyb3dzLmxlbmd0aCk7XG5cbiAgICAgIHZhciByb3dzUGVyU2xvdCA9IHt9O1xuXG4gICAgICAvLyBwcmVjYWNoZSBwaXhlbCBwb3NpdGlvbnNcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICB2YXIgcm93ID0gcm93c1tyXTtcbiAgICAgICAgeFtyXSA9IHJvdy54X191aW50OCAqIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICB5W3JdID0gcm93LnlfX3VpbnQ4ICogdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG5cbiAgICAgICAgdmFyIGRhdGVzID0gcm93LmRhdGVzX191aW50MTY7XG4gICAgICAgIHZhciB2YWxzID0gcm93LnZhbHNfX3VpbnQ4O1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jdW11bGF0aXZlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciByciA9IHJvd3NQZXJTbG90W2RhdGVzW2pdXSB8fCAocm93c1BlclNsb3RbZGF0ZXNbal1dID0gW10pO1xuICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdmFsc1tqXSArPSBwcmV2X3ZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmV2X3ZhbCA9IHZhbHNbal07XG4gICAgICAgICAgICAgIHJyLnB1c2goW3IsIHZhbHNbal1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbEJ5RGF0ZSA9IHt9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICB2YWxCeURhdGVbZGF0ZXNbal1dID0gdmFsc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFjY3VtID0gMDtcblxuICAgICAgICAgIC8vIGV4dGVuZCB0aGUgbGF0ZXN0IHRvIHRoZSBlbmRcbiAgICAgICAgICBmb3IgKHZhciBqID0gZGF0ZXNbMF07IGogPD0gbWF4RGF0ZVNsb3RzOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIHJyID0gcm93c1BlclNsb3Rbal0gfHwgKHJvd3NQZXJTbG90W2pdID0gW10pO1xuICAgICAgICAgICAgICB2YXIgdiA9IHZhbEJ5RGF0ZVtqXTtcbiAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICBhY2N1bSArPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJyLnB1c2goW3IsIGFjY3VtXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyp2YXIgbGFzdERhdGVTbG90ID0gZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGxhc3REYXRlU2xvdCArIDE7IGogPD0gbWF4RGF0ZVNsb3RzOyArK2opIHtcbiAgICAgICAgICAgIHZhciByciA9IHJvd3NQZXJTbG90W2pdIHx8IChyb3dzUGVyU2xvdFtqXSA9IFtdKTtcbiAgICAgICAgICAgIHJyLnB1c2goW3IsIHByZXZfdmFsXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICovXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZWFjaCB0aW1lc2xvdCBzZWFyY2ggYWN0aXZlIGJ1Y2tldHNcbiAgICAgIHZhciByZW5kZXJEYXRhSW5kZXggPSAwO1xuICAgICAgdmFyIHRpbWVTbG90SW5kZXggPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSBtYXhEYXRlU2xvdHM7ICsraSkge1xuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBzbG90Um93cyA9IHJvd3NQZXJTbG90W2ldXG4gICAgICAgIGlmKHNsb3RSb3dzKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzbG90Um93cy5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgdmFyIHJyID0gc2xvdFJvd3Nbcl07XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICByZW5kZXJEYXRhUG9zW3JlbmRlckRhdGFJbmRleF0gPSByclswXVxuICAgICAgICAgICAgcmVuZGVyRGF0YVtyZW5kZXJEYXRhSW5kZXhdID0gcnJbMV07XG4gICAgICAgICAgICArK3JlbmRlckRhdGFJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGltZUluZGV4W2ldID0gdGltZVNsb3RJbmRleDtcbiAgICAgICAgdGltZUNvdW50W2ldID0gYztcbiAgICAgICAgdGltZVNsb3RJbmRleCArPSBjO1xuICAgICAgfVxuXG4gICAgICBwcm9mX3Byb2Nlc3NfdGltZS5lbmQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgejogem9vbSxcbiAgICAgICAgY29vcmQ6IHtcbiAgICAgICAgICB4OiBjb29yZC54LFxuICAgICAgICAgIHk6IGNvb3JkLnksXG4gICAgICAgICAgejogem9vbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lQ291bnQ6IHRpbWVDb3VudCxcbiAgICAgICAgdGltZUluZGV4OiB0aW1lSW5kZXgsXG4gICAgICAgIHJlbmRlckRhdGFQb3M6IHJlbmRlckRhdGFQb3MsXG4gICAgICAgIHJlbmRlckRhdGE6IHJlbmRlckRhdGEsXG4gICAgICAgIG1heERhdGU6IG1heERhdGVTbG90c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLypzZXRDYXJ0b0NTUzogZnVuY3Rpb24oYykge1xuICAgICAgdGhpcy5vcHRpb25zLmNhcnRvY3NzID0gYztcbiAgICB9LCovXG5cbiAgICBzZXRTdGVwczogZnVuY3Rpb24oc3RlcHMsIG9wdCkgeyBcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcHMgIT09IHN0ZXBzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcCA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KS90aGlzLmdldFN0ZXBzKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAgfHwgMTtcbiAgICAgICAgaWYgKCFvcHQuc2lsZW50KSB0aGlzLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgIHZhciByZWZyZXNoID0gZmFsc2U7XG5cbiAgICAgIGlmKG9wdC5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgJiYgb3B0LnJlc29sdXRpb24gIT09IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uID0gb3B0LnJlc29sdXRpb247XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuc3RlcHMgIT09IHVuZGVmaW5lZCAmJiBvcHQuc3RlcHMgIT09IHRoaXMub3B0aW9ucy5zdGVwcykge1xuICAgICAgICB0aGlzLnNldFN0ZXBzKG9wdC5zdGVwcywgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgb3B0LmNvbHVtbiAhPT0gdGhpcy5vcHRpb25zLmNvbHVtbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY29sdW1uID0gb3B0LmNvbHVtbjtcbiAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKG9wdC5jb3VudGJ5ICE9PSB1bmRlZmluZWQgJiYgb3B0LmNvdW50YnkgIT09IHRoaXMub3B0aW9ucy5jb3VudGJ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudGJ5ID0gb3B0LmNvdW50Ynk7XG4gICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZihvcHQuZGF0YV9hZ2dyZWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjID0gb3B0LmRhdGFfYWdncmVnYXRpb24gPT09ICdjdW11bGF0aXZlJztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlICE9PSBjKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmN1bXVsYXRpdmUgPSBjO1xuICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWZyZXNoKSB0aGlzLnJlbG9hZCgpO1xuICAgICAgcmV0dXJuIHJlZnJlc2g7XG4gICAgfSxcblxuICAgIF9leHRyYVBhcmFtczogZnVuY3Rpb24oZSkge1xuICAgICAgZSA9IHRvcnF1ZS5leHRlbmQodG9ycXVlLmV4dGVuZCh7fSwgZSksIHRoaXMub3B0aW9ucy5leHRyYV9wYXJhbXMpO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgZm9yKHZhciBrIGluIGUpIHtcbiAgICAgICAgICB2YXIgdiA9IGVba107XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGlmICh0b3JxdWUuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHAucHVzaChrICsgXCJbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2W2ldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucHVzaChrICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZURhdGE6IGZ1bmN0aW9uKGNvb3JkLCB6b29tLCBjYWxsYmFjaykge1xuICAgICAgaWYoIXRoaXMuX3JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpbGVRdWV1ZS5wdXNoKFtjb29yZCwgem9vbSwgY2FsbGJhY2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2dldFRpbGVEYXRhKGNvb3JkLCB6b29tLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRSZWFkeTogZnVuY3Rpb24ocmVhZHkpIHtcbiAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgICAgdGhpcy5vcHRpb25zLnJlYWR5ICYmIHRoaXMub3B0aW9ucy5yZWFkeSgpO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVtO1xuICAgICAgd2hpbGUgKGl0ZW0gPSB0aGlzLl90aWxlUXVldWUucG9wKCkpIHtcbiAgICAgICAgdGhpcy5fZ2V0VGlsZURhdGEuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGBjb29yZGAgb2JqZWN0IGxpa2Uge3ggOiB0aWxleCwgeTogdGlsZXkgfVxuICAgICAqIGB6b29tYCBxdWFkdHJlZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgX2dldFRpbGVEYXRhOiBmdW5jdGlvbihjb29yZCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwcm9mX2ZldGNoX3RpbWUgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5wcm92aWRlci53aW5kc2hhZnQudGlsZS5mZXRjaCcpLnN0YXJ0KCk7XG4gICAgICB2YXIgc3ViZG9tYWlucyA9IHRoaXMub3B0aW9ucy5zdWJkb21haW5zIHx8ICcwMTIzJztcbiAgICAgIHZhciBsaW1pdF94ID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgICB2YXIgY29ycmVjdGVkX3ggPSAoKGNvb3JkLnggJSBsaW1pdF94KSArIGxpbWl0X3gpICUgbGltaXRfeDtcbiAgICAgIHZhciBpbmRleCA9IE1hdGguYWJzKGNvcnJlY3RlZF94ICsgY29vcmQueSkgJSBzdWJkb21haW5zLmxlbmd0aDtcbiAgICAgIHZhciB1cmwgPSB0aGlzLnRlbXBsYXRlVXJsXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t4fScsIGNvcnJlY3RlZF94KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7eX0nLCBjb29yZC55KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7en0nLCB6b29tKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7c30nLCBzdWJkb21haW5zW2luZGV4XSlcblxuICAgICAgdmFyIGV4dHJhID0gdGhpcy5fZXh0cmFQYXJhbXMoKTtcbiAgICAgIHRvcnF1ZS5uZXQuZ2V0KCB1cmwgKyAoZXh0cmEgPyBcIj9cIiArIGV4dHJhOiAnJyksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHByb2ZfZmV0Y2hfdGltZS5lbmQoKTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB2YXIgcm93cyA9IEpTT04ucGFyc2UoZGF0YS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIGNhbGxiYWNrKHNlbGYucHJvY2Nlc3NUaWxlKHJvd3MsIGNvb3JkLCB6b29tKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUHJvZmlsZXIubWV0cmljKCd0b3JxdWUucHJvdmlkZXIud2luZHNoYWZ0LnRpbGUuZXJyb3InKS5pbmMoKTtcbiAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldEtleVNwYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHRoaXMub3B0aW9ucy5zdGFydCxcbiAgICAgICAgZW5kOiB0aGlzLm9wdGlvbnMuZW5kLFxuICAgICAgICBzdGVwOiB0aGlzLm9wdGlvbnMuc3RlcCxcbiAgICAgICAgc3RlcHM6IHRoaXMub3B0aW9ucy5zdGVwcyxcbiAgICAgICAgY29sdW1uVHlwZTogdGhpcy5vcHRpb25zLmNvbHVtbl90eXBlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbiwgaXNUaW1lKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy5vcHRpb25zLmlzX3RpbWUgPSBpc1RpbWUgPT09IHVuZGVmaW5lZCA/IHRydWU6IGZhbHNlO1xuICAgICAgdGhpcy5yZWxvYWQoKTtcbiAgICB9LFxuXG4gICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9mZXRjaE1hcCgpO1xuICAgIH0sXG5cbiAgICBnZXRTdGVwczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5vcHRpb25zLnN0ZXBzLCB0aGlzLm9wdGlvbnMuZGF0YV9zdGVwcyk7XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvdW5kcztcbiAgICB9LFxuXG4gICAgZ2V0U1FMOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3FsIHx8IFwic2VsZWN0ICogZnJvbSBcIiArIHRoaXMub3B0aW9ucy50YWJsZTtcbiAgICB9LFxuXG4gICAgc2V0U1FMOiBmdW5jdGlvbihzcWwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3FsICE9IHNxbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc3FsID0gc3FsO1xuICAgICAgICB0aGlzLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYnVpbGRNYXBzQXBpVGVtcGxhdGU6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICB2YXIgdXNlciA9IG9wdHMudXNlcl9uYW1lIHx8IG9wdHMudXNlcjtcbiAgICAgICBvcHRzLm1hcHNfYXBpX3RlbXBsYXRlID0gb3B0cy50aWxlcl9wcm90b2NvbCArXG4gICAgICAgICAgIFwiOi8vXCIgKyAoKHVzZXIpID8gXCJ7dXNlcn0uXCI6XCJcIikgICtcbiAgICAgICAgICAgb3B0cy50aWxlcl9kb21haW4gK1xuICAgICAgICAgICAoKG9wdHMudGlsZXJfcG9ydCAhPSBcIlwiKSA/IChcIjpcIiArIG9wdHMudGlsZXJfcG9ydCkgOiBcIlwiKTtcbiAgICB9LFxuXG4gICAgX3RpbGVySG9zdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciB1c2VyID0gb3B0cy51c2VyX25hbWUgfHwgb3B0cy51c2VyO1xuICAgICAgcmV0dXJuIG9wdHMubWFwc19hcGlfdGVtcGxhdGUucmVwbGFjZSgne3VzZXJ9JywgdXNlcik7XG4gICAgfSxcblxuICAgIHVybDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY2RuX2hvc3QgPSBvcHRzLmNkbl91cmw7XG4gICAgICB2YXIgaGFzX2VtcHR5X2NkbiA9ICFjZG5faG9zdCB8fCAoY2RuX2hvc3QgJiYgKCFjZG5faG9zdC5odHRwICYmICFjZG5faG9zdC5odHRwcykpO1xuXG4gICAgICBpZiAob3B0cy5ub19jZG4gfHwgaGFzX2VtcHR5X2Nkbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXJIb3N0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLmlzSHR0cHMoKSA/ICdodHRwcyc6ICdodHRwJztcbiAgICAgICAgdmFyIGggPSBwcm90b2NvbCArIFwiOi8vXCI7XG4gICAgICAgIGlmICghdGhpcy5pc0h0dHBzKCkpIHtcbiAgICAgICAgICBoICs9IFwie3N9LlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZG5fdXJsID0gY2RuX2hvc3RbcHJvdG9jb2xdO1xuICAgICAgICAvLyBidWlsZCBkZWZhdWx0IHRlbXBsYXRlIHVybCBpZiB0aGUgY2RuIHVybCBpcyBub3QgdGVtcGxhdGl6ZWRcbiAgICAgICAgLy8gdGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eSwgaWRlYWxseSB3ZSBzaG91bGQgdXNlIHRoZSB1cmxcbiAgICAgICAgLy8gdGhhdCB0aWxlciBzZW5kcyB0byB1cyByaWdodCBhd2F5XG4gICAgICAgIGlmICghdGhpcy5faXNVc2VyVGVtcGxhdGVVcmwoY2RuX3VybCkpIHtcbiAgICAgICAgICBjZG5fdXJsID0gY2RuX3VybCAgKyBcIi97dXNlcn1cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlciA9IG9wdHMudXNlcl9uYW1lIHx8IG9wdHMudXNlcjtcbiAgICAgICAgaCArPSBjZG5fdXJsLnJlcGxhY2UoJ3t1c2VyfScsIHVzZXIpXG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIF9pc1VzZXJUZW1wbGF0ZVVybDogZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQgJiYgdC5pbmRleE9mKCd7dXNlcn0nKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIGlzSHR0cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tYXBzX2FwaV90ZW1wbGF0ZS5pbmRleE9mKCdodHRwcycpID09PSAwO1xuICAgIH0sXG5cbiAgICBfZ2VuZXJhdGVDYXJ0b0NTUzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXR0ciA9IHtcbiAgICAgICAgJy10b3JxdWUtZnJhbWUtY291bnQnOiB0aGlzLm9wdGlvbnMuc3RlcHMsXG4gICAgICAgICctdG9ycXVlLXJlc29sdXRpb24nOiB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgICAgJy10b3JxdWUtYWdncmVnYXRpb24tZnVuY3Rpb24nOiBcIidcIiArIHRoaXMub3B0aW9ucy5jb3VudGJ5ICsgXCInXCIsXG4gICAgICAgICctdG9ycXVlLXRpbWUtYXR0cmlidXRlJzogXCInXCIgKyB0aGlzLm9wdGlvbnMuY29sdW1uICsgXCInXCIsXG4gICAgICAgICctdG9ycXVlLWRhdGEtYWdncmVnYXRpb24nOiB0aGlzLm9wdGlvbnMuY3VtdWxhdGl2ZSA/ICdjdW11bGF0aXZlJzogJ2xpbmVhcicsXG4gICAgICB9O1xuICAgICAgdmFyIHN0ID0gJ01hcHsnO1xuICAgICAgZm9yICh2YXIgayBpbiBhdHRyKSB7XG4gICAgICAgIHN0ICs9IGsgKyBcIjpcIiArIGF0dHJba10gKyBcIjtcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdCArIFwifVwiO1xuICAgIH0sXG5cbiAgICBfZmV0Y2hNYXA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbGF5ZXJncm91cCA9IHt9O1xuICAgICAgdmFyIGhvc3QgPSB0aGlzLm9wdGlvbnMuZHluYW1pY19jZG4gPyB0aGlzLnVybCgpLnJlcGxhY2UoJ3tzfScsICcwJyk6IHRoaXMuX3RpbGVySG9zdCgpO1xuICAgICAgdmFyIHVybCA9IGhvc3QgKyBcIi9hcGkvdjEvbWFwXCI7XG4gICAgICB2YXIgbmFtZWQgPSB0aGlzLm9wdGlvbnMubmFtZWRfbWFwO1xuICAgICAgdmFyIGFsbFBhcmFtcyA9IHt9O1xuXG4gICAgICBpZihuYW1lZCkge1xuICAgICAgICAvL3RpbGVzL3RlbXBsYXRlXG4gICAgICAgIHVybCA9IGhvc3QgKyBcIi9hcGkvdjEvbWFwL25hbWVkL1wiICsgbmFtZWQubmFtZSArIFwiL2pzb25wXCI7XG4gICAgICAgIGlmKHR5cGVvZiBuYW1lZC5wYXJhbXMgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgIGxheWVyZ3JvdXAgPSBuYW1lZC5wYXJhbXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyZ3JvdXAgPSB7XG4gICAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjFcIixcbiAgICAgICAgICBcInN0YXRfdGFnXCI6IHRoaXMub3B0aW9ucy5zdGF0X3RhZyB8fCAndG9ycXVlJyxcbiAgICAgICAgICBcImxheWVyc1wiOiBbe1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidG9ycXVlXCIsXG4gICAgICAgICAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgICAgICAgICBcImNhcnRvY3NzX3ZlcnNpb25cIjogXCIxLjAuMFwiLFxuICAgICAgICAgICAgICBcImNhcnRvY3NzXCI6IHRoaXMuX2dlbmVyYXRlQ2FydG9DU1MoKSxcbiAgICAgICAgICAgICAgXCJzcWxcIjogdGhpcy5nZXRTUUwoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKHRoaXMub3B0aW9ucy5zdGF0X3RhZyl7XG4gICAgICAgIGFsbFBhcmFtc1tcInN0YXRfdGFnXCJdID0gdGhpcy5vcHRpb25zLnN0YXRfdGFnO1xuICAgICAgfVxuXG4gICAgICBleHRyYSA9IHRoaXMuX2V4dHJhUGFyYW1zKGFsbFBhcmFtcyk7XG5cbiAgICAgIC8vIHRpbGVyIG5lZWRzIG1hcF9rZXkgaW5zdGVhZCBvZiBhcGlfa2V5XG4gICAgICAvLyBzbyByZXBsYWNlIGl0XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgZXh0cmEgPSBleHRyYS5yZXBsYWNlKCdhcGlfa2V5PScsICdtYXBfa2V5PScpO1xuICAgICAgfVxuXG4gICAgICB1cmwgPSB1cmwgK1xuICAgICAgICBcIj9jb25maWc9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobGF5ZXJncm91cCkpICtcbiAgICAgICAgXCImY2FsbGJhY2s9P1wiICsgKGV4dHJhID8gXCImXCIgKyBleHRyYTogJycpO1xuXG4gICAgICB2YXIgbWFwX2luc3RhbmNlX3RpbWUgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5wcm92aWRlci53aW5kc2hhZnQubGF5ZXJncm91cC50aW1lJykuc3RhcnQoKTtcbiAgICAgIHRvcnF1ZS5uZXQuanNvbnAodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBtYXBfaW5zdGFuY2VfdGltZS5lbmQoKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5lcnJvcnMpe1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLmVycm9yQ2FsbGJhY2sgJiYgc2VsZi5vcHRpb25zLmVycm9yQ2FsbGJhY2soZGF0YS5lcnJvcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdG9ycXVlX2tleSA9IE9iamVjdC5rZXlzKGRhdGEubWV0YWRhdGEudG9ycXVlKVswXVxuICAgICAgICAgIHZhciBvcHQgPSBkYXRhLm1ldGFkYXRhLnRvcnF1ZVt0b3JxdWVfa2V5XTtcbiAgICAgICAgICBmb3IodmFyIGsgaW4gb3B0KSB7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnNba10gPSBvcHRba107XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHVzZSBjZG5fdXJsIGlmIHByZXNlbnRcbiAgICAgICAgICBpZiAoZGF0YS5jZG5fdXJsKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHNlbGYub3B0aW9ucy5jZG5fdXJsID0gc2VsZi5vcHRpb25zLmNkbl91cmwgfHwge307XG4gICAgICAgICAgICBjLmh0dHAgPSBkYXRhLmNkbl91cmwuaHR0cCB8fCBjLmh0dHA7XG4gICAgICAgICAgICBjLmh0dHBzID0gZGF0YS5jZG5fdXJsLmh0dHBzIHx8IGMuaHR0cHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYudGVtcGxhdGVVcmwgPSBzZWxmLnVybCgpICsgXCIvYXBpL3YxL21hcC9cIiArIGRhdGEubGF5ZXJncm91cGlkICsgXCIvXCIgKyB0b3JxdWVfa2V5ICsgXCIve3p9L3t4fS97eX0uanNvbi50b3JxdWVcIjtcbiAgICAgICAgICBzZWxmLl9zZXRSZWFkeSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5wcm92aWRlci53aW5kc2hhZnQubGF5ZXJncm91cC5lcnJvcicpLmluYygpO1xuICAgICAgICB9XG4gICAgICB9LCB7IGNhbGxiYWNrTmFtZTogc2VsZi5vcHRpb25zLmluc3RhbmNpYXRlQ2FsbGJhY2sgfSk7XG4gICAgfVxuXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kc2hhZnQ7XG4iLCIgIHZhciBUQVUgPSBNYXRoLlBJKjI7XG4gIC8vIG1pbiB2YWx1ZSB0byByZW5kZXIgYSBsaW5lLiBcbiAgLy8gaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byByZW5kZXIgYSBsaW5lIG9mIGEgd2lkdGggaXMgbm90IGV2ZW4gdmlzaWJsZVxuICB2YXIgTElORVdJRFRIX01JTl9WQUxVRSA9IDAuMDU7IFxuICB2YXIgTUFYX1NQUklURV9SQURJVVMgPSAyNTU7XG5cbiAgZnVuY3Rpb24gcmVuZGVyUG9pbnQoY3R4LCBzdCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdFsnbWFya2VyLWZpbGwnXTtcbiAgICB2YXIgcGl4ZWxfc2l6ZSA9IHN0WydtYXJrZXItd2lkdGgnXTtcblxuICAgIC8vIHJlbmRlciBhIGNpcmNsZVxuICAgIC8vIFRPRE86IGZpbGwgYW5kIHN0cm9rZSBvcmRlciBzaG91bGQgZGVwZW5kIG9uIHRoZSBvcmRlciBvZiB0aGUgcHJvcGVydGllc1xuICAgIC8vIGluIHRoZSBjYXJ0b2Nzcy5cblxuICAgIC8vIGZpbGxcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYygwLCAwLCBwaXhlbF9zaXplLCAwLCBUQVUsIHRydWUsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChzdFsnbWFya2VyLW9wYWNpdHknXSAhPT0gdW5kZWZpbmVkICkgIHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gPSBzdFsnbWFya2VyLWxpbmUtb3BhY2l0eSddID0gc3RbJ21hcmtlci1vcGFjaXR5J107XG5cbiAgICBpZiAoc3RbJ21hcmtlci1maWxsJ10pIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3RbJ21hcmtlci1maWxsLW9wYWNpdHknXSA+PSAwPyBzdFsnbWFya2VyLWZpbGwtb3BhY2l0eSddOiAxO1xuXG4gICAgICBpZiAoY3R4Lmdsb2JhbEFscGhhID4gMCkge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0cm9rZVxuICAgIGlmIChzdFsnbWFya2VyLWxpbmUtY29sb3InXSAmJiBzdFsnbWFya2VyLWxpbmUtd2lkdGgnXSAmJiBzdFsnbWFya2VyLWxpbmUtd2lkdGgnXSA+IExJTkVXSURUSF9NSU5fVkFMVUUpIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0WydtYXJrZXItbGluZS1vcGFjaXR5J10gPj0gMD8gc3RbJ21hcmtlci1saW5lLW9wYWNpdHknXTogMTtcbiAgICAgIGlmIChzdFsnbWFya2VyLWxpbmUtd2lkdGgnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdFsnbWFya2VyLWxpbmUtd2lkdGgnXTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0WydtYXJrZXItbGluZS1jb2xvciddO1xuXG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGZvciBhbHBoYSA9IDBcbiAgICAgIGlmIChjdHguZ2xvYmFsQWxwaGEgPiAwKSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSZWN0YW5nbGUoY3R4LCBzdCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdFsnbWFya2VyLWZpbGwnXTtcbiAgICB2YXIgcGl4ZWxfc2l6ZSA9IHN0WydtYXJrZXItd2lkdGgnXTtcbiAgICB2YXIgdyA9IHBpeGVsX3NpemUgKiAyO1xuXG4gICAgLy8gZmlsbFxuICAgIGlmIChzdFsnbWFya2VyLWZpbGwnXSkge1xuICAgICAgaWYgKHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gIT09IHVuZGVmaW5lZCB8fCBzdFsnbWFya2VyLW9wYWNpdHknXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0WydtYXJrZXItZmlsbC1vcGFjaXR5J10gfHwgc3RbJ21hcmtlci1vcGFjaXR5J107XG4gICAgICB9XG4gICAgICBjdHguZmlsbFJlY3QoLXBpeGVsX3NpemUsIC1waXhlbF9zaXplLCB3LCB3KVxuICAgIH1cblxuICAgIC8vIHN0cm9rZVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgICBpZiAoc3RbJ21hcmtlci1saW5lLWNvbG9yJ10gJiYgc3RbJ21hcmtlci1saW5lLXdpZHRoJ10pIHtcbiAgICAgIGlmIChzdFsnbWFya2VyLWxpbmUtb3BhY2l0eSddKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0WydtYXJrZXItbGluZS1vcGFjaXR5J107XG4gICAgICB9XG4gICAgICBpZiAoc3RbJ21hcmtlci1saW5lLXdpZHRoJ10pIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0WydtYXJrZXItbGluZS13aWR0aCddO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3RbJ21hcmtlci1saW5lLWNvbG9yJ107XG5cbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgZm9yIGFscGhhID0gMFxuICAgICAgaWYgKGN0eC5nbG9iYWxBbHBoYSA+IDApIHtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoLXBpeGVsX3NpemUsIC1waXhlbF9zaXplLCB3LCB3KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclNwcml0ZShjdHgsIGltZywgc3QpIHtcblxuICAgIGlmKGltZy5jb21wbGV0ZSl7XG4gICAgICBpZiAoc3RbJ21hcmtlci1maWxsLW9wYWNpdHknXSAhPT0gdW5kZWZpbmVkIHx8IHN0WydtYXJrZXItb3BhY2l0eSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3RbJ21hcmtlci1maWxsLW9wYWNpdHknXSB8fCBzdFsnbWFya2VyLW9wYWNpdHknXTtcbiAgICAgIH1cbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBNYXRoLm1pbihpbWcud2lkdGgsIE1BWF9TUFJJVEVfUkFESVVTKSwgTWF0aC5taW4oaW1nLmhlaWdodCwgTUFYX1NQUklURV9SQURJVVMpKTtcbiAgICB9XG4gIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVuZGVyUG9pbnQ6IHJlbmRlclBvaW50LFxuICAgIHJlbmRlclNwcml0ZTogcmVuZGVyU3ByaXRlLFxuICAgIHJlbmRlclJlY3RhbmdsZTogcmVuZGVyUmVjdGFuZ2xlLFxuICAgIE1BWF9TUFJJVEVfUkFESVVTOiBNQVhfU1BSSVRFX1JBRElVU1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNhcnRvY3NzOiByZXF1aXJlKCcuL2NhcnRvY3NzX3JlbmRlcicpLFxuICAgIFBvaW50OiByZXF1aXJlKCcuL3BvaW50JyksXG4gICAgUmVjdGFuZ2xlOiByZXF1aXJlKCcuL3JlY3RhbmdsZScpXG59OyIsInZhciB0b3JxdWUgPSByZXF1aXJlKCcuLi8nKTtcbnZhciBjYXJ0b2NzcyA9IHJlcXVpcmUoJy4vY2FydG9jc3NfcmVuZGVyJyk7XG52YXIgUHJvZmlsZXIgPSByZXF1aXJlKCcuLi9wcm9maWxlcicpO1xudmFyIGNhcnRvID0gZ2xvYmFsLmNhcnRvIHx8IHJlcXVpcmUoJ2NhcnRvJyk7XG52YXIgRmlsdGVycyA9IHJlcXVpcmUoJy4vdG9ycXVlX2ZpbHRlcnMnKTtcblxuICB2YXIgVEFVID0gTWF0aC5QSSAqIDI7XG4gIHZhciBERUZBVUxUX0NBUlRPQ1NTID0gW1xuICAgICcjbGF5ZXIgeycsXG4gICAgJyAgbWFya2VyLWZpbGw6ICM2NjI1MDY7JyxcbiAgICAnICBtYXJrZXItd2lkdGg6IDQ7JyxcbiAgICAnICBbdmFsdWUgPiAxXSB7IG1hcmtlci1maWxsOiAjRkVFMzkxOyB9JyxcbiAgICAnICBbdmFsdWUgPiAyXSB7IG1hcmtlci1maWxsOiAjRkVDNDRGOyB9JyxcbiAgICAnICBbdmFsdWUgPiAzXSB7IG1hcmtlci1maWxsOiAjRkU5OTI5OyB9JyxcbiAgICAnICBbdmFsdWUgPiA0XSB7IG1hcmtlci1maWxsOiAjRUM3MDE0OyB9JyxcbiAgICAnICBbdmFsdWUgPiA1XSB7IG1hcmtlci1maWxsOiAjQ0M0QzAyOyB9JyxcbiAgICAnICBbdmFsdWUgPiA2XSB7IG1hcmtlci1maWxsOiAjOTkzNDA0OyB9JyxcbiAgICAnICBbdmFsdWUgPiA3XSB7IG1hcmtlci1maWxsOiAjNjYyNTA2OyB9JyxcbiAgICAnfSdcbiAgXS5qb2luKCdcXG4nKTtcblxuICB2YXIgQ09NUF9PUF9UT19DQU5WQVMgPSB7XG4gICAgXCJzcmNcIjogJ3NvdXJjZS1vdmVyJyxcbiAgICBcInNyYy1vdmVyXCI6ICdzb3VyY2Utb3ZlcicsXG4gICAgXCJkc3Qtb3ZlclwiOiAnZGVzdGluYXRpb24tb3ZlcicsXG4gICAgXCJzcmMtaW5cIjogJ3NvdXJjZS1pbicsXG4gICAgXCJkc3QtaW5cIjogJ2Rlc3RpbmF0aW9uLWluJyxcbiAgICBcInNyYy1vdXRcIjogJ3NvdXJjZS1vdXQnLFxuICAgIFwiZHN0LW91dFwiOiAnZGVzdGluYXRpb24tb3V0JyxcbiAgICBcInNyYy1hdG9wXCI6ICdzb3VyY2UtYXRvcCcsXG4gICAgXCJkc3QtYXRvcFwiOiAnZGVzdGluYXRpb24tYXRvcCcsXG4gICAgXCJ4b3JcIjogJ3hvcicsXG4gICAgXCJkYXJrZW5cIjogJ2RhcmtlbicsXG4gICAgXCJsaWdodGVuXCI6ICdsaWdodGVuJ1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcG9wMmNhbnZhcyhjb21wb3ApIHtcbiAgICByZXR1cm4gQ09NUF9PUF9UT19DQU5WQVNbY29tcG9wXSB8fCBjb21wb3A7XG4gIH1cblxuICAvL1xuICAvLyB0aGlzIHJlbmRlcmVyIGp1c3QgcmVuZGVyIHBvaW50cyBkZXBlbmRpbmcgb2YgdGhlIHZhbHVlXG4gIC8vXG4gIGZ1bmN0aW9uIFBvaW50UmVuZGVyZXIoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbnZhcyBjYW4ndCBiZSB1bmRlZmluZWRcIik7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuX3Nwcml0ZXMgPSBbXTsgLy8gc3ByaXRlcyBwZXIgbGF5ZXJcbiAgICB0aGlzLl9zaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2ljb25zID0ge307XG4gICAgdGhpcy5faWNvbnNUb0xvYWQgPSAwO1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLl9jYW52YXMsIHtjYW52YXNDbGFzczogb3B0aW9ucy5jYW52YXNDbGFzc30pO1xuICAgIHRoaXMuc2V0Q2FydG9DU1ModGhpcy5vcHRpb25zLmNhcnRvY3NzIHx8IERFRkFVTFRfQ0FSVE9DU1MpO1xuICAgIHRoaXMuVElMRV9TSVpFID0gMjU2O1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9ncmFkaWVudHMgPSB7fTtcbiAgICBcbiAgICB0aGlzLl9mb3JjZVBvaW50cyA9IGZhbHNlO1xuICB9XG5cbiAgdG9ycXVlLmV4dGVuZChQb2ludFJlbmRlcmVyLnByb3RvdHlwZSwgdG9ycXVlLkV2ZW50LCB7XG5cbiAgICBjbGVhckNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5fTWFwWyctdG9ycXVlLWNsZWFyLWNvbG9yJ11cbiAgICAgIC8vIHNob3J0Y3V0IGZvciB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgaWYgKGNvbG9yICA9PT0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApXCIgfHwgIWNvbG9yKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHZhciBjb21wb3AgPSB0aGlzLl9NYXBbJ2NvbXAtb3AnXVxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9wMmNhbnZhcyhjb21wb3ApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRDYW52YXM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8vXG4gICAgLy8gc2V0cyB0aGUgY2FydG9jc3Mgc3R5bGUgdG8gcmVuZGVyIHN0dWZmXG4gICAgLy9cbiAgICBzZXRDYXJ0b0NTUzogZnVuY3Rpb24oY2FydG9jc3MpIHtcbiAgICAgIC8vIGNsZWFuIHNwcml0ZXNcbiAgICAgIHRoaXMuc2V0U2hhZGVyKG5ldyBjYXJ0by5SZW5kZXJlckpTKCkucmVuZGVyKGNhcnRvY3NzKSk7XG4gICAgfSxcblxuICAgIHNldFNoYWRlcjogZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgICAvLyBjbGVhbiBzcHJpdGVzXG4gICAgICB0aGlzLl9zcHJpdGVzID0gW107XG4gICAgICB0aGlzLl9zaGFkZXIgPSBzaGFkZXI7XG4gICAgICB0aGlzLl9NYXAgPSB0aGlzLl9zaGFkZXIuZ2V0RGVmYXVsdCgpLmdldFN0eWxlKHt9LCB7IHpvb206IDAgfSk7XG4gICAgICB2YXIgaW1nX25hbWVzID0gdGhpcy5fc2hhZGVyLmdldEltYWdlVVJMcygpO1xuICAgICAgdGhpcy5fcHJlbG9hZEljb25zKGltZ19uYW1lcyk7XG4gICAgfSxcblxuICAgIGNsZWFyU3ByaXRlQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc3ByaXRlcyA9IFtdO1xuICAgIH0sXG5cblxuICAgIC8vXG4gICAgLy8gZ2VuZXJhdGUgc3ByaXRlIGJhc2VkIG9uIGNhcnRvY3NzIHN0eWxlXG4gICAgLy9cbiAgICBnZW5lcmF0ZVNwcml0ZTogZnVuY3Rpb24oc2hhZGVyLCB2YWx1ZSwgc2hhZGVyVmFycykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHByb2YgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5yZW5kZXJlci5wb2ludC5nZW5lcmF0ZVNwcml0ZScpLnN0YXJ0KCk7XG4gICAgICB2YXIgc3QgPSBzaGFkZXIuZ2V0U3R5bGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0sIHNoYWRlclZhcnMpO1xuICAgICAgaWYodGhpcy5fc3R5bGUgPT09IG51bGwgfHwgdGhpcy5fc3R5bGUgIT09IHN0KXtcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBzdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50U2l6ZSA9IHN0WydtYXJrZXItd2lkdGgnXTtcbiAgICAgIGlmICghcG9pbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RbJ21hcmtlci1vcGFjaXR5J10gPT09IDAgJiYgIXN0WydtYXJrZXItbGluZS1vcGFjaXR5J10pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMoKTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgdmFyIG1hcmtlckZpbGUgPSBzdFtcIm1hcmtlci1maWxlXCJdIHx8IHN0W1wicG9pbnQtZmlsZVwiXTtcbiAgICAgIHZhciBxdWFsaWZpZWRVcmwgPSBtYXJrZXJGaWxlICYmIHRoaXMuX3F1YWxpZnlVUkwobWFya2VyRmlsZSk7XG5cbiAgICAgIGlmIChxdWFsaWZpZWRVcmwgJiYgdGhpcy5faWNvbnNUb0xvYWQgPD0gMCAmJiB0aGlzLl9pY29uc1txdWFsaWZpZWRVcmxdKSB7XG4gICAgICAgIHZhciBpbWcgPSB0aGlzLl9pY29uc1txdWFsaWZpZWRVcmxdO1xuXG4gICAgICAgIHZhciBkV2lkdGggPSAgTWF0aC5taW4oc3RbJ21hcmtlci13aWR0aCddICogMiB8fCBpbWcud2lkdGgsIGNhcnRvY3NzLk1BWF9TUFJJVEVfUkFESVVTICogMik7XG4gICAgICAgIHZhciBkSGVpZ2h0ID0gTWF0aC5taW4oKHN0WydtYXJrZXItaGVpZ2h0J10gfHwgZFdpZHRoKSAqIChpbWcud2lkdGggLyBpbWcuaGVpZ2h0KSwgY2FydG9jc3MuTUFYX1NQUklURV9SQURJVVMgKiAyKTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSBjdHgud2lkdGggPSBkV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjdHguaGVpZ2h0ID0gZEhlaWdodDtcblxuICAgICAgICBjdHguc2NhbGUoZFdpZHRoL2ltZy53aWR0aCwgZEhlaWdodC9pbWcuaGVpZ2h0KTtcblxuICAgICAgICBjYXJ0b2Nzcy5yZW5kZXJTcHJpdGUoY3R4LCBpbWcsIHN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHRoZSBleHRlcmlvciByaW5nIHRvIGNhbGN1bGF0ZSB0aGUgc2l6ZVxuICAgICAgICB2YXIgY2FudmFzU2l6ZSA9IChzdFsnbWFya2VyLWxpbmUtd2lkdGgnXSB8fCAwKSArIHBvaW50U2l6ZSoyO1xuICAgICAgICB2YXIgdyA9IGN0eC53aWR0aCA9IGNhbnZhcy53aWR0aCA9IGN0eC5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGNhbnZhc1NpemUpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHcvMiwgdy8yKTtcblxuICAgICAgICB2YXIgbXQgPSBzdFsnbWFya2VyLXR5cGUnXTtcbiAgICAgICAgaWYgKG10ICYmIG10ID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgIGNhcnRvY3NzLnJlbmRlclJlY3RhbmdsZShjdHgsIHN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJ0b2Nzcy5yZW5kZXJQb2ludChjdHgsIHN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvZi5lbmQodHJ1ZSk7XG4gICAgICBpZiAodG9ycXVlLmZsYWdzLnNwcml0ZXNfdG9faW1hZ2VzKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgaS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0sXG5cbiAgICAvL1xuICAgIC8vIHJlbmRlcnMgYWxsIHRoZSBsYXllcnMgKGFuZCBmcmFtZXMgZm9yIGVhY2ggbGF5ZXIpIGZyb20gY2FydG9jc3NcbiAgICAvL1xuICAgIHJlbmRlclRpbGU6IGZ1bmN0aW9uKHRpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLl9pY29uc1RvTG9hZCA+IDApIHtcbiAgICAgICAgICB0aGlzLm9uKCdhbGxJY29uc0xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUuYXBwbHkodGhpcywgW3RpbGUsIGtleSwgY2FsbGJhY2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZiA9IFByb2ZpbGVyLm1ldHJpYygndG9ycXVlLnJlbmRlcmVyLnBvaW50LnJlbmRlckxheWVycycpLnN0YXJ0KCk7XG4gICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fc2hhZGVyLmdldExheWVycygpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGxheWVycy5sZW5ndGg7IGkgPCBuOyArK2kgKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgICAgaWYgKGxheWVyLm5hbWUoKSAhPT0gXCJNYXBcIikge1xuICAgICAgICAgIHZhciBzcHJpdGVzID0gdGhpcy5fc3ByaXRlc1tpXSB8fCAodGhpcy5fc3ByaXRlc1tpXSA9IHt9KTtcbiAgICAgICAgICAvLyBmcmFtZXMgZm9yIGVhY2ggbGF5ZXJcbiAgICAgICAgICBmb3IodmFyIGZyID0gMDsgZnIgPCBsYXllci5mcmFtZXMoKS5sZW5ndGg7ICsrZnIpIHtcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGxheWVyLmZyYW1lcygpW2ZyXTtcbiAgICAgICAgICAgIHZhciBmcl9zcHJpdGVzID0gc3ByaXRlc1tmcmFtZV0gfHwgKHNwcml0ZXNbZnJhbWVdID0gW10pO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGlsZSh0aWxlLCBrZXkgLSBmcmFtZSwgZnJhbWUsIGZyX3Nwcml0ZXMsIGxheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcHJvZi5lbmQodHJ1ZSk7XG5cbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNhbnZhc0NsYXNzXG4gICAgICAgID8gbmV3IHRoaXMub3B0aW9ucy5jYW52YXNDbGFzcygpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmltYWdlQ2xhc3NcbiAgICAgICAgPyBuZXcgdGhpcy5vcHRpb25zLmltYWdlQ2xhc3MoKVxuICAgICAgICA6IG5ldyBJbWFnZSgpO1xuICAgIH0sXG5cbiAgICBfc2V0SW1hZ2VTcmM6IGZ1bmN0aW9uKGltZywgdXJsLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXRJbWFnZVNyYykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2V0SW1hZ2VTcmMoaW1nLCB1cmwsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgaW1hZ2UnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9xdWFsaWZ5VVJMOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnF1YWxpZnlVUkwgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnF1YWxpZnlVUkwodXJsKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAgIHJldHVybiBhLmhyZWY7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vXG4gICAgLy8gcmVuZGVycyBhIHRpbGUgaW4gdGhlIGNhbnZhcyBmb3Iga2V5IGRlZmluZWQgaW4gXG4gICAgLy8gdGhlIHRvcnF1ZSB0aWxlXG4gICAgLy9cbiAgICBfcmVuZGVyVGlsZTogZnVuY3Rpb24odGlsZSwga2V5LCBmcmFtZV9vZmZzZXQsIHNwcml0ZXMsIHNoYWRlciwgc2hhZGVyVmFycykge1xuICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHJldHVybjtcblxuICAgICAgdmFyIHByb2YgPSBQcm9maWxlci5tZXRyaWMoJ3RvcnF1ZS5yZW5kZXJlci5wb2ludC5yZW5kZXJUaWxlJykuc3RhcnQoKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICB2YXIgYmxlbmRNb2RlID0gY29tcG9wMmNhbnZhcyhzaGFkZXIuZXZhbCgnY29tcC1vcCcpKSB8fCB0aGlzLm9wdGlvbnMuYmxlbmRtb2RlO1xuICAgICAgaWYgKGJsZW5kTW9kZSkge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdW11bGF0aXZlICYmIGtleSA+IHRpbGUubWF4RGF0ZSkge1xuICAgICAgICAvL1RPRE86IHByZWNhY2hlIGJlY2F1c2UgdGhpcyB0aWxlIGlzIG5vdCBnb2luZyB0byBjaGFuZ2VcbiAgICAgICAga2V5ID0gdGlsZS5tYXhEYXRlO1xuICAgICAgfVxuICAgICAgdmFyIHRpbGVNYXggPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAqICh0aGlzLlRJTEVfU0laRS90aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAtIDEpXG4gICAgICB2YXIgYWN0aXZlUGl4ZWxzID0gdGlsZS50aW1lQ291bnRba2V5XTtcbiAgICAgIHZhciBhbmNob3IgPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbi8yO1xuICAgICAgaWYgKGFjdGl2ZVBpeGVscykge1xuICAgICAgICB2YXIgcGl4ZWxJbmRleCA9IHRpbGUudGltZUluZGV4W2tleV07XG4gICAgICAgIGZvcih2YXIgcCA9IDA7IHAgPCBhY3RpdmVQaXhlbHM7ICsrcCkge1xuICAgICAgICAgIHZhciBwb3NJZHggPSB0aWxlLnJlbmRlckRhdGFQb3NbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICAgIHZhciBjID0gdGlsZS5yZW5kZXJEYXRhW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICB2YXIgc3AgPSBzcHJpdGVzW2NdO1xuICAgICAgICAgICBpZiAoc3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgIHNwID0gc3ByaXRlc1tjXSA9IHRoaXMuZ2VuZXJhdGVTcHJpdGUoc2hhZGVyLCBjLCB0b3JxdWUuZXh0ZW5kKHsgem9vbTogdGlsZS56LCAnZnJhbWUtb2Zmc2V0JzogZnJhbWVfb2Zmc2V0IH0sIHNoYWRlclZhcnMpKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoc3ApIHtcbiAgICAgICAgICAgICB2YXIgeCA9IHRpbGUueFtwb3NJZHhdLSAoc3Aud2lkdGggPj4gMSkgKyBhbmNob3I7XG4gICAgICAgICAgICAgdmFyIHkgPSB0aWxlTWF4IC0gdGlsZS55W3Bvc0lkeF0gKyBhbmNob3I7IC8vIGZsaXAgbWVyY2F0b3JcbiAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHNwLCB4LCB5IC0gKHNwLmhlaWdodCA+PiAxKSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuXG4gICAgICBwcm9mLmVuZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbihiKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuYmxlbmRtb2RlID0gYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGFjdGl2ZSBwb2ludHMgZm9yIGEgc3RlcCBpbiBhY3RpdmUgem9vbVxuICAgICAqIHJldHVybnMgYSBsaXN0IG9mIGJvdW5kaW5nIGJveGVzIFtbc3csIG5lXSAsIFtdLCBbXV0gd2hlcmUgbmUgaXMgYSB7bGF0OiAuLiwgbG9uOiAuLi59IG9ialxuICAgICAqIGVtcHR5IGxpc3QgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIHBpeGVsc1xuICAgICAqL1xuICAgIGdldEFjdGl2ZVBvaW50c0JCb3g6IGZ1bmN0aW9uKHRpbGUsIHN0ZXApIHtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgIHZhciBtZXJjYXRvciA9IG5ldyB0b3JxdWUuTWVyY2F0b3IoKTtcblxuICAgICAgdmFyIHRpbGVNYXggPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAqICh0aGlzLlRJTEVfU0laRS90aGlzLm9wdGlvbnMucmVzb2x1dGlvbiAtIDEpO1xuICAgICAgLy90aGlzLnJlbmRlcmVyLnJlbmRlclRpbGUodGlsZSwgdGhpcy5rZXksIHBvcy54LCBwb3MueSk7XG4gICAgICB2YXIgYWN0aXZlUGl4ZWxzID0gdGlsZS50aW1lQ291bnRbc3RlcF07XG4gICAgICB2YXIgcGl4ZWxJbmRleCA9IHRpbGUudGltZUluZGV4W3N0ZXBdO1xuICAgICAgZm9yKHZhciBwID0gMDsgcCA8IGFjdGl2ZVBpeGVsczsgKytwKSB7XG4gICAgICAgIHZhciBwb3NJZHggPSB0aWxlLnJlbmRlckRhdGFQb3NbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICB2YXIgYyA9IHRpbGUucmVuZGVyRGF0YVtwaXhlbEluZGV4ICsgcF07XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICB2YXIgeCA9IHRpbGUueFtwb3NJZHhdO1xuICAgICAgICAgdmFyIHkgPSB0aWxlTWF4IC0gdGlsZS55W3Bvc0lkeF07IC8vIGZsaXAgbWVyY2F0b3JcbiAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG1lcmNhdG9yLnRpbGVQaXhlbEJCb3goXG4gICAgICAgICAgIHRpbGUuY29vcmQueCxcbiAgICAgICAgICAgdGlsZS5jb29yZC55LFxuICAgICAgICAgICB0aWxlLmNvb3JkLnosXG4gICAgICAgICAgIHgsIHlcbiAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIHRoZSB2YWx1ZXMgZm9yIHRoZSBhY3RpdmUgcGl4ZWxzXG4gICAgICogQHRpbGUgdGlsZSBvYmplY3RcbiAgICAgKiBAc3RlcCBpbnRlZ2VyIHdpdGggdGhlIHN0ZXBcbiAgICAgKiBAdmFsdWVzIChvcHRpb25hbCkgYW4gYXJyYXkgd2hlcmUgdGhlIHZhbHVlcyB3aWxsIGJlIHBsYWNlZFxuICAgICAqL1xuICAgIGdldFZhbHVlczogZnVuY3Rpb24odGlsZSwgc3RlcCwgdmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW107XG4gICAgICB2YXIgYWN0aXZlUGl4ZWxzID0gdGlsZS50aW1lQ291bnRbc3RlcF07XG4gICAgICB2YXIgcGl4ZWxJbmRleCA9IHRpbGUudGltZUluZGV4W3N0ZXBdO1xuICAgICAgZm9yKHZhciBwID0gMDsgcCA8IGFjdGl2ZVBpeGVsczsgKytwKSB7XG4gICAgICAgIHZhciBwb3NJZHggPSB0aWxlLnJlbmRlckRhdGFQb3NbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICB2YWx1ZXMucHVzaCh0aWxlLnJlbmRlckRhdGFbcGl4ZWxJbmRleCArIHBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgdmFsdWUgZm9yIHgsIHkgKHRpbGUgY29vcmRpbmF0ZXMpXG4gICAgLy8gbnVsbCBmb3Igbm8gdmFsdWVcbiAgICBnZXRWYWx1ZUZvcjogZnVuY3Rpb24odGlsZSwgc3RlcCwgcHgsIHB5KSB7XG4gICAgICB2YXIgbWVyY2F0b3IgPSBuZXcgdG9ycXVlLk1lcmNhdG9yKCk7XG4gICAgICB2YXIgcmVzID0gdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG4gICAgICB2YXIgcmVzMiA9IHJlcyA+PiAxO1xuXG4gICAgICB2YXIgdGlsZU1heCA9IHRoaXMub3B0aW9ucy5yZXNvbHV0aW9uICogKHRoaXMuVElMRV9TSVpFL3RoaXMub3B0aW9ucy5yZXNvbHV0aW9uIC0gMSk7XG4gICAgICAvL3RoaXMucmVuZGVyZXIucmVuZGVyVGlsZSh0aWxlLCB0aGlzLmtleSwgcG9zLngsIHBvcy55KTtcbiAgICAgIHZhciBhY3RpdmVQaXhlbHMgPSB0aWxlLnRpbWVDb3VudFtzdGVwXTtcbiAgICAgIHZhciBwaXhlbEluZGV4ID0gdGlsZS50aW1lSW5kZXhbc3RlcF07XG4gICAgICBmb3IodmFyIHAgPSAwOyBwIDwgYWN0aXZlUGl4ZWxzOyArK3ApIHtcbiAgICAgICAgdmFyIHBvc0lkeCA9IHRpbGUucmVuZGVyRGF0YVBvc1twaXhlbEluZGV4ICsgcF07XG4gICAgICAgIHZhciBjID0gdGlsZS5yZW5kZXJEYXRhW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgIHZhciB4ID0gdGlsZS54W3Bvc0lkeF07XG4gICAgICAgICB2YXIgeSA9IHRpbGVNYXggLSB0aWxlLnlbcG9zSWR4XTtcbiAgICAgICAgIHZhciBkeCA9IHB4ICsgcmVzMiAtIHg7XG4gICAgICAgICB2YXIgZHkgPSBweSArIHJlczIgLSB5O1xuICAgICAgICAgaWYgKGR4ID49IDAgJiYgZHggPCByZXMgJiYgZHkgPj0gMCAmJiBkeSA8IHJlcykge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgIHZhbHVlOiBjLFxuICAgICAgICAgICAgIGJib3g6IG1lcmNhdG9yLnRpbGVQaXhlbEJCb3goXG4gICAgICAgICAgICAgICB0aWxlLmNvb3JkLngsXG4gICAgICAgICAgICAgICB0aWxlLmNvb3JkLnksXG4gICAgICAgICAgICAgICB0aWxlLmNvb3JkLnosXG4gICAgICAgICAgICAgICB4IC0gcmVzMiwgeSAtIHJlczIsIHJlc1xuICAgICAgICAgICAgIClcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX3ByZWxvYWRJY29uczogZnVuY3Rpb24oaW1nX25hbWVzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChpbWdfbmFtZXMubGVuZ3RoID4gMCAmJiAhdGhpcy5fZm9yY2VQb2ludHMpIHtcblxuICAgICAgICB2YXIgcXVhbGlmaWVkSW1hZ2VVcmxTZXQgPSBPYmplY3Qua2V5cyhpbWdfbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGltZ05hbWVzTWFwLCBpbWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcXVhbGlmaWVkVXJsID0gc2VsZi5fcXVhbGlmeVVSTChpbWdOYW1lKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5faWNvbnNbcXVhbGlmaWVkVXJsXSkge1xuICAgICAgICAgICAgICAgIGltZ05hbWVzTWFwW3F1YWxpZmllZFVybF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGltZ05hbWVzTWFwO1xuICAgICAgICB9LCB7fSkpO1xuXG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHNlbGYuX3NoYWRlci5nZXRMYXllcnMoKS5zb21lKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBsYXllci5zaGFkZXJbXCJpbWFnZS1maWx0ZXJzXCJdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9pY29uc1RvTG9hZCArPSBxdWFsaWZpZWRJbWFnZVVybFNldC5sZW5ndGg7XG5cbiAgICAgICAgcXVhbGlmaWVkSW1hZ2VVcmxTZXQuZm9yRWFjaChmdW5jdGlvbihxdWFsaWZpZWRJbWFnZVVybCkge1xuICAgICAgICAgIHNlbGYuX2ljb25zW3F1YWxpZmllZEltYWdlVXJsXSA9IG51bGw7XG5cbiAgICAgICAgICB2YXIgaW1nID0gc2VsZi5fY3JlYXRlSW1hZ2UoKTtcblxuICAgICAgICAgIGlmIChmaWx0ZXJlZCkge1xuICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fc2V0SW1hZ2VTcmMoaW1nLCBxdWFsaWZpZWRJbWFnZVVybCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2ZvcmNlUG9pbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZi5jbGVhclNwcml0ZUNhY2hlKCk7XG4gICAgICAgICAgICAgIHNlbGYuX2ljb25zVG9Mb2FkID0gMDtcbiAgICAgICAgICAgICAgc2VsZi5maXJlKFwiYWxsSWNvbnNMb2FkZWRcIik7XG4gICAgICAgICAgICAgIGlmKGZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiT25seSBDT1JTLWVuYWJsZWQsIG9yIHNhbWUgZG9tYWluIGltYWdlLWZpbGVzIGNhbiBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggaW1hZ2UtZmlsdGVyc1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgZ2V0IG1hcmtlci1maWxlIFwiICsgcXVhbGlmaWVkSW1hZ2VVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5faWNvbnNbcXVhbGlmaWVkSW1hZ2VVcmxdID0gaW1nO1xuICAgICAgICAgICAgICBzZWxmLl9pY29uc1RvTG9hZC0tO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxmLl9pY29uc1RvTG9hZCA8PSAwKXtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyU3ByaXRlQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZpcmUoXCJhbGxJY29uc0xvYWRlZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5maXJlKFwiYWxsSWNvbnNMb2FkZWRcIik7XG4gICAgICB9XG4gIH0sXG5cbiAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuX3N0eWxlKXtcbiAgICAgIGlmKHRoaXMuX3N0eWxlWydpbWFnZS1maWx0ZXJzJ10pe1xuICAgICAgICBmdW5jdGlvbiBncmFkaWVudEtleShpbWYpe1xuICAgICAgICAgIHZhciBoYXNoID0gXCJcIlxuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbWYuYXJncy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgcmdiID0gaW1mLmFyZ3NbaV0ucmdiO1xuICAgICAgICAgICAgaGFzaCArPSByZ2JbMF0gKyBcIjpcIiArIHJnYlsxXSArIFwiOlwiICsgcmdiWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JhZGllbnQgPSB0aGlzLl9ncmFkaWVudHNbZ3JhZGllbnRLZXkodGhpcy5fc3R5bGVbJ2ltYWdlLWZpbHRlcnMnXSldO1xuICAgICAgICBpZighZ3JhZGllbnQpe1xuICAgICAgICAgIGZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgICAgICAgICAgIHZhciBoZXggPSBjLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByZ2JUb0hleChyLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBjb21wb25lbnRUb0hleChyKSArIGNvbXBvbmVudFRvSGV4KGcpICsgY29tcG9uZW50VG9IZXgoYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyYWRpZW50ID0ge307XG4gICAgICAgICAgdmFyIGNvbG9yaXplID0gdGhpcy5fc3R5bGVbJ2ltYWdlLWZpbHRlcnMnXS5hcmdzO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSAxL2NvbG9yaXplLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yaXplLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBrZXkgPSBpbmNyZW1lbnQgKiBpICsgaW5jcmVtZW50O1xuICAgICAgICAgICAgdmFyIHJnYiA9IGNvbG9yaXplW2ldLnJnYjtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRDb2xvciA9IHJnYlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgICAgICAgICAgZ3JhZGllbnRba2V5XSA9IGZvcm1hdHRlZENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9ncmFkaWVudHNbZ3JhZGllbnRLZXkodGhpcy5fc3R5bGVbJ2ltYWdlLWZpbHRlcnMnXSldID0gZ3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlsdGVycy5ncmFkaWVudChncmFkaWVudCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuZHJhdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cblxuICAvLyBleHBvcnRzIHB1YmxpYyBhcGlcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRSZW5kZXJlcjtcbiIsInZhciBjYXJ0byA9IGdsb2JhbC5jYXJ0byB8fCByZXF1aXJlKCdjYXJ0bycpO1xuXG4gIHZhciBERUZBVUxUX0NBUlRPQ1NTID0gW1xuICAgICcjbGF5ZXIgeycsXG4gICAgJyAgcG9seWdvbi1maWxsOiAjRkZGRjAwOycsXG4gICAgJyAgW3ZhbHVlID4gMTBdIHsgcG9seWdvbi1maWxsOiAjRkZGRjAwOyB9JyxcbiAgICAnICBbdmFsdWUgPiAxMDBdIHsgcG9seWdvbi1maWxsOiAjRkZDQzAwOyB9JyxcbiAgICAnICBbdmFsdWUgPiAxMDAwXSB7IHBvbHlnb24tZmlsbDogI0ZFOTkyOTsgfScsXG4gICAgJyAgW3ZhbHVlID4gMTAwMDBdIHsgcG9seWdvbi1maWxsOiAjRkY2NjAwOyB9JyxcbiAgICAnICBbdmFsdWUgPiAxMDAwMDBdIHsgcG9seWdvbi1maWxsOiAjRkYzMzAwOyB9JyxcbiAgICAnfSdcbiAgXS5qb2luKCdcXG4nKTtcblxuICB2YXIgVEFVID0gTWF0aC5QSSAqIDI7XG5cbiAgLy9cbiAgLy8gdGhpcyByZW5kZXJlciBqdXN0IHJlbmRlciBwb2ludHMgZGVwZW5kaW5nIG9mIHRoZSB2YWx1ZVxuICAvLyBcbiAgZnVuY3Rpb24gUmVjdGFuYmxlUmVuZGVyZXIoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBjYXJ0by50cmVlLlJlZmVyZW5jZS5zZXQodG9ycXVlWyd0b3JxdWUtcmVmZXJlbmNlJ10pO1xuICAgIHRoaXMuc2V0Q2FudmFzKGNhbnZhcyk7XG4gICAgdGhpcy5zZXRDYXJ0b0NTUyh0aGlzLm9wdGlvbnMuY2FydG9jc3MgfHwgREVGQVVMVF9DQVJUT0NTUyk7XG4gIH1cblxuICBSZWN0YW5ibGVSZW5kZXJlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvL1xuICAgIC8vIHNldHMgdGhlIGNhcnRvY3NzIHN0eWxlIHRvIHJlbmRlciBzdHVmZlxuICAgIC8vXG4gICAgc2V0Q2FydG9DU1M6IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gICAgICB0aGlzLl9jYXJ0b0Nzc1N0eWxlID0gbmV3IGNhcnRvLlJlbmRlcmVySlMoKS5yZW5kZXIoY2FydG9jc3MpO1xuICAgICAgaWYodGhpcy5fY2FydG9Dc3NTdHlsZS5nZXRMYXllcnMoKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIENhcnRvQ1NTIGxheWVyIGlzIHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NoYWRlciA9IHRoaXMuX2NhcnRvQ3NzU3R5bGUuZ2V0TGF5ZXJzKClbMF0uc2hhZGVyO1xuICAgIH0sXG5cbiAgICBzZXRDYW52YXM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgaWYoIWNhbnZhcykgcmV0dXJuO1xuICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIGFjY3VtdWxhdGU6IGZ1bmN0aW9uKHRpbGUsIGtleXMpIHtcbiAgICAgIHZhciBwcm9mID0gUHJvZmlsZXIubWV0cmljKCdSZWN0YW5nbGVSZW5kZXI6YWNjdW11bGF0ZScpLnN0YXJ0KCk7XG4gICAgICB2YXIgeCwgeSwgcG9zSWR4LCBwLCBrLCBrZXksIGFjdGl2ZVBpeGVscywgcGl4ZWxJbmRleDtcbiAgICAgIHZhciByZXMgPSB0aGlzLm9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgIHZhciBzID0gMjU2L3JlcztcbiAgICAgIHZhciBhY2N1bSA9IG5ldyBGbG9hdDMyQXJyYXkocypzKTtcblxuICAgICAgaWYodHlwZW9mKGtleXMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBrZXlzID0gW2tleXNdO1xuICAgICAgfVxuXG4gICAgICBmb3IoayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGtleSA9IGtleXNba107XG4gICAgICAgIGFjdGl2ZVBpeGVscyA9IHRpbGUudGltZUNvdW50W2tleV07XG4gICAgICAgIGlmKGFjdGl2ZVBpeGVscykge1xuICAgICAgICAgIHBpeGVsSW5kZXggPSB0aWxlLnRpbWVJbmRleFtrZXldO1xuICAgICAgICAgIGZvcihwID0gMDsgcCA8IGFjdGl2ZVBpeGVsczsgKytwKSB7XG4gICAgICAgICAgICBwb3NJZHggPSB0aWxlLnJlbmRlckRhdGFQb3NbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICAgICAgeCA9IHRpbGUueFtwb3NJZHhdL3JlcztcbiAgICAgICAgICAgIHkgPSB0aWxlLnlbcG9zSWR4XS9yZXM7XG4gICAgICAgICAgICBhY2N1bVt4KnMgKyB5XSArPSB0aWxlLnJlbmRlckRhdGFbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9mLmVuZCgpO1xuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaWxlQWNjdW06IGZ1bmN0aW9uKGFjY3VtLCBweCwgcHkpIHtcbiAgICAgIHZhciBwcm9mID0gUHJvZmlsZXIubWV0cmljKCdSZWN0YW5nbGVSZW5kZXI6cmVuZGVyVGlsZUFjY3VtJykuc3RhcnQoKTtcbiAgICAgIHZhciBjb2xvciwgeCwgeSwgYWxwaGE7XG4gICAgICB2YXIgcmVzID0gdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgdmFyIHMgPSAoMjU2L3JlcykgfCAwO1xuICAgICAgdmFyIHMyID0gcypzO1xuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuX2NvbG9ycztcbiAgICAgIGlmKHRoaXMub3B0aW9ucy5ibGVuZG1vZGUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMub3B0aW9ucy5ibGVuZG1vZGU7XG4gICAgICB9XG4gICAgICB2YXIgcG9seWdvbl9hbHBoYSA9IHRoaXMuX3NoYWRlclsncG9seWdvbi1vcGFjaXR5J10gfHwgZnVuY3Rpb24oKSB7IHJldHVybiAxLjA7IH07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgczI7ICsraSkge1xuICAgICAgICB2YXIgeHkgPSBpO1xuICAgICAgICB2YXIgdmFsdWUgPSBhY2N1bVtpXTtcbiAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICB4ID0gKHh5L3MpIHwgMDtcbiAgICAgICAgICB5ID0geHkgJSBzO1xuICAgICAgICAgIC8vIGJ5LXBhc3MgdGhlIHN0eWxlIGdlbmVyYXRpb24gZm9yIGltcHJvdmluZyBwZXJmb3JtYW5jZVxuICAgICAgICAgIGNvbG9yID0gdGhpcy5fc2hhZGVyWydwb2x5Z29uLWZpbGwnXSh7IHZhbHVlOiB2YWx1ZSB9LCB7IHpvb206IDAgfSk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgIC8vVE9ETzogZWFjaCBmdW5jdGlvbiBzaG91bGQgaGF2ZSBhIGRlZmF1bHQgdmFsdWUgZm9yIGVhY2ggXG4gICAgICAgICAgLy9wcm9wZXJ0eSBkZWZpbmVkIGluIHRoZSBjYXJ0b2Nzc1xuICAgICAgICAgIGFscGhhID0gcG9seWdvbl9hbHBoYSh7IHZhbHVlOiB2YWx1ZSB9LCB7IHpvb206IDAgfSk7XG4gICAgICAgICAgaWYoYWxwaGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoeCAqIHJlcywgMjU2IC0gcmVzIC0geSAqIHJlcywgcmVzLCByZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9mLmVuZCgpO1xuICAgIH0sXG5cbiAgICAvL1xuICAgIC8vIHJlbmRlcnMgYSB0aWxlIGluIHRoZSBjYW52YXMgZm9yIGtleSBkZWZpbmVkIGluIFxuICAgIC8vIHRoZSB0b3JxdWUgdGlsZVxuICAgIC8vXG4gICAgcmVuZGVyVGlsZTogZnVuY3Rpb24odGlsZSwga2V5LCBjYWxsYmFjaykge1xuICAgICAgaWYoIXRoaXMuX2NhbnZhcykgcmV0dXJuO1xuXG4gICAgICB2YXIgcmVzID0gdGhpcy5vcHRpb25zLnJlc29sdXRpb247XG5cbiAgICAgIC8vdmFyIHByb2YgPSBQcm9maWxlci5nZXQoJ3JlbmRlcicpLnN0YXJ0KCk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuX2NvbG9ycztcbiAgICAgIHZhciBhY3RpdmVwaXhlbHMgPSB0aWxlLnRpbWVDb3VudFtrZXldO1xuICAgICAgaWYoYWN0aXZlcGl4ZWxzKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy5fY2FudmFzLndpZHRoO1xuICAgICAgICB2YXIgaCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQ7XG4gICAgICAgIC8vdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG4gICAgICAgIC8vdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICB2YXIgcGl4ZWxJbmRleCA9IHRpbGUudGltZUluZGV4W2tleV07XG4gICAgICAgIGZvcih2YXIgcCA9IDA7IHAgPCBhY3RpdmVQaXhlbHM7ICsrcCkge1xuICAgICAgICAgIHZhciBwb3NJZHggPSB0aWxlLnJlbmRlckRhdGFQb3NbcGl4ZWxJbmRleCArIHBdO1xuICAgICAgICAgIHZhciBjID0gdGlsZS5yZW5kZXJEYXRhW3BpeGVsSW5kZXggKyBwXTtcbiAgICAgICAgICBpZihjKSB7XG4gICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yc1tNYXRoLm1pbihjLCBjb2xvcnMubGVuZ3RoIC0gMSldO1xuICAgICAgICAgICB2YXIgeCA9IHRpbGUueFtwb3NJZHhdOy8vICsgcHg7XG4gICAgICAgICAgIHZhciB5ID0gdGlsZS55W3Bvc0lkeF07IC8vKyBweTtcblxuICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCByZXMsIHJlcyk7XG4gICAgICAgICAgIC8qXG5cbiAgICAgICAgICAgZm9yKHZhciB4eCA9IDA7IHh4IDwgcmVzOyArK3h4KSB7XG4gICAgICAgICAgICBmb3IodmFyIHl5ID0gMDsgeXkgPCByZXM7ICsreXkpIHtcbiAgICAgICAgICAgICAgdmFyIGlkeCA9IDQqKCh4K3h4KSArIHcqKHkgKyB5eSkpO1xuICAgICAgICAgICAgICBwaXhlbHNbaWR4ICsgMF0gPSBjb2xvclswXTtcbiAgICAgICAgICAgICAgcGl4ZWxzW2lkeCArIDFdID0gY29sb3JbMV07XG4gICAgICAgICAgICAgIHBpeGVsc1tpZHggKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgICAgICAgICBwaXhlbHNbaWR4ICsgM10gPSBjb2xvclszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL2N0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIH1cbiAgICAgIC8vcHJvZi5lbmQoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH07XG5cblxuICAvLyBleHBvcnRzIHB1YmxpYyBhcGlcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuYmxlUmVuZGVyZXI7XG4iLCIvKlxuIEJhc2VkIG9uIHNpbXBsZWhlYXQsIGEgdGlueSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGRyYXdpbmcgaGVhdG1hcHMgd2l0aCBDYW52YXMsIFxuIGJ5IFZsYWRpbWlyIEFnYWZvbmtpblxuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3NpbXBsZWhlYXRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdG9ycXVlX2ZpbHRlcnMoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgLy8ganNoaW50IG5ld2NhcDogZmFsc2UsIHZhbGlkdGhpczogdHJ1ZVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0b3JxdWVfZmlsdGVycykpIHsgcmV0dXJuIG5ldyB0b3JxdWVfZmlsdGVycyhjYW52YXMsIG9wdGlvbnMpOyB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcyA9IHR5cGVvZiBjYW52YXMgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKSA6IGNhbnZhcztcblxuICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuX3dpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICB0aGlzLl9tYXggPSAxO1xuICAgIHRoaXMuX2RhdGEgPSBbXTtcblxuICAgIHRoaXMuY2FudmFzQ2xhc3MgPSBvcHRpb25zLmNhbnZhc0NsYXNzO1xufVxuXG50b3JxdWVfZmlsdGVycy5wcm90b3R5cGUgPSB7XG5cbiAgICBkZWZhdWx0R3JhZGllbnQ6IHtcbiAgICAgICAgMC40OiAnYmx1ZScsXG4gICAgICAgIDAuNjogJ2N5YW4nLFxuICAgICAgICAwLjc6ICdsaW1lJyxcbiAgICAgICAgMC44OiAneWVsbG93JyxcbiAgICAgICAgMS4wOiAncmVkJ1xuICAgIH0sXG5cbiAgICBncmFkaWVudDogZnVuY3Rpb24gKGdyYWQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgMjU2eDEgZ3JhZGllbnQgdGhhdCB3ZSdsbCB1c2UgdG8gdHVybiBhIGdyYXlzY2FsZSBoZWF0bWFwIGludG8gYSBjb2xvcmVkIG9uZVxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKCksXG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIDI1Nik7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBmb3IgKHZhciBpIGluIGdyYWQpIHtcbiAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgraSwgZ3JhZFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2dyYWQgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDI1NikuZGF0YTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2dyYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnQodGhpcy5kZWZhdWx0R3JhZGllbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgdmFyIGNvbG9yZWQgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2NvbG9yaXplKGNvbG9yZWQuZGF0YSwgdGhpcy5fZ3JhZCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoY29sb3JlZCwgMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9jb2xvcml6ZTogZnVuY3Rpb24gKHBpeGVscywgZ3JhZGllbnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDMsIGxlbiA9IHBpeGVscy5sZW5ndGgsIGo7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICAgICAgaiA9IHBpeGVsc1tpXSAqIDQ7IC8vIGdldCBncmFkaWVudCBjb2xvciBmcm9tIG9wYWNpdHkgdmFsdWVcblxuICAgICAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbaSAtIDNdID0gZ3JhZGllbnRbal07XG4gICAgICAgICAgICAgICAgcGl4ZWxzW2kgLSAyXSA9IGdyYWRpZW50W2ogKyAxXTtcbiAgICAgICAgICAgICAgICBwaXhlbHNbaSAtIDFdID0gZ3JhZGllbnRbaiArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jcmVhdGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNDbGFzc1xuICAgICAgICAgICAgPyBuZXcgdGhpcy5jYW52YXNDbGFzcygpXG4gICAgICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdG9ycXVlX2ZpbHRlcnM7XG4iLCJ2YXIgdG9ycXVlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbiAgdmFyIGxhc3RDYWxsID0gbnVsbDtcblxuICBmdW5jdGlvbiBqc29ucCh1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICBvcHRpb25zLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IDEwMDAwOiBvcHRpb25zLnRpbWVvdXQ7XG4gICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgIC8vIGZ1bmN0aW9uIG5hbWVcbiAgICAgdmFyIGZuTmFtZSA9IG9wdGlvbnMuY2FsbGJhY2tOYW1lIHx8ICd0b3JxdWVfJyArIERhdGUubm93KCk7XG5cbiAgICAgaWYgKHRvcnF1ZS5pc0Z1bmN0aW9uKGZuTmFtZSkpIHtcbiAgICAgICBmbk5hbWUgPSBmbk5hbWUoKTtcbiAgICAgfVxuXG4gICAgIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcbiAgICAgICBkZWxldGUgd2luZG93W2ZuTmFtZV07XG4gICAgIH1cblxuICAgICB3aW5kb3dbZm5OYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgIGNsZWFuKCk7XG4gICAgICAgY2FsbGJhY2suYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xuICAgICB9O1xuXG4gICAgIC8vIHRpbWVvdXQgZm9yIGVycm9yc1xuICAgICB2YXIgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgXG4gICAgICAgY2xlYW4oKTtcbiAgICAgICBjYWxsYmFjay5jYWxsKHdpbmRvdywgbnVsbCk7IFxuICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuXG4gICAgIC8vIHNldHVwIHVybFxuICAgICB1cmwgPSB1cmwucmVwbGFjZSgnY2FsbGJhY2s9XFw/JywgJ2NhbGxiYWNrPScgKyBmbk5hbWUpO1xuICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAvLyBkZWZlciB0aGUgbG9hZGluZyBiZWNhdXNlIElFOSBsb2FkcyBpbiB0aGUgc2FtZSBmcmFtZSB0aGUgc2NyaXB0XG4gICAgIC8vIHNvIExvYWRlci5fc2NyaXB0IGlzIG51bGxcbiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpOyB9LCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCh1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0J1xuICAgIH07XG4gICAgbGFzdENhbGwgPSB7IHVybDogdXJsLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICB2YXIgcmVxdWVzdCA9IFhNTEh0dHBSZXF1ZXN0O1xuICAgIC8vIGZyb20gZDMuanNcbiAgICBpZiAoZ2xvYmFsLlhEb21haW5SZXF1ZXN0XG4gICAgICAgICYmICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0KVxuICAgICAgICAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gWERvbWFpblJlcXVlc3Q7XG5cbiAgICB2YXIgcmVxID0gbmV3IHJlcXVlc3QoKTtcbiAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuXG4gICAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICAgIHZhciBzdGF0dXMgPSByZXEuc3RhdHVzLCByZXN1bHQ7XG4gICAgICB2YXIgciA9IG9wdGlvbnMucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInID8gcmVxLnJlc3BvbnNlOiByZXEucmVzcG9uc2VUZXh0O1xuICAgICAgaWYgKCFzdGF0dXMgJiYgciB8fCBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICBjYWxsYmFjayhyZXEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgXCJvbmxvYWRcIiBpbiByZXFcbiAgICAgID8gcmVxLm9ubG9hZCA9IHJlcS5vbmVycm9yID0gcmVzcG9uZFxuICAgICAgOiByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7IHJlcS5yZWFkeVN0YXRlID4gMyAmJiByZXNwb25kKCk7IH07XG5cbiAgICByZXEub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XG5cbiAgICByZXEucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7IC8vJ2FycmF5YnVmZmVyJztcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAvL3JlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpXG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcIipcIik7XG4gICAgfVxuICAgIHJlcS5zZW5kKG9wdGlvbnMuZGF0YSk7XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3QodXJsLCBkYXRhLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBnZXQodXJsLCBjYWxsYmFjaywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgICB9KTtcbiAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXQ6IGdldCxcbiAgICBwb3N0OiBwb3N0LFxuICAgIGpzb25wOiBqc29ucCxcbiAgICBsYXN0Q2FsbDogZnVuY3Rpb24oKSB7IHJldHVybiBsYXN0Q2FsbDsgfVxufTtcbiIsIihmdW5jdGlvbiAodHJlZSkge1xuXG50cmVlLmZ1bmN0aW9ucyA9IHtcbiAgICByZ2I6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJnYmEociwgZywgYiwgMS4wKTtcbiAgICB9LFxuICAgIHJnYmE6IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XG4gICAgICAgIHZhciByZ2IgPSBbciwgZywgYl0ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBudW1iZXIoYyk7IH0pO1xuICAgICAgICBhID0gbnVtYmVyKGEpO1xuICAgICAgICBpZiAocmdiLnNvbWUoaXNOYU4pIHx8IGlzTmFOKGEpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbG9yKHJnYiwgYSk7XG4gICAgfSxcbiAgICAvLyBPbmx5IHJlcXVpcmUgdmFsXG4gICAgc3RvcDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgY29sb3IsIG1vZGU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgY29sb3IgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgbW9kZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXM6ICd0YWcnLFxuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXFxuXFx0PHN0b3AgdmFsdWU9XCInICsgdmFsLmV2KGVudikgKyAnXCInICtcbiAgICAgICAgICAgICAgICAgICAgKGNvbG9yID8gJyBjb2xvcj1cIicgKyBjb2xvci5ldihlbnYpICsgJ1wiICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAobW9kZSA/ICcgbW9kZT1cIicgKyBtb2RlLmV2KGVudikgKyAnXCIgJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICcvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBoc2w6IGZ1bmN0aW9uIChoLCBzLCBsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhzbGEoaCwgcywgbCwgMS4wKTtcbiAgICB9LFxuICAgIGhzbGE6IGZ1bmN0aW9uIChoLCBzLCBsLCBhKSB7XG4gICAgICAgIGggPSAobnVtYmVyKGgpICUgMzYwKSAvIDM2MDtcbiAgICAgICAgcyA9IG51bWJlcihzKTsgbCA9IG51bWJlcihsKTsgYSA9IG51bWJlcihhKTtcbiAgICAgICAgaWYgKFtoLCBzLCBsLCBhXS5zb21lKGlzTmFOKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgICBtMSA9IGwgKiAyIC0gbTI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmdiYShodWUoaCArIDEvMykgKiAyNTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaHVlKGgpICAgICAgICogMjU1LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGh1ZShoIC0gMS8zKSAqIDI1NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhKTtcblxuICAgICAgICBmdW5jdGlvbiBodWUoaCkge1xuICAgICAgICAgICAgaCA9IGggPCAwID8gaCArIDEgOiAoaCA+IDEgPyBoIC0gMSA6IGgpO1xuICAgICAgICAgICAgaWYgICAgICAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICAgICAgICAgICAgZWxzZSBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICByZXR1cm4gbTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRpbWVuc2lvbihNYXRoLnJvdW5kKGNvbG9yLnRvSFNMKCkuaCkpO1xuICAgIH0sXG4gICAgc2F0dXJhdGlvbjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRpbWVuc2lvbihNYXRoLnJvdW5kKGNvbG9yLnRvSFNMKCkucyAqIDEwMCksICclJyk7XG4gICAgfSxcbiAgICBsaWdodG5lc3M6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24oTWF0aC5yb3VuZChjb2xvci50b0hTTCgpLmwgKiAxMDApLCAnJScpO1xuICAgIH0sXG4gICAgYWxwaGE6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24oY29sb3IudG9IU0woKS5hKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5zICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLnMgPSBjbGFtcChoc2wucyk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBkZXNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5zIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLnMgPSBjbGFtcChoc2wucyk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBsaWdodGVuOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBpZiAoISgndG9IU0wnIGluIGNvbG9yKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoc2wgPSBjb2xvci50b0hTTCgpO1xuXG4gICAgICAgIGhzbC5sICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcbiAgICAgICAgaHNsLmwgPSBjbGFtcChoc2wubCk7XG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIGlmICghKCd0b0hTTCcgaW4gY29sb3IpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGhzbCA9IGNvbG9yLnRvSFNMKCk7XG5cbiAgICAgICAgaHNsLmwgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xuICAgICAgICBoc2wubCA9IGNsYW1wKGhzbC5sKTtcbiAgICAgICAgcmV0dXJuIGhzbGEoaHNsKTtcbiAgICB9LFxuICAgIGZhZGVpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wuYSArPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgZmFkZW91dDogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcblxuICAgICAgICBoc2wuYSAtPSBhbW91bnQudmFsdWUgLyAxMDA7XG4gICAgICAgIGhzbC5hID0gY2xhbXAoaHNsLmEpO1xuICAgICAgICByZXR1cm4gaHNsYShoc2wpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgaWYgKCEoJ3RvSFNMJyBpbiBjb2xvcikpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaHNsID0gY29sb3IudG9IU0woKTtcbiAgICAgICAgdmFyIGh1ZSA9IChoc2wuaCArIGFtb3VudC52YWx1ZSkgJSAzNjA7XG5cbiAgICAgICAgaHNsLmggPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXG4gICAgICAgIHJldHVybiBoc2xhKGhzbCk7XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoZW50aXR5LCBhLCBiKSB7XG4gICAgICAgIGlmIChlbnRpdHkuaXMgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHkudG9TdHJpbmcgKyAnLnJlcGxhY2UoJyArIGEudG9TdHJpbmcoKSArICcsICcgKyBiLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5LnJlcGxhY2UoYSwgYik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vXG4gICAgLy8gQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgSGFtcHRvbiBDYXRsaW4sIE5hdGhhbiBXZWl6ZW5iYXVtLCBhbmQgQ2hyaXMgRXBwc3RlaW5cbiAgICAvLyBodHRwOi8vc2Fzcy1sYW5nLmNvbVxuICAgIC8vXG4gICAgbWl4OiBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIHdlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHdlaWdodC52YWx1ZSAvIDEwMC4wO1xuICAgICAgICB2YXIgdyA9IHAgKiAyIC0gMTtcbiAgICAgICAgdmFyIGEgPSBjb2xvcjEudG9IU0woKS5hIC0gY29sb3IyLnRvSFNMKCkuYTtcblxuICAgICAgICB2YXIgdzEgPSAoKCh3ICogYSA9PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgICB2YXIgdzIgPSAxIC0gdzE7XG5cbiAgICAgICAgdmFyIHJnYiA9IFtjb2xvcjEucmdiWzBdICogdzEgKyBjb2xvcjIucmdiWzBdICogdzIsXG4gICAgICAgICAgICAgICAgICAgY29sb3IxLnJnYlsxXSAqIHcxICsgY29sb3IyLnJnYlsxXSAqIHcyLFxuICAgICAgICAgICAgICAgICAgIGNvbG9yMS5yZ2JbMl0gKiB3MSArIGNvbG9yMi5yZ2JbMl0gKiB3Ml07XG5cbiAgICAgICAgdmFyIGFscGhhID0gY29sb3IxLmFscGhhICogcCArIGNvbG9yMi5hbHBoYSAqICgxIC0gcCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbG9yKHJnYiwgYWxwaGEpO1xuICAgIH0sXG4gICAgZ3JleXNjYWxlOiBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzYXR1cmF0ZShjb2xvciwgbmV3IHRyZWUuRGltZW5zaW9uKDEwMCkpO1xuICAgIH0sXG4gICAgJyUnOiBmdW5jdGlvbiAocXVvdGVkIC8qIGFyZywgYXJnLCAuLi4qLykge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBzdHIgPSBxdW90ZWQudmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvJXMvLCAgICBhcmdzW2ldLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyVbZGFdLywgYXJnc1tpXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvJSUvZywgJyUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlF1b3RlZChzdHIpO1xuICAgIH1cbn07XG5cbnZhciBpbWFnZV9maWx0ZXJfZnVuY3RvcnMgPSBbXG4gICAgJ2VtYm9zcycsICdibHVyJywgJ2dyYXknLCAnc29iZWwnLCAnZWRnZS1kZXRlY3QnLFxuICAgICd4LWdyYWRpZW50JywgJ3ktZ3JhZGllbnQnLCAnc2hhcnBlbiddO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IGltYWdlX2ZpbHRlcl9mdW5jdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmID0gaW1hZ2VfZmlsdGVyX2Z1bmN0b3JzW2ldO1xuICAgIHRyZWUuZnVuY3Rpb25zW2ZdID0gKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkltYWdlRmlsdGVyKGYpO1xuICAgICAgICB9O1xuICAgIH0pKGYpO1xufVxuXG50cmVlLmZ1bmN0aW9uc1snYWdnLXN0YWNrLWJsdXInXSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IHRyZWUuSW1hZ2VGaWx0ZXIoJ2FnZy1zdGFjay1ibHVyJywgW3gsIHldKTtcbn07XG5cbnRyZWUuZnVuY3Rpb25zWydzY2FsZS1oc2xhJ10gPSBmdW5jdGlvbihoMCxoMSxzMCxzMSxsMCxsMSxhMCxhMSkge1xuICAgIHJldHVybiBuZXcgdHJlZS5JbWFnZUZpbHRlcignc2NhbGUtaHNsYScsIFtoMCxoMSxzMCxzMSxsMCxsMSxhMCxhMV0pO1xufTtcblxuZnVuY3Rpb24gaHNsYShoKSB7XG4gICAgcmV0dXJuIHRyZWUuZnVuY3Rpb25zLmhzbGEoaC5oLCBoLnMsIGgubCwgaC5hKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIHRyZWUuRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4udW5pdCA9PSAnJScgPyBuLnZhbHVlIC8gMTAwIDogbi52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YobikgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGFtcCh2YWwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsKSk7XG59XG5cbn0pKHJlcXVpcmUoJy4vdHJlZScpKTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJylbMV0sIDEwKSA+IDQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGRlciBub2RlXG4gICAgICAgIHZhciBwYWNrYWdlX2pzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oX19kaXJuYW1lLCcuLi8uLi9wYWNrYWdlLmpzb24nKSkpO1xuICAgICAgICByZXR1cm4gcGFja2FnZV9qc29uLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICB9XG59XG5cbnZhciBjYXJ0byA9IHtcbiAgICB2ZXJzaW9uOiBnZXRWZXJzaW9uKCksXG4gICAgUGFyc2VyOiByZXF1aXJlKCcuL3BhcnNlcicpLlBhcnNlcixcbiAgICBSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcicpLlJlbmRlcmVyLFxuICAgIHRyZWU6IHJlcXVpcmUoJy4vdHJlZScpLFxuICAgIFJlbmRlcmVySlM6IHJlcXVpcmUoJy4vcmVuZGVyZXJfanMnKSxcbiAgICBkZWZhdWx0X3JlZmVyZW5jZTogcmVxdWlyZSgnLi90b3JxdWUtcmVmZXJlbmNlJyksXG5cbiAgICAvLyBAVE9ET1xuICAgIHdyaXRlRXJyb3I6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICB2YXIgZXh0cmFjdCA9IGN0eC5leHRyYWN0O1xuICAgICAgICB2YXIgZXJyb3IgPSBbXTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgb3B0aW9ucy5pbmRlbnQgPSBvcHRpb25zLmluZGVudCB8fCAnJztcblxuICAgICAgICBpZiAoISgnaW5kZXgnIGluIGN0eCkgfHwgIWV4dHJhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsLmVycm9yKG9wdGlvbnMuaW5kZW50ICsgKGN0eC5zdGFjayB8fCBjdHgubWVzc2FnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihleHRyYWN0WzBdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yLnB1c2goc3R5bGl6ZSgoY3R4LmxpbmUgLSAxKSArICcgJyArIGV4dHJhY3RbMF0sICdncmV5JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhY3RbMV0gPT09ICcnICYmIHR5cGVvZiBleHRyYWN0WzJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmFjdFsxXSA9ICfCtic7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IucHVzaChjdHgubGluZSArICcgJyArIGV4dHJhY3RbMV0uc2xpY2UoMCwgY3R4LmNvbHVtbikgK1xuICAgICAgICAgICAgc3R5bGl6ZShzdHlsaXplKGV4dHJhY3RbMV1bY3R4LmNvbHVtbl0sICdib2xkJykgK1xuICAgICAgICAgICAgZXh0cmFjdFsxXS5zbGljZShjdHguY29sdW1uICsgMSksICd5ZWxsb3cnKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZihleHRyYWN0WzJdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yLnB1c2goc3R5bGl6ZSgoY3R4LmxpbmUgKyAxKSArICcgJyArIGV4dHJhY3RbMl0sICdncmV5JykpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gb3B0aW9ucy5pbmRlbnQgKyBlcnJvci5qb2luKCdcXG4nICsgb3B0aW9ucy5pbmRlbnQpICsgJ1xcMDMzWzBtXFxuJztcblxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5pbmRlbnQgKyBtZXNzYWdlICsgc3R5bGl6ZShjdHgubWVzc2FnZSwgJ3JlZCcpO1xuICAgICAgICBpZiAoY3R4LmZpbGVuYW1lKSAobWVzc2FnZSArPSBzdHlsaXplKCcgaW4gJywgJ3JlZCcpICsgY3R4LmZpbGVuYW1lKTtcblxuICAgICAgICB1dGlsLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcblxuICAgICAgICBpZiAoY3R4LmNhbGxMaW5lKSB7XG4gICAgICAgICAgICB1dGlsLmVycm9yKHN0eWxpemUoJ2Zyb20gJywgJ3JlZCcpICsgKGN0eC5maWxlbmFtZSB8fCAnJykpO1xuICAgICAgICAgICAgdXRpbC5lcnJvcihzdHlsaXplKGN0eC5jYWxsTGluZSwgJ2dyZXknKSArICcgJyArIGN0eC5jYWxsRXh0cmFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5zdGFjaykgeyB1dGlsLmVycm9yKHN0eWxpemUoY3R4LnN0YWNrLCAncmVkJykpOyB9XG4gICAgfVxufTtcblxucmVxdWlyZSgnLi90cmVlL2NhbGwnKTtcbnJlcXVpcmUoJy4vdHJlZS9jb2xvcicpO1xucmVxdWlyZSgnLi90cmVlL2NvbW1lbnQnKTtcbnJlcXVpcmUoJy4vdHJlZS9kZWZpbml0aW9uJyk7XG5yZXF1aXJlKCcuL3RyZWUvZGltZW5zaW9uJyk7XG5yZXF1aXJlKCcuL3RyZWUvZWxlbWVudCcpO1xucmVxdWlyZSgnLi90cmVlL2V4cHJlc3Npb24nKTtcbnJlcXVpcmUoJy4vdHJlZS9maWx0ZXJzZXQnKTtcbnJlcXVpcmUoJy4vdHJlZS9maWx0ZXInKTtcbnJlcXVpcmUoJy4vdHJlZS9maWVsZCcpO1xucmVxdWlyZSgnLi90cmVlL2tleXdvcmQnKTtcbnJlcXVpcmUoJy4vdHJlZS9sYXllcicpO1xucmVxdWlyZSgnLi90cmVlL2xpdGVyYWwnKTtcbnJlcXVpcmUoJy4vdHJlZS9vcGVyYXRpb24nKTtcbnJlcXVpcmUoJy4vdHJlZS9xdW90ZWQnKTtcbnJlcXVpcmUoJy4vdHJlZS9pbWFnZWZpbHRlcicpO1xucmVxdWlyZSgnLi90cmVlL3JlZmVyZW5jZScpO1xucmVxdWlyZSgnLi90cmVlL3J1bGUnKTtcbnJlcXVpcmUoJy4vdHJlZS9ydWxlc2V0Jyk7XG5yZXF1aXJlKCcuL3RyZWUvc2VsZWN0b3InKTtcbnJlcXVpcmUoJy4vdHJlZS9zdHlsZScpO1xucmVxdWlyZSgnLi90cmVlL3VybCcpO1xucmVxdWlyZSgnLi90cmVlL3ZhbHVlJyk7XG5yZXF1aXJlKCcuL3RyZWUvdmFyaWFibGUnKTtcbnJlcXVpcmUoJy4vdHJlZS96b29tJyk7XG5yZXF1aXJlKCcuL3RyZWUvaW52YWxpZCcpO1xucmVxdWlyZSgnLi90cmVlL2ZvbnRzZXQnKTtcbnJlcXVpcmUoJy4vdHJlZS9mcmFtZV9vZmZzZXQnKTtcbnJlcXVpcmUoJy4vZnVuY3Rpb25zJyk7XG5cbmZvciAodmFyIGsgaW4gY2FydG8pIHsgZXhwb3J0c1trXSA9IGNhcnRvW2tdOyB9XG5cbi8vIFN0eWxpemUgYSBzdHJpbmdcbmZ1bmN0aW9uIHN0eWxpemUoc3RyLCBzdHlsZSkge1xuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSxcbiAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAncmVkJyA6IFszMSwgMzldLFxuICAgICAgICAnZ3JleScgOiBbOTAsIDM5XVxuICAgIH07XG4gICAgcmV0dXJuICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbn1cbiIsInZhciBjYXJ0byA9IGV4cG9ydHMsXG4gICAgdHJlZSA9IHJlcXVpcmUoJy4vdHJlZScpLFxuICAgIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vICAgIFRva2VuIG1hdGNoaW5nIGlzIGRvbmUgd2l0aCB0aGUgYCRgIGZ1bmN0aW9uLCB3aGljaCBlaXRoZXIgdGFrZXNcbi8vICAgIGEgdGVybWluYWwgc3RyaW5nIG9yIHJlZ2V4cCwgb3IgYSBub24tdGVybWluYWwgZnVuY3Rpb24gdG8gY2FsbC5cbi8vICAgIEl0IGFsc28gdGFrZXMgY2FyZSBvZiBtb3ZpbmcgYWxsIHRoZSBpbmRpY2VzIGZvcndhcmRzLlxuY2FydG8uUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKGVudikge1xuICAgIHZhciBpbnB1dCwgICAgICAgLy8gTGVTUyBpbnB1dCBzdHJpbmdcbiAgICAgICAgaSwgICAgICAgICAgIC8vIGN1cnJlbnQgaW5kZXggaW4gYGlucHV0YFxuICAgICAgICBqLCAgICAgICAgICAgLy8gY3VycmVudCBjaHVua1xuICAgICAgICB0ZW1wLCAgICAgICAgLy8gdGVtcG9yYXJpbHkgaG9sZHMgYSBjaHVuaydzIHN0YXRlLCBmb3IgYmFja3RyYWNraW5nXG4gICAgICAgIG1lbW8sICAgICAgICAvLyB0ZW1wb3JhcmlseSBob2xkcyBgaWAsIHdoZW4gYmFja3RyYWNraW5nXG4gICAgICAgIGZ1cnRoZXN0LCAgICAvLyBmdXJ0aGVzdCBpbmRleCB0aGUgcGFyc2VyIGhhcyBnb25lIHRvXG4gICAgICAgIGNodW5rcywgICAgICAvLyBjaHVua2lmaWVkIGlucHV0XG4gICAgICAgIGN1cnJlbnQsICAgICAvLyBpbmRleCBvZiBjdXJyZW50IGNodW5rLCBpbiBgaW5wdXRgXG4gICAgICAgIHBhcnNlcjtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGFsbCBmaWxlc1xuICAgIC8vIGhhdmUgYmVlbiBpbXBvcnRlZCB0aHJvdWdoIGBAaW1wb3J0YC5cbiAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIGZ1bmN0aW9uIHNhdmUoKSAgICB7XG4gICAgICAgIHRlbXAgPSBjaHVua3Nbal07XG4gICAgICAgIG1lbW8gPSBpO1xuICAgICAgICBjdXJyZW50ID0gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgY2h1bmtzW2pdID0gdGVtcDtcbiAgICAgICAgaSA9IG1lbW87XG4gICAgICAgIGN1cnJlbnQgPSBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmIChpID4gY3VycmVudCkge1xuICAgICAgICAgICAgY2h1bmtzW2pdID0gY2h1bmtzW2pdLnNsaWNlKGkgLSBjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vXG4gICAgLy8gUGFyc2UgZnJvbSBhIHRva2VuLCByZWdleHAgb3Igc3RyaW5nLCBhbmQgbW92ZSBmb3J3YXJkIGlmIG1hdGNoXG4gICAgLy9cbiAgICBmdW5jdGlvbiAkKHRvaykge1xuICAgICAgICB2YXIgbWF0Y2gsIGFyZ3MsIGxlbmd0aCwgYywgaW5kZXgsIGVuZEluZGV4LCBrO1xuXG4gICAgICAgIC8vIE5vbi10ZXJtaW5hbFxuICAgICAgICBpZiAodG9rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2suY2FsbChwYXJzZXIucGFyc2Vycyk7XG4gICAgICAgIC8vIFRlcm1pbmFsXG4gICAgICAgIC8vIEVpdGhlciBtYXRjaCBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LFxuICAgICAgICAvLyBvciBtYXRjaCBhIHJlZ2V4cCBpbiB0aGUgY3VycmVudCBjaHVuayAoY2h1bmtbal0pLlxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZih0b2spID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5jaGFyQXQoaSkgPT09IHRvayA/IHRvayA6IG51bGw7XG4gICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgICAgc3luYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3luYygpO1xuXG4gICAgICAgICAgICBtYXRjaCA9IHRvay5leGVjKGNodW5rc1tqXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hdGNoIGlzIGNvbmZpcm1lZCwgYWRkIHRoZSBtYXRjaCBsZW5ndGggdG8gYGlgLFxuICAgICAgICAvLyBhbmQgY29uc3VtZSBhbnkgZXh0cmEgd2hpdGUtc3BhY2UgY2hhcmFjdGVycyAoJyAnIHx8ICdcXG4nKVxuICAgICAgICAvLyB3aGljaCBjb21lIGFmdGVyIHRoYXQuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBMZVNTJ3NcbiAgICAgICAgLy8gZ3JhbW1hciBpcyBtb3N0bHkgd2hpdGUtc3BhY2UgaW5zZW5zaXRpdmUuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1lbSA9IGkgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgZW5kSW5kZXggPSBpICsgY2h1bmtzW2pdLmxlbmd0aCAtIGxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGkgPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIGMgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmICghIChjID09PSAzMiB8fCBjID09PSAxMCB8fCBjID09PSA5KSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rc1tqXSA9IGNodW5rc1tqXS5zbGljZShsZW5ndGggKyAoaSAtIG1lbSkpO1xuICAgICAgICAgICAgY3VycmVudCA9IGk7XG5cbiAgICAgICAgICAgIGlmIChjaHVua3Nbal0ubGVuZ3RoID09PSAwICYmIGogPCBjaHVua3MubGVuZ3RoIC0gMSkgeyBqKys7IH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZihtYXRjaCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2gubGVuZ3RoID09PSAxID8gbWF0Y2hbMF0gOiBtYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhbWUgYXMgJCgpLCBidXQgZG9uJ3QgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLFxuICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBtYXRjaC5cbiAgICBmdW5jdGlvbiBwZWVrKHRvaykge1xuICAgICAgICBpZiAodHlwZW9mKHRvaykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KGkpID09PSB0b2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gISF0b2sudGVzdChjaHVua3Nbal0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEVycm9yTGluZShzdHlsZSwgZXJyb3JJbmRleCkge1xuICAgICAgICByZXR1cm4gKHN0eWxlLnNsaWNlKDAsIGVycm9ySW5kZXgpLm1hdGNoKC9cXG4vZykgfHwgJycpLmxlbmd0aCArIDE7XG4gICAgfVxuXG5cbiAgICAvLyBNYWtlIGFuIGVycm9yIG9iamVjdCBmcm9tIGEgcGFzc2VkIHNldCBvZiBwcm9wZXJ0aWVzLlxuICAgIC8vIEFjY2VwdGVkIHByb3BlcnRpZXM6XG4gICAgLy8gLSBgbWVzc2FnZWA6IFRleHQgb2YgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgLy8gLSBgZmlsZW5hbWVgOiBGaWxlbmFtZSB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgLy8gLSBgaW5kZXhgOiBDaGFyLiBpbmRleCB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgZnVuY3Rpb24gbWFrZUVycm9yKGVycikge1xuICAgICAgICB2YXIgZWlucHV0O1xuXG4gICAgICAgIF8oZXJyKS5kZWZhdWx0cyh7XG4gICAgICAgICAgICBpbmRleDogZnVydGhlc3QsXG4gICAgICAgICAgICBmaWxlbmFtZTogZW52LmZpbGVuYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1BhcnNlIGVycm9yLicsXG4gICAgICAgICAgICBsaW5lOiAwLFxuICAgICAgICAgICAgY29sdW1uOiAtMVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXJyLmZpbGVuYW1lICYmIHRoYXQuZW52LmlucHV0cyAmJiB0aGF0LmVudi5pbnB1dHNbZXJyLmZpbGVuYW1lXSkge1xuICAgICAgICAgICAgZWlucHV0ID0gdGhhdC5lbnYuaW5wdXRzW2Vyci5maWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVyci5saW5lID0gZXh0cmFjdEVycm9yTGluZShlaW5wdXQsIGVyci5pbmRleCk7XG4gICAgICAgIGZvciAodmFyIG4gPSBlcnIuaW5kZXg7IG4gPj0gMCAmJiBlaW5wdXQuY2hhckF0KG4pICE9PSAnXFxuJzsgbi0tKSB7XG4gICAgICAgICAgICBlcnIuY29sdW1uKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKF8oJzwlPWZpbGVuYW1lJT46PCU9bGluZSU+OjwlPWNvbHVtbiU+IDwlPW1lc3NhZ2UlPicpLnRlbXBsYXRlKGVycikpO1xuICAgIH1cblxuICAgIHRoaXMuZW52ID0gZW52ID0gZW52IHx8IHt9O1xuICAgIHRoaXMuZW52LmZpbGVuYW1lID0gdGhpcy5lbnYuZmlsZW5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLmVudi5pbnB1dHMgPSB0aGlzLmVudi5pbnB1dHMgfHwge307XG5cbiAgICAvLyBUaGUgUGFyc2VyXG4gICAgcGFyc2VyID0ge1xuXG4gICAgICAgIGV4dHJhY3RFcnJvckxpbmU6IGV4dHJhY3RFcnJvckxpbmUsXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlLlxuICAgICAgICAvLyBUaHJvd3MgYW4gZXJyb3Igb24gcGFyc2UgZXJyb3JzLlxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCwgc3RhcnQsIGVuZCwgem9uZSwgbGluZSwgbGluZXMsIGJ1ZmYgPSBbXSwgYywgZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICBpID0gaiA9IGN1cnJlbnQgPSBmdXJ0aGVzdCA9IDA7XG4gICAgICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGlucHV0ID0gc3RyLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgICAgICAgICBpZiAoZW52LmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbnYuaW5wdXRzW2Vudi5maWxlbmFtZV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVhcmx5X2V4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGlucHV0IGludG8gY2h1bmtzLlxuICAgICAgICAgICAgY2h1bmtzID0gKGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHNraXAgPSAvKD86QFxce1tcXHctXStcXH18W15cIidgXFx7XFx9XFwvXFwoXFwpXFxcXF0pKy9nLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gL1xcL1xcKig/OlteKl18XFwqK1teXFwvKl0pKlxcKitcXC98XFwvXFwvLiovZyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gL1wiKCg/OlteXCJcXFxcXFxyXFxuXXxcXFxcLikqKVwifCcoKD86W14nXFxcXFxcclxcbl18XFxcXC4pKiknfGAoKD86W15gXXxcXFxcLikqKWAvZyxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSAwLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVua3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIGluUGFyYW07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYywgY2M7IGkgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAubGFzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gc2tpcC5leGVjKGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsucHVzaChtYXRjaFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYyA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5sYXN0SW5kZXggPSBzdHJpbmcubGFzdEluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBzdHJpbmcuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpblBhcmFtICYmIGMgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBpbnB1dC5jaGFyQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjID09PSAnLycgfHwgY2MgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IGNvbW1lbnQuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOiBpZiAoISBpblBhcmFtKSB7IGxldmVsICsrOyAgICAgICAgY2h1bmsucHVzaChjKTsgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnfSc6IGlmICghIGluUGFyYW0pIHsgbGV2ZWwgLS07ICAgICAgICBjaHVuay5wdXNoKGMpOyBjaHVua3NbKytqXSA9IGNodW5rID0gW107IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzogaWYgKCEgaW5QYXJhbSkgeyBpblBhcmFtID0gdHJ1ZTsgIGNodW5rLnB1c2goYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOiBpZiAoICBpblBhcmFtKSB7IGluUGFyYW0gPSBmYWxzZTsgY2h1bmsucHVzaChjKTsgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUGFyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKGxldmVsID4gMCkgPyBcIm1pc3NpbmcgY2xvc2luZyBgfWBcIiA6IFwibWlzc2luZyBvcGVuaW5nIGB7YFwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuam9pbignJyk7IH0pO1xuICAgICAgICAgICAgfSkoW1tdXSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHByaW1hcnkgcnVsZS5cbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBzeW50YXggdHJlZSBpcyBoZWxkIHVuZGVyIGEgUnVsZXNldCBub2RlLFxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHJvb3RgIHByb3BlcnR5IHNldCB0byB0cnVlLCBzbyBubyBge31gIGFyZVxuICAgICAgICAgICAgLy8gb3V0cHV0LlxuICAgICAgICAgICAgcm9vdCA9IG5ldyB0cmVlLlJ1bGVzZXQoW10sICQodGhpcy5wYXJzZXJzLnByaW1hcnkpKTtcbiAgICAgICAgICAgIHJvb3Qucm9vdCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEdldCBhbiBhcnJheSBvZiBSdWxlc2V0IG9iamVjdHMsIGZsYXR0ZW5lZFxuICAgICAgICAgICAgLy8gYW5kIHNvcnRlZCBhY2NvcmRpbmcgdG8gc3BlY2lmaWNpdHlTb3J0XG4gICAgICAgICAgICByb290LnRvTGlzdCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSwgbGluZXMsIGNvbHVtbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZW52KSB7XG4gICAgICAgICAgICAgICAgICAgIGVudi5lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW52LmVycm9ycykgZW52LmVycm9ycyA9IG5ldyBFcnJvcignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW52LmVycm9ycy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LmVycm9ycy5tZXNzYWdlICs9ICdcXG4nICsgbWFrZUVycm9yKGUpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudi5lcnJvcnMubWVzc2FnZSA9IG1ha2VFcnJvcihlKS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBlbnYuZnJhbWVzID0gZW52LmZyYW1lcyB8fCBbXTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgcG9wdWxhdGVzIEludmFsaWQtY2F1c2VkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbnMgPSB0aGlzLmZsYXR0ZW4oW10sIFtdLCBlbnYpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9ucy5zb3J0KHNwZWNpZmljaXR5U29ydCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgLy8gU29ydCBydWxlcyBieSBzcGVjaWZpY2l0eTogdGhpcyBmdW5jdGlvbiBleHBlY3RzIHNlbGVjdG9ycyB0byBiZVxuICAgICAgICAgICAgLy8gc3BsaXQgYWxyZWFkeS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXcml0dGVuIHRvIGJlIHVzZWQgYXMgYSAuc29ydChGdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBhcmd1bWVudC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBbMSwgMCwgMCwgNDY3XSA+IFswLCAwLCAxLCA1MjBdXG4gICAgICAgICAgICB2YXIgc3BlY2lmaWNpdHlTb3J0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhcyA9IGEuc3BlY2lmaWNpdHk7XG4gICAgICAgICAgICAgICAgdmFyIGJzID0gYi5zcGVjaWZpY2l0eTtcblxuICAgICAgICAgICAgICAgIGlmIChhc1swXSAhPSBic1swXSkgcmV0dXJuIGJzWzBdIC0gYXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGFzWzFdICE9IGJzWzFdKSByZXR1cm4gYnNbMV0gLSBhc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoYXNbMl0gIT0gYnNbMl0pIHJldHVybiBic1syXSAtIGFzWzJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBic1szXSAtIGFzWzNdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSGVyZSBpbiwgdGhlIHBhcnNpbmcgcnVsZXMvZnVuY3Rpb25zXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHN5bnRheCB0cmVlIGdlbmVyYXRlZCBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIFJ1bGVzZXQgLT4gIFJ1bGUgLT4gVmFsdWUgLT4gRXhwcmVzc2lvbiAtPiBFbnRpdHlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gIEluIGdlbmVyYWwsIG1vc3QgcnVsZXMgd2lsbCB0cnkgdG8gcGFyc2UgYSB0b2tlbiB3aXRoIHRoZSBgJCgpYCBmdW5jdGlvbiwgYW5kIGlmIHRoZSByZXR1cm5cbiAgICAgICAgLy8gIHZhbHVlIGlzIHRydWx5LCB3aWxsIHJldHVybiBhIG5ldyBub2RlLCBvZiB0aGUgcmVsZXZhbnQgdHlwZS4gU29tZXRpbWVzLCB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgIC8vICBmaXJzdCwgYmVmb3JlIHBhcnNpbmcsIHRoYXQncyB3aGVuIHdlIHVzZSBgcGVlaygpYC5cbiAgICAgICAgcGFyc2Vyczoge1xuICAgICAgICAgICAgLy8gVGhlIGBwcmltYXJ5YCBydWxlIGlzIHRoZSAqZW50cnkqIGFuZCAqZXhpdCogcG9pbnQgb2YgdGhlIHBhcnNlci5cbiAgICAgICAgICAgIC8vIFRoZSBydWxlcyBoZXJlIGNhbiBhcHBlYXIgYXQgYW55IGxldmVsIG9mIHRoZSBwYXJzZSB0cmVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSByZWN1cnNpdmUgbmF0dXJlIG9mIHRoZSBncmFtbWFyIGlzIGFuIGludGVycGxheSBiZXR3ZWVuIHRoZSBgYmxvY2tgXG4gICAgICAgICAgICAvLyBydWxlLCB3aGljaCByZXByZXNlbnRzIGB7IC4uLiB9YCwgdGhlIGBydWxlc2V0YCBydWxlLCBhbmQgdGhpcyBgcHJpbWFyeWAgcnVsZSxcbiAgICAgICAgICAgIC8vIGFzIHJlcHJlc2VudGVkIGJ5IHRoaXMgc2ltcGxpZmllZCBncmFtbWFyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBwcmltYXJ5ICDihpIgIChydWxlc2V0IHwgcnVsZSkrXG4gICAgICAgICAgICAvLyAgICAgcnVsZXNldCAg4oaSICBzZWxlY3RvcisgYmxvY2tcbiAgICAgICAgICAgIC8vICAgICBibG9jayAgICDihpIgICd7JyBwcmltYXJ5ICd9J1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE9ubHkgYXQgb25lIHBvaW50IGlzIHRoZSBwcmltYXJ5IHJ1bGUgbm90IGNhbGxlZCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gYmxvY2sgcnVsZTogYXQgdGhlIHJvb3QgbGV2ZWwuXG4gICAgICAgICAgICBwcmltYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSwgcm9vdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gJCh0aGlzLnJ1bGUpIHx8ICQodGhpcy5ydWxlc2V0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5jb21tZW50KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKC9eW1xcc1xcbl0rLykgfHwgKG5vZGUgPSAkKHRoaXMuaW52YWxpZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSByb290LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW52YWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHVuayA9ICQoL15bXjtcXG5dKls7XFxuXS8pO1xuXG4gICAgICAgICAgICAgICAgLy8gVG8gZmFpbCBncmFjZWZ1bGx5LCBtYXRjaCBldmVyeXRoaW5nIHVudGlsIGEgc2VtaWNvbG9uIG9yIGxpbmVicmVhay5cbiAgICAgICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkludmFsaWQoY2h1bmssIG1lbW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFdlIGNyZWF0ZSBhIENvbW1lbnQgbm9kZSBmb3IgQ1NTIGNvbW1lbnRzIGAvKiAqL2AsXG4gICAgICAgICAgICAvLyBidXQga2VlcCB0aGUgTGVTUyBjb21tZW50cyBgLy9gIHNpbGVudCwgYnkganVzdCBza2lwcGluZ1xuICAgICAgICAgICAgLy8gb3ZlciB0aGVtLlxuICAgICAgICAgICAgY29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkpICE9PSAnLycpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSArIDEpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNvbW1lbnQoJCgvXlxcL1xcLy4qLyksIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudCA9ICQoL15cXC9cXCooPzpbXipdfFxcKitbXlxcLypdKSpcXCorXFwvXFxuPy8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0b2tlbnMgd2hpY2ggY2FuIGJlIGZvdW5kIGluc2lkZSBhbiBFeHByZXNzaW9uXG4gICAgICAgICAgICBlbnRpdGllczoge1xuXG4gICAgICAgICAgICAgICAgLy8gQSBzdHJpbmcsIHdoaWNoIHN1cHBvcnRzIGVzY2FwaW5nIFwiIGFuZCAnIFwibWlsa3kgd2F5XCIgJ2hlXFwncyB0aGUgb25lISdcbiAgICAgICAgICAgICAgICBxdW90ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkpICE9PSAnXCInICYmIGlucHV0LmNoYXJBdChpKSAhPT0gXCInXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9ICQoL15cIigoPzpbXlwiXFxcXFxcclxcbl18XFxcXC4pKilcInwnKCg/OlteJ1xcXFxcXHJcXG5dfFxcXFwuKSopJy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuUXVvdGVkKHN0clsxXSB8fCBzdHJbMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIGEgTWFwbmlrIGZpZWxkLCBsaWtlIFtOQU1FXVxuICAgICAgICAgICAgICAgIC8vIEJlaGluZCB0aGUgc2NlbmVzLCB0aGlzIGhhcyB0aGUgc2FtZSByZXByZXNlbnRhdGlvbiwgYnV0IENhcnRvXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gYmUgY2FyZWZ1bCB0byB3YXJuIHdoZW4gdW5zdXBwb3J0ZWQgb3BlcmF0aW9ucyBhcmUgdXNlZC5cbiAgICAgICAgICAgICAgICBmaWVsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghICQoJ1snKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9ICQoLyheW15cXF1dKykvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnXScpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF9uYW1lKSByZXR1cm4gbmV3IHRyZWUuRmllbGQoZmllbGRfbmFtZVsxXSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb21wYXJpc29uIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSAkKC9ePX58PXwhPXw8PXw+PXw8fD4vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIGNhdGNoLWFsbCB3b3JkLCBzdWNoIGFzOiBoYXJkLWxpZ2h0XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgY2FuIHN0YXJ0IHdpdGggZWl0aGVyIGEgbGV0dGVyIG9yIGEgZGFzaCAoLSksXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gY29udGFpbiBudW1iZXJzLCB1bmRlcnNjb3JlcywgYW5kIGxldHRlcnMuXG4gICAgICAgICAgICAgICAga2V5d29yZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gJCgvXltBLVphLXotXStbQS1aYS16LTAtOV9dKi8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaykgeyByZXR1cm4gbmV3IHRyZWUuS2V5d29yZChrKTsgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgbGlrZSByZ2IoMjU1LCAwLCAyNTUpXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIHdpdGggdGhlIGBlbnRpdGllcy5hcmd1bWVudHNgIHBhcnNlci5cbiAgICAgICAgICAgICAgICBjYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobmFtZSA9IC9eKFtcXHdcXC1dK3wlKVxcKC8uZXhlYyhjaHVua3Nbal0pKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXJsKCkgaXMgaGFuZGxlZCBieSB0aGUgdXJsIHBhcnNlciBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkKCcoJyk7IC8vIFBhcnNlIHRoZSAnKCcgYW5kIGNvbnN1bWUgd2hpdGVzcGFjZS5cblxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gJCh0aGlzLmVudGl0aWVzWydhcmd1bWVudHMnXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKCcpJykpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkNhbGwobmFtZSwgYXJncywgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50cyBhcmUgY29tbWEtc2VwYXJhdGVkIGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFyZyA9ICQodGhpcy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMuZW50aXRpZXMuZGltZW5zaW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmtleXdvcmRjb2xvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5oZXhjb2xvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5xdW90ZWQpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB1cmwoKSB0b2tlbnNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHNwZWNpZmljIHJ1bGUgZm9yIHVybHMsIGJlY2F1c2UgdGhleSBkb24ndCByZWFsbHkgYmVoYXZlIGxpa2VcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZCBmdW5jdGlvbiBjYWxscy4gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCB0aGUgYXJndW1lbnQgZG9lc24ndCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgZW5jbG9zZWQgd2l0aGluIGEgc3RyaW5nLCBzbyBpdCBjYW4ndCBiZSBwYXJzZWQgYXMgYW4gRXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSAhPT0gJ3UnIHx8ICEkKC9edXJsXFwoLykpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkKHRoaXMuZW50aXRpZXMucXVvdGVkKSB8fCAkKHRoaXMuZW50aXRpZXMudmFyaWFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgvXltcXC1cXHclQCRcXC8uJj06OyMrP35dKy8pIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5JbnZhbGlkKHZhbHVlLCBtZW1vLCAnTWlzc2luZyBjbG9zaW5nICkgaW4gVVJMLicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlVSTCgodHlwZW9mIHZhbHVlLnZhbHVlICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogbmV3IHRyZWUuUXVvdGVkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQSBWYXJpYWJsZSBlbnRpdHksIHN1Y2ggYXMgYEBmaW5rYCwgaW5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICB3aWR0aDogQGZpbmsgKyAycHhcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBhIGRpZmZlcmVudCBwYXJzZXIgZm9yIHZhcmlhYmxlIGRlZmluaXRpb25zLFxuICAgICAgICAgICAgICAgIC8vIHNlZSBgcGFyc2Vycy52YXJpYWJsZWAuXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSwgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSkgPT09ICdAJyAmJiAobmFtZSA9ICQoL15AW1xcdy1dKy8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhcmlhYmxlKG5hbWUsIGluZGV4LCBlbnYuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGhleGNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJnYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSA9PT0gJyMnICYmIChyZ2IgPSAkKC9eIyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcihyZ2JbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGtleXdvcmRjb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZ2IgPSBjaHVua3Nbal0ubWF0Y2goL15bYS16XSsvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJnYiAmJiByZ2JbMF0gaW4gdHJlZS5SZWZlcmVuY2UuZGF0YS5jb2xvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcih0cmVlLlJlZmVyZW5jZS5kYXRhLmNvbG9yc1skKC9eW2Etel0rLyldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBBIERpbWVuc2lvbiwgdGhhdCBpcywgYSBudW1iZXIgYW5kIGEgdW5pdC4gVGhlIG9ubHlcbiAgICAgICAgICAgICAgICAvLyB1bml0IHRoYXQgaGFzIGFuIGVmZmVjdCBpcyAlXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPiA1NyB8fCBjIDwgNDUpIHx8IGMgPT09IDQ3KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICQoL14oLT9cXGQqXFwuP1xcZCsoPzpbZUVdWy0rXT9cXGQrKT8pKFxcJXxcXHcrKT8vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGltZW5zaW9uKHZhbHVlWzFdLCB2YWx1ZVsyXSwgbWVtbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUaGUgdmFyaWFibGUgcGFydCBvZiBhIHZhcmlhYmxlIGRlZmluaXRpb24uXG4gICAgICAgICAgICAvLyBVc2VkIGluIHRoZSBgcnVsZWAgcGFyc2VyLiBMaWtlIEBmaW5rOlxuICAgICAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpKSA9PT0gJ0AnICYmIChuYW1lID0gJCgvXihAW1xcdy1dKylcXHMqOi8pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBFbnRpdGllcyBhcmUgdGhlIHNtYWxsZXN0IHJlY29nbml6ZWQgdG9rZW4sXG4gICAgICAgICAgICAvLyBhbmQgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHJ1bGUncyB2YWx1ZS5cbiAgICAgICAgICAgIGVudGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcy5lbnRpdGllcy5jYWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMubGl0ZXJhbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmZpZWxkKSB8fFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMudmFyaWFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy51cmwpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5rZXl3b3JkKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEEgUnVsZSB0ZXJtaW5hdG9yLiBOb3RlIHRoYXQgd2UgdXNlIGBwZWVrKClgIHRvIGNoZWNrIGZvciAnfScsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBgYmxvY2tgIHJ1bGUgd2lsbCBiZSBleHBlY3RpbmcgaXQsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQncyB0aGVyZSwgaWYgJzsnIHdhcyBvbW1pdHRlZC5cbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJzsnKSB8fCBwZWVrKCd9Jyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBFbGVtZW50cyBhcmUgdGhlIGJ1aWxkaW5nIGJsb2NrcyBmb3IgU2VsZWN0b3JzLiBUaGV5IGNvbnNpc3Qgb2ZcbiAgICAgICAgICAgIC8vIGFuIGVsZW1lbnQgbmFtZSwgc3VjaCBhcyBhIHRhZyBhIGNsYXNzLCBvciBgKmAuXG4gICAgICAgICAgICBlbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9ICQoL14oPzpbLiNdW1xcd1xcLV0rfFxcKnxNYXApLyk7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHJldHVybiBuZXcgdHJlZS5FbGVtZW50KGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQXR0YWNobWVudHMgYWxsb3cgYWRkaW5nIG11bHRpcGxlIGxpbmVzLCBwb2x5Z29ucyBldGMuIHRvIGFuXG4gICAgICAgICAgICAvLyBvYmplY3QuIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhdHRhY2htZW50IHBlciBzZWxlY3Rvci5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gJCgvXjo6KFtcXHdcXC1dKyg/OlxcL1tcXHdcXC1dKykqKS8pO1xuICAgICAgICAgICAgICAgIGlmIChzKSByZXR1cm4gc1sxXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFNlbGVjdG9ycyBhcmUgbWFkZSBvdXQgb2Ygb25lIG9yIG1vcmUgRWxlbWVudHMsIHNlZSBhYm92ZS5cbiAgICAgICAgICAgIHNlbGVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSwgYXR0YWNobWVudCxcbiAgICAgICAgICAgICAgICAgICAgZSwgZWxlbWVudHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgZiwgZmlsdGVycyA9IG5ldyB0cmVlLkZpbHRlcnNldCgpLFxuICAgICAgICAgICAgICAgICAgICB6LCB6b29tcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBmcmFtZV9vZmZzZXQgPSB0cmVlLkZyYW1lT2Zmc2V0Lm5vbmU7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gMCwgY29uZGl0aW9ucyA9IDA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZSA9ICQodGhpcy5lbGVtZW50KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh6ID0gJCh0aGlzLnpvb20pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGZvID0gJCh0aGlzLmZyYW1lX29mZnNldCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZiA9ICQodGhpcy5maWx0ZXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGEgPSAkKHRoaXMuYXR0YWNobWVudCkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tcy5wdXNoKHopO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9ucysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZV9vZmZzZXQgPSBmbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gZmlsdGVycy5hZGQoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFbmNvdW50ZXJlZCBzZWNvbmQgYXR0YWNobWVudCBuYW1lLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGkgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQgPSBhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAneycgfHwgYyA9PT0gJ30nIHx8IGMgPT09ICc7JyB8fCBjID09PSAnLCcpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlNlbGVjdG9yKGZpbHRlcnMsIHpvb21zLCBmcmFtZV9vZmZzZXQsIGVsZW1lbnRzLCBhdHRhY2htZW50LCBjb25kaXRpb25zLCBtZW1vKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5LCBvcCwgdmFsO1xuICAgICAgICAgICAgICAgIGlmICghICQoJ1snKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPSAkKC9eW2EtekEtWjAtOVxcLV9dKy8pIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5xdW90ZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy52YXJpYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmtleXdvcmQpIHx8XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbnRpdGllcy5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGF0IDEuMC4wXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiB0cmVlLlF1b3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV3IHRyZWUuRmllbGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgob3AgPSAkKHRoaXMuZW50aXRpZXMuY29tcGFyaXNvbikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsID0gJCh0aGlzLmVudGl0aWVzLnF1b3RlZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLnZhcmlhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMuZGltZW5zaW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMuZW50aXRpZXMua2V5d29yZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVudGl0aWVzLmZpZWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghICQoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIGNsb3NpbmcgXSBvZiBmaWx0ZXIuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG1lbW8gLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleS5pcykga2V5ID0gbmV3IHRyZWUuRmllbGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5GaWx0ZXIoa2V5LCBvcCwgdmFsLCBtZW1vLCBlbnYuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZnJhbWVfb2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9wLCB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKCQoL15cXFtcXHMqZnJhbWUtb2Zmc2V0L2cpICYmXG4gICAgICAgICAgICAgICAgICAgIChvcCA9ICQodGhpcy5lbnRpdGllcy5jb21wYXJpc29uKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbCA9ICQoL15cXGQrLykpICYmXG4gICAgICAgICAgICAgICAgICAgICQoJ10nKSkgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmVlLkZyYW1lT2Zmc2V0KG9wLCB2YWwsIG1lbW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3AsIHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoJCgvXlxcW1xccyp6b29tL2cpICYmXG4gICAgICAgICAgICAgICAgICAgIChvcCA9ICQodGhpcy5lbnRpdGllcy5jb21wYXJpc29uKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbCA9ICQodGhpcy5lbnRpdGllcy52YXJpYWJsZSkgfHwgJCh0aGlzLmVudGl0aWVzLmRpbWVuc2lvbikpICYmICQoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlpvb20ob3AsIHZhbCwgbWVtbyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFja3RyYWNrXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUaGUgYGJsb2NrYCBydWxlIGlzIHVzZWQgYnkgYHJ1bGVzZXRgXG4gICAgICAgICAgICAvLyBJdCdzIGEgd3JhcHBlciBhcm91bmQgdGhlIGBwcmltYXJ5YCBydWxlLCB3aXRoIGFkZGVkIGB7fWAuXG4gICAgICAgICAgICBibG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoJCgneycpICYmIChjb250ZW50ID0gJCh0aGlzLnByaW1hcnkpKSAmJiAkKCd9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZGl2LCAuY2xhc3MsIGJvZHkgPiBwIHsuLi59XG4gICAgICAgICAgICBydWxlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gW10sIHMsIGYsIGwsIHJ1bGVzLCBmaWx0ZXJzID0gW107XG4gICAgICAgICAgICAgICAgc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHMgPSAkKHRoaXMuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoJCh0aGlzLmNvbW1lbnQpKSB7fVxuICAgICAgICAgICAgICAgICAgICBpZiAoISAkKCcsJykpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCQodGhpcy5jb21tZW50KSkge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCQodGhpcy5jb21tZW50KSkge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKHJ1bGVzID0gJCh0aGlzLmJsb2NrKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc1swXS5lbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc1swXS5lbGVtZW50c1swXS52YWx1ZSA9PT0gJ01hcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBycyA9IG5ldyB0cmVlLlJ1bGVzZXQoc2VsZWN0b3JzLCBydWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBycy5pc01hcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlJ1bGVzZXQoc2VsZWN0b3JzLCBydWxlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3RyYWNrXG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBydWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSwgdmFsdWUsIGMgPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcuJyB8fCBjID09PSAnIycpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9ICQodGhpcy52YXJpYWJsZSkgfHwgJCh0aGlzLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICQodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmICQodGhpcy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuUnVsZShuYW1lLCB2YWx1ZSwgbWVtbywgZW52LmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1cnRoZXN0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZvbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFtdLCBleHByZXNzaW9uID0gW10sIHdlaWdodCwgZm9udCwgZTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChlID0gJCh0aGlzLmVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2gobmV3IHRyZWUuRXhwcmVzc2lvbihleHByZXNzaW9uKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlID0gJCh0aGlzLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEEgVmFsdWUgaXMgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBFeHByZXNzaW9uc1xuICAgICAgICAgICAgLy8gSW4gYSBSdWxlLCBhIFZhbHVlIHJlcHJlc2VudHMgZXZlcnl0aGluZyBhZnRlciB0aGUgYDpgLFxuICAgICAgICAgICAgLy8gYW5kIGJlZm9yZSB0aGUgYDtgLlxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlLCBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGUgPSAkKHRoaXMuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgJCgnLCcpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhbHVlKGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5WYWx1ZShleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEEgc3ViLWV4cHJlc3Npb24sIGNvbnRhaW5lZCBieSBwYXJlbnRoZW5zaXNcbiAgICAgICAgICAgIHN1YjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoJCgnKCcpICYmIChlID0gJCh0aGlzLmV4cHJlc3Npb24pKSAmJiAkKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtaXNub21lciBiZWNhdXNlIGl0IGFjdHVhbGx5IGhhbmRsZXMgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICAgIC8vIGFuZCBkaXZpc2lvbi5cbiAgICAgICAgICAgIG11bHRpcGxpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSwgYSwgb3AsIG9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobSA9ICQodGhpcy5vcGVyYW5kKSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9wID0gKCQoJy8nKSB8fCAkKCcqJykgfHwgJCgnJScpKSkgJiYgKGEgPSAkKHRoaXMub3BlcmFuZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBuZXcgdHJlZS5PcGVyYXRpb24ob3AsIFtvcGVyYXRpb24gfHwgbSwgYV0sIG1lbW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtLCBhLCBvcCwgb3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChtID0gJCh0aGlzLm11bHRpcGxpY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9wID0gJCgvXlstK11cXHMrLykgfHwgKGlucHV0LmNoYXJBdChpIC0gMSkgIT0gJyAnICYmICgkKCcrJykgfHwgJCgnLScpKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoYSA9ICQodGhpcy5tdWx0aXBsaWNhdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBuZXcgdHJlZS5PcGVyYXRpb24ob3AsIFtvcGVyYXRpb24gfHwgbSwgYV0sIG1lbW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBbiBvcGVyYW5kIGlzIGFueXRoaW5nIHRoYXQgY2FuIGJlIHBhcnQgb2YgYW4gb3BlcmF0aW9uLFxuICAgICAgICAgICAgLy8gc3VjaCBhcyBhIENvbG9yLCBvciBhIFZhcmlhYmxlXG4gICAgICAgICAgICBvcGVyYW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzLnN1YikgfHwgJCh0aGlzLmVudGl0eSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBFeHByZXNzaW9ucyBlaXRoZXIgcmVwcmVzZW50IG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zLFxuICAgICAgICAgICAgLy8gb3Igd2hpdGUtc3BhY2UgZGVsaW1pdGVkIEVudGl0aWVzLiAgQHZhciAqIDJcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlLCBkZWxpbSwgZW50aXRpZXMgPSBbXSwgZDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChlID0gJCh0aGlzLmFkZGl0aW9uKSB8fCAkKHRoaXMuZW50aXR5KSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbnRpdGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5FeHByZXNzaW9uKGVudGl0aWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJCgvXigoW2Etel1bLWEtel8wLTldKlxcLyk/XFwqPy0/Wy1hLXpfMC05XSspXFxzKjovKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkgcmV0dXJuIG5hbWVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZXI7XG59O1xuIiwidmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgY2FydG8gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNhcnRvLlJlbmRlcmVyID0gZnVuY3Rpb24gUmVuZGVyZXIoZW52LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbnYgPSBlbnYgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24gPSB0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24gfHwgJzMuMC4wJztcbn07XG5cbi8qKlxuICogUHJlcGFyZSBhIE1TUyBkb2N1bWVudCAoZ2l2ZW4gYXMgYW4gc3RyaW5nKSBpbnRvIGFcbiAqIFhNTCBTdHlsZSBmcmFnbWVudCAobW9zdGx5IHVzZWZ1bCBmb3IgZGVidWdnaW5nKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRoZSBtc3MgY29udGVudHMgYXMgYSBzdHJpbmcuXG4gKi9cbmNhcnRvLlJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJNU1MgPSBmdW5jdGlvbiByZW5kZXIoZGF0YSkge1xuICAgIC8vIGVmZmVjdHMgaXMgYSBjb250YWluZXIgZm9yIHNpZGUtZWZmZWN0cywgd2hpY2ggY3VycmVudGx5XG4gICAgLy8gYXJlIGxpbWl0ZWQgdG8gRm9udFNldHMuXG4gICAgdmFyIGVudiA9IF8odGhpcy5lbnYpLmRlZmF1bHRzKHtcbiAgICAgICAgYmVuY2htYXJrOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGlvbl9kYXRhOiBmYWxzZSxcbiAgICAgICAgZWZmZWN0czogW11cbiAgICB9KTtcblxuICAgIGlmICghY2FydG8udHJlZS5SZWZlcmVuY2Uuc2V0VmVyc2lvbih0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXQgbWFwbmlrIHZlcnNpb24gdG8gXCIgKyB0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24pO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgc3R5bGVzID0gW107XG5cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lKCdQYXJzaW5nIE1TUycpO1xuICAgIHZhciBwYXJzZXIgPSAoY2FydG8uUGFyc2VyKGVudikpLnBhcnNlKGRhdGEpO1xuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWVFbmQoJ1BhcnNpbmcgTVNTJyk7XG5cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lKCdSdWxlIGdlbmVyYXRpb24nKTtcbiAgICB2YXIgcnVsZV9saXN0ID0gcGFyc2VyLnRvTGlzdChlbnYpO1xuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWVFbmQoJ1J1bGUgZ2VuZXJhdGlvbicpO1xuXG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZSgnUnVsZSBpbmhlcml0YW5jZScpO1xuICAgIHZhciBydWxlcyA9IGluaGVyaXREZWZpbml0aW9ucyhydWxlX2xpc3QsIGVudik7XG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZUVuZCgnUnVsZSBpbmhlcml0YW5jZScpO1xuXG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZSgnU3R5bGUgc29ydCcpO1xuICAgIHZhciBzb3J0ZWQgPSBzb3J0U3R5bGVzKHJ1bGVzLGVudik7XG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZUVuZCgnU3R5bGUgc29ydCcpO1xuXG4gICAgaWYgKGVudi5iZW5jaG1hcmspIGNvbnNvbGUudGltZSgnVG90YWwgU3R5bGUgZ2VuZXJhdGlvbicpO1xuICAgIGZvciAodmFyIGsgPSAwLCBydWxlLCBzdHlsZV9uYW1lOyBrIDwgc29ydGVkLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHJ1bGUgPSBzb3J0ZWRba107XG4gICAgICAgIHN0eWxlX25hbWUgPSAnc3R5bGUnICsgKHJ1bGUuYXR0YWNobWVudCAhPT0gJ19fZGVmYXVsdF9fJyA/ICctJyArIHJ1bGUuYXR0YWNobWVudCA6ICcnKTtcbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGVfbmFtZSk7XG4gICAgICAgIHZhciBiZW5jaF9uYW1lID0gJ1xcdFN0eWxlIFwiJytzdHlsZV9uYW1lKydcIiAoIycraysnKSB0b1hNTCc7XG4gICAgICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLnRpbWUoYmVuY2hfbmFtZSk7XG4gICAgICAgIC8vIGVudi5lZmZlY3RzIGNhbiBiZSBtb2RpZmllZCBieSB0aGlzIGNhbGxcbiAgICAgICAgb3V0cHV0LnB1c2goY2FydG8udHJlZS5TdHlsZVhNTChzdHlsZV9uYW1lLCBydWxlLmF0dGFjaG1lbnQsIHJ1bGUsIGVudikpO1xuICAgICAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lRW5kKGJlbmNoX25hbWUpO1xuICAgIH1cbiAgICBpZiAoZW52LmJlbmNobWFyaykgY29uc29sZS50aW1lRW5kKCdUb3RhbCBTdHlsZSBnZW5lcmF0aW9uJyk7XG4gICAgaWYgKGVudi5lcnJvcnMpIHRocm93IGVudi5lcnJvcnM7XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSBhIE1NTCBkb2N1bWVudCAoZ2l2ZW4gYXMgYW4gb2JqZWN0KSBpbnRvIGFcbiAqIGZ1bGx5LWxvY2FsaXplZCBYTUwgZmlsZSByZWFkeSBmb3IgTWFwbmlrMiBjb25zdW1wdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtIC0gdGhlIEpTT04gZmlsZSBhcyBhIHN0cmluZy5cbiAqL1xuY2FydG8uUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihtKSB7XG4gICAgLy8gZWZmZWN0cyBpcyBhIGNvbnRhaW5lciBmb3Igc2lkZS1lZmZlY3RzLCB3aGljaCBjdXJyZW50bHlcbiAgICAvLyBhcmUgbGltaXRlZCB0byBGb250U2V0cy5cbiAgICB2YXIgZW52ID0gXyh0aGlzLmVudikuZGVmYXVsdHMoe1xuICAgICAgICBiZW5jaG1hcms6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW9uX2RhdGE6IGZhbHNlLFxuICAgICAgICBlZmZlY3RzOiBbXSxcbiAgICAgICAgcHBpOiA5MC43MTRcbiAgICB9KTtcblxuICAgIGlmICghY2FydG8udHJlZS5SZWZlcmVuY2Uuc2V0VmVyc2lvbih0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXQgbWFwbmlrIHZlcnNpb24gdG8gXCIgKyB0aGlzLm9wdGlvbnMubWFwbmlrX3ZlcnNpb24pO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgIC8vIFRyYW5zZm9ybSBzdHlsZXNoZWV0cyBpbnRvIGRlZmluaXRpb25zLlxuICAgIHZhciBkZWZpbml0aW9ucyA9IF8obS5TdHlsZXNoZWV0KS5jaGFpbigpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3R5bGVzaGVldCBvYmplY3QgaXMgZXhwZWN0ZWQgbm90IGEgc3RyaW5nOiAnXCIgKyBzICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW52aXJvbm1lbnQgZnJvbSBzdHlsZXNoZWV0IHRvIHN0eWxlc2hlZXQsXG4gICAgICAgICAgICAvLyBhbGxvd3MgZnJhbWVzIGFuZCBlZmZlY3RzIHRvIGJlIG1haW50YWluZWQuXG4gICAgICAgICAgICBlbnYgPSBfKGVudikuZXh0ZW5kKHtmaWxlbmFtZTpzLmlkfSk7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gK25ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgcm9vdCA9IChjYXJ0by5QYXJzZXIoZW52KSkucGFyc2Uocy5kYXRhKTtcbiAgICAgICAgICAgIGlmIChlbnYuYmVuY2htYXJrKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyc2luZyB0aW1lOiAnICsgKG5ldyBEYXRlKCkgLSB0aW1lKSArICdtcycpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QudG9MaXN0KGVudik7XG4gICAgICAgIH0pXG4gICAgICAgIC5mbGF0dGVuKClcbiAgICAgICAgLnZhbHVlKCk7XG5cbiAgICBmdW5jdGlvbiBhcHBsaWVzVG8obmFtZSwgY2xhc3NJbmRleCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb24uYXBwbGllc1RvKGwubmFtZSwgY2xhc3NJbmRleCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGxheWVycyBhbmQgY3JlYXRlIHN0eWxlcyBjdXN0b20tYnVpbHRcbiAgICAvLyBmb3IgZWFjaCBvZiB0aGVtLCBhbmQgYXBwbHkgdGhvc2Ugc3R5bGVzIHRvIHRoZSBsYXllcnMuXG4gICAgdmFyIHN0eWxlcywgbCwgY2xhc3NJbmRleCwgcnVsZXMsIHNvcnRlZCwgbWF0Y2hpbmc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLkxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGwgPSBtLkxheWVyW2ldO1xuICAgICAgICBzdHlsZXMgPSBbXTtcbiAgICAgICAgY2xhc3NJbmRleCA9IHt9O1xuXG4gICAgICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLndhcm4oJ3Byb2Nlc3NpbmcgbGF5ZXI6ICcgKyBsLmlkKTtcbiAgICAgICAgLy8gQ2xhc3NlcyBhcmUgZ2l2ZW4gYXMgc3BhY2Utc2VwYXJhdGVkIGFscGhhbnVtZXJpYyBzdHJpbmdzLlxuICAgICAgICB2YXIgY2xhc3NlcyA9IChsWydjbGFzcyddIHx8ICcnKS5zcGxpdCgvXFxzKy9nKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjbGFzc0luZGV4W2NsYXNzZXNbal1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGluZyA9IGRlZmluaXRpb25zLmZpbHRlcihhcHBsaWVzVG8obC5uYW1lLCBjbGFzc0luZGV4KSk7XG4gICAgICAgIHJ1bGVzID0gaW5oZXJpdERlZmluaXRpb25zKG1hdGNoaW5nLCBlbnYpO1xuICAgICAgICBzb3J0ZWQgPSBzb3J0U3R5bGVzKHJ1bGVzLCBlbnYpO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBydWxlLCBzdHlsZV9uYW1lOyBrIDwgc29ydGVkLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBydWxlID0gc29ydGVkW2tdO1xuICAgICAgICAgICAgc3R5bGVfbmFtZSA9IGwubmFtZSArIChydWxlLmF0dGFjaG1lbnQgIT09ICdfX2RlZmF1bHRfXycgPyAnLScgKyBydWxlLmF0dGFjaG1lbnQgOiAnJyk7XG5cbiAgICAgICAgICAgIC8vIGVudi5lZmZlY3RzIGNhbiBiZSBtb2RpZmllZCBieSB0aGlzIGNhbGxcbiAgICAgICAgICAgIHZhciBzdHlsZVhNTCA9IGNhcnRvLnRyZWUuU3R5bGVYTUwoc3R5bGVfbmFtZSwgcnVsZS5hdHRhY2htZW50LCBydWxlLCBlbnYpO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGVYTUwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHlsZVhNTCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goc3R5bGVfbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaChjYXJ0by50cmVlLkxheWVyWE1MKGwsIHN0eWxlcykpO1xuICAgIH1cblxuICAgIG91dHB1dC51bnNoaWZ0KGVudi5lZmZlY3RzLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnRvWE1MKGVudik7XG4gICAgfSkuam9pbignXFxuJykpO1xuXG4gICAgdmFyIG1hcF9wcm9wZXJ0aWVzID0gZ2V0TWFwUHJvcGVydGllcyhtLCBkZWZpbml0aW9ucywgZW52KTtcblxuICAgIC8vIEV4aXQgb24gZXJyb3JzLlxuICAgIGlmIChlbnYuZXJyb3JzKSB0aHJvdyBlbnYuZXJyb3JzO1xuXG4gICAgLy8gUGFzcyBUaWxlSlNPTiBhbmQgb3RoZXIgY3VzdG9tIHBhcmFtZXRlcnMgdGhyb3VnaCB0byBNYXBuaWsgWE1MLlxuICAgIHZhciBwYXJhbWV0ZXJzID0gXyhtKS5yZWR1Y2UoZnVuY3Rpb24obWVtbywgdiwgaykge1xuICAgICAgICBpZiAoIXYgJiYgdiAhPT0gMCkgcmV0dXJuIG1lbW87XG5cbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIC8vIEtub3duIHNraXBwYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICBjYXNlICdzcnMnOlxuICAgICAgICBjYXNlICdMYXllcic6XG4gICAgICAgIGNhc2UgJ1N0eWxlc2hlZXQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE5vbiBVUkwtYm91bmQgVGlsZUpTT04gcHJvcGVydGllcy5cbiAgICAgICAgY2FzZSAnYm91bmRzJzpcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgY2FzZSAnbWluem9vbSc6XG4gICAgICAgIGNhc2UgJ21heHpvb20nOlxuICAgICAgICBjYXNlICd2ZXJzaW9uJzpcbiAgICAgICAgICAgIG1lbW8ucHVzaCgnICA8UGFyYW1ldGVyIG5hbWU9XCInICsgayArICdcIj4nICsgdiArICc8L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBDREFUQS5cbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgIGNhc2UgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICAgY2FzZSAnbGVnZW5kJzpcbiAgICAgICAgY2FzZSAnYXR0cmlidXRpb24nOlxuICAgICAgICBjYXNlICd0ZW1wbGF0ZSc6XG4gICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+PCFbQ0RBVEFbJyArIHYgKyAnXV0+PC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gTWFwbmlrIGltYWdlIGZvcm1hdC5cbiAgICAgICAgY2FzZSAnZm9ybWF0JzpcbiAgICAgICAgICAgIG1lbW8ucHVzaCgnICA8UGFyYW1ldGVyIG5hbWU9XCInICsgayArICdcIj4nICsgdiArICc8L1BhcmFtZXRlcj4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNYXBuaWsgaW50ZXJhY3Rpdml0eSBzZXR0aW5ncy5cbiAgICAgICAgY2FzZSAnaW50ZXJhY3Rpdml0eSc6XG4gICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiaW50ZXJhY3Rpdml0eV9sYXllclwiPicgKyB2LmxheWVyICsgJzwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cImludGVyYWN0aXZpdHlfZmllbGRzXCI+JyArIHYuZmllbGRzICsgJzwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFN1cHBvcnQgYW55IGFkZGl0aW9uYWwgc2NhbGFyIHByb3BlcnRpZXMuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgbWVtby5wdXNoKCcgIDxQYXJhbWV0ZXIgbmFtZT1cIicgKyBrICsgJ1wiPjwhW0NEQVRBWycgKyB2ICsgJ11dPjwvUGFyYW1ldGVyPicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+JyArIHYgKyAnPC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vLnB1c2goJyAgPFBhcmFtZXRlciBuYW1lPVwiJyArIGsgKyAnXCI+JyArIHYgKyAnPC9QYXJhbWV0ZXI+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG4gICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoKSBvdXRwdXQudW5zaGlmdChcbiAgICAgICAgJzxQYXJhbWV0ZXJzPlxcbicgK1xuICAgICAgICBwYXJhbWV0ZXJzLmpvaW4oJ1xcbicpICtcbiAgICAgICAgJ1xcbjwvUGFyYW1ldGVycz5cXG4nXG4gICAgKTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gXyhtYXBfcHJvcGVydGllcykubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuICcgJyArIHY7IH0pLmpvaW4oJycpO1xuXG4gICAgb3V0cHV0LnVuc2hpZnQoXG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgJyArXG4gICAgICAgICdlbmNvZGluZz1cInV0Zi04XCI/PlxcbicgK1xuICAgICAgICAnPCFET0NUWVBFIE1hcFtdPlxcbicgK1xuICAgICAgICAnPE1hcCcgKyBwcm9wZXJ0aWVzICsnPlxcbicpO1xuICAgIG91dHB1dC5wdXNoKCc8L01hcD4nKTtcbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGN1cnJlbnRseSBtb2RpZmllcyAnY3VycmVudCdcbiAqIEBwYXJhbSB7QXJyYXl9ICBjdXJyZW50ICBjdXJyZW50IGxpc3Qgb2YgcnVsZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIGEgRGVmaW5pdGlvbiBvYmplY3QgdG8gYWRkIHRvIHRoZSBydWxlc1xuICogQHBhcmFtIHtPYmplY3R9IGJ5RmlsdGVyIGFuIG9iamVjdC9kaWN0aW9uYXJ5IG9mIGV4aXN0aW5nIGZpbHRlcnMuIFRoaXMgaXNcbiAqIGFjdHVhbGx5IGtleWVkIGBhdHRhY2htZW50LT5maWx0ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gZW52IHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4qL1xuZnVuY3Rpb24gYWRkUnVsZXMoY3VycmVudCwgZGVmaW5pdGlvbiwgYnlGaWx0ZXIsIGVudikge1xuICAgIHZhciBuZXdGaWx0ZXJzID0gZGVmaW5pdGlvbi5maWx0ZXJzLFxuICAgICAgICBuZXdSdWxlcyA9IGRlZmluaXRpb24ucnVsZXMsXG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzLCBjbG9uZSwgcHJldmlvdXM7XG5cbiAgICAvLyBUaGUgY3VycmVudCBkZWZpbml0aW9uIG1pZ2h0IGhhdmUgYmVlbiBzcGxpdCB1cCBpbnRvXG4gICAgLy8gbXVsdGlwbGUgZGVmaW5pdGlvbnMgYWxyZWFkeS5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGN1cnJlbnQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdXBkYXRlZEZpbHRlcnMgPSBjdXJyZW50W2tdLmZpbHRlcnMuY2xvbmVXaXRoKG5ld0ZpbHRlcnMpO1xuICAgICAgICBpZiAodXBkYXRlZEZpbHRlcnMpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gYnlGaWx0ZXJbdXBkYXRlZEZpbHRlcnNdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgZGVmaW5pdGlvbiB3aXRoIHRob3NlIGV4YWN0XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVycy4gQWRkIHRoZSBjdXJyZW50IGRlZmluaXRpb25zJyBydWxlc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzdG9wIHByb2Nlc3NpbmcgaXQgYXMgdGhlIGV4aXN0aW5nIHJ1bGVcbiAgICAgICAgICAgICAgICAvLyBoYXMgYWxyZWFkeSBnb25lIGRvd24gdGhlIGluaGVyaXRhbmNlIGNoYWluLlxuICAgICAgICAgICAgICAgIHByZXZpb3VzLmFkZFJ1bGVzKG5ld1J1bGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBjdXJyZW50W2tdLmNsb25lKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSBvbmx5IG1haW50YWluaW5nIHRoZSBjbG9uZVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgZGlkIGFjdHVhbGx5IGFkZCBydWxlcy4gSWYgbm90LCB0aGVyZSdzXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBrZWVwIHRoZSBjbG9uZSBhcm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKGNsb25lLmFkZFJ1bGVzKG5ld1J1bGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBpbnNlcnRlZCBhbiBlbGVtZW50IGJlZm9yZSB0aGlzIG9uZSwgc28gd2UgbmVlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCBpbiB0aGUgbmV4dCBsb29wIGl0ZXJhdGlvbiwgd2UncmVcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHBlcmZvcm1pbmcgdGhlIHNhbWUgdGFzayBmb3IgdGhpcyBlbGVtZW50IGFnYWluLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZW5jZSB0aGUgaysrLlxuICAgICAgICAgICAgICAgICAgICBieUZpbHRlclt1cGRhdGVkRmlsdGVyc10gPSBjbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaywgMCwgY2xvbmUpO1xuICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGaWx0ZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpZiB1cGRhdGVkRmlsdGVycyBpcyBudWxsLCB0aGVuIGFkZGluZyB0aGUgZmlsdGVycyBkb2Vzbid0XG4gICAgICAgICAgICAvLyBpbnZhbGlkYXRlIG9yIHNwbGl0IHRoZSBzZWxlY3Rvciwgc28gd2UgYWRkUnVsZXMgdG8gdGhlXG4gICAgICAgICAgICAvLyBjb21iaW5lZCBzZWxlY3RvclxuXG4gICAgICAgICAgICAvLyBGaWx0ZXJzIGNhbiBiZSBhZGRlZCwgYnV0IHRoZXkgZG9uJ3QgY2hhbmdlIHRoZVxuICAgICAgICAgICAgLy8gZmlsdGVycy4gVGhpcyBtZWFucyB3ZSBkb24ndCBoYXZlIHRvIHNwbGl0IHRoZVxuICAgICAgICAgICAgLy8gZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGNsb25lZCBoZXJlIGJlY2F1c2Ugb2Ygc2hhcmVkIGNsYXNzZXMsIHNlZVxuICAgICAgICAgICAgLy8gc2hhcmVkY2xhc3MubXNzXG4gICAgICAgICAgICBjdXJyZW50W2tdID0gY3VycmVudFtrXS5jbG9uZSgpO1xuICAgICAgICAgICAgY3VycmVudFtrXS5hZGRSdWxlcyhuZXdSdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdXBkYXRlZEZlYXR1cmVzIGlzIGZhbHNlLCB0aGVuIHRoZSBmaWx0ZXJzIHNwbGl0IHRoZSBydWxlLFxuICAgICAgICAvLyBzbyB0aGV5IGFyZW4ndCB0aGUgc2FtZSBpbmhlcml0YW5jZSBjaGFpblxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBBcHBseSBpbmhlcml0ZWQgc3R5bGVzIGZyb20gdGhlaXIgYW5jZXN0b3JzIHRvIHRoZW0uXG4gKlxuICogY2FsbGVkIGVpdGhlciBvbmNlIHBlciByZW5kZXIgKGluIHRoZSBjYXNlIG9mIG1zcykgb3IgcGVyIGxheWVyXG4gKiAoZm9yIG1tbClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbnMgLSBhIGxpc3Qgb2YgZGVmaW5pdGlvbnMgb2JqZWN0c1xuICogICB0aGF0IGNvbnRhaW4gLnJ1bGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZW52IC0gdGhlIGVudmlyb25tZW50XG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheT59IGFuIGFycmF5IG9mIGFycmF5cyBpcyByZXR1cm5lZCxcbiAqICAgaW4gd2hpY2ggZWFjaCBhcnJheSByZWZlcnMgdG8gYSBzcGVjaWZpYyBhdHRhY2htZW50XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXREZWZpbml0aW9ucyhkZWZpbml0aW9ucywgZW52KSB7XG4gICAgdmFyIGluaGVyaXRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgLy8gZGVmaW5pdGlvbnMgYXJlIG9yZGVyZWQgYnkgc3BlY2lmaWNpdHksXG4gICAgLy8gaGlnaCAoaW5kZXggMCkgdG8gbG93XG4gICAgdmFyIGJ5QXR0YWNobWVudCA9IHt9LFxuICAgICAgICBieUZpbHRlciA9IHt9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgY3VycmVudCwgcHJldmlvdXMsIGF0dGFjaG1lbnQ7XG5cbiAgICAvLyBFdmFsdWF0ZSB0aGUgZmlsdGVycyBzcGVjaWZpZWQgYnkgZWFjaCBkZWZpbml0aW9uIHdpdGggdGhlIGdpdmVuXG4gICAgLy8gZW52aXJvbm1lbnQgdG8gY29ycmVjdGx5IHJlc29sdmUgdmFyaWFibGUgcmVmZXJlbmNlc1xuICAgIGRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICBkLmZpbHRlcnMuZXYoZW52KTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmaW5pdGlvbnMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBhdHRhY2htZW50ID0gZGVmaW5pdGlvbnNbaV0uYXR0YWNobWVudDtcbiAgICAgICAgY3VycmVudCA9IFtkZWZpbml0aW9uc1tpXV07XG5cbiAgICAgICAgaWYgKCFieUF0dGFjaG1lbnRbYXR0YWNobWVudF0pIHtcbiAgICAgICAgICAgIGJ5QXR0YWNobWVudFthdHRhY2htZW50XSA9IFtdO1xuICAgICAgICAgICAgYnlBdHRhY2htZW50W2F0dGFjaG1lbnRdLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgYnlGaWx0ZXJbYXR0YWNobWVudF0gPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ5QXR0YWNobWVudFthdHRhY2htZW50XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIHN1YnNlcXVlbnQgcnVsZXMuXG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGRlZmluaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbal0uYXR0YWNobWVudCA9PT0gYXR0YWNobWVudCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaW5oZXJpdCBydWxlcyBmcm9tIHRoZSBzYW1lIGF0dGFjaG1lbnQuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGFkZFJ1bGVzKGN1cnJlbnQsIGRlZmluaXRpb25zW2pdLCBieUZpbHRlclthdHRhY2htZW50XSwgZW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY3VycmVudC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgYnlGaWx0ZXJbYXR0YWNobWVudF1bY3VycmVudFtrXS5maWx0ZXJzXSA9IGN1cnJlbnRba107XG4gICAgICAgICAgICBieUF0dGFjaG1lbnRbYXR0YWNobWVudF0ucHVzaChjdXJyZW50W2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnYuYmVuY2htYXJrKSBjb25zb2xlLndhcm4oJ0luaGVyaXRhbmNlIHRpbWU6ICcgKyAoKG5ldyBEYXRlKCkgLSBpbmhlcml0VGltZSkpICsgJ21zJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59XG5cbi8vIFNvcnQgc3R5bGVzIGJ5IHRoZSBtaW5pbXVtIGluZGV4IG9mIHRoZWlyIHJ1bGVzLlxuLy8gVGhpcyBzb3J0cyBhIHNsaWNlIG9mIHRoZSBzdHlsZXMsIHNvIGl0IHJldHVybnMgYSBzb3J0ZWRcbi8vIGFycmF5IGJ1dCBkb2VzIG5vdCBjaGFuZ2UgdGhlIGlucHV0LlxuZnVuY3Rpb24gc29ydFN0eWxlc0luZGV4KGEsIGIpIHsgcmV0dXJuIGIuaW5kZXggLSBhLmluZGV4OyB9XG5mdW5jdGlvbiBzb3J0U3R5bGVzKHN0eWxlcywgZW52KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICBzdHlsZS5pbmRleCA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IHN0eWxlLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBzdHlsZVtiXS5ydWxlcztcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnVsZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW3JdO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmluZGV4IDwgc3R5bGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5kZXggPSBydWxlLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzdHlsZXMuc2xpY2UoKTtcbiAgICByZXN1bHQuc29ydChzb3J0U3R5bGVzSW5kZXgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmluZCBhIHJ1bGUgbGlrZSBNYXAgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9LFxuICogaWYgYW55LCBhbmQgcmV0dXJuIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGJlIGluc2VydGVkXG4gKiBpbnRvIHRoZSA8TWFwIGVsZW1lbnQgb2YgdGhlIHJlc3VsdGluZyBYTUwuIFRyYW5zbGF0ZXNcbiAqIHByb3BlcnRpZXMgb2YgdGhlIG1tbCBvYmplY3QgYXQgYG1gIGRpcmVjdGx5IGludG8gWE1MXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtIHRoZSBtbWwgb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheX0gZGVmaW5pdGlvbnMgdGhlIG91dHB1dCBvZiB0b0xpc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gZW52XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJlbmRlcmVkIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcFByb3BlcnRpZXMobSwgZGVmaW5pdGlvbnMsIGVudikge1xuICAgIHZhciBydWxlcyA9IHt9O1xuICAgIHZhciBzeW1ib2xpemVycyA9IGNhcnRvLnRyZWUuUmVmZXJlbmNlLmRhdGEuc3ltYm9saXplcnMubWFwO1xuXG4gICAgXyhtKS5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiBzeW1ib2xpemVycykgcnVsZXNba2V5XSA9IGtleSArICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgIH0pO1xuXG4gICAgZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuZWxlbWVudHMuam9pbignJykgPT09ICdNYXAnO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByLnJ1bGVzW2ldLm5hbWU7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gc3ltYm9saXplcnMpKSB7XG4gICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1J1bGUgJyArIGtleSArICcgbm90IGFsbG93ZWQgZm9yIE1hcC4nLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogci5ydWxlc1tpXS5pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVsZXNba2V5XSA9IHIucnVsZXNbaV0uZXYoZW52KS50b1hNTChlbnYpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJ1bGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhcnRvO1xubW9kdWxlLmV4cG9ydHMuYWRkUnVsZXMgPSBhZGRSdWxlcztcbm1vZHVsZS5leHBvcnRzLmluaGVyaXREZWZpbml0aW9ucyA9IGluaGVyaXREZWZpbml0aW9ucztcbm1vZHVsZS5leHBvcnRzLnNvcnRTdHlsZXMgPSBzb3J0U3R5bGVzO1xuIiwiKGZ1bmN0aW9uKGNhcnRvKSB7XG52YXIgdHJlZSA9IHJlcXVpcmUoJy4vdHJlZScpO1xudmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cblxuZnVuY3Rpb24gQ2FydG9DU1Moc3R5bGUsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5pbWFnZVVSTHMgPSBbXTtcbiAgaWYoc3R5bGUpIHtcbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgfVxufVxuXG5DYXJ0b0NTUy5MYXllciA9IGZ1bmN0aW9uKHNoYWRlciwgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbn07XG5cblxuQ2FydG9DU1MuTGF5ZXIucHJvdG90eXBlID0ge1xuXG4gIGZ1bGxOYW1lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIuYXR0YWNobWVudDtcbiAgfSxcblxuICBuYW1lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsTmFtZSgpLnNwbGl0KCc6OicpWzBdO1xuICB9LFxuXG4gIC8vIGZyYW1lcyB0aGlzIGxheWVyIG5lZWQgdG8gYmUgcmVuZGVyZWRcbiAgZnJhbWVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIuZnJhbWVzO1xuICB9LFxuXG4gIGF0dGFjaG1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxOYW1lKCkuc3BsaXQoJzo6JylbMV07XG4gIH0sXG5cbiAgZXZhbDogZnVuY3Rpb24ocHJvcCkge1xuICAgIHZhciBwID0gdGhpcy5zaGFkZXJbcHJvcF07XG4gICAgaWYgKCFwIHx8ICFwLnN0eWxlKSByZXR1cm47XG4gICAgcmV0dXJuIHAuc3R5bGUoe30sIHsgem9vbTogMCwgJ2ZyYW1lLW9mZnNldCc6IDAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogYHByb3BzYDogZmVhdHVyZSBwcm9wZXJ0aWVzXG4gICAqIGBjb250ZXh0YDogcmVuZGVyaW5nIHByb3BlcnRpZXMsIGkuZSB6b29tXG4gICAqL1xuICBnZXRTdHlsZTogZnVuY3Rpb24ocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICBmb3IodmFyIGkgaW4gdGhpcy5zaGFkZXIpIHtcbiAgICAgIGlmKGkgIT09ICdhdHRhY2htZW50JyAmJiBpICE9PSAnem9vbScgJiYgaSAhPT0gJ2ZyYW1lcycgJiYgaSAhPT0gJ3N5bWJvbGl6ZXJzJykge1xuICAgICAgICBzdHlsZVtpXSA9IHRoaXMuc2hhZGVyW2ldLnN0eWxlKHByb3BzLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIHN5bWJvbGl6ZXJzIHRoYXQgbmVlZCB0byBiZSByZW5kZXJlZCB3aXRoIFxuICAgKiB0aGlzIHN0eWxlLiBUaGUgb3JkZXIgaXMgdGhlIHJlbmRlcmluZyBvcmRlci5cbiAgICogQHJldHVybnMgYSBsaXN0IHdpdGggMyBwb3NzaWJsZSB2YWx1ZXMgJ2xpbmUnLCAnbWFya2VyJywgJ3BvbHlnb24nXG4gICAqL1xuICBnZXRTeW1ib2xpemVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLnN5bWJvbGl6ZXJzO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGlmIHRoZSBzdHlsZSB2YXJpZXMgd2l0aCBzb21lIGZlYXR1cmUgcHJvcGVydHkuXG4gICAqIFVzZWZ1bCB0byBvcHRpbWl6ZSByZW5kZXJpbmdcbiAgICovXG4gIGlzVmFyaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgaSBpbiB0aGlzLnNoYWRlcikge1xuICAgICAgaWYoaSAhPT0gJ2F0dGFjaG1lbnQnICYmIGkgIT09ICd6b29tJyAmJiBpICE9PSAnZnJhbWVzJyAmJiBpICE9PSAnc3ltYm9saXplcnMnKSB7XG4gICAgICAgIGlmICghdGhpcy5zaGFkZXJbaV0uY29uc3RhbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0U2hhZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgdHJ1ZSBpZiBhIGZlYXR1cmUgbmVlZHMgdG8gYmUgcmVuZGVyZWRcbiAgICovXG4gIGZpbHRlcjogZnVuY3Rpb24oZmVhdHVyZVR5cGUsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgZm9yKHZhciBpIGluIHRoaXMuc2hhZGVyKSB7XG4gICAgIHZhciBzID0gdGhpcy5zaGFkZXJbaV0ocHJvcHMsIGNvbnRleHQpO1xuICAgICBpZihzKSB7XG4gICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8vXG4gIC8vIGdpdmVuIGEgZ2VvZW10cnkgdHlwZSByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCBvbmUgYWNvcmRpbmcgdGhlIENhcnRvQ1NTXG4gIC8vIEZvciBwb2ludHMgdGhlcmUgYXJlIHR3byBraW5kIG9mIHR5cGVzOiBwb2ludCBhbmQgc3ByaXRlLCB0aGUgZmlyc3Qgb25lIFxuICAvLyBpcyBhIGNpcmNsZSwgc2Vjb25kIG9uZSBpcyBhbiBpbWFnZSBzcHJpdGVcbiAgLy9cbiAgLy8gdGhlIG90aGVyIGdlb21ldHJ5IHR5cGVzIGFyZSB0aGUgc2FtZSB0aGFuIGdlb2pzb24gKHBvbHlnb24sIGxpbmVzdHJpbmcuLi4pXG4gIC8vXG4gIHRyYW5zZm9ybUdlb21ldHJ5OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH0sXG5cbiAgdHJhbnNmb3JtR2VvbWV0cmllczogZnVuY3Rpb24oZ2VvanNvbikge1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbn07XG5cbkNhcnRvQ1NTLnByb3RvdHlwZSA9IHtcblxuICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5wYXJzZShzdHlsZSk7XG4gICAgaWYoIWxheWVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMucGFyc2VfZW52LmVycm9ycyk7XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzLm1hcChmdW5jdGlvbihzaGFkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJ0b0NTUy5MYXllcihzaGFkZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICB9LFxuXG4gIGdldERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRMYXllcih7IGF0dGFjaG1lbnQ6ICdfX2RlZmF1bHRfXycgfSk7XG4gIH0sXG5cbiAgZmluZExheWVyOiBmdW5jdGlvbih3aGVyZSkge1xuICAgIHJldHVybiBfLmZpbmQodGhpcy5sYXllcnMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gd2hlcmUpIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mKHYpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdiA9IHYuY2FsbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoZXJlW2tleV0gIT09IHYpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9LFxuXG4gIF9jcmVhdGVGbjogZnVuY3Rpb24ob3BzKSB7XG4gICAgdmFyIGJvZHkgPSBvcHMuam9pbignXFxuJyk7XG4gICAgaWYodGhpcy5vcHRpb25zLmRlYnVnKSBjb25zb2xlLmxvZyhib2R5KTtcbiAgICByZXR1cm4gRnVuY3Rpb24oXCJkYXRhXCIsXCJjdHhcIiwgXCJ2YXIgX3ZhbHVlID0gbnVsbDsgXCIgKyAgYm9keSArIFwiOyByZXR1cm4gX3ZhbHVlOyBcIik7XG4gIH0sXG5cbiAgX2NvbXBpbGU6IGZ1bmN0aW9uKHNoYWRlcikge1xuICAgIGlmKHR5cGVvZiBzaGFkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNoYWRlciA9IGV2YWwoXCIoZnVuY3Rpb24oKSB7IHJldHVybiBcIiArIHNoYWRlciArXCI7IH0pKClcIik7XG4gICAgfVxuICAgIHRoaXMuc2hhZGVyX3NyYyA9IHNoYWRlcjtcbiAgICBmb3IodmFyIGF0dHIgaW4gc2hhZGVyKSB7XG4gICAgICAgIHZhciBjID0gbWFwcGVyW2F0dHJdO1xuICAgICAgICBpZihjKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkW2NdID0gZXZhbChcIihmdW5jdGlvbigpIHsgcmV0dXJuIHNoYWRlclthdHRyXTsgfSkoKTtcIik7XG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldEltYWdlVVJMczogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVVSTHM7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGNhcnRvY3NzKSB7XG4gICAgdmFyIHBhcnNlX2VudiA9IHtcbiAgICAgIGZyYW1lczogW10sXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnBhcnNlX2VudiA9IHBhcnNlX2VudjtcblxuICAgIHZhciBydWxlc2V0ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcnVsZXNldCA9IChuZXcgY2FydG8uUGFyc2VyKHBhcnNlX2VudikpLnBhcnNlKGNhcnRvY3NzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIGFkZCB0aGUgc3R5bGUubXNzIHN0cmluZyB0byBtYXRjaCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICBwYXJzZV9lbnYuZXJyb3JzLnB1c2goZS5tZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYocnVsZXNldCkge1xuXG4gICAgICBmdW5jdGlvbiBkZWZLZXkoZGVmKSB7XG4gICAgICAgIHJldHVybiBkZWYuZWxlbWVudHNbMF0gKyBcIjo6XCIgKyBkZWYuYXR0YWNobWVudDtcbiAgICAgIH1cbiAgICAgIHZhciBkZWZzID0gcnVsZXNldC50b0xpc3QocGFyc2VfZW52KTtcbiAgICAgIGRlZnMucmV2ZXJzZSgpO1xuICAgICAgLy8gZ3JvdXAgYnkgZWxlbWVudHNbMF0udmFsdWU6OmF0dGFjaG1lbnRcbiAgICAgIHZhciBsYXllcnMgPSB7fTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkZWZzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2ldO1xuICAgICAgICB2YXIga2V5ID0gZGVmS2V5KGRlZik7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1trZXldID0gKGxheWVyc1trZXldIHx8IHtcbiAgICAgICAgICBzeW1ib2xpemVyczogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcih2YXIgdSA9IDA7IHU8ZGVmLnJ1bGVzLmxlbmd0aDsgdSsrKXtcbiAgICAgICAgICAgIGlmKGRlZi5ydWxlc1t1XS5uYW1lID09PSBcIm1hcmtlci1maWxlXCIgfHwgZGVmLnJ1bGVzW3VdLm5hbWUgPT09IFwicG9pbnQtZmlsZVwiKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWYucnVsZXNbdV0udmFsdWUudmFsdWVbMF0udmFsdWVbMF0udmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZVVSTHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGxheWVyLmZyYW1lcyA9IFtdO1xuICAgICAgICBsYXllci56b29tID0gdHJlZS5ab29tLmFsbDtcbiAgICAgICAgdmFyIHByb3BzID0gZGVmLnRvSlMocGFyc2VfZW52KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coXCJwcm9wc1wiLCBwcm9wcyk7XG4gICAgICAgIGZvcih2YXIgdiBpbiBwcm9wcykge1xuICAgICAgICAgIHZhciBseXIgPSBsYXllclt2XSA9IGxheWVyW3ZdIHx8IHtcbiAgICAgICAgICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICAgIHN5bWJvbGl6ZXI6IG51bGwsXG4gICAgICAgICAgICBqczogW10sXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gYnVpbGQgamF2YXNjcmlwdCBzdGF0ZW1lbnRzXG4gICAgICAgICAgbHlyLmpzLnB1c2gocHJvcHNbdl0ubWFwKGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEuanM7IH0pLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAvLyBnZXQgc3ltYm9saXplciBmb3IgcHJvcFxuICAgICAgICAgIGx5ci5zeW1ib2xpemVyID0gXy5maXJzdChwcm9wc1t2XS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5zeW1ib2xpemVyOyB9KSk7XG4gICAgICAgICAgLy8gc2VyYWNoIHRoZSBtYXggaW5kZXggdG8ga25vdyByZW5kZXJpbmcgb3JkZXJcbiAgICAgICAgICBseXIuaW5kZXggPSBfLm1heChwcm9wc1t2XS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5pbmRleDsgfSkuY29uY2F0KGx5ci5pbmRleCkpO1xuICAgICAgICAgIGx5ci5jb25zdGFudCA9ICFfLmFueShwcm9wc1t2XS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gIWEuY29uc3RhbnQ7IH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXJlZF9sYXllcnMgPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIGNvbnNvbGUubG9nKGxheWVycyk7XG5cbiAgICAgIHZhciBkb25lID0ge307XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgdmFyIGsgPSBkZWZLZXkoZGVmKTtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2tdO1xuICAgICAgICBpZighZG9uZVtrXSkge1xuICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coXCIqKlwiLCBrKTtcbiAgICAgICAgICBmb3IodmFyIHByb3AgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnem9vbScgJiYgcHJvcCAhPT0gJ2ZyYW1lcycgJiYgcHJvcCAhPT0gJ3N5bWJvbGl6ZXJzJykge1xuICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGVidWcpIGNvbnNvbGUubG9nKFwiKlwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgbGF5ZXJbcHJvcF0uc3R5bGUgPSB0aGlzLl9jcmVhdGVGbihsYXllcltwcm9wXS5qcyk7XG4gICAgICAgICAgICAgIGxheWVyLnN5bWJvbGl6ZXJzLnB1c2gobGF5ZXJbcHJvcF0uc3ltYm9saXplcik7XG4gICAgICAgICAgICAgIGxheWVyLnN5bWJvbGl6ZXJzID0gXy51bmlxKGxheWVyLnN5bWJvbGl6ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGF5ZXIuYXR0YWNobWVudCA9IGs7XG4gICAgICAgICAgb3JkZXJlZF9sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgZG9uZVtrXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIuem9vbSB8PSBkZWYuem9vbTtcbiAgICAgICAgbGF5ZXIuZnJhbWVzLnB1c2goZGVmLmZyYW1lX29mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVuaXEgdGhlIGZyYW1lc1xuICAgICAgZm9yKGkgPSAwOyBpIDwgb3JkZXJlZF9sYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgb3JkZXJlZF9sYXllcnNbaV0uZnJhbWVzID0gXy51bmlxKG9yZGVyZWRfbGF5ZXJzW2ldLmZyYW1lcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmRlcmVkX2xheWVycztcblxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG5jYXJ0by5SZW5kZXJlckpTID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbiA9IHRoaXMub3B0aW9ucy5tYXBuaWtfdmVyc2lvbiB8fCAnbGF0ZXN0Jztcbn07XG5cbi8vIFByZXBhcmUgYSBqYXZhc2NyaXB0IG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbGF5ZXJzXG5jYXJ0by5SZW5kZXJlckpTLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2FydG9jc3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vdG9ycXVlLXJlZmVyZW5jZScpO1xuICAgIHRyZWUuUmVmZXJlbmNlLnNldERhdGEocmVmZXJlbmNlLnZlcnNpb24ubGF0ZXN0KTtcbiAgICByZXR1cm4gbmV3IENhcnRvQ1NTKGNhcnRvY3NzLCB0aGlzLm9wdGlvbnMpO1xufVxuXG5pZih0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjYXJ0by5SZW5kZXJlckpTO1xufVxuXG5cbn0pKHJlcXVpcmUoJy4uL2NhcnRvJykpO1xuIiwidmFyIF9tYXBuaWtfcmVmZXJlbmNlX2xhdGVzdCA9IHtcbiAgICBcInZlcnNpb25cIjogXCIyLjEuMVwiLFxuICAgIFwic3R5bGVcIjoge1xuICAgICAgICBcImZpbHRlci1tb2RlXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgXCJhbGxcIixcbiAgICAgICAgICAgICAgICBcImZpcnN0XCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgdGhlIHByb2Nlc3NpbmcgYmVoYXZpb3Igb2YgUnVsZSBmaWx0ZXJzIHdpdGhpbiBhIFN0eWxlLiBJZiAnYWxsJyBpcyB1c2VkIHRoZW4gYWxsIFJ1bGVzIGFyZSBwcm9jZXNzZWQgc2VxdWVudGlhbGx5IGluZGVwZW5kZW50IG9mIHdoZXRoZXIgYW55IHByZXZpb3VzIGZpbHRlcnMgbWF0Y2hlZC4gSWYgJ2ZpcnN0JyBpcyB1c2VkIHRoZW4gaXQgbWVhbnMgcHJvY2Vzc2luZyBlbmRzIGFmdGVyIHRoZSBmaXJzdCBtYXRjaCAoYSBwb3NpdGl2ZSBmaWx0ZXIgZXZhbHVhdGlvbikgYW5kIG5vIGZ1cnRoZXIgUnVsZXMgaW4gdGhlIFN0eWxlIGFyZSBwcm9jZXNzZWQgKCdmaXJzdCcgaXMgdXN1YWxseSB0aGUgZGVmYXVsdCBmb3IgQ1NTIGltcGxlbWVudGF0aW9ucyBvbiB0b3Agb2YgTWFwbmlrIHRvIHNpbXBsaWZ5IHRyYW5zbGF0aW9uIGZyb20gQ1NTIHRvIE1hcG5payBYTUwpXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJhbGxcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQWxsIFJ1bGVzIGluIGEgU3R5bGUgYXJlIHByb2Nlc3NlZCB3aGV0aGVyIHRoZXkgaGF2ZSBmaWx0ZXJzIG9yIG5vdCBhbmQgd2hldGhlciBvciBub3QgdGhlIGZpbHRlciBjb25kaXRpb25zIGV2YWx1YXRlIHRvIHRydWUuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbWFnZS1maWx0ZXJzXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiaW1hZ2UtZmlsdGVyc1wiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBmaWx0ZXJzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICBbXCJhZ2ctc3RhY2stYmx1clwiLCAyXSxcbiAgICAgICAgICAgICAgICBbXCJlbWJvc3NcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wiYmx1clwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJncmF5XCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcInNvYmVsXCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImVkZ2UtZGV0ZWN0XCIsIDBdLFxuICAgICAgICAgICAgICAgIFtcIngtZ3JhZGllbnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wieS1ncmFkaWVudFwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJpbnZlcnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgW1wic2hhcnBlblwiLCAwXSxcbiAgICAgICAgICAgICAgICBbXCJjb2xvcml6ZS1hbHBoYVwiLCAtMV0sXG4gICAgICAgICAgICAgICAgW1wiY29sb3ItdG8tYWxwaGFcIiwgMV0sXG4gICAgICAgICAgICAgICAgW1wic2NhbGUtaHNsYVwiLCA4XVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBsaXN0IG9mIGltYWdlIGZpbHRlcnMuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgIFwiY3NzXCI6IFwiY29tcC1vcFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IGxheWVyIG9uIHRvcCBvZiBvdGhlciBsYXllcnNcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIGxheWVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gbGF5ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogW1wiY2xlYXJcIixcbiAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwic291cmNlLW92ZXJcIiwgLy8gYWRkZWQgZm9yIHRvcnF1ZVxuICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgIFwibGlnaHRlclwiLCAvLyBhZGRlZCBmb3IgdG9ycXVlXG4gICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgXCJjc3NcIjogXCJvcGFjaXR5XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBhbHBoYSB2YWx1ZSBmb3IgdGhlIHN0eWxlICh3aGljaCBtZWFucyBhbiBhbHBoYSBhcHBsaWVkIHRvIGFsbCBmZWF0dXJlcyBpbiBzZXBhcmF0ZSBidWZmZXIgYW5kIHRoZW4gY29tcG9zaXRlZCBiYWNrIHRvIG1haW4gYnVmZmVyKVwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNlcGFyYXRlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYW5kIG5vIGFscGhhIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgc3R5bGUgYWZ0ZXIgcmVuZGVyaW5nXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJsYXllclwiIDoge1xuICAgICAgICBcIm5hbWVcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICBcInR5cGVcIjpcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiIDogdHJ1ZSxcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gbGF5ZXIgbmFtZSBoYXMgYmVlbiBwcm92aWRlZFwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbmFtZSBvZiBhIGxheWVyLiBDYW4gYmUgYW55dGhpbmcgeW91IHdpc2ggYW5kIGlzIG5vdCBzdHJpY3RseSB2YWxpZGF0ZWQsIGJ1dCBpZGVhbGx5IHVuaXF1ZSAgaW4gdGhlIG1hcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3JzXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gc3JzIHZhbHVlIGlzIHByb3ZpZGVkIGFuZCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgTWFwJ3Mgc3JzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW0gZGVmaW5pdGlvbiBmb3IgdGhlIGxheWVyLCBha2EgdGhlIHByb2plY3Rpb24uIENhbiBlaXRoZXIgYmUgYSBwcm9qNCBsaXRlcmFsIHN0cmluZyBsaWtlICcrcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK25vX2RlZnMnIG9yLCBpZiB0aGUgcHJvcGVyIHByb2o0IGVwc2cvbmFkL2V0YyBpZGVudGlmaWVyIGZpbGVzIGFyZSBpbnN0YWxsZWQsIGEgc3RyaW5nIHRoYXQgdXNlcyBhbiBpZCBsaWtlOiAnK2luaXQ9ZXBzZzo0MzI2J1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoaXMgbGF5ZXIgd2lsbCBiZSBtYXJrZWQgYXMgYWN0aXZlIGFuZCBhdmFpbGFibGUgZm9yIHByb2Nlc3NpbmdcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBwcm9wZXJ0eSB0aGF0IGNhbiBiZSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGxheWVyIGZyb20gYmVpbmcgcHJvY2Vzc2VkXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtaW56b29tXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjBcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIGxheWVyIHdpbGwgYmUgdmlzaWJsZSBhdCB0aGUgbWluaW11bSBwb3NzaWJsZSBzY2FsZVwiLFxuICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSBzY2FsZSBkZW5vbWluYXRvciB0aGF0IHRoaXMgbGF5ZXIgd2lsbCBiZSB2aXNpYmxlIGF0LiBBIGxheWVyJ3MgdmlzaWJpbGl0eSBpcyBkZXRlcm1pbmVkIGJ5IHdoZXRoZXIgaXRzIHN0YXR1cyBpcyB0cnVlIGFuZCBpZiB0aGUgTWFwIHNjYWxlID49IG1pbnpvb20gLSAxZS02IGFuZCBzY2FsZSA8IG1heHpvb20gKyAxZS02XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXh6b29tXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjEuNzk3NjllKzMwOFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbGF5ZXIgd2lsbCBiZSB2aXNpYmxlIGF0IHRoZSBtYXhpbXVtIHBvc3NpYmxlIHNjYWxlXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHNjYWxlIGRlbm9taW5hdG9yIHRoYXQgdGhpcyBsYXllciB3aWxsIGJlIHZpc2libGUgYXQuIFRoZSBkZWZhdWx0IGlzIHRoZSBudW1lcmljIGxpbWl0IG9mIHRoZSBDKysgZG91YmxlIHR5cGUsIHdoaWNoIG1heSB2YXJ5IHNsaWdodGx5IGJ5IHN5c3RlbSwgYnV0IGlzIGxpa2VseSBhIG1hc3NpdmUgbnVtYmVyIGxpa2UgMS43OTc2OWUrMzA4IGFuZCBlbnN1cmVzIHRoYXQgdGhpcyBsYXllciB3aWxsIGFsd2F5cyBiZSB2aXNpYmxlIHVubGVzcyB0aGUgdmFsdWUgaXMgcmVkdWNlZC4gQSBsYXllcidzIHZpc2liaWxpdHkgaXMgZGV0ZXJtaW5lZCBieSB3aGV0aGVyIGl0cyBzdGF0dXMgaXMgdHJ1ZSBhbmQgaWYgdGhlIE1hcCBzY2FsZSA+PSBtaW56b29tIC0gMWUtNiBhbmQgc2NhbGUgPCBtYXh6b29tICsgMWUtNlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicXVlcnlhYmxlXCI6IHtcbiAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwidHlwZVwiOlwiYm9vbGVhblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJUaGUgbGF5ZXIgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGZvciB0aGUgZGlyZWN0IHF1ZXJ5aW5nIG9mIGRhdGEgdmFsdWVzXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIlRoaXMgcHJvcGVydHkgd2FzIGFkZGVkIGZvciBHZXRGZWF0dXJlSW5mby9XTVMgY29tcGF0aWJpbGl0eSBhbmQgaXMgcmFyZWx5IHVzZWQuIEl0IGlzIG9mZiBieSBkZWZhdWx0IG1lYW5pbmcgdGhhdCBpbiBhIFdNUyBjb250ZXh0IHRoZSBsYXllciB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIHF1ZXJpZWQgdW5sZXNzIHRoZSBwcm9wZXJ0eSBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjbGVhci1sYWJlbC1jYWNoZVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICBcInR5cGVcIjpcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIHJlbmRlcmVyJ3MgY29sbGlzaW9uIGRldGVjdG9yIGNhY2hlICh1c2VkIGZvciBhdm9pZGluZyBkdXBsaWNhdGUgbGFiZWxzIGFuZCBvdmVybGFwcGluZyBtYXJrZXJzKSB3aWxsIG5vdCBiZSBjbGVhcmVkIGltbWVkaWF0ZWx5IGJlZm9yZSBwcm9jZXNzaW5nIHRoaXMgbGF5ZXJcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhpcyBwcm9wZXJ0eSwgYnkgZGVmYXVsdCBvZmYsIGNhbiBiZSBlbmFibGVkIHRvIGFsbG93IGEgdXNlciB0byBjbGVhciB0aGUgY29sbGlzaW9uIGRldGVjdG9yIGNhY2hlIGJlZm9yZSBhIGdpdmVuIGxheWVyIGlzIHByb2Nlc3NlZC4gVGhpcyBtYXkgYmUgZGVzaXJhYmxlIHRvIGVuc3VyZSB0aGF0IGEgZ2l2ZW4gbGF5ZXJzIGRhdGEgc2hvd3MgdXAgb24gdGhlIG1hcCBldmVuIGlmIGl0IG5vcm1hbGx5IHdvdWxkIG5vdCBiZWNhdXNlIG9mIGNvbGxpc2lvbnMgd2l0aCBwcmV2aW91c2x5IHJlbmRlcmVkIGxhYmVscyBvciBtYXJrZXJzXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJncm91cC1ieVwiOiB7XG4gICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOlwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIHNwZWNpYWwgbGF5ZXIgZ3JvdXBpbmcgd2lsbCBiZSB1c2VkIGR1cmluZyByZW5kZXJpbmdcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL21hcG5pay9tYXBuaWsvd2lraS9Hcm91cGVkLXJlbmRlcmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYnVmZmVyLXNpemVcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBidWZmZXIgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICBcImRvY1wiOiBcIkV4dHJhIHRvbGVyYW5jZSBhcm91bmQgdGhlIExheWVyIGV4dGVudCAoaW4gcGl4ZWxzKSB1c2VkIHRvIHdoZW4gcXVlcnlpbmcgYW5kIChwb3RlbnRpYWxseSkgY2xpcHBpbmcgdGhlIGxheWVyIGRhdGEgZHVyaW5nIHJlbmRlcmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4aW11bS1leHRlbnRcIjoge1xuICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6XCJiYm94XCIsXG4gICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGNsaXBwaW5nIGV4dGVudCB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gZXh0ZW50IHRvIGJlIHVzZWQgdG8gbGltaXQgdGhlIGJvdW5kcyB1c2VkIHRvIHF1ZXJ5IHRoaXMgc3BlY2lmaWMgbGF5ZXIgZGF0YSBkdXJpbmcgcmVuZGVyaW5nLiBTaG91bGQgYmUgbWlueCwgbWlueSwgbWF4eCwgbWF4eSBpbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIExheWVyLlwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwic3ltYm9saXplcnNcIiA6IHtcbiAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICAgIFwiaW1hZ2UtZmlsdGVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJpbWFnZS1maWx0ZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gZmlsdGVyc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uc1wiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgW1wiYWdnLXN0YWNrLWJsdXJcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcImVtYm9zc1wiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiYmx1clwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiZ3JheVwiLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic29iZWxcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImVkZ2UtZGV0ZWN0XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ4LWdyYWRpZW50XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ5LWdyYWRpZW50XCIsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbXCJpbnZlcnRcIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNoYXJwZW5cIiwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcImNvbG9yaXplLWFscGhhXCIsIC0xXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiY29sb3ItdG8tYWxwaGFcIiwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNjYWxlLWhzbGFcIiwgOF1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBsaXN0IG9mIGltYWdlIGZpbHRlcnMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgbGF5ZXIgb24gdG9wIG9mIG90aGVyIGxheWVyc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIGxheWVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gbGF5ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2Utb3ZlclwiLCAvLyBhZGRlZCBmb3IgdG9ycXVlXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlclwiLCAvLyBhZGRlZCBmb3IgdG9ycXVlXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwib3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBhbHBoYSB2YWx1ZSBmb3IgdGhlIHN0eWxlICh3aGljaCBtZWFucyBhbiBhbHBoYSBhcHBsaWVkIHRvIGFsbCBmZWF0dXJlcyBpbiBzZXBhcmF0ZSBidWZmZXIgYW5kIHRoZW4gY29tcG9zaXRlZCBiYWNrIHRvIG1haW4gYnVmZmVyKVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc2VwYXJhdGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhbmQgbm8gYWxwaGEgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBzdHlsZSBhZnRlciByZW5kZXJpbmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1hcFwiOiB7XG4gICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIk1hcCBCYWNrZ3JvdW5kIGNvbG9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJhY2tncm91bmQtaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiYmFja2dyb3VuZC1pbWFnZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVyaVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIGltYWdlIHRoYXQgaXMgcmVwZWF0ZWQgYmVsb3cgYWxsIGZlYXR1cmVzIG9uIGEgbWFwIGFzIGEgYmFja2dyb3VuZC5cIixcbiAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWFwIEJhY2tncm91bmQgaW1hZ2VcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3JzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNyc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIitwcm9qPWxvbmdsYXQgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArbm9fZGVmc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIHByb2o0IGxpdGVyYWwgb2YgRVBTRzo0MzI2IGlzIGFzc3VtZWQgdG8gYmUgdGhlIE1hcCdzIHNwYXRpYWwgcmVmZXJlbmNlIGFuZCBhbGwgZGF0YSBmcm9tIGxheWVycyB3aXRoaW4gdGhpcyBtYXAgd2lsbCBiZSBwbG90dGVkIHVzaW5nIHRoaXMgY29vcmRpbmF0ZSBzeXN0ZW0uIElmIGFueSBsYXllcnMgZG8gbm90IGRlY2xhcmUgYW4gc3JzIHZhbHVlIHRoZW4gdGhleSB3aWxsIGJlIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgc3JzIGFzIHRoZSBNYXAgYW5kIG5vdCB0cmFuc2Zvcm1hdGlvbnMgd2lsbCBiZSBuZWVkZWQgdG8gcGxvdCB0aGVtIGluIHRoZSBNYXAncyBjb29yZGluYXRlIHNwYWNlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJNYXAgc3BhdGlhbCByZWZlcmVuY2UgKHByb2o0IHN0cmluZylcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYnVmZmVyLXNpemVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiYnVmZmVyLXNpemVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6XCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gYnVmZmVyIHdpbGwgYmUgdXNlZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRXh0cmEgdG9sZXJhbmNlIGFyb3VuZCB0aGUgbWFwIChpbiBwaXhlbHMpIHVzZWQgdG8gZW5zdXJlIGxhYmVscyBjcm9zc2luZyB0aWxlIGJvdW5kYXJpZXMgYXJlIGVxdWFsbHkgcmVuZGVyZWQgaW4gZWFjaCB0aWxlIChlLmcuIGN1dCBpbiBlYWNoIHRpbGUpLiBOb3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIFxcXCJhdm9pZC1lZGdlc1xcXCIuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1heGltdW0tZXh0ZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjpcImJib3hcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk5vIGNsaXBwaW5nIGV4dGVudCB3aWxsIGJlIHVzZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIGV4dGVudCB0byBiZSB1c2VkIHRvIGxpbWl0IHRoZSBib3VuZHMgdXNlZCB0byBxdWVyeSBhbGwgbGF5ZXJzIGR1cmluZyByZW5kZXJpbmcuIFNob3VsZCBiZSBtaW54LCBtaW55LCBtYXh4LCBtYXh5IGluIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgTWFwLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiYXNlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJhc2VcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIlRoaXMgYmFzZSBwYXRoIGRlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZyBtZWFuaW5nIHRoYXQgYW55IHJlbGF0aXZlIHBhdGhzIHRvIGZpbGVzIHJlZmVyZW5jZWQgaW4gc3R5bGVzIG9yIGxheWVycyB3aWxsIGJlIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBhcHBsaWNhdGlvbiBwcm9jZXNzLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW55IHJlbGF0aXZlIHBhdGhzIHVzZWQgdG8gcmVmZXJlbmNlIGZpbGVzIHdpbGwgYmUgdW5kZXJzdG9vZCBhcyByZWxhdGl2ZSB0byB0aGlzIGRpcmVjdG9yeSBwYXRoIGlmIHRoZSBtYXAgaXMgbG9hZGVkIGZyb20gYW4gaW4gbWVtb3J5IG9iamVjdCByYXRoZXIgdGhhbiBmcm9tIHRoZSBmaWxlc3lzdGVtLiBJZiB0aGUgbWFwIGlzIGxvYWRlZCBmcm9tIHRoZSBmaWxlc3lzdGVtIGFuZCB0aGlzIG9wdGlvbiBpcyBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGRpcmVjdG9yeSBvZiB0aGUgc3R5bGVzaGVldC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGF0aHMtZnJvbS14bWxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJQYXRocyByZWFkIGZyb20gWE1MIHdpbGwgYmUgaW50ZXJwcmV0ZWQgZnJvbSB0aGUgbG9jYXRpb24gb2YgdGhlIFhNTFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcInZhbHVlIHRvIGNvbnRyb2wgd2hldGhlciBwYXRocyBpbiB0aGUgWE1MIHdpbGwgYmUgaW50ZXJwcmV0ZWQgZnJvbSB0aGUgbG9jYXRpb24gb2YgdGhlIFhNTCBvciBmcm9tIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB0aGUgcHJvZ3JhbSB0aGF0IGNhbGxzIGxvYWRfbWFwKClcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWluaW11bS12ZXJzaW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIk1hcG5payB2ZXJzaW9uIHdpbGwgbm90IGJlIGRldGVjdGVkIGFuZCBubyBlcnJvciB3aWxsIGJlIHRocm93biBhYm91dCBjb21wYXRpYmlsaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgbWludW11bSBNYXBuaWsgdmVyc2lvbiAoZS5nLiAwLjcuMikgbmVlZGVkIHRvIHVzZSBjZXJ0YWluIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHN0eWxlc2hlZXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZm9udC1kaXJlY3RvcnlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiZm9udC1kaXJlY3RvcnlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyBtYXAtc3BlY2lmaWMgZm9udHMgd2lsbCBiZSByZWdpc3RlcmVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJQYXRoIHRvIGEgZGlyZWN0b3J5IHdoaWNoIGhvbGRzIGZvbnRzIHdoaWNoIHNob3VsZCBiZSByZWdpc3RlcmVkIHdoZW4gdGhlIE1hcCBpcyBsb2FkZWQgKGluIGFkZGl0aW9uIHRvIGFueSBmb250cyB0aGF0IG1heSBiZSBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyZWQpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9seWdvblwiOiB7XG4gICAgICAgICAgICBcImZpbGxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJyZ2JhKDEyOCwxMjgsMTI4LDEpXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJncmF5IGFuZCBmdWxseSBvcGFxdWUgKGFscGhhID0gMSksIHNhbWUgYXMgcmdiKDEyOCwxMjgsMTI4KVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRmlsbCBjb2xvciB0byBhc3NpZ24gdG8gYSBwb2x5Z29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIHBvbHlnb25cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnYW1tYVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2x5Z29uLWdhbW1hXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImZ1bGx5IGFudGlhbGlhc2VkXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTGV2ZWwgb2YgYW50aWFsaWFzaW5nIG9mIHBvbHlnb24gZWRnZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2FtbWEtbWV0aG9kXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tZ2FtbWEtbWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb3dlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aHJlc2hvbGRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb3dlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwicG93KHgsZ2FtbWEpIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHBpeGVsIGdhbW1hLCB3aGljaCBwcm9kdWNlcyBzbGlnaHRseSBzbW9vdGhlciBsaW5lIGFuZCBwb2x5Z29uIGFudGlhbGlhc2luZyB0aGFuIHRoZSAnbGluZWFyJyBtZXRob2QsIHdoaWxlIG90aGVyIG1ldGhvZHMgYXJlIHVzdWFsbHkgb25seSB1c2VkIHRvIGRpc2FibGUgQUFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkFuIEFudGlncmFpbiBHZW9tZXRyeSBzcGVjaWZpYyByZW5kZXJpbmcgaGludCB0byBjb250cm9sIHRoZSBxdWFsaXR5IG9mIGFudGlhbGlhc2luZy4gVW5kZXIgdGhlIGhvb2QgaW4gTWFwbmlrIHRoaXMgbWV0aG9kIGlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgJ2dhbW1hJyB2YWx1ZSAod2hpY2ggZGVmYXVsdHMgdG8gMSkuIFRoZSBtZXRob2RzIGFyZSBpbiB0aGUgQUdHIHNvdXJjZSBhdCBodHRwczovL2dpdGh1Yi5jb20vbWFwbmlrL21hcG5pay9ibG9iL21hc3Rlci9kZXBzL2FnZy9pbmNsdWRlL2FnZ19nYW1tYV9mdW5jdGlvbnMuaFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic21vb3RoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tc21vb3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNtb290aGluZ1wiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNtb290aHMgb3V0IGdlb21ldHJ5IGFuZ2xlcy4gMCBpcyBubyBzbW9vdGhpbmcsIDEgaXMgZnVsbHkgc21vb3RoZWQuIFZhbHVlcyBncmVhdGVyIHRoYW4gMSB3aWxsIHByb2R1Y2Ugd2lsZCwgbG9vcGluZyBnZW9tZXRyaWVzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tZXRyeS10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tY29tcC1vcFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJhZGQgdGhlIGN1cnJlbnQgc3ltYm9saXplciBvbiB0b3Agb2Ygb3RoZXIgc3ltYm9saXplclwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29tcG9zaXRlIG9wZXJhdGlvbi4gVGhpcyBkZWZpbmVzIGhvdyB0aGlzIHN5bWJvbGl6ZXIgc2hvdWxkIGJlaGF2ZSByZWxhdGl2ZSB0byBzeW1ib2xpemVycyBhdG9wIG9yIGJlbG93IGl0LlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXCJjbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4b3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwbHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWludXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBcIm92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXJrZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJsaWdodGVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItZG9kZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1idXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFyZC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNvZnQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkaWZmZXJlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZXhjbHVzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udHJhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnZlcnQtcmdiXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tbWVyZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1leHRyYWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2F0dXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJsaW5lXCI6IHtcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJyZ2JhKDAsMCwwLDEpXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImJsYWNrIGFuZCBmdWxseSBvcGFxdWUgKGFscGhhID0gMSksIHNhbWUgYXMgcmdiKDAsMCwwKVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIGEgZHJhd24gbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS13aWR0aFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgd2lkdGggb2YgYSBsaW5lIGluIHBpeGVsc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwib3BhcXVlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiBhIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtam9pblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm1pdGVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJtaXRlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmV2ZWxcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgYmVoYXZpb3Igb2YgbGluZXMgd2hlbiBqb2luaW5nXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtY2FwXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYnV0dFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0dFwiLFxuICAgICAgICAgICAgICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3F1YXJlXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1nYW1tYVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWdhbW1hXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImZ1bGx5IGFudGlhbGlhc2VkXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTGV2ZWwgb2YgYW50aWFsaWFzaW5nIG9mIHN0cm9rZSBsaW5lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1nYW1tYS1tZXRob2RcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1nYW1tYS1tZXRob2RcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcInBvd2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGluZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInRocmVzaG9sZFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInBvd2VyXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJwb3coeCxnYW1tYSkgaXMgdXNlZCB0byBjYWxjdWxhdGUgcGl4ZWwgZ2FtbWEsIHdoaWNoIHByb2R1Y2VzIHNsaWdodGx5IHNtb290aGVyIGxpbmUgYW5kIHBvbHlnb24gYW50aWFsaWFzaW5nIHRoYW4gdGhlICdsaW5lYXInIG1ldGhvZCwgd2hpbGUgb3RoZXIgbWV0aG9kcyBhcmUgdXN1YWxseSBvbmx5IHVzZWQgdG8gZGlzYWJsZSBBQVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gQW50aWdyYWluIEdlb21ldHJ5IHNwZWNpZmljIHJlbmRlcmluZyBoaW50IHRvIGNvbnRyb2wgdGhlIHF1YWxpdHkgb2YgYW50aWFsaWFzaW5nLiBVbmRlciB0aGUgaG9vZCBpbiBNYXBuaWsgdGhpcyBtZXRob2QgaXMgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAnZ2FtbWEnIHZhbHVlICh3aGljaCBkZWZhdWx0cyB0byAxKS4gVGhlIG1ldGhvZHMgYXJlIGluIHRoZSBBR0cgc291cmNlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBuaWsvbWFwbmlrL2Jsb2IvbWFzdGVyL2RlcHMvYWdnL2luY2x1ZGUvYWdnX2dhbW1hX2Z1bmN0aW9ucy5oXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1kYXNoYXJyYXlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBIHBhaXIgb2YgbGVuZ3RoIHZhbHVlcyBbYSxiXSwgd2hlcmUgKGEpIGlzIHRoZSBkYXNoIGxlbmd0aCBhbmQgKGIpIGlzIHRoZSBnYXAgbGVuZ3RoIHJlc3BlY3RpdmVseS4gTW9yZSB0aGFuIHR3byB2YWx1ZXMgYXJlIHN1cHBvcnRlZCBmb3IgbW9yZSBjb21wbGV4IHBhdHRlcm5zLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInNvbGlkIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1kYXNoLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlcnNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcInZhbGlkIHBhcmFtZXRlciBidXQgbm90IGN1cnJlbnRseSB1c2VkIGluIHJlbmRlcmVycyAob25seSBleGlzdHMgZm9yIGV4cGVyaW1lbnRhbCBzdmcgc3VwcG9ydCBpbiBNYXBuaWsgd2hpY2ggaXMgbm90IHlldCBlbmFibGVkKVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInNvbGlkIGxpbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1taXRlcmxpbWl0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBsaW1pdCBvbiB0aGUgcmF0aW8gb2YgdGhlIG1pdGVyIGxlbmd0aCB0byB0aGUgc3Ryb2tlLXdpZHRoLiBVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzIHRvIGF2b2lkIHRoZSBtaXRlciBleHRlbmRpbmcgYmV5b25kIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9raW5nIHBhdGguIE5vcm1hbGx5IHdpbGwgbm90IG5lZWQgdG8gYmUgc2V0LCBidXQgYSBsYXJnZXIgdmFsdWUgY2FuIHNvbWV0aW1lcyBoZWxwIGF2b2lkIGphZ2d5IGFydGlmYWN0cy5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogNC4wLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiV2lsbCBhdXRvLWNvbnZlcnQgbWl0ZXJzIHRvIGJldmVsIGxpbmUgam9pbnMgd2hlbiB0aGV0YSBpcyBsZXNzIHRoYW4gMjkgZGVncmVlcyBhcyBwZXIgdGhlIFNWRyBzcGVjOiAnbWl0ZXJMZW5ndGggLyBzdHJva2Utd2lkdGggPSAxIC8gc2luICggdGhldGEgLyAyICknXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsaXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1jbGlwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBiZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYmVmb3JlIHJlbmRlcmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiZ2VvbWV0cmllcyBhcmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJ5IGRlZmF1bHQgZm9yIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJbiBzb21lIGNhc2VzIHVzZXJzIG1heSB3aXNoIHRvIGRpc2FibGUgdGhpcyB0byBhdm9pZCByZW5kZXJpbmcgYXJ0aWZhY3RzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzbW9vdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1zbW9vdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gc21vb3RoaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU21vb3RocyBvdXQgZ2VvbWV0cnkgYW5nbGVzLiAwIGlzIG5vIHNtb290aGluZywgMSBpcyBmdWxseSBzbW9vdGhlZC4gVmFsdWVzIGdyZWF0ZXIgdGhhbiAxIHdpbGwgcHJvZHVjZSB3aWxkLCBsb29waW5nIGdlb21ldHJpZXMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9mZnNldFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBvZmZzZXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIk9mZnNldHMgYSBsaW5lIGEgbnVtYmVyIG9mIHBpeGVscyBwYXJhbGxlbCB0byBpdHMgYWN0dWFsIHBhdGguIFBvc3RpdmUgdmFsdWVzIG1vdmUgdGhlIGxpbmUgbGVmdCwgbmVnYXRpdmUgdmFsdWVzIG1vdmUgaXQgcmlnaHQgKHJlbGF0aXZlIHRvIHRoZSBkaXJlY3Rpb25hbGl0eSBvZiB0aGUgbGluZSkuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJhc3Rlcml6ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1yYXN0ZXJpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJmdWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZmFzdFwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJmdWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJFeHBvc2VzIGFuIGFsdGVybmF0ZSBBR0cgcmVuZGVyaW5nIG1ldGhvZCB0aGF0IHNhY3JpZmljZXMgc29tZSBhY2N1cmFjeSBmb3Igc3BlZWQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21ldHJ5LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJsaW5lLWdlb21ldHJ5LXRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgbm90IGJlIHRyYW5zZm9ybWVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbGxvd3MgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGdlb21ldHJ5LlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgW1wibWF0cml4XCIsIDZdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ0cmFuc2xhdGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNjYWxlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJyb3RhdGVcIiwgM10sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdYXCIsIDFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WVwiLCAxXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1hcmtlcnNcIjoge1xuICAgICAgICAgICAgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbiBTVkcgZmlsZSB0aGF0IHRoaXMgbWFya2VyIHNob3dzIGF0IGVhY2ggcGxhY2VtZW50LiBJZiBubyBmaWxlIGlzIGdpdmVuLCB0aGUgbWFya2VyIHdpbGwgc2hvdyBhbiBlbGxpcHNlLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQW4gZWxsaXBzZSBvciBjaXJjbGUsIGlmIHdpZHRoIGVxdWFscyBoZWlnaHRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG92ZXJhbGwgb3BhY2l0eSBvZiB0aGUgbWFya2VyLCBpZiBzZXQsIG92ZXJyaWRlcyBib3RoIHRoZSBvcGFjaXR5IG9mIGJvdGggdGhlIGZpbGwgYW5kIHN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIHN0cm9rZS1vcGFjaXR5IGFuZCBmaWxsLW9wYWNpdHkgd2lsbCBiZSB1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxsLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBmaWxsIG9wYWNpdHkgb2YgdGhlIG1hcmtlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwib3BhcXVlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3Ryb2tlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLWNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHN0cm9rZSBhcm91bmQgYSBtYXJrZXIgc2hhcGUuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmxhY2tcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWxpbmUtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlIGFyb3VuZCBhIG1hcmtlciBzaGFwZSwgaW4gcGl4ZWxzLiBUaGlzIGlzIHBvc2l0aW9uZWQgb24gdGhlIGJvdW5kYXJ5LCBzbyBoaWdoIHZhbHVlcyBjYW4gY292ZXIgdGhlIGFyZWEgaXRzZWxmLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1saW5lLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG9wYWNpdHkgb2YgYSBsaW5lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1wbGFjZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcInBvaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImludGVyaW9yXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJQbGFjZSBtYXJrZXJzIGF0IHRoZSBjZW50ZXIgcG9pbnQgKGNlbnRyb2lkKSBvZiB0aGUgZ2VvbWV0cnlcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkF0dGVtcHQgdG8gcGxhY2UgbWFya2VycyBvbiBhIHBvaW50LCBpbiB0aGUgY2VudGVyIG9mIGEgcG9seWdvbiwgb3IgaWYgbWFya2Vycy1wbGFjZW1lbnQ6bGluZSwgdGhlbiBtdWx0aXBsZSB0aW1lcyBhbG9uZyBhIGxpbmUuICdpbnRlcmlvcicgcGxhY2VtZW50IGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHBvaW50cyBwbGFjZWQgb24gcG9seWdvbnMgYXJlIGZvcmNlZCB0byBiZSBpbnNpZGUgdGhlIHBvbHlnb24gaW50ZXJpb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibXVsdGktcG9saWN5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1tdWx0aS1wb2xpY3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImVhY2hcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ3aG9sZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxhcmdlc3RcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZWFjaFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiSWYgYSBmZWF0dXJlIGNvbnRhaW5zIG11bHRpcGxlIGdlb21ldHJpZXMgYW5kIHRoZSBwbGFjZW1lbnQgdHlwZSBpcyBlaXRoZXIgcG9pbnQgb3IgaW50ZXJpb3IgdGhlbiBhIG1hcmtlciB3aWxsIGJlIHJlbmRlcmVkIGZvciBlYWNoXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBIHNwZWNpYWwgc2V0dGluZyB0byBhbGxvdyB0aGUgdXNlciB0byBjb250cm9sIHJlbmRlcmluZyBiZWhhdmlvciBmb3IgJ211bHRpLWdlb21ldHJpZXMnICh3aGVuIGEgZmVhdHVyZSBjb250YWlucyBtdWx0aXBsZSBnZW9tZXRyaWVzKS4gVGhpcyBzZXR0aW5nIGRvZXMgbm90IGFwcGx5IHRvIG1hcmtlcnMgcGxhY2VkIGFsb25nIGxpbmVzLiBUaGUgJ2VhY2gnIHBvbGljeSBpcyBkZWZhdWx0IGFuZCBtZWFucyBhbGwgZ2VvbWV0cmllcyB3aWxsIGdldCBhIG1hcmtlci4gVGhlICd3aG9sZScgcG9saWN5IG1lYW5zIHRoYXQgdGhlIGFnZ3JlZ2F0ZSBjZW50cm9pZCBiZXR3ZWVuIGFsbCBnZW9tZXRyaWVzIHdpbGwgYmUgdXNlZC4gVGhlICdsYXJnZXN0JyBwb2xpY3kgbWVhbnMgdGhhdCBvbmx5IHRoZSBsYXJnZXN0IChieSBib3VuZGluZyBib3ggYXJlYXMpIGZlYXR1cmUgd2lsbCBnZXQgYSByZW5kZXJlZCBtYXJrZXIgKHRoaXMgaXMgaG93IHRleHQgbGFiZWxpbmcgYmVoYXZlcyBieSBkZWZhdWx0KS5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWFya2VyLXR5cGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLXR5cGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImFycm93XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlY3RhbmdsZVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJlbGxpcHNlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgZGVmYXVsdCBtYXJrZXItdHlwZS4gSWYgYSBTVkcgZmlsZSBpcyBub3QgZ2l2ZW4gYXMgdGhlIG1hcmtlci1maWxlIHBhcmFtZXRlciwgdGhlIHJlbmRlcmVyIHByb3ZpZGVzIGVpdGhlciBhbiBhcnJvdyBvciBhbiBlbGxpcHNlIChhIGNpcmNsZSBpZiBoZWlnaHQgaXMgZXF1YWwgdG8gd2lkdGgpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci13aWR0aFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB3aWR0aCBvZiB0aGUgbWFya2VyLCBpZiB1c2luZyBvbmUgb2YgdGhlIGRlZmF1bHQgdHlwZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1oZWlnaHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgaGVpZ2h0IG9mIHRoZSBtYXJrZXIsIGlmIHVzaW5nIG9uZSBvZiB0aGUgZGVmYXVsdCB0eXBlcy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBhcmVhIG9mIHRoZSBtYXJrZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItYWxsb3ctb3ZlcmxhcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgb3ZlcmxhcHBpbmcgbWFya2VycyBhcmUgc2hvd24gb3IgaGlkZGVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IG1ha2VycyB0byBvdmVybGFwIHdpdGggZWFjaCBvdGhlciAtIG92ZXJsYXBwaW5nIG1hcmtlcnMgd2lsbCBub3QgYmUgc2hvd24uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWlnbm9yZS1wbGFjZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZG8gbm90IHN0b3JlIHRoZSBiYm94IG9mIHRoaXMgZ2VvbWV0cnkgaW4gdGhlIGNvbGxpc2lvbiBkZXRlY3RvciBjYWNoZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwidmFsdWUgdG8gY29udHJvbCB3aGV0aGVyIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGZlYXR1cmUgd2lsbCBwcmV2ZW50IHRoZSBwbGFjZW1lbnQgb2Ygb3RoZXIgZmVhdHVyZXNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic3BhY2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItc3BhY2luZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BhY2UgYmV0d2VlbiByZXBlYXRlZCBsYWJlbHNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTAwLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1heC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItbWF4LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMC4yLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gZGlmZmVyZW5jZSBiZXR3ZWVuIGFjdHVhbCBtYXJrZXIgcGxhY2VtZW50IGFuZCB0aGUgbWFya2VyLXNwYWNpbmcgcGFyYW1ldGVyLiBTZXR0aW5nIGEgaGlnaCB2YWx1ZSBjYW4gYWxsb3cgdGhlIHJlbmRlcmVyIHRvIHRyeSB0byByZXNvbHZlIHBsYWNlbWVudCBjb25mbGljdHMgd2l0aCBvdGhlciBzeW1ib2xpemVycy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcIm1hcmtlci10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiTm8gdHJhbnNmb3JtYXRpb25cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNWRyB0cmFuc2Zvcm1hdGlvbiBkZWZpbml0aW9uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNsaXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWNsaXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIGJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBiZWZvcmUgcmVuZGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJnZW9tZXRyaWVzIGFyZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYnkgZGVmYXVsdCBmb3IgYmVzdCByZW5kZXJpbmcgcGVyZm9ybWFuY2UuIEluIHNvbWUgY2FzZXMgdXNlcnMgbWF5IHdpc2ggdG8gZGlzYWJsZSB0aGlzIHRvIGF2b2lkIHJlbmRlcmluZyBhcnRpZmFjdHMuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNtb290aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJtYXJrZXItc21vb3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIHNtb290aGluZ1wiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIjogXCIwLTFcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNtb290aHMgb3V0IGdlb21ldHJ5IGFuZ2xlcy4gMCBpcyBubyBzbW9vdGhpbmcsIDEgaXMgZnVsbHkgc21vb3RoZWQuIFZhbHVlcyBncmVhdGVyIHRoYW4gMSB3aWxsIHByb2R1Y2Ugd2lsZCwgbG9vcGluZyBnZW9tZXRyaWVzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZW9tZXRyeS10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWdlb21ldHJ5LXRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgbm90IGJlIHRyYW5zZm9ybWVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbGxvd3MgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGdlb21ldHJ5LlwiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgW1wibWF0cml4XCIsIDZdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ0cmFuc2xhdGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNjYWxlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJyb3RhdGVcIiwgM10sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdYXCIsIDFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WVwiLCAxXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNvbXAtb3BcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibWFya2VyLWNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXJcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBzeW1ib2xpemVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gc3ltYm9saXplcnMgYXRvcCBvciBiZWxvdyBpdC5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1wiY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb2Z0LWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLW1lcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNhdHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic2hpZWxkXCI6IHtcbiAgICAgICAgICAgIFwibmFtZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtbmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwic2VyaWFsaXphdGlvblwiOiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSBzaGllbGRcXFwicyB0ZXh0IGxhYmVsLiBEYXRhIGNvbHVtbnMgYXJlIHNwZWNpZmllZCB1c2luZyBicmFja2V0cyBsaWtlIFtjb2x1bW5fbmFtZV1cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtZmlsZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJJbWFnZSBmaWxlIHRvIHJlbmRlciBiZWhpbmQgdGhlIHNoaWVsZCB0ZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZhY2UtbmFtZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtZmFjZS1uYW1lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ2YWxpZGF0ZVwiOiBcImZvbnRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkZvbnQgbmFtZSBhbmQgc3R5bGUgdG8gdXNlIGZvciB0aGUgc2hpZWxkIHRleHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInVubG9jay1pbWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtdW5sb2NrLWltYWdlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhpcyBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNldCB0byB0cnVlIGlmIHlvdSBhcmUgdHJ5aW5nIHRvIHBvc2l0aW9uIHRleHQgYmVzaWRlIHJhdGhlciB0aGFuIG9uIHRvcCBvZiB0aGUgc2hpZWxkIGltYWdlXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGV4dCBhbGlnbm1lbnQgcmVsYXRpdmUgdG8gdGhlIHNoaWVsZCBpbWFnZSB1c2VzIHRoZSBjZW50ZXIgb2YgdGhlIGltYWdlIGFzIHRoZSBhbmNob3IgZm9yIHRleHQgcG9zaXRpb25pbmcuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNpemVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXNpemVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHNpemUgb2YgdGhlIHNoaWVsZCB0ZXh0IGluIHBpeGVsc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1maWxsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciBvZiB0aGUgc2hpZWxkIHRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1wbGFjZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcInBvaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZlcnRleFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludGVyaW9yXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJIb3cgdGhpcyBzaGllbGQgc2hvdWxkIGJlIHBsYWNlZC4gUG9pbnQgcGxhY2VtZW50IGF0dGVtcHRzIHRvIHBsYWNlIGl0IG9uIHRvcCBvZiBwb2ludHMsIGxpbmUgcGxhY2VzIGFsb25nIGxpbmVzIG11bHRpcGxlIHRpbWVzIHBlciBmZWF0dXJlLCB2ZXJ0ZXggcGxhY2VzIG9uIHRoZSB2ZXJ0ZXhlcyBvZiBwb2x5Z29ucywgYW5kIGludGVyaW9yIGF0dGVtcHRzIHRvIHBsYWNlIGluc2lkZSBvZiBwb2x5Z29ucy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYXZvaWQtZWRnZXNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWF2b2lkLWVkZ2VzXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUZWxsIHBvc2l0aW9uaW5nIGFsZ29yaXRobSB0byBhdm9pZCBsYWJlbGluZyBuZWFyIGludGVyc2VjdGlvbiBlZGdlcy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1hbGxvdy1vdmVybGFwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbnRyb2wgd2hldGhlciBvdmVybGFwcGluZyBzaGllbGRzIGFyZSBzaG93biBvciBoaWRkZW4uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJEbyBub3QgYWxsb3cgc2hpZWxkcyB0byBvdmVybGFwIHdpdGggb3RoZXIgbWFwIGVsZW1lbnRzIGFscmVhZHkgcGxhY2VkLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLWRpc3RhbmNlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1taW4tZGlzdGFuY2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTWluaW11bSBkaXN0YW5jZSB0byB0aGUgbmV4dCBzaGllbGQgc3ltYm9sLCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgc2hpZWxkLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzcGFjaW5nIGJldHdlZW4gcmVwZWF0ZWQgb2NjdXJyZW5jZXMgb2YgdGhlIHNhbWUgc2hpZWxkIG9uIGEgbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLXBhZGRpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLW1pbi1wYWRkaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEZXRlcm1pbmVzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiBwYWRkaW5nIHRoYXQgYSBzaGllbGQgZ2V0cyByZWxhdGl2ZSB0byBvdGhlciBzaGllbGRzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwid3JhcC13aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtd3JhcC13aWR0aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJMZW5ndGggb2YgYSBjaHVuayBvZiB0ZXh0IGluIGNoYXJhY3RlcnMgYmVmb3JlIHdyYXBwaW5nIHRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwid3JhcC1iZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXdyYXAtYmVmb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIldyYXAgdGV4dCBiZWZvcmUgd3JhcC13aWR0aCBpcyByZWFjaGVkLiBJZiBmYWxzZSwgd3JhcHBlZCBsaW5lcyB3aWxsIGJlIGEgYml0IGxvbmdlciB0aGFuIHdyYXAtd2lkdGguXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtY2hhcmFjdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC13cmFwLWNoYXJhY3RlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiBcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlVzZSB0aGlzIGNoYXJhY3RlciBpbnN0ZWFkIG9mIGEgc3BhY2UgdG8gd3JhcCBsb25nIG5hbWVzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJoYWxvLWZpbGxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWhhbG8tZmlsbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgY29sb3Igb2YgdGhlIGhhbG8gYXJvdW5kIHRoZSB0ZXh0LlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJoYWxvLXJhZGl1c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtaGFsby1yYWRpdXNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwZWNpZnkgdGhlIHJhZGl1cyBvZiB0aGUgaGFsbyBpbiBwaXhlbHNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm5vIGhhbG9cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjaGFyYWN0ZXItc3BhY2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtY2hhcmFjdGVyLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSG9yaXpvbnRhbCBzcGFjaW5nIGJldHdlZW4gY2hhcmFjdGVycyAoaW4gcGl4ZWxzKS4gQ3VycmVudGx5IHdvcmtzIGZvciBwb2ludCBwbGFjZW1lbnQgb25seSwgbm90IGxpbmUgcGxhY2VtZW50LlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsaW5lLXNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWxpbmUtc3BhY2luZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVmVydGljYWwgc3BhY2luZyBiZXR3ZWVuIGxpbmVzIG9mIG11bHRpbGluZSBsYWJlbHMgKGluIHBpeGVscylcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkeFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtdGV4dC1keFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSB0ZXh0IHdpdGhpbiBzaGllbGQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWCBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC10ZXh0LWR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRpc3BsYWNlIHRleHQgd2l0aGluIHNoaWVsZCBieSBmaXhlZCBhbW91bnQsIGluIHBpeGVscywgKy8tIGFsb25nIHRoZSBZIGF4aXMuICBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgc2hpZnQgdGhlIHRleHQgZG93blwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzaGllbGQtZHhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWR4XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRpc3BsYWNlIHNoaWVsZCBieSBmaXhlZCBhbW91bnQsIGluIHBpeGVscywgKy8tIGFsb25nIHRoZSBYIGF4aXMuICBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgc2hpZnQgdGhlIHRleHQgcmlnaHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2hpZWxkLWR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1keVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSBzaGllbGQgYnkgZml4ZWQgYW1vdW50LCBpbiBwaXhlbHMsICsvLSBhbG9uZyB0aGUgWSBheGlzLiAgQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IGRvd25cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJzaGllbGQtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCIoRGVmYXVsdCAxLjApIC0gb3BhY2l0eSBvZiB0aGUgaW1hZ2UgdXNlZCBmb3IgdGhlIHNoaWVsZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0ZXh0LW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXRleHQtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCIoRGVmYXVsdCAxLjApIC0gb3BhY2l0eSBvZiB0aGUgdGV4dCBwbGFjZWQgb24gdG9wIG9mIHRoZSBzaGllbGRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaG9yaXpvbnRhbC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWhvcml6b250YWwtYWxpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIHNoaWVsZCdzIGhvcml6b250YWwgYWxpZ25tZW50IGZyb20gaXRzIGNlbnRlcnBvaW50XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ2ZXJ0aWNhbC1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXZlcnRpY2FsLWFsaWdubWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwidG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWlkZGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzaGllbGQncyB2ZXJ0aWNhbCBhbGlnbm1lbnQgZnJvbSBpdHMgY2VudGVycG9pbnRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJtaWRkbGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLXRleHQtdHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidXBwZXJjYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibG93ZXJjYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2FwaXRhbGl6ZVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRyYW5zZm9ybSB0aGUgY2FzZSBvZiB0aGUgY2hhcmFjdGVyc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwianVzdGlmeS1hbGlnbm1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwic2hpZWxkLWp1c3RpZnktYWxpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGVmaW5lIGhvdyB0ZXh0IGluIGEgc2hpZWxkJ3MgbGFiZWwgaXMganVzdGlmaWVkXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1jbGlwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBiZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYmVmb3JlIHJlbmRlcmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiZ2VvbWV0cmllcyBhcmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJ5IGRlZmF1bHQgZm9yIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJbiBzb21lIGNhc2VzIHVzZXJzIG1heSB3aXNoIHRvIGRpc2FibGUgdGhpcyB0byBhdm9pZCByZW5kZXJpbmcgYXJ0aWZhY3RzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInNoaWVsZC1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1wYXR0ZXJuLWZpbGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW4gaW1hZ2UgZmlsZSB0byBiZSByZXBlYXRlZCBhbmQgd2FycGVkIGFsb25nIGEgbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1jbGlwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBiZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYmVmb3JlIHJlbmRlcmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiZ2VvbWV0cmllcyBhcmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJ5IGRlZmF1bHQgZm9yIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJbiBzb21lIGNhc2VzIHVzZXJzIG1heSB3aXNoIHRvIGRpc2FibGUgdGhpcyB0byBhdm9pZCByZW5kZXJpbmcgYXJ0aWZhY3RzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzbW9vdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwibGluZS1wYXR0ZXJuLXNtb290aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzbW9vdGhpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IFwiMC0xXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTbW9vdGhzIG91dCBnZW9tZXRyeSBhbmdsZXMuIDAgaXMgbm8gc21vb3RoaW5nLCAxIGlzIGZ1bGx5IHNtb290aGVkLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2lsbCBwcm9kdWNlIHdpbGQsIGxvb3BpbmcgZ2VvbWV0cmllcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbWV0cnktdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImxpbmUtcGF0dGVybi1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvbHlnb24tcGF0dGVyblwiOiB7XG4gICAgICAgICAgICBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1wYXR0ZXJuLWZpbGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1cmlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSW1hZ2UgdG8gdXNlIGFzIGEgcmVwZWF0ZWQgcGF0dGVybiBmaWxsIHdpdGhpbiBhIHBvbHlnb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1hbGlnbm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImxvY2FsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xvYmFsXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImxvY2FsXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZ5IHdoZXRoZXIgdG8gYWxpZ24gcGF0dGVybiBmaWxscyB0byB0aGUgbGF5ZXIgb3IgdG8gdGhlIG1hcC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2FtbWFcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1wYXR0ZXJuLWdhbW1hXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImZ1bGx5IGFudGlhbGlhc2VkXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiOiBcIjAtMVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiTGV2ZWwgb2YgYW50aWFsaWFzaW5nIG9mIHBvbHlnb24gcGF0dGVybiBlZGdlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcGFjaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIihEZWZhdWx0IDEuMCkgLSBBcHBseSBhbiBvcGFjaXR5IGxldmVsIHRvIHRoZSBpbWFnZSB1c2VkIGZvciB0aGUgcGF0dGVyblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiVGhlIGltYWdlIGlzIHJlbmRlcmVkIHdpdGhvdXQgbW9kaWZpY2F0aW9uc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1jbGlwXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZ2VvbWV0cnkgd2lsbCBiZSBjbGlwcGVkIHRvIG1hcCBib3VuZHMgYmVmb3JlIHJlbmRlcmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiZ2VvbWV0cmllcyBhcmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJ5IGRlZmF1bHQgZm9yIGJlc3QgcmVuZGVyaW5nIHBlcmZvcm1hbmNlLiBJbiBzb21lIGNhc2VzIHVzZXJzIG1heSB3aXNoIHRvIGRpc2FibGUgdGhpcyB0byBhdm9pZCByZW5kZXJpbmcgYXJ0aWZhY3RzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzbW9vdGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9seWdvbi1wYXR0ZXJuLXNtb290aFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJubyBzbW9vdGhpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCI6IFwiMC0xXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTbW9vdGhzIG91dCBnZW9tZXRyeSBhbmdsZXMuIDAgaXMgbm8gc21vb3RoaW5nLCAxIGlzIGZ1bGx5IHNtb290aGVkLiBWYWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2lsbCBwcm9kdWNlIHdpbGQsIGxvb3BpbmcgZ2VvbWV0cmllcy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2VvbWV0cnktdHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1nZW9tZXRyeS10cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJnZW9tZXRyeSB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQWxsb3dzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBnZW9tZXRyeS5cIixcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIFtcIm1hdHJpeFwiLCA2XSxcbiAgICAgICAgICAgICAgICAgICAgW1widHJhbnNsYXRlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJzY2FsZVwiLCAyXSxcbiAgICAgICAgICAgICAgICAgICAgW1wicm90YXRlXCIsIDNdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WFwiLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic2tld1lcIiwgMV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvbHlnb24tcGF0dGVybi1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInJhc3RlclwiOiB7XG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicmFzdGVyLW9wYWNpdHlcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIm9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBvZiB0aGUgcmFzdGVyIHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXJzLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWx0ZXItZmFjdG9yXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInJhc3Rlci1maWx0ZXItZmFjdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IC0xLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiQWxsb3cgdGhlIGRhdGFzb3VyY2UgdG8gY2hvb3NlIGFwcHJvcHJpYXRlIGRvd25zY2FsaW5nLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGlzIGlzIHVzZWQgYnkgdGhlIFJhc3RlciBvciBHZGFsIGRhdGFzb3VyY2VzIHRvIHByZS1kb3duc2NhbGUgaW1hZ2VzIHVzaW5nIG92ZXJ2aWV3cy4gSGlnaGVyIG51bWJlcnMgY2FuIHNvbWV0aW1lcyBjYXVzZSBtdWNoIGJldHRlciBzY2FsZWQgaW1hZ2Ugb3V0cHV0LCBhdCB0aGUgY29zdCBvZiBzcGVlZC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2NhbGluZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJyYXN0ZXItc2NhbGluZ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibmVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcImZhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiaWxpbmVhclwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpbGluZWFyOFwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpY3ViaWNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcGxpbmUxNlwiLFxuICAgICAgICAgICAgICAgICAgICBcInNwbGluZTM2XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaGFubmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImhhbW1pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoZXJtaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwia2Fpc2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicXVhZHJpY1wiLFxuICAgICAgICAgICAgICAgICAgICBcImNhdHJvbVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdhdXNzaWFuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmVzc2VsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWl0Y2hlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzaW5jXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGFuY3pvc1wiLFxuICAgICAgICAgICAgICAgICAgICBcImJsYWNrbWFuXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIm5lYXJcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBzY2FsaW5nIGFsZ29yaXRobSB1c2VkIHRvIG1ha2luZyBkaWZmZXJlbnQgcmVzb2x1dGlvbiB2ZXJzaW9ucyBvZiB0aGlzIHJhc3RlciBsYXllci4gQmlsaW5lYXIgaXMgYSBnb29kIGNvbXByb21pc2UgYmV0d2VlbiBzcGVlZCBhbmQgYWNjdXJhY3ksIHdoaWxlIGxhbmN6b3MgZ2l2ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eS5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWVzaC1zaXplXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInJhc3Rlci1tZXNoLXNpemVcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMTYsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJSZXByb2plY3Rpb24gbWVzaCB3aWxsIGJlIDEvMTYgb2YgdGhlIHJlc29sdXRpb24gb2YgdGhlIHNvdXJjZSBpbWFnZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBIHJlZHVjZWQgcmVzb2x1dGlvbiBtZXNoIGlzIHVzZWQgZm9yIHJhc3RlciByZXByb2plY3Rpb24sIGFuZCB0aGUgdG90YWwgaW1hZ2Ugc2l6ZSBpcyBkaXZpZGVkIGJ5IHRoZSBtZXNoLXNpemUgdG8gZGV0ZXJtaW5lIHRoZSBxdWFsaXR5IG9mIHRoYXQgbWVzaC4gVmFsdWVzIGZvciBtZXNoLXNpemUgbGFyZ2VyIHRoYW4gdGhlIGRlZmF1bHQgd2lsbCByZXN1bHQgaW4gZmFzdGVyIHJlcHJvamVjdGlvbiBidXQgbWlnaHQgbGVhZCB0byBkaXN0b3J0aW9uLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjb21wLW9wXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInJhc3Rlci1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50XCI6IHtcbiAgICAgICAgICAgIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2ludC1maWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidXJpXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJJbWFnZSBmaWxlIHRvIHJlcHJlc2VudCBhIHBvaW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFsbG93LW92ZXJsYXBcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtYWxsb3ctb3ZlcmxhcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgb3ZlcmxhcHBpbmcgcG9pbnRzIGFyZSBzaG93biBvciBoaWRkZW4uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJEbyBub3QgYWxsb3cgcG9pbnRzIHRvIG92ZXJsYXAgd2l0aCBlYWNoIG90aGVyIC0gb3ZlcmxhcHBpbmcgbWFya2VycyB3aWxsIG5vdCBiZSBzaG93bi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2ludC1pZ25vcmUtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImRvIG5vdCBzdG9yZSB0aGUgYmJveCBvZiB0aGlzIGdlb21ldHJ5IGluIHRoZSBjb2xsaXNpb24gZGV0ZWN0b3IgY2FjaGVcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcInZhbHVlIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgcGxhY2VtZW50IG9mIHRoZSBmZWF0dXJlIHdpbGwgcHJldmVudCB0aGUgcGxhY2VtZW50IG9mIG90aGVyIGZlYXR1cmVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtb3BhY2l0eVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEuMCxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkZ1bGx5IG9wYXF1ZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSB2YWx1ZSBmcm9tIDAgdG8gMSB0byBjb250cm9sIHRoZSBvcGFjaXR5IG9mIHRoZSBwb2ludFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwicG9pbnQtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJjZW50cm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludGVyaW9yXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSG93IHRoaXMgcG9pbnQgc2hvdWxkIGJlIHBsYWNlZC4gQ2VudHJvaWQgY2FsY3VsYXRlcyB0aGUgZ2VvbWV0cmljIGNlbnRlciBvZiBhIHBvbHlnb24sIHdoaWNoIGNhbiBiZSBvdXRzaWRlIG9mIGl0LCB3aGlsZSBpbnRlcmlvciBhbHdheXMgcGxhY2VzIGluc2lkZSBvZiBhIHBvbHlnb24uXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiY2VudHJvaWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInBvaW50LXRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uc1wiLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgW1wibWF0cml4XCIsIDZdLFxuICAgICAgICAgICAgICAgICAgICBbXCJ0cmFuc2xhdGVcIiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNjYWxlXCIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJyb3RhdGVcIiwgM10sXG4gICAgICAgICAgICAgICAgICAgIFtcInNrZXdYXCIsIDFdLFxuICAgICAgICAgICAgICAgICAgICBbXCJza2V3WVwiLCAxXVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJObyB0cmFuc2Zvcm1hdGlvblwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU1ZHIHRyYW5zZm9ybWF0aW9uIGRlZmluaXRpb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJwb2ludC1jb21wLW9wXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImFkZCB0aGUgY3VycmVudCBzeW1ib2xpemVyIG9uIHRvcCBvZiBvdGhlciBzeW1ib2xpemVyXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJDb21wb3NpdGUgb3BlcmF0aW9uLiBUaGlzIGRlZmluZXMgaG93IHRoaXMgc3ltYm9saXplciBzaG91bGQgYmVoYXZlIHJlbGF0aXZlIHRvIHN5bWJvbGl6ZXJzIGF0b3Agb3IgYmVsb3cgaXQuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcImNsZWFyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1pblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNyYy1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3Qtb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWF0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3QtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcInhvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInBsdXNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm11bHRpcGx5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhcmtlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvci1kb2RnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWJ1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJoYXJkLWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwic29mdC1saWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRpZmZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJleGNsdXNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb250cmFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBcImludmVydC1yZ2JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncmFpbi1tZXJnZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLWV4dHJhY3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJodWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzYXR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRleHRcIjoge1xuICAgICAgICAgICAgXCJuYW1lXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtbmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInNlcmlhbGl6YXRpb25cIjogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJWYWx1ZSB0byB1c2UgZm9yIGEgdGV4dCBsYWJlbC4gRGF0YSBjb2x1bW5zIGFyZSBzcGVjaWZpZWQgdXNpbmcgYnJhY2tldHMgbGlrZSBbY29sdW1uX25hbWVdXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZhY2UtbmFtZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWZhY2UtbmFtZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwidmFsaWRhdGVcIjogXCJmb250XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJGb250IG5hbWUgYW5kIHN0eWxlIHRvIHJlbmRlciBhIGxhYmVsIGluXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzaXplXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtc2l6ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDEwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGV4dCBzaXplIGluIHBpeGVsc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0ZXh0LXJhdGlvXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtcmF0aW9cIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRlZmluZSB0aGUgYW1vdW50IG9mIHRleHQgKG9mIHRoZSB0b3RhbCkgcHJlc2VudCBvbiBzdWNjZXNzaXZlIGxpbmVzIHdoZW4gd3JhcHBpbmcgb2NjdXJzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDAsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwid3JhcC13aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXdyYXAtd2lkdGhcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkxlbmd0aCBvZiBhIGNodW5rIG9mIHRleHQgaW4gY2hhcmFjdGVycyBiZWZvcmUgd3JhcHBpbmcgdGV4dFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndyYXAtYmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtd3JhcC1iZWZvcmVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiV3JhcCB0ZXh0IGJlZm9yZSB3cmFwLXdpZHRoIGlzIHJlYWNoZWQuIElmIGZhbHNlLCB3cmFwcGVkIGxpbmVzIHdpbGwgYmUgYSBiaXQgbG9uZ2VyIHRoYW4gd3JhcC13aWR0aC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwid3JhcC1jaGFyYWN0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC13cmFwLWNoYXJhY3RlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiBcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlVzZSB0aGlzIGNoYXJhY3RlciBpbnN0ZWFkIG9mIGEgc3BhY2UgdG8gd3JhcCBsb25nIHRleHQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1zcGFjaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidW5zaWduZWRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIGJldHdlZW4gcmVwZWF0ZWQgdGV4dCBsYWJlbHMgb24gYSBsaW5lIChha2EuIGxhYmVsLXNwYWNpbmcpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNoYXJhY3Rlci1zcGFjaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtY2hhcmFjdGVyLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiSG9yaXpvbnRhbCBzcGFjaW5nIGFkanVzdG1lbnQgYmV0d2VlbiBjaGFyYWN0ZXJzIGluIHBpeGVsc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsaW5lLXNwYWNpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1saW5lLXNwYWNpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMCxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVmVydGljYWwgc3BhY2luZyBhZGp1c3RtZW50IGJldHdlZW4gbGluZXMgaW4gcGl4ZWxzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxhYmVsLXBvc2l0aW9uLXRvbGVyYW5jZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWxhYmVsLXBvc2l0aW9uLXRvbGVyYW5jZVwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBbGxvd3MgdGhlIGxhYmVsIHRvIGJlIGRpc3BsYWNlZCBmcm9tIGl0cyBpZGVhbCBwb3NpdGlvbiBieSBhIG51bWJlciBvZiBwaXhlbHMgKG9ubHkgd29ya3Mgd2l0aCBwbGFjZW1lbnQ6bGluZSlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWF4LWNoYXItYW5nbGUtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1tYXgtY2hhci1hbmdsZS1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiMjIuNVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gYW5nbGUgY2hhbmdlLCBpbiBkZWdyZWVzLCBhbGxvd2VkIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycyBpbiBhIGxhYmVsLiBUaGlzIHZhbHVlIGludGVybmFsbHkgaXMgY29udmVydGVkIHRvIHJhZGlhbnMgdG8gdGhlIGRlZmF1bHQgaXMgMjIuNSptYXRoLnBpLzE4MC4wLiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSB0aGUgZmV3ZXIgbGFiZWxzIHdpbGwgYmUgcGxhY2VkIGFyb3VuZCBhcm91bmQgc2hhcnAgY29ybmVycy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmlsbFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWZpbGxcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgY29sb3IgZm9yIHRoZSB0ZXh0XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImNvbG9yXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJBIG51bWJlciBmcm9tIDAgdG8gMSBzcGVjaWZ5aW5nIHRoZSBvcGFjaXR5IGZvciB0aGUgdGV4dFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxLjAsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJGdWxseSBvcGFxdWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJoYWxvLWZpbGxcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1oYWxvLWZpbGxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIiNGRkZGRkZcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGNvbG9yIG9mIHRoZSBoYWxvIGFyb3VuZCB0aGUgdGV4dC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaGFsby1yYWRpdXNcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1oYWxvLXJhZGl1c1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiU3BlY2lmeSB0aGUgcmFkaXVzIG9mIHRoZSBoYWxvIGluIHBpeGVsc1wiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwibm8gaGFsb1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImR4XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtZHhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGlzcGxhY2UgdGV4dCBieSBmaXhlZCBhbW91bnQsIGluIHBpeGVscywgKy8tIGFsb25nIHRoZSBYIGF4aXMuICBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgc2hpZnQgdGhlIHRleHQgcmlnaHRcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1keVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJEaXNwbGFjZSB0ZXh0IGJ5IGZpeGVkIGFtb3VudCwgaW4gcGl4ZWxzLCArLy0gYWxvbmcgdGhlIFkgYXhpcy4gIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInZlcnRpY2FsLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXZlcnRpY2FsLWFsaWdubWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICBcInRvcFwiLFxuICAgICAgICAgICAgICAgICAgXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgICAgICAgICAgICBcImF1dG9cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJQb3NpdGlvbiBvZiBsYWJlbCByZWxhdGl2ZSB0byBwb2ludCBwb3NpdGlvbi5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJEZWZhdWx0IGFmZmVjdGVkIGJ5IHZhbHVlIG9mIGR5OyBcXFwiYm90dG9tXFxcIiBmb3IgZHk+MCwgXFxcInRvcFxcXCIgZm9yIGR5PDAuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtYXZvaWQtZWRnZXNcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRlbGwgcG9zaXRpb25pbmcgYWxnb3JpdGhtIHRvIGF2b2lkIGxhYmVsaW5nIG5lYXIgaW50ZXJzZWN0aW9uIGVkZ2VzLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1pbmltdW0tZGlzdGFuY2VcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1taW4tZGlzdGFuY2VcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIk1pbmltdW0gcGVybWl0dGVkIGRpc3RhbmNlIHRvIHRoZSBuZXh0IHRleHQgc3ltYm9saXplci5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJtaW5pbXVtLXBhZGRpbmdcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1taW4tcGFkZGluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGV0ZXJtaW5lcyB0aGUgbWluaW11bSBhbW91bnQgb2YgcGFkZGluZyB0aGF0IGEgdGV4dCBzeW1ib2xpemVyIGdldHMgcmVsYXRpdmUgdG8gb3RoZXIgdGV4dFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZsb2F0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1pbmltdW0tcGF0aC1sZW5ndGhcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1taW4tcGF0aC1sZW5ndGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAwLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwicGxhY2UgbGFiZWxzIG9uIGFsbCBwYXRoc1wiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiUGxhY2UgbGFiZWxzIG9ubHkgb24gcGF0aHMgbG9uZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIG92ZXJsYXBwaW5nIHRleHQgaXMgc2hvd24gb3IgaGlkZGVuLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiRG8gbm90IGFsbG93IHRleHQgdG8gb3ZlcmxhcCB3aXRoIG90aGVyIHRleHQgLSBvdmVybGFwcGluZyBtYXJrZXJzIHdpbGwgbm90IGJlIHNob3duLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJvcmllbnRhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LW9yaWVudGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlJvdGF0ZSB0aGUgdGV4dC5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0ZXhcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcmlvclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB0aGUgc3R5bGUgb2YgcGxhY2VtZW50IG9mIGEgcG9pbnQgdmVyc3VzIHRoZSBnZW9tZXRyeSBpdCBpcyBhdHRhY2hlZCB0by5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50LXR5cGVcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwidGV4dC1wbGFjZW1lbnQtdHlwZVwiLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiUmUtcG9zaXRpb24gYW5kL29yIHJlLXNpemUgdGV4dCB0byBhdm9pZCBvdmVybGFwcy4gXFxcInNpbXBsZVxcXCIgZm9yIGJhc2ljIGFsZ29yaXRobSAodXNpbmcgdGV4dC1wbGFjZW1lbnRzIHN0cmluZywpIFxcXCJkdW1teVxcXCIgdG8gdHVybiB0aGlzIGZlYXR1cmUgb2ZmLlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZHVtbXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzaW1wbGVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiZHVtbXlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGxhY2VtZW50c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXBsYWNlbWVudHNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIklmIFxcXCJwbGFjZW1lbnQtdHlwZVxcXCIgaXMgc2V0IHRvIFxcXCJzaW1wbGVcXFwiLCB1c2UgdGhpcyBcXFwiUE9TSVRJT05TLFtTSVpFU11cXFwiIHN0cmluZy4gQW4gZXhhbXBsZSBpcyBgdGV4dC1wbGFjZW1lbnRzOiBcXFwiRSxORSxTRSxXLE5XLFNXXFxcIjtgIFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LXRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInVwcGVyY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxvd2VyY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImNhcGl0YWxpemVcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUcmFuc2Zvcm0gdGhlIGNhc2Ugb2YgdGhlIGNoYXJhY3RlcnNcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJub25lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImhvcml6b250YWwtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtaG9yaXpvbnRhbC1hbGlnbm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1xuICAgICAgICAgICAgICAgICAgICBcImxlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtaWRkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcImF1dG9cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgdGV4dCdzIGhvcml6b250YWwgYWxpZ25tZW50IGZyb20gaXRzIGNlbnRlcnBvaW50XCIsXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJqdXN0aWZ5LWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWFsaWduXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhdXRvXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZG9jXCI6IFwiRGVmaW5lIGhvdyB0ZXh0IGlzIGp1c3RpZmllZFwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcIkF1dG8gYWxpZ25tZW50IG1lYW5zIHRoYXQgdGV4dCB3aWxsIGJlIGNlbnRlcmVkIGJ5IGRlZmF1bHQgZXhjZXB0IHdoZW4gdXNpbmcgdGhlIGBwbGFjZW1lbnQtdHlwZWAgcGFyYW1ldGVyIC0gaW4gdGhhdCBjYXNlIGVpdGhlciByaWdodCBvciBsZWZ0IGp1c3RpZmljYXRpb24gd2lsbCBiZSB1c2VkIGF1dG9tYXRpY2FsbHkgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSB0ZXh0IGNvdWxkIGJlIGZpdCBnaXZlbiB0aGUgYHRleHQtcGxhY2VtZW50c2AgZGlyZWN0aXZlc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjbGlwXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcInRleHQtY2xpcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcImdlb21ldHJ5IHdpbGwgYmUgY2xpcHBlZCB0byBtYXAgYm91bmRzIGJlZm9yZSByZW5kZXJpbmdcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcImdlb21ldHJpZXMgYXJlIGNsaXBwZWQgdG8gbWFwIGJvdW5kcyBieSBkZWZhdWx0IGZvciBiZXN0IHJlbmRlcmluZyBwZXJmb3JtYW5jZS4gSW4gc29tZSBjYXNlcyB1c2VycyBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgdG8gYXZvaWQgcmVuZGVyaW5nIGFydGlmYWN0cy5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY29tcC1vcFwiOiB7XG4gICAgICAgICAgICAgICAgXCJjc3NcIjogXCJ0ZXh0LWNvbXAtb3BcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiYWRkIHRoZSBjdXJyZW50IHN5bWJvbGl6ZXIgb24gdG9wIG9mIG90aGVyIHN5bWJvbGl6ZXJcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIkNvbXBvc2l0ZSBvcGVyYXRpb24uIFRoaXMgZGVmaW5lcyBob3cgdGhpcyBzeW1ib2xpemVyIHNob3VsZCBiZWhhdmUgcmVsYXRpdmUgdG8gc3ltYm9saXplcnMgYXRvcCBvciBiZWxvdyBpdC5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogW1wiY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtb3ZlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZHN0LWluXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3JjLW91dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzcmMtYXRvcFwiLFxuICAgICAgICAgICAgICAgICAgICBcImRzdC1hdG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwieG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicGx1c1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm1pbnVzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibXVsdGlwbHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdmVybGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlnaHRlblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29sb3ItYnVyblwiLFxuICAgICAgICAgICAgICAgICAgICBcImhhcmQtbGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb2Z0LWxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlmZmVyZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4Y2x1c2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaW52ZXJ0LXJnYlwiLFxuICAgICAgICAgICAgICAgICAgICBcImdyYWluLW1lcmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhaW4tZXh0cmFjdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImh1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNhdHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnVpbGRpbmdcIjoge1xuICAgICAgICAgICAgXCJmaWxsXCI6IHtcbiAgICAgICAgICAgICAgICBcImNzc1wiOiBcImJ1aWxkaW5nLWZpbGxcIixcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGJ1aWxkaW5ncyB3YWxscy5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiYnVpbGRpbmctZmlsbC1vcGFjaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBidWlsZGluZyBhcyBhIHdob2xlLCBpbmNsdWRpbmcgYWxsIHdhbGxzLlwiLFxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJoZWlnaHRcIjoge1xuICAgICAgICAgICAgICAgIFwiY3NzXCI6IFwiYnVpbGRpbmctaGVpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJkb2NcIjogXCJUaGUgaGVpZ2h0IG9mIHRoZSBidWlsZGluZyBpbiBwaXhlbHMuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBcImV4cHJlc3Npb25cIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIwXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3JxdWVcIjoge1xuICAgICAgICAgIFwiLXRvcnF1ZS1jbGVhci1jb2xvclwiOiB7XG4gICAgICAgICAgICAgIFwiY3NzXCI6IFwiLXRvcnF1ZS1jbGVhci1jb2xvclwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApXCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwiZnVsbCBjbGVhclwiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcImNvbG9yIHVzZWQgdG8gY2xlYXIgY2FudmFzIG9uIGVhY2ggZnJhbWVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCItdG9ycXVlLWZyYW1lLWNvdW50XCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLWZyYW1lLWNvdW50XCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcIjEyOFwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjpcImZsb2F0XCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIGRhdGEgaXMgYnJva2VuIGludG8gMTI4IHRpbWUgZnJhbWVzXCIsXG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiTnVtYmVyIG9mIGFuaW1hdGlvbiBzdGVwcy9mcmFtZXMgdXNlZCBpbiB0aGUgYW5pbWF0aW9uLiBJZiB0aGUgZGF0YSBjb250YWlucyBhIGZld2VyZSBudW1iZXIgb2YgdG90YWwgZnJhbWVzLCB0aGUgbGVzc2VyIHZhbHVlIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCItdG9ycXVlLXJlc29sdXRpb25cIjoge1xuICAgICAgICAgICAgICBcImNzc1wiOiBcIi10b3JxdWUtcmVzb2x1dGlvblwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIyXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOlwiZmxvYXRcIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LW1lYW5pbmdcIjogXCJcIixcbiAgICAgICAgICAgICAgXCJkb2NcIjogXCJTcGF0aWFsIHJlc29sdXRpb24gaW4gcGl4ZWxzLiBBIHJlc29sdXRpb24gb2YgMSBtZWFucyBubyBzcGF0aWFsIGFnZ3JlZ2F0aW9uIG9mIHRoZSBkYXRhLiBBbnkgb3RoZXIgcmVzb2x1dGlvbiBvZiBOIHJlc3VsdHMgaW4gc3BhdGlhbCBhZ2dyZWdhdGlvbiBpbnRvIGNlbGxzIG9mIE54TiBwaXhlbHMuIFRoZSB2YWx1ZSBOIG11c3QgYmUgcG93ZXIgb2YgMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIi10b3JxdWUtYW5pbWF0aW9uLWR1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLWFuaW1hdGlvbi1kdXJhdGlvblwiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogXCIzMFwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjpcImZsb2F0XCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIGFuaW1hdGlvbiBsYXN0cyAzMCBzZWNvbmRzXCIsXG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiQW5pbWF0aW9uIGR1cmF0aW9uIGluIHNlY29uZHNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCItdG9ycXVlLWFnZ3JlZ2F0aW9uLWZ1bmN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLWFnZ3JlZ2F0aW9uLWZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcImNvdW50KGNhcnRvZGJfaWQpXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInRoZSB2YWx1ZSBmb3IgZWFjaCBjZWxsIGlzIHRoZSBjb3VudCBvZiBwb2ludHMgaW4gdGhhdCBjZWxsXCIsXG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBmdW5jdGlvbiB1c2VkIHRvIGNhbGN1bGF0ZSBhIHZhbHVlIGZyb20gdGhlIGFnZ3JlZ2F0ZSBkYXRhIGZvciBlYWNoIGNlbGwuIFNlZSAtdG9ycXVlLXJlc29sdXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCItdG9ycXVlLXRpbWUtYXR0cmlidXRlXCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLXRpbWUtYXR0cmlidXRlXCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC12YWx1ZVwiOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1tZWFuaW5nXCI6IFwidGhlIGRhdGEgY29sdW1uIGluIHlvdXIgdGFibGUgdGhhdCBpcyBvZiBhIHRpbWUgYmFzZWQgdHlwZVwiLFxuICAgICAgICAgICAgICBcImRvY1wiOiBcIlRoZSB0YWJsZSBjb2x1bW4gdGhhdCBjb250YWlucyB0aGUgdGltZSBpbmZvcm1hdGlvbiB1c2VkIGNyZWF0ZSB0aGUgYW5pbWF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiLXRvcnF1ZS1kYXRhLWFnZ3JlZ2F0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJjc3NcIjogXCItdG9ycXVlLWRhdGEtYWdncmVnYXRpb25cIixcbiAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IFwibGluZWFyXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBbXG4gICAgICAgICAgICAgICAgXCJsaW5lYXJcIixcbiAgICAgICAgICAgICAgICBcImN1bXVsYXRpdmVcIlxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBcImRlZmF1bHQtbWVhbmluZ1wiOiBcInByZXZpb3VzIHZhbHVlcyBhcmUgZGlzY2FyZGVkXCIsXG4gICAgICAgICAgICAgIFwiZG9jXCI6IFwiQSBsaW5lYXIgYW5pbWF0aW9uIHdpbGwgZGlzY2FyZCBwcmV2aW91cyB2YWx1ZXMgd2hpbGUgYSBjdW11bGF0aXZlIGFuaW1hdGlvbiB3aWxsIGFjY3VtdWxhdGUgdGhlbSB1bnRpbCBpdCByZXN0YXJ0c1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImNvbG9yc1wiOiB7XG4gICAgICAgIFwiYWxpY2VibHVlXCI6ICBbMjQwLCAyNDgsIDI1NV0sXG4gICAgICAgIFwiYW50aXF1ZXdoaXRlXCI6ICBbMjUwLCAyMzUsIDIxNV0sXG4gICAgICAgIFwiYXF1YVwiOiAgWzAsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJhcXVhbWFyaW5lXCI6ICBbMTI3LCAyNTUsIDIxMl0sXG4gICAgICAgIFwiYXp1cmVcIjogIFsyNDAsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJiZWlnZVwiOiAgWzI0NSwgMjQ1LCAyMjBdLFxuICAgICAgICBcImJpc3F1ZVwiOiAgWzI1NSwgMjI4LCAxOTZdLFxuICAgICAgICBcImJsYWNrXCI6ICBbMCwgMCwgMF0sXG4gICAgICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogIFsyNTUsMjM1LDIwNV0sXG4gICAgICAgIFwiYmx1ZVwiOiAgWzAsIDAsIDI1NV0sXG4gICAgICAgIFwiYmx1ZXZpb2xldFwiOiAgWzEzOCwgNDMsIDIyNl0sXG4gICAgICAgIFwiYnJvd25cIjogIFsxNjUsIDQyLCA0Ml0sXG4gICAgICAgIFwiYnVybHl3b29kXCI6ICBbMjIyLCAxODQsIDEzNV0sXG4gICAgICAgIFwiY2FkZXRibHVlXCI6ICBbOTUsIDE1OCwgMTYwXSxcbiAgICAgICAgXCJjaGFydHJldXNlXCI6ICBbMTI3LCAyNTUsIDBdLFxuICAgICAgICBcImNob2NvbGF0ZVwiOiAgWzIxMCwgMTA1LCAzMF0sXG4gICAgICAgIFwiY29yYWxcIjogIFsyNTUsIDEyNywgODBdLFxuICAgICAgICBcImNvcm5mbG93ZXJibHVlXCI6ICBbMTAwLCAxNDksIDIzN10sXG4gICAgICAgIFwiY29ybnNpbGtcIjogIFsyNTUsIDI0OCwgMjIwXSxcbiAgICAgICAgXCJjcmltc29uXCI6ICBbMjIwLCAyMCwgNjBdLFxuICAgICAgICBcImN5YW5cIjogIFswLCAyNTUsIDI1NV0sXG4gICAgICAgIFwiZGFya2JsdWVcIjogIFswLCAwLCAxMzldLFxuICAgICAgICBcImRhcmtjeWFuXCI6ICBbMCwgMTM5LCAxMzldLFxuICAgICAgICBcImRhcmtnb2xkZW5yb2RcIjogIFsxODQsIDEzNCwgMTFdLFxuICAgICAgICBcImRhcmtncmF5XCI6ICBbMTY5LCAxNjksIDE2OV0sXG4gICAgICAgIFwiZGFya2dyZWVuXCI6ICBbMCwgMTAwLCAwXSxcbiAgICAgICAgXCJkYXJrZ3JleVwiOiAgWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICBcImRhcmtraGFraVwiOiAgWzE4OSwgMTgzLCAxMDddLFxuICAgICAgICBcImRhcmttYWdlbnRhXCI6ICBbMTM5LCAwLCAxMzldLFxuICAgICAgICBcImRhcmtvbGl2ZWdyZWVuXCI6ICBbODUsIDEwNywgNDddLFxuICAgICAgICBcImRhcmtvcmFuZ2VcIjogIFsyNTUsIDE0MCwgMF0sXG4gICAgICAgIFwiZGFya29yY2hpZFwiOiAgWzE1MywgNTAsIDIwNF0sXG4gICAgICAgIFwiZGFya3JlZFwiOiAgWzEzOSwgMCwgMF0sXG4gICAgICAgIFwiZGFya3NhbG1vblwiOiAgWzIzMywgMTUwLCAxMjJdLFxuICAgICAgICBcImRhcmtzZWFncmVlblwiOiAgWzE0MywgMTg4LCAxNDNdLFxuICAgICAgICBcImRhcmtzbGF0ZWJsdWVcIjogIFs3MiwgNjEsIDEzOV0sXG4gICAgICAgIFwiZGFya3NsYXRlZ3JleVwiOiAgWzQ3LCA3OSwgNzldLFxuICAgICAgICBcImRhcmt0dXJxdW9pc2VcIjogIFswLCAyMDYsIDIwOV0sXG4gICAgICAgIFwiZGFya3Zpb2xldFwiOiAgWzE0OCwgMCwgMjExXSxcbiAgICAgICAgXCJkZWVwcGlua1wiOiAgWzI1NSwgMjAsIDE0N10sXG4gICAgICAgIFwiZGVlcHNreWJsdWVcIjogIFswLCAxOTEsIDI1NV0sXG4gICAgICAgIFwiZGltZ3JheVwiOiAgWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICBcImRpbWdyZXlcIjogIFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgICAgXCJkb2RnZXJibHVlXCI6ICBbMzAsIDE0NCwgMjU1XSxcbiAgICAgICAgXCJmaXJlYnJpY2tcIjogIFsxNzgsIDM0LCAzNF0sXG4gICAgICAgIFwiZmxvcmFsd2hpdGVcIjogIFsyNTUsIDI1MCwgMjQwXSxcbiAgICAgICAgXCJmb3Jlc3RncmVlblwiOiAgWzM0LCAxMzksIDM0XSxcbiAgICAgICAgXCJmdWNoc2lhXCI6ICBbMjU1LCAwLCAyNTVdLFxuICAgICAgICBcImdhaW5zYm9yb1wiOiAgWzIyMCwgMjIwLCAyMjBdLFxuICAgICAgICBcImdob3N0d2hpdGVcIjogIFsyNDgsIDI0OCwgMjU1XSxcbiAgICAgICAgXCJnb2xkXCI6ICBbMjU1LCAyMTUsIDBdLFxuICAgICAgICBcImdvbGRlbnJvZFwiOiAgWzIxOCwgMTY1LCAzMl0sXG4gICAgICAgIFwiZ3JheVwiOiAgWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgICBcImdyZXlcIjogIFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJncmVlblwiOiAgWzAsIDEyOCwgMF0sXG4gICAgICAgIFwiZ3JlZW55ZWxsb3dcIjogIFsxNzMsIDI1NSwgNDddLFxuICAgICAgICBcImhvbmV5ZGV3XCI6ICBbMjQwLCAyNTUsIDI0MF0sXG4gICAgICAgIFwiaG90cGlua1wiOiAgWzI1NSwgMTA1LCAxODBdLFxuICAgICAgICBcImluZGlhbnJlZFwiOiAgWzIwNSwgOTIsIDkyXSxcbiAgICAgICAgXCJpbmRpZ29cIjogIFs3NSwgMCwgMTMwXSxcbiAgICAgICAgXCJpdm9yeVwiOiAgWzI1NSwgMjU1LCAyNDBdLFxuICAgICAgICBcImtoYWtpXCI6ICBbMjQwLCAyMzAsIDE0MF0sXG4gICAgICAgIFwibGF2ZW5kZXJcIjogIFsyMzAsIDIzMCwgMjUwXSxcbiAgICAgICAgXCJsYXZlbmRlcmJsdXNoXCI6ICBbMjU1LCAyNDAsIDI0NV0sXG4gICAgICAgIFwibGF3bmdyZWVuXCI6ICBbMTI0LCAyNTIsIDBdLFxuICAgICAgICBcImxlbW9uY2hpZmZvblwiOiAgWzI1NSwgMjUwLCAyMDVdLFxuICAgICAgICBcImxpZ2h0Ymx1ZVwiOiAgWzE3MywgMjE2LCAyMzBdLFxuICAgICAgICBcImxpZ2h0Y29yYWxcIjogIFsyNDAsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJsaWdodGN5YW5cIjogIFsyMjQsIDI1NSwgMjU1XSxcbiAgICAgICAgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiAgWzI1MCwgMjUwLCAyMTBdLFxuICAgICAgICBcImxpZ2h0Z3JheVwiOiAgWzIxMSwgMjExLCAyMTFdLFxuICAgICAgICBcImxpZ2h0Z3JlZW5cIjogIFsxNDQsIDIzOCwgMTQ0XSxcbiAgICAgICAgXCJsaWdodGdyZXlcIjogIFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgXCJsaWdodHBpbmtcIjogIFsyNTUsIDE4MiwgMTkzXSxcbiAgICAgICAgXCJsaWdodHNhbG1vblwiOiAgWzI1NSwgMTYwLCAxMjJdLFxuICAgICAgICBcImxpZ2h0c2VhZ3JlZW5cIjogIFszMiwgMTc4LCAxNzBdLFxuICAgICAgICBcImxpZ2h0c2t5Ymx1ZVwiOiAgWzEzNSwgMjA2LCAyNTBdLFxuICAgICAgICBcImxpZ2h0c2xhdGVncmF5XCI6ICBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgIFwibGlnaHRzbGF0ZWdyZXlcIjogIFsxMTksIDEzNiwgMTUzXSxcbiAgICAgICAgXCJsaWdodHN0ZWVsYmx1ZVwiOiAgWzE3NiwgMTk2LCAyMjJdLFxuICAgICAgICBcImxpZ2h0eWVsbG93XCI6ICBbMjU1LCAyNTUsIDIyNF0sXG4gICAgICAgIFwibGltZVwiOiAgWzAsIDI1NSwgMF0sXG4gICAgICAgIFwibGltZWdyZWVuXCI6ICBbNTAsIDIwNSwgNTBdLFxuICAgICAgICBcImxpbmVuXCI6ICBbMjUwLCAyNDAsIDIzMF0sXG4gICAgICAgIFwibWFnZW50YVwiOiAgWzI1NSwgMCwgMjU1XSxcbiAgICAgICAgXCJtYXJvb25cIjogIFsxMjgsIDAsIDBdLFxuICAgICAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogIFsxMDIsIDIwNSwgMTcwXSxcbiAgICAgICAgXCJtZWRpdW1ibHVlXCI6ICBbMCwgMCwgMjA1XSxcbiAgICAgICAgXCJtZWRpdW1vcmNoaWRcIjogIFsxODYsIDg1LCAyMTFdLFxuICAgICAgICBcIm1lZGl1bXB1cnBsZVwiOiAgWzE0NywgMTEyLCAyMTldLFxuICAgICAgICBcIm1lZGl1bXNlYWdyZWVuXCI6ICBbNjAsIDE3OSwgMTEzXSxcbiAgICAgICAgXCJtZWRpdW1zbGF0ZWJsdWVcIjogIFsxMjMsIDEwNCwgMjM4XSxcbiAgICAgICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiAgWzAsIDI1MCwgMTU0XSxcbiAgICAgICAgXCJtZWRpdW10dXJxdW9pc2VcIjogIFs3MiwgMjA5LCAyMDRdLFxuICAgICAgICBcIm1lZGl1bXZpb2xldHJlZFwiOiAgWzE5OSwgMjEsIDEzM10sXG4gICAgICAgIFwibWlkbmlnaHRibHVlXCI6ICBbMjUsIDI1LCAxMTJdLFxuICAgICAgICBcIm1pbnRjcmVhbVwiOiAgWzI0NSwgMjU1LCAyNTBdLFxuICAgICAgICBcIm1pc3R5cm9zZVwiOiAgWzI1NSwgMjI4LCAyMjVdLFxuICAgICAgICBcIm1vY2Nhc2luXCI6ICBbMjU1LCAyMjgsIDE4MV0sXG4gICAgICAgIFwibmF2YWpvd2hpdGVcIjogIFsyNTUsIDIyMiwgMTczXSxcbiAgICAgICAgXCJuYXZ5XCI6ICBbMCwgMCwgMTI4XSxcbiAgICAgICAgXCJvbGRsYWNlXCI6ICBbMjUzLCAyNDUsIDIzMF0sXG4gICAgICAgIFwib2xpdmVcIjogIFsxMjgsIDEyOCwgMF0sXG4gICAgICAgIFwib2xpdmVkcmFiXCI6ICBbMTA3LCAxNDIsIDM1XSxcbiAgICAgICAgXCJvcmFuZ2VcIjogIFsyNTUsIDE2NSwgMF0sXG4gICAgICAgIFwib3JhbmdlcmVkXCI6ICBbMjU1LCA2OSwgMF0sXG4gICAgICAgIFwib3JjaGlkXCI6ICBbMjE4LCAxMTIsIDIxNF0sXG4gICAgICAgIFwicGFsZWdvbGRlbnJvZFwiOiAgWzIzOCwgMjMyLCAxNzBdLFxuICAgICAgICBcInBhbGVncmVlblwiOiAgWzE1MiwgMjUxLCAxNTJdLFxuICAgICAgICBcInBhbGV0dXJxdW9pc2VcIjogIFsxNzUsIDIzOCwgMjM4XSxcbiAgICAgICAgXCJwYWxldmlvbGV0cmVkXCI6ICBbMjE5LCAxMTIsIDE0N10sXG4gICAgICAgIFwicGFwYXlhd2hpcFwiOiAgWzI1NSwgMjM5LCAyMTNdLFxuICAgICAgICBcInBlYWNocHVmZlwiOiAgWzI1NSwgMjE4LCAxODVdLFxuICAgICAgICBcInBlcnVcIjogIFsyMDUsIDEzMywgNjNdLFxuICAgICAgICBcInBpbmtcIjogIFsyNTUsIDE5MiwgMjAzXSxcbiAgICAgICAgXCJwbHVtXCI6ICBbMjIxLCAxNjAsIDIyMV0sXG4gICAgICAgIFwicG93ZGVyYmx1ZVwiOiAgWzE3NiwgMjI0LCAyMzBdLFxuICAgICAgICBcInB1cnBsZVwiOiAgWzEyOCwgMCwgMTI4XSxcbiAgICAgICAgXCJyZWRcIjogIFsyNTUsIDAsIDBdLFxuICAgICAgICBcInJvc3licm93blwiOiAgWzE4OCwgMTQzLCAxNDNdLFxuICAgICAgICBcInJveWFsYmx1ZVwiOiAgWzY1LCAxMDUsIDIyNV0sXG4gICAgICAgIFwic2FkZGxlYnJvd25cIjogIFsxMzksIDY5LCAxOV0sXG4gICAgICAgIFwic2FsbW9uXCI6ICBbMjUwLCAxMjgsIDExNF0sXG4gICAgICAgIFwic2FuZHlicm93blwiOiAgWzI0NCwgMTY0LCA5Nl0sXG4gICAgICAgIFwic2VhZ3JlZW5cIjogIFs0NiwgMTM5LCA4N10sXG4gICAgICAgIFwic2Vhc2hlbGxcIjogIFsyNTUsIDI0NSwgMjM4XSxcbiAgICAgICAgXCJzaWVubmFcIjogIFsxNjAsIDgyLCA0NV0sXG4gICAgICAgIFwic2lsdmVyXCI6ICBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgICAgIFwic2t5Ymx1ZVwiOiAgWzEzNSwgMjA2LCAyMzVdLFxuICAgICAgICBcInNsYXRlYmx1ZVwiOiAgWzEwNiwgOTAsIDIwNV0sXG4gICAgICAgIFwic2xhdGVncmF5XCI6ICBbMTEyLCAxMjgsIDE0NF0sXG4gICAgICAgIFwic2xhdGVncmV5XCI6ICBbMTEyLCAxMjgsIDE0NF0sXG4gICAgICAgIFwic25vd1wiOiAgWzI1NSwgMjUwLCAyNTBdLFxuICAgICAgICBcInNwcmluZ2dyZWVuXCI6ICBbMCwgMjU1LCAxMjddLFxuICAgICAgICBcInN0ZWVsYmx1ZVwiOiAgWzcwLCAxMzAsIDE4MF0sXG4gICAgICAgIFwidGFuXCI6ICBbMjEwLCAxODAsIDE0MF0sXG4gICAgICAgIFwidGVhbFwiOiAgWzAsIDEyOCwgMTI4XSxcbiAgICAgICAgXCJ0aGlzdGxlXCI6ICBbMjE2LCAxOTEsIDIxNl0sXG4gICAgICAgIFwidG9tYXRvXCI6ICBbMjU1LCA5OSwgNzFdLFxuICAgICAgICBcInR1cnF1b2lzZVwiOiAgWzY0LCAyMjQsIDIwOF0sXG4gICAgICAgIFwidmlvbGV0XCI6ICBbMjM4LCAxMzAsIDIzOF0sXG4gICAgICAgIFwid2hlYXRcIjogIFsyNDUsIDIyMiwgMTc5XSxcbiAgICAgICAgXCJ3aGl0ZVwiOiAgWzI1NSwgMjU1LCAyNTVdLFxuICAgICAgICBcIndoaXRlc21va2VcIjogIFsyNDUsIDI0NSwgMjQ1XSxcbiAgICAgICAgXCJ5ZWxsb3dcIjogIFsyNTUsIDI1NSwgMF0sXG4gICAgICAgIFwieWVsbG93Z3JlZW5cIjogIFsxNTQsIDIwNSwgNTBdLFxuICAgICAgICBcInRyYW5zcGFyZW50XCI6ICBbMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgICAgXCJ2YWx1ZVwiOiBbXG4gICAgICAgICAgICBcInRydWVcIixcbiAgICAgICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgICAgIFwibnVsbFwiLFxuICAgICAgICAgICAgXCJwb2ludFwiLFxuICAgICAgICAgICAgXCJsaW5lc3RyaW5nXCIsXG4gICAgICAgICAgICBcInBvbHlnb25cIixcbiAgICAgICAgICAgIFwiY29sbGVjdGlvblwiXG4gICAgICAgIF1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJzaW9uOiB7XG4gICAgbGF0ZXN0OiBfbWFwbmlrX3JlZmVyZW5jZV9sYXRlc3QsXG4gICAgJzIuMS4xJzogX21hcG5pa19yZWZlcmVuY2VfbGF0ZXN0XG4gIH1cbn07XG4iLCIvKipcbiAqIFRPRE86IGRvY3VtZW50IHRoaXMuIFdoYXQgZG9lcyB0aGlzIGRvP1xuICovXG5pZih0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBtb2R1bGUuZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gKG9iaiwgZnVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyID0gZnVuLmNhbGwob2JqLCBvYmpbaV0pKSB7IHJldHVybiByOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbiIsIihmdW5jdGlvbih0cmVlKSB7XG52YXIgXyA9IGdsb2JhbC5fIHx8IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnRyZWUuQ2FsbCA9IGZ1bmN0aW9uIENhbGwobmFtZSwgYXJncywgaW5kZXgpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxudHJlZS5DYWxsLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ2NhbGwnLFxuICAgIC8vIFdoZW4gZXZ1YXRpbmcgYSBmdW5jdGlvbiBjYWxsLFxuICAgIC8vIHdlIGVpdGhlciBmaW5kIHRoZSBmdW5jdGlvbiBpbiBgdHJlZS5mdW5jdGlvbnNgIFsxXSxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGNhbGwgaXQsIHBhc3NpbmcgdGhlICBldmFsdWF0ZWQgYXJndW1lbnRzLFxuICAgIC8vIG9yIHdlIHNpbXBseSBwcmludCBpdCBvdXQgYXMgaXQgYXBwZWFyZWQgb3JpZ2luYWxseSBbMl0uXG4gICAgLy8gVGhlICpmdW5jdGlvbnMuanMqIGZpbGUgY29udGFpbnMgdGhlIGJ1aWx0LWluIGZ1bmN0aW9ucy5cbiAgICAvLyBUaGUgcmVhc29uIHdoeSB3ZSBldmFsdWF0ZSB0aGUgYXJndW1lbnRzLCBpcyBpbiB0aGUgY2FzZSB3aGVyZVxuICAgIC8vIHdlIHRyeSB0byBwYXNzIGEgdmFyaWFibGUgdG8gYSBmdW5jdGlvbiwgbGlrZTogYHNhdHVyYXRlKEBjb2xvcilgLlxuICAgIC8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSB0aGUgdmFsdWUsIG5vdCB0aGUgdmFyaWFibGUuXG4gICAgJ2V2JzogZnVuY3Rpb24oZW52KSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLmV2KGVudik7IH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3NbaV0uaXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmFtZSBpbiB0cmVlLmZ1bmN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyZWUuZnVuY3Rpb25zW3RoaXMubmFtZV0ubGVuZ3RoIDw9IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRyZWUuZnVuY3Rpb25zW3RoaXMubmFtZV0uYXBwbHkodHJlZS5mdW5jdGlvbnMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmNvcnJlY3QgYXJndW1lbnRzIGdpdmVuIHRvICcgKyB0aGlzLm5hbWUgKyAnKCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncnVudGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaXM6ICd1bmRlZmluZWQnLCB2YWx1ZTogJ3VuZGVmaW5lZCcgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciAnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoKS4gJyArIHRyZWUuZnVuY3Rpb25zW3RoaXMubmFtZV0ubGVuZ3RoICsgJyBleHBlY3RlZC4nLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHRyZWUuUmVmZXJlbmNlLm1hcG5pa0Z1bmN0aW9uc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25zID0gXy5wYWlycyh0cmVlLlJlZmVyZW5jZS5tYXBuaWtGdW5jdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWFwIGNsb3Nlc3QsIG5lZWRzIGltcHJvdmVtZW50LlxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciBtZWFuID0gZnVuY3Rpb25zLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZlswXSwgdHJlZS5SZWZlcmVuY2UuZWRpdERpc3RhbmNlKG5hbWUsIGZbMF0pLCBmWzFdXTtcbiAgICAgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbMV0gLSBiWzFdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICd1bmtub3duIGZ1bmN0aW9uICcgKyB0aGlzLm5hbWUgKyAnKCksIGRpZCB5b3UgbWVhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYW5bMF1bMF0gKyAnKCcgKyBtZWFuWzBdWzJdICsgJyknLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbiAhPT0gYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAhKEFycmF5LmlzQXJyYXkoZm4pICYmIF8uaW5jbHVkZShmbiwgYXJncy5sZW5ndGgpKSAmJlxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgdmFyaWFibGUtYXJnIGZ1bmN0aW9ucyBsaWtlIGBjb2xvcml6ZS1hbHBoYWBcbiAgICAgICAgICAgICAgICBmbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoKSB0YWtlcyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuICsgJyBhcmd1bWVudHMgYW5kIHdhcyBnaXZlbiAnICsgYXJncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncnVudGltZScsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBldmFsdWF0ZWQgdmVyc2lvbnMgb2YgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW52LCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnKCcgKyB0aGlzLmFyZ3Muam9pbignLCcpICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuLy8gUkdCIENvbG9ycyAtICNmZjAwMTQsICNlZWVcbi8vIGNhbiBiZSBpbml0aWFsaXplZCB3aXRoIGEgMyBvciA2IGNoYXIgc3RyaW5nIG9yIGEgMyBvciA0IGVsZW1lbnRcbi8vIG51bWVyaWNhbCBhcnJheVxudHJlZS5Db2xvciA9IGZ1bmN0aW9uIENvbG9yKHJnYiwgYSkge1xuICAgIC8vIFRoZSBlbmQgZ29hbCBoZXJlLCBpcyB0byBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgLy8gaW50byBhbiBpbnRlZ2VyIHRyaXBsZXQsIHN1Y2ggYXMgYDEyOCwgMjU1LCAwYFxuICAgIC8vXG4gICAgLy8gVGhpcyBmYWNpbGl0YXRlcyBvcGVyYXRpb25zIGFuZCBjb252ZXJzaW9ucy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZ2IpKSB7XG4gICAgICAgIHRoaXMucmdiID0gcmdiLnNsaWNlKDAsIDMpO1xuICAgIH0gZWxzZSBpZiAocmdiLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgIHRoaXMucmdiID0gcmdiLm1hdGNoKC8uezJ9L2cpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYywgMTYpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJnYiA9IHJnYi5zcGxpdCgnJykubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjICsgYywgMTYpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmFscGhhID0gYTtcbiAgICB9IGVsc2UgaWYgKHJnYi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5hbHBoYSA9IHJnYlszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFscGhhID0gMTtcbiAgICB9XG59O1xuXG50cmVlLkNvbG9yLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ2NvbG9yJyxcbiAgICAnZXYnOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBJZiB3ZSBoYXZlIHNvbWUgdHJhbnNwYXJlbmN5LCB0aGUgb25seSB3YXkgdG8gcmVwcmVzZW50IGl0XG4gICAgLy8gaXMgdmlhIGByZ2JhYC4gT3RoZXJ3aXNlLCB3ZSB1c2UgdGhlIGhleCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3aGljaCBoYXMgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBicm93c2Vycy5cbiAgICAvLyBWYWx1ZXMgYXJlIGNhcHBlZCBiZXR3ZWVuIGAwYCBhbmQgYDI1NWAsIHJvdW5kZWQgYW5kIHplcm8tcGFkZGVkLlxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEgPCAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgdGhpcy5yZ2IubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjKTtcbiAgICAgICAgICAgIH0pLmNvbmNhdCh0aGlzLmFscGhhKS5qb2luKCcsICcpICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcjJyArIHRoaXMucmdiLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7XG4gICAgICAgICAgICAgICAgaSA9IChpID4gMjU1ID8gMjU1IDogKGkgPCAwID8gMCA6IGkpKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGVuZ3RoID09PSAxID8gJzAnICsgaSA6IGk7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBPcGVyYXRpb25zIGhhdmUgdG8gYmUgZG9uZSBwZXItY2hhbm5lbCwgaWYgbm90LFxuICAgIC8vIGNoYW5uZWxzIHdpbGwgc3BpbGwgb250byBlYWNoIG90aGVyLiBPbmNlIHdlIGhhdmVcbiAgICAvLyBvdXIgcmVzdWx0LCBpbiB0aGUgZm9ybSBvZiBhbiBpbnRlZ2VyIHRyaXBsZXQsXG4gICAgLy8gd2UgY3JlYXRlIGEgbmV3IENvbG9yIG5vZGUgdG8gaG9sZCB0aGUgcmVzdWx0LlxuICAgIG9wZXJhdGU6IGZ1bmN0aW9uKGVudiwgb3AsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiB0cmVlLkNvbG9yKSkge1xuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci50b0NvbG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDM7IGMrKykge1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gdHJlZS5vcGVyYXRlKG9wLCB0aGlzLnJnYltjXSwgb3RoZXIucmdiW2NdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ29sb3IocmVzdWx0KTtcbiAgICB9LFxuXG4gICAgdG9IU0w6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LFxuICAgICAgICAgICAgZyA9IHRoaXMucmdiWzFdIC8gMjU1LFxuICAgICAgICAgICAgYiA9IHRoaXMucmdiWzJdIC8gMjU1LFxuICAgICAgICAgICAgYSA9IHRoaXMuYWxwaGE7XG5cbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDIsIGQgPSBtYXggLSBtaW47XG5cbiAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICBoID0gcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggLz0gNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoOiBoICogMzYwLCBzOiBzLCBsOiBsLCBhOiBhIH07XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuQ29tbWVudCA9IGZ1bmN0aW9uIENvbW1lbnQodmFsdWUsIHNpbGVudCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNpbGVudCA9ICEhc2lsZW50O1xufTtcblxudHJlZS5Db21tZW50LnByb3RvdHlwZSA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW52KSB7XG4gICAgICAgIHJldHVybiAnPCEtLScgKyB0aGlzLnZhbHVlICsgJy0tPic7XG4gICAgfSxcbiAgICAnZXYnOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpLFxuICAgIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vIEEgZGVmaW5pdGlvbiBpcyB0aGUgY29tYmluYXRpb24gb2YgYSBzZWxlY3RvciBhbmQgcnVsZXMsIGxpa2Vcbi8vICNmb28ge1xuLy8gICAgIHBvbHlnb24tb3BhY2l0eToxLjA7XG4vLyB9XG4vL1xuLy8gVGhlIHNlbGVjdG9yIGNhbiBoYXZlIGZpbHRlcnNcbnRyZWUuRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIERlZmluaXRpb24oc2VsZWN0b3IsIHJ1bGVzKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IHNlbGVjdG9yLmVsZW1lbnRzO1xuICAgIGFzc2VydC5vayhzZWxlY3Rvci5maWx0ZXJzIGluc3RhbmNlb2YgdHJlZS5GaWx0ZXJzZXQpO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLnJ1bGVJbmRleCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoJ3pvb20nIGluIHRoaXMucnVsZXNbaV0pIHRoaXMucnVsZXNbaV0gPSB0aGlzLnJ1bGVzW2ldLmNsb25lKCk7XG4gICAgICAgIHRoaXMucnVsZXNbaV0uem9vbSA9IHNlbGVjdG9yLnpvb207XG4gICAgICAgIHRoaXMucnVsZUluZGV4W3RoaXMucnVsZXNbaV0udXBkYXRlSUQoKV0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmZpbHRlcnMgPSBzZWxlY3Rvci5maWx0ZXJzO1xuICAgIHRoaXMuem9vbSA9IHNlbGVjdG9yLnpvb207XG4gICAgdGhpcy5mcmFtZV9vZmZzZXQgPSBzZWxlY3Rvci5mcmFtZV9vZmZzZXQ7XG4gICAgdGhpcy5hdHRhY2htZW50ID0gc2VsZWN0b3IuYXR0YWNobWVudCB8fCAnX19kZWZhdWx0X18nO1xuICAgIHRoaXMuc3BlY2lmaWNpdHkgPSBzZWxlY3Rvci5zcGVjaWZpY2l0eSgpO1xufTtcblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHIgPSB0aGlzLmZpbHRlcnMudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyICs9ICdcXG4gICAgJyArIHRoaXMucnVsZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oZmlsdGVycykge1xuICAgIGlmIChmaWx0ZXJzKSBhc3NlcnQub2soZmlsdGVycyBpbnN0YW5jZW9mIHRyZWUuRmlsdGVyc2V0KTtcbiAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUpO1xuICAgIGNsb25lLnJ1bGVzID0gdGhpcy5ydWxlcy5zbGljZSgpO1xuICAgIGNsb25lLnJ1bGVJbmRleCA9IF8uY2xvbmUodGhpcy5ydWxlSW5kZXgpO1xuICAgIGNsb25lLmZpbHRlcnMgPSBmaWx0ZXJzID8gZmlsdGVycyA6IHRoaXMuZmlsdGVycy5jbG9uZSgpO1xuICAgIGNsb25lLmF0dGFjaG1lbnQgPSB0aGlzLmF0dGFjaG1lbnQ7XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS5hZGRSdWxlcyA9IGZ1bmN0aW9uKHJ1bGVzKSB7XG4gICAgdmFyIGFkZGVkID0gMDtcblxuICAgIC8vIEFkZCBvbmx5IHVuaXF1ZSBydWxlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5ydWxlSW5kZXhbcnVsZXNbaV0uaWRdKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZXNbaV0pO1xuICAgICAgICAgICAgdGhpcy5ydWxlSW5kZXhbcnVsZXNbaV0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGFkZGVkKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWQ7XG59O1xuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHNlbGVjdG9yIG1hdGNoZXMgYSBnaXZlbiBpZFxuLy8gYW5kIGFycmF5IG9mIGNsYXNzZXMsIGJ5IGRldGVybWluaW5nIHdoZXRoZXJcbi8vIGFsbCBlbGVtZW50cyBpdCBjb250YWlucyBtYXRjaC5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUuYXBwbGllc1RvID0gZnVuY3Rpb24oaWQsIGNsYXNzZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgICAgaWYgKCEoZWxlbS53aWxkY2FyZCB8fFxuICAgICAgICAgICAgKGVsZW0udHlwZSA9PT0gJ2NsYXNzJyAmJiBjbGFzc2VzW2VsZW0uY2xlYW5dKSB8fFxuICAgICAgICAgICAgKGVsZW0udHlwZSA9PT0gJ2lkJyAmJiBpZCA9PT0gZWxlbS5jbGVhbikpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gc3ltYm9saXplck5hbWUoc3ltYm9saXplcikge1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7IHJldHVybiBzdHJbMV0udG9VcHBlckNhc2UoKTsgfVxuICAgIHJldHVybiBzeW1ib2xpemVyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgc3ltYm9saXplci5zbGljZSgxKS5yZXBsYWNlKC9cXC0uLywgY2FwaXRhbGl6ZSkgKyAnU3ltYm9saXplcic7XG59XG5cbi8vIEdldCBhIHNpbXBsZSBsaXN0IG9mIHRoZSBzeW1ib2xpemVycywgaW4gb3JkZXJcbmZ1bmN0aW9uIHN5bWJvbGl6ZXJMaXN0KHN5bV9vcmRlcikge1xuICAgIHJldHVybiBzeW1fb3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2WzBdOyB9KTtcbn1cblxudHJlZS5EZWZpbml0aW9uLnByb3RvdHlwZS5zeW1ib2xpemVyc1RvWE1MID0gZnVuY3Rpb24oZW52LCBzeW1ib2xpemVycywgem9vbSkge1xuICAgIHZhciB4bWwgPSB6b29tLnRvWE1MKGVudikuam9pbignJykgKyB0aGlzLmZpbHRlcnMudG9YTUwoZW52KTtcblxuICAgIC8vIFNvcnQgc3ltYm9saXplcnMgYnkgdGhlIGluZGV4IG9mIHRoZWlyIGZpcnN0IHByb3BlcnR5IGRlZmluaXRpb25cbiAgICB2YXIgc3ltX29yZGVyID0gW10sIGluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3ltYm9saXplcnMpIHtcbiAgICAgICAgaW5kZXhlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN5bWJvbGl6ZXJzW2tleV0pIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChzeW1ib2xpemVyc1trZXldW3Byb3BdLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluX2lkeCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGluZGV4ZXMpO1xuICAgICAgICBzeW1fb3JkZXIucHVzaChba2V5LCBtaW5faWR4XSk7XG4gICAgfVxuXG4gICAgc3ltX29yZGVyID0gc3ltYm9saXplckxpc3Qoc3ltX29yZGVyKTtcbiAgICB2YXIgc3ltX2NvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltX29yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3ltYm9saXplcnNbc3ltX29yZGVyW2ldXTtcbiAgICAgICAgdmFyIHN5bWJvbGl6ZXIgPSBzeW1fb3JkZXJbaV0uc3BsaXQoJy8nKS5wb3AoKTtcblxuICAgICAgICAvLyBTa2lwIHRoZSBtYWdpY2FsICogc3ltYm9saXplciB3aGljaCBpcyB1c2VkIGZvciB1bml2ZXJzYWwgcHJvcGVydGllc1xuICAgICAgICAvLyB3aGljaCBhcmUgYnViYmxlZCB1cCB0byBTdHlsZSBlbGVtZW50cyBpbnRlYWQgb2YgU3ltYm9saXplciBlbGVtZW50cy5cbiAgICAgICAgaWYgKHN5bWJvbGl6ZXIgPT09ICcqJykgY29udGludWU7XG4gICAgICAgIHN5bV9jb3VudCsrO1xuXG4gICAgICAgIHZhciBmYWlsID0gdHJlZS5SZWZlcmVuY2UucmVxdWlyZWRQcm9wZXJ0aWVzKHN5bWJvbGl6ZXIsIGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoZmFpbCkge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBhdHRyaWJ1dGVzW09iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNoaWZ0KCldO1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBmYWlsLFxuICAgICAgICAgICAgICAgIGluZGV4OiBydWxlLmluZGV4LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBydWxlLmZpbGVuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gc3ltYm9saXplck5hbWUoc3ltYm9saXplcik7XG5cbiAgICAgICAgdmFyIHNlbGZjbG9zaW5nID0gdHJ1ZSwgdGFnY29udGVudDtcbiAgICAgICAgeG1sICs9ICcgICAgPCcgKyBuYW1lICsgJyAnO1xuICAgICAgICBmb3IgKHZhciBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2xpemVyID09PSAnbWFwJykgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTWFwIHByb3BlcnRpZXMgYXJlIG5vdCBwZXJtaXR0ZWQgaW4gb3RoZXIgcnVsZXMnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBhdHRyaWJ1dGVzW2pdLmluZGV4LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBhdHRyaWJ1dGVzW2pdLmZpbGVuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB4ID0gdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IoYXR0cmlidXRlc1tqXS5uYW1lKTtcbiAgICAgICAgICAgIGlmICh4ICYmIHguc2VyaWFsaXphdGlvbiAmJiB4LnNlcmlhbGl6YXRpb24gPT09ICdjb250ZW50Jykge1xuICAgICAgICAgICAgICAgIHNlbGZjbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFnY29udGVudCA9IGF0dHJpYnV0ZXNbal0uZXYoZW52KS50b1hNTChlbnYsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4ICYmIHguc2VyaWFsaXphdGlvbiAmJiB4LnNlcmlhbGl6YXRpb24gPT09ICd0YWcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZmNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YWdjb250ZW50ID0gYXR0cmlidXRlc1tqXS5ldihlbnYpLnRvWE1MKGVudiwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhtbCArPSBhdHRyaWJ1dGVzW2pdLmV2KGVudikudG9YTUwoZW52KSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHhtbCArPSAnLz5cXG4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YWdjb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodGFnY29udGVudC5pbmRleE9mKCc8JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB4bWwgKz0gJz4nICsgdGFnY29udGVudCArICc8LycgKyBuYW1lICsgJz5cXG4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bWwgKz0gJz48IVtDREFUQVsnICsgdGFnY29udGVudCArICddXT48LycgKyBuYW1lICsgJz5cXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc3ltX2NvdW50IHx8ICF4bWwpIHJldHVybiAnJztcbiAgICByZXR1cm4gJyAgPFJ1bGU+XFxuJyArIHhtbCArICcgIDwvUnVsZT5cXG4nO1xufTtcblxuLy8gVGFrZSBhIHpvb20gcmFuZ2Ugb2Ygem9vbXMgYW5kICdpJywgdGhlIGluZGV4IG9mIGEgcnVsZSBpbiB0aGlzLnJ1bGVzLFxuLy8gYW5kIGZpbmRzIGFsbCBhcHBsaWNhYmxlIHN5bWJvbGl6ZXJzXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLmNvbGxlY3RTeW1ib2xpemVycyA9IGZ1bmN0aW9uKHpvb21zLCBpKSB7XG4gICAgdmFyIHN5bWJvbGl6ZXJzID0ge30sIGNoaWxkO1xuXG4gICAgZm9yICh2YXIgaiA9IGk7IGogPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5ydWxlc1tqXTtcbiAgICAgICAgdmFyIGtleSA9IGNoaWxkLmluc3RhbmNlICsgJy8nICsgY2hpbGQuc3ltYm9saXplcjtcbiAgICAgICAgaWYgKHpvb21zLmN1cnJlbnQgJiBjaGlsZC56b29tICYmXG4gICAgICAgICAgICghKGtleSBpbiBzeW1ib2xpemVycykgfHxcbiAgICAgICAgICAgKCEoY2hpbGQubmFtZSBpbiBzeW1ib2xpemVyc1trZXldKSkpKSB7XG4gICAgICAgICAgICB6b29tcy5jdXJyZW50ICY9IGNoaWxkLnpvb207XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gc3ltYm9saXplcnMpKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9saXplcnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ltYm9saXplcnNba2V5XVtjaGlsZC5uYW1lXSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHN5bWJvbGl6ZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgem9vbXMucnVsZSAmPSAoem9vbXMuYXZhaWxhYmxlICY9IH56b29tcy5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIHN5bWJvbGl6ZXJzO1xuICAgIH1cbn07XG5cbi8vIFRoZSB0cmVlLlpvb20udG9TdHJpbmcgZnVuY3Rpb24gaWdub3JlcyB0aGUgaG9sZXMgaW4gem9vbSByYW5nZXMgYW5kIG91dHB1dHNcbi8vIHNjYWxlZGVub21pbmF0b3JzIHRoYXQgY292ZXIgdGhlIHdob2xlIHJhbmdlIGZyb20gdGhlIGZpcnN0IHRvIGxhc3QgYml0IHNldC5cbi8vIFRoaXMgYWxnb3JpdGhtIGNhbiBwcm9kdWNlcyB6b29tIHJhbmdlcyB0aGF0IG1heSBoYXZlIGhvbGVzLiBIb3dldmVyLFxuLy8gd2hlbiB1c2luZyB0aGUgZmlsdGVyLW1vZGU9XCJmaXJzdFwiLCBtb3JlIHNwZWNpZmljIHpvb20gZmlsdGVycyB3aWxsIGFsd2F5c1xuLy8gZW5kIHVwIGJlZm9yZSBicm9hZGVyIHJhbmdlcy4gVGhlIGZpbHRlci1tb2RlIHdpbGwgcGljayB0aG9zZSBmaXJzdCBiZWZvcmVcbi8vIHJlc29ydGluZyB0byB0aGUgem9vbSByYW5nZSB3aXRoIHRoZSBob2xlIGFuZCBzdG9wIHByb2Nlc3NpbmcgZnVydGhlciBydWxlcy5cbnRyZWUuRGVmaW5pdGlvbi5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYsIGV4aXN0aW5nKSB7XG4gICAgdmFyIGZpbHRlciA9IHRoaXMuZmlsdGVycy50b1N0cmluZygpO1xuICAgIGlmICghKGZpbHRlciBpbiBleGlzdGluZykpIGV4aXN0aW5nW2ZpbHRlcl0gPSB0cmVlLlpvb20uYWxsO1xuXG4gICAgdmFyIGF2YWlsYWJsZSA9IHRyZWUuWm9vbS5hbGwsIHhtbCA9ICcnLCB6b29tLCBzeW1ib2xpemVycyxcbiAgICAgICAgem9vbXMgPSB7IGF2YWlsYWJsZTogdHJlZS5ab29tLmFsbCB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ydWxlcy5sZW5ndGggJiYgYXZhaWxhYmxlOyBpKyspIHtcbiAgICAgICAgem9vbXMucnVsZSA9IHRoaXMucnVsZXNbaV0uem9vbTtcbiAgICAgICAgaWYgKCEoZXhpc3RpbmdbZmlsdGVyXSAmIHpvb21zLnJ1bGUpKSBjb250aW51ZTtcblxuICAgICAgICB3aGlsZSAoem9vbXMuY3VycmVudCA9IHpvb21zLnJ1bGUgJiBhdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2xpemVycyA9IHRoaXMuY29sbGVjdFN5bWJvbGl6ZXJzKHpvb21zLCBpKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGV4aXN0aW5nW2ZpbHRlcl0gJiB6b29tcy5jdXJyZW50KSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgeG1sICs9IHRoaXMuc3ltYm9saXplcnNUb1hNTChlbnYsIHN5bWJvbGl6ZXJzLFxuICAgICAgICAgICAgICAgICAgICAobmV3IHRyZWUuWm9vbSgpKS5zZXRab29tKGV4aXN0aW5nW2ZpbHRlcl0gJiB6b29tcy5jdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdbZmlsdGVyXSAmPSB+em9vbXMuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4bWw7XG59O1xuXG50cmVlLkRlZmluaXRpb24ucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbihlbnYpIHtcbiAgdmFyIHNoYWRlckF0dHJzID0ge307XG5cbiAgLy8gbWVyZ2UgY29uZGl0aW9ucyBmcm9tIGZpbHRlcnMgd2l0aCB6b29tIGNvbmRpdGlvbiBvZiB0aGVcbiAgLy8gZGVmaW5pdGlvblxuICB2YXIgem9vbSA9IFwiKFwiICsgdGhpcy56b29tICsgXCIgJiAoMSA8PCBjdHguem9vbSkpXCI7XG4gIHZhciBmcmFtZV9vZmZzZXQgPSB0aGlzLmZyYW1lX29mZnNldDtcbiAgdmFyIF9pZiA9IHRoaXMuZmlsdGVycy50b0pTKGVudik7XG4gIHZhciBmaWx0ZXJzID0gW3pvb21dO1xuICBpZihfaWYpIGZpbHRlcnMucHVzaChfaWYpO1xuICBpZihmcmFtZV9vZmZzZXQpIGZpbHRlcnMucHVzaCgnY3R4W1wiZnJhbWUtb2Zmc2V0XCJdID09PSAnICsgZnJhbWVfb2Zmc2V0KTtcbiAgX2lmID0gZmlsdGVycy5qb2luKFwiICYmIFwiKTtcbiAgXy5lYWNoKHRoaXMucnVsZXMsIGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgIGlmKHJ1bGUgaW5zdGFuY2VvZiB0cmVlLlJ1bGUpIHtcbiAgICAgICAgc2hhZGVyQXR0cnNbcnVsZS5uYW1lXSA9IHNoYWRlckF0dHJzW3J1bGUubmFtZV0gfHwgW107XG5cbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgaW5kZXg6IHJ1bGUuaW5kZXgsXG4gICAgICAgICAgc3ltYm9saXplcjogcnVsZS5zeW1ib2xpemVyXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKF9pZikge1xuICAgICAgICAgIHIuanMgPSBcImlmKFwiICsgX2lmICsgXCIpe1wiICsgcnVsZS52YWx1ZS50b0pTKGVudikgKyBcIn1cIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIuanMgPSBydWxlLnZhbHVlLnRvSlMoZW52KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuY29uc3RhbnQgPSBydWxlLnZhbHVlLmV2KGVudikuaXMgIT09ICdmaWVsZCc7XG4gICAgICAgIHIuZmlsdGVyZWQgPSAhIV9pZjtcblxuICAgICAgICBzaGFkZXJBdHRyc1tydWxlLm5hbWVdLnB1c2gocik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdWxlc2V0IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIC8vaWYgKHJ1bGUgaW5zdGFuY2VvZiB0cmVlLlJ1bGVzZXQpIHtcbiAgICAgICAgICAvL3ZhciBzaCA9IHJ1bGUudG9KUyhlbnYpO1xuICAgICAgICAgIC8vZm9yKHZhciB2IGluIHNoKSB7XG4gICAgICAgICAgICAvL3NoYWRlckF0dHJzW3ZdID0gc2hhZGVyQXR0cnNbdl0gfHwgW107XG4gICAgICAgICAgICAvL2Zvcih2YXIgYXR0ciBpbiBzaFt2XSkge1xuICAgICAgICAgICAgICAvL3NoYWRlckF0dHJzW3ZdLnB1c2goc2hbdl1bYXR0cl0pO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgLy99XG4gICAgICAgIC8vfVxuICAgICAgfVxuICB9KTtcbiAgcmV0dXJuIHNoYWRlckF0dHJzO1xufTtcblxuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcbnZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuLy9cbi8vIEEgbnVtYmVyIHdpdGggYSB1bml0XG4vL1xudHJlZS5EaW1lbnNpb24gPSBmdW5jdGlvbiBEaW1lbnNpb24odmFsdWUsIHVuaXQsIGluZGV4KSB7XG4gICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgbnVsbDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuXG50cmVlLkRpbWVuc2lvbi5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdmbG9hdCcsXG4gICAgcGh5c2ljYWxfdW5pdHM6IFsnbScsICdjbScsICdpbicsICdtbScsICdwdCcsICdwYyddLFxuICAgIHNjcmVlbl91bml0czogWydweCcsICclJ10sXG4gICAgYWxsX3VuaXRzOiBbJ20nLCAnY20nLCAnaW4nLCAnbW0nLCAncHQnLCAncGMnLCAncHgnLCAnJSddLFxuICAgIGRlbnNpdGllczoge1xuICAgICAgICBtOiAwLjAyNTQsXG4gICAgICAgIG1tOiAyNS40LFxuICAgICAgICBjbTogMi41NCxcbiAgICAgICAgcHQ6IDcyLFxuICAgICAgICBwYzogNlxuICAgIH0sXG4gICAgZXY6IGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgaWYgKHRoaXMudW5pdCAmJiAhXy5jb250YWlucyh0aGlzLmFsbF91bml0cywgdGhpcy51bml0KSkge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgdW5pdDogJ1wiICsgdGhpcy51bml0ICsgXCInXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXM6ICd1bmRlZmluZWQnLCB2YWx1ZTogJ3VuZGVmaW5lZCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB1bml0cyB3aGljaCBhcmUgbm90IHB4IG9yICVcbiAgICAgICAgaWYgKHRoaXMudW5pdCAmJiBfLmNvbnRhaW5zKHRoaXMucGh5c2ljYWxfdW5pdHMsIHRoaXMudW5pdCkpIHtcbiAgICAgICAgICAgIGlmICghZW52LnBwaSkge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwicHBpIGlzIG5vdCBzZXQsIHNvIG1ldHJpYyB1bml0cyBjYW4ndCBiZSB1c2VkXCIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXM6ICd1bmRlZmluZWQnLCB2YWx1ZTogJ3VuZGVmaW5lZCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYWxsIHVuaXRzIHRvIGluY2hcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgaW5jaCB0byBweCB1c2luZyBwcGlcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAodGhpcy52YWx1ZSAvIHRoaXMuZGVuc2l0aWVzW3RoaXMudW5pdF0pICogZW52LnBwaTtcbiAgICAgICAgICAgIHRoaXMudW5pdCA9ICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgucm91bmQodGhpcy52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9Db2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5Db2xvcihbdGhpcy52YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy52YWx1ZV0pO1xuICAgIH0sXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC5yb3VuZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBvcGVyYXRlOiBmdW5jdGlvbihlbnYsIG9wLCBvdGhlcikge1xuICAgICAgICBpZiAodGhpcy51bml0ID09PSAnJScgJiYgb3RoZXIudW5pdCAhPT0gJyUnKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJZiB0d28gb3BlcmFuZHMgZGlmZmVyLCB0aGUgZmlyc3QgbXVzdCBub3QgYmUgJScsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudW5pdCAhPT0gJyUnICYmIG90aGVyLnVuaXQgPT09ICclJykge1xuICAgICAgICAgICAgaWYgKG9wID09PSAnKicgfHwgb3AgPT09ICcvJyB8fCBvcCA9PT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1BlcmNlbnQgdmFsdWVzIGNhbiBvbmx5IGJlIGFkZGVkIG9yIHN1YnRyYWN0ZWQgZnJvbSBvdGhlciB2YWx1ZXMnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRpbWVuc2lvbih0cmVlLm9wZXJhdGUob3AsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUsIHRoaXMudmFsdWUgKiBvdGhlci52YWx1ZSAqIDAuMDEpLFxuICAgICAgICAgICAgICAgIHRoaXMudW5pdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2hlcmUgdGhlIG9wZXJhbmRzIGFyZSBlaXRoZXIgdGhlIHNhbWUgKCUgb3IgdW5kZWZpbmVkIG9yIHB4KSwgb3Igb25lIGlzIHVuZGVmaW5lZCBhbmQgdGhlIG90aGVyIGlzIHB4XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5EaW1lbnNpb24odHJlZS5vcGVyYXRlKG9wLCB0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSksXG4gICAgICAgICAgICB0aGlzLnVuaXQgfHwgb3RoZXIudW5pdCk7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbi8vIEFuIGVsZW1lbnQgaXMgYW4gaWQgb3IgY2xhc3Mgc2VsZWN0b3JcbnRyZWUuRWxlbWVudCA9IGZ1bmN0aW9uIEVsZW1lbnQodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIGlmICh0aGlzLnZhbHVlWzBdID09PSAnIycpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lkJztcbiAgICAgICAgdGhpcy5jbGVhbiA9IHRoaXMudmFsdWUucmVwbGFjZSgvXiMvLCAnJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbHVlWzBdID09PSAnLicpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NsYXNzJztcbiAgICAgICAgdGhpcy5jbGVhbiA9IHRoaXMudmFsdWUucmVwbGFjZSgvXlxcLi8sICcnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFsdWUuaW5kZXhPZignKicpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnd2lsZGNhcmQnO1xuICAgIH1cbn07XG5cbi8vIERldGVybWluZSB0aGUgJ3NwZWNpZmljaXR5IG1hdHJpeCcgb2YgdGhpc1xuLy8gc3BlY2lmaWMgc2VsZWN0b3JcbnRyZWUuRWxlbWVudC5wcm90b3R5cGUuc3BlY2lmaWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAodGhpcy50eXBlID09PSAnaWQnKSA/IDEgOiAwLCAvLyBhXG4gICAgICAgICh0aGlzLnR5cGUgPT09ICdjbGFzcycpID8gMSA6IDAgIC8vIGJcbiAgICBdO1xufTtcblxudHJlZS5FbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIEV4cHJlc3Npb24odmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuXG50cmVlLkV4cHJlc3Npb24ucHJvdG90eXBlID0ge1xuICAgIGlzOiAnZXhwcmVzc2lvbicsXG4gICAgZXY6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRXhwcmVzc2lvbih0aGlzLnZhbHVlLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZXYoZW52KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlWzBdLmV2KGVudik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudG9TdHJpbmcoZW52KTtcbiAgICAgICAgfSkuam9pbignICcpO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkZpZWxkID0gZnVuY3Rpb24gRmllbGQoY29udGVudCkge1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xufTtcblxudHJlZS5GaWVsZC5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdmaWVsZCcsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ1snICsgdGhpcy52YWx1ZSArICddJztcbiAgICB9LFxuICAgICdldic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5GaWx0ZXIgPSBmdW5jdGlvbiBGaWx0ZXIoa2V5LCBvcCwgdmFsLCBpbmRleCwgZmlsZW5hbWUpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wID0gb3A7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcblxuICAgIHRoaXMuaWQgPSB0aGlzLmtleSArIHRoaXMub3AgKyB0aGlzLnZhbDtcbn07XG5cbi8vIHhtbHNhZmUsIG51bWVyaWMsIHN1ZmZpeFxudmFyIG9wcyA9IHtcbiAgICAnPCc6IFsnICZsdDsgJywgJ251bWVyaWMnXSxcbiAgICAnPic6IFsnICZndDsgJywgJ251bWVyaWMnXSxcbiAgICAnPSc6IFsnID0gJywgJ2JvdGgnXSxcbiAgICAnIT0nOiBbJyAhPSAnLCAnYm90aCddLFxuICAgICc8PSc6IFsnICZsdDs9ICcsICdudW1lcmljJ10sXG4gICAgJz49JzogWycgJmd0Oz0gJywgJ251bWVyaWMnXSxcbiAgICAnPX4nOiBbJy5tYXRjaCgnLCAnc3RyaW5nJywgJyknXVxufTtcblxudHJlZS5GaWx0ZXIucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oZW52KSB7XG4gICAgdGhpcy5rZXkgPSB0aGlzLmtleS5ldihlbnYpO1xuICAgIHRoaXMudmFsID0gdGhpcy52YWwuZXYoZW52KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnRyZWUuRmlsdGVyLnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKGVudikge1xuICAgIGlmICh0cmVlLlJlZmVyZW5jZS5kYXRhLmZpbHRlcikge1xuICAgICAgICBpZiAodGhpcy5rZXkuaXMgPT09ICdrZXl3b3JkJyAmJiAtMSA9PT0gdHJlZS5SZWZlcmVuY2UuZGF0YS5maWx0ZXIudmFsdWUuaW5kZXhPZih0aGlzLmtleS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmtleS50b1N0cmluZygpICsgJyBpcyBub3QgYSB2YWxpZCBrZXl3b3JkIGluIGEgZmlsdGVyIGV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWwuaXMgPT09ICdrZXl3b3JkJyAmJiAtMSA9PT0gdHJlZS5SZWZlcmVuY2UuZGF0YS5maWx0ZXIudmFsdWUuaW5kZXhPZih0aGlzLnZhbC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLnZhbC50b1N0cmluZygpICsgJyBpcyBub3QgYSB2YWxpZCBrZXl3b3JkIGluIGEgZmlsdGVyIGV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIga2V5ID0gdGhpcy5rZXkudG9TdHJpbmcoZmFsc2UpO1xuICAgIHZhciB2YWwgPSB0aGlzLnZhbC50b1N0cmluZyh0aGlzLnZhbC5pcyA9PSAnc3RyaW5nJyk7XG5cbiAgICBpZiAoXG4gICAgICAgIChvcHNbdGhpcy5vcF1bMV0gPT0gJ251bWVyaWMnICYmIGlzTmFOKHZhbCkgJiYgdGhpcy52YWwuaXMgIT09ICdmaWVsZCcpIHx8XG4gICAgICAgIChvcHNbdGhpcy5vcF1bMV0gPT0gJ3N0cmluZycgJiYgKHZhbClbMF0gIT0gXCInXCIpXG4gICAgKSB7XG4gICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IHVzZSBvcGVyYXRvciBcIicgKyB0aGlzLm9wICsgJ1wiIHdpdGggdmFsdWUgJyArIHRoaXMudmFsLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5ICsgb3BzW3RoaXMub3BdWzBdICsgdmFsICsgKG9wc1t0aGlzLm9wXVsyXSB8fCAnJyk7XG59O1xuXG50cmVlLkZpbHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1snICsgdGhpcy5pZCArICddJztcbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCJ2YXIgdHJlZSA9IHJlcXVpcmUoJy4uL3RyZWUnKTtcbnZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG50cmVlLkZpbHRlcnNldCA9IGZ1bmN0aW9uIEZpbHRlcnNldCgpIHtcbiAgICB0aGlzLmZpbHRlcnMgPSB7fTtcbn07XG5cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKGVudikge1xuICAgIHZhciBmaWx0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgIGZpbHRlcnMucHVzaCgnKCcgKyB0aGlzLmZpbHRlcnNbaWRdLnRvWE1MKGVudikudHJpbSgpICsgJyknKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnICAgIDxGaWx0ZXI+JyArIGZpbHRlcnMuam9pbignIGFuZCAnKSArICc8L0ZpbHRlcj5cXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5maWx0ZXJzKSBhcnIucHVzaCh0aGlzLmZpbHRlcnNbaWRdLmlkKTtcbiAgICByZXR1cm4gYXJyLnNvcnQoKS5qb2luKCdcXHQnKTtcbn07XG5cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS5ldiA9IGZ1bmN0aW9uKGVudikge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyc1tpXS5ldihlbnYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbG9uZSA9IG5ldyB0cmVlLkZpbHRlcnNldCgpO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICBjbG9uZS5maWx0ZXJzW2lkXSA9IHRoaXMuZmlsdGVyc1tpZF07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbi8vIE5vdGU6IG90aGVyIGhhcyB0byBiZSBhIHRyZWUuRmlsdGVyc2V0LlxudHJlZS5GaWx0ZXJzZXQucHJvdG90eXBlLmNsb25lV2l0aCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIG90aGVyLmZpbHRlcnMpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuYWRkYWJsZShvdGhlci5maWx0ZXJzW2lkXSk7XG4gICAgICAgIC8vIHN0YXR1cyBpcyB0cnVlLCBmYWxzZSBvciBudWxsLiBpZiBpdCdzIG51bGwgd2UgZG9uJ3QgZmFpbCB0aGlzXG4gICAgICAgIC8vIGNsb25lIG5vciBkbyB3ZSBhZGQgdGhlIGZpbHRlci5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgdGhlIGZpbHRlciB3aWxsIG92ZXJyaWRlIGFub3RoZXIgdmFsdWUuXG4gICAgICAgICAgICBhZGRpdGlvbnMucHVzaChvdGhlci5maWx0ZXJzW2lkXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGRpbmcgdGhlIG90aGVyIGZpbHRlcnMgZG9lc24ndCBtYWtlIHRoaXMgZmlsdGVyc2V0IGludmFsaWQsIGJ1dCBpdFxuICAgIC8vIGRvZXNuJ3QgYWRkIGFueXRoaW5nIHRvIGl0IGVpdGhlci5cbiAgICBpZiAoIWFkZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIHN1Y2Nlc3NmdWxseSBhZGQgYWxsIGZpbHRlcnMuIE5vdyBjbG9uZSB0aGUgZmlsdGVyc2V0IGFuZCBhZGQgdGhlXG4gICAgLy8gbmV3IHJ1bGVzLlxuICAgIHZhciBjbG9uZSA9IG5ldyB0cmVlLkZpbHRlcnNldCgpO1xuXG4gICAgLy8gV2UgY2FuIGFkZCB0aGUgcnVsZXMgdGhhdCBhcmUgYWxyZWFkeSBwcmVzZW50IHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGVcbiAgICAvLyBhZGQgZnVuY3Rpb24gYXMgYSBGaWx0ZXJzZXQgaXMgYWx3YXlzIGluIGl0J3Mgc2ltcGxlc3QgY2Fub25pY2FsIGZvcm0uXG4gICAgZm9yIChpZCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgY2xvbmUuZmlsdGVyc1tpZF0gPSB0aGlzLmZpbHRlcnNbaWRdO1xuICAgIH1cblxuICAgIC8vIE9ubHkgYWRkIG5ldyBmaWx0ZXJzIHRoYXQgYWN0dWFsbHkgY2hhbmdlIHRoZSBmaWx0ZXIuXG4gICAgd2hpbGUgKGlkID0gYWRkaXRpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgY2xvbmUuYWRkKGlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uKGVudikge1xuICB2YXIgb3BNYXAgPSB7XG4gICAgJz0nOiAnPT09J1xuICB9O1xuICByZXR1cm4gXy5tYXAodGhpcy5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgb3AgPSBmaWx0ZXIub3A7XG4gICAgaWYob3AgaW4gb3BNYXApIHtcbiAgICAgIG9wID0gb3BNYXBbb3BdO1xuICAgIH1cbiAgICB2YXIgdmFsID0gZmlsdGVyLnZhbDtcbiAgICBpZihmaWx0ZXIuX3ZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWwgPSBmaWx0ZXIuX3ZhbC50b1N0cmluZyh0cnVlKTtcbiAgICB9XG4gICAgdmFyIGF0dHJzID0gXCJkYXRhXCI7XG4gICAgcmV0dXJuIGF0dHJzICsgXCIuXCIgKyBmaWx0ZXIua2V5LnZhbHVlICArIFwiIFwiICsgb3AgKyBcIiBcIiArICh2YWwuaXMgPT09ICdzdHJpbmcnID8gXCInXCIrIHZhbCArXCInXCIgOiB2YWwpO1xuICB9KS5qb2luKCcgJiYgJyk7XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGUgbmV3IGZpbHRlciBjYW4gYmUgYWRkZWQsIGZhbHNlIG90aGVyd2lzZS5cbi8vIEl0IGNhbiBhbHNvIHJldHVybiBudWxsLCBhbmQgb24gdGhlIG90aGVyIHNpZGUgd2UgdGVzdCBmb3IgPT09IHRydWUgb3Jcbi8vIGZhbHNlXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuYWRkYWJsZSA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBrZXkgPSBmaWx0ZXIua2V5LnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlID0gZmlsdGVyLnZhbC50b1N0cmluZygpO1xuXG4gICAgaWYgKHZhbHVlLm1hdGNoKC9eWzAtOV0rKFxcLlswLTldKik/JC8pKSB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgc3dpdGNoIChmaWx0ZXIub3ApIHtcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbHJlYWR5IGZvbz0gYW5kIHdlJ3JlIGFkZGluZyBmb289XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9J10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwudG9TdHJpbmcoKSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgdmFsdWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPiB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzw9J10udmFsIDwgdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgJz1+JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbCA9PSB2YWx1ZSkgPyBmYWxzZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICchPScgKyB2YWx1ZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXS52YWwgPj0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz49J10gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz49J10udmFsID4gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPCB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIGlmIChrZXkgKyAnPScgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbCA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8J10udmFsIDw9IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc8PSddICE9PSB1bmRlZmluZWQgICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPD0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPiB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9JyBdICE9PSB1bmRlZmluZWQpIHJldHVybiAodGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsIDwgdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCcgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPCB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPicgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc+PSddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc+PSddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nIF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuICh0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwgPj0gdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPicgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPj0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNba2V5ICsgJzwnIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXS52YWwgPD0gdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXS52YWwgPCB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc9JyBdICE9PSB1bmRlZmluZWQpIHJldHVybiAodGhpcy5maWx0ZXJzW2tleSArICc9J10udmFsID4gdmFsdWUpID8gZmFsc2UgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPicgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPiddLnZhbCA+PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXS52YWwgPiB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnPCcgXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyc1trZXkgKyAnPCddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tleSArICc8PSddICE9PSB1bmRlZmluZWQgJiYgdGhpcy5maWx0ZXJzW2tleSArICc8PSddLnZhbCA8PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vLyBEb2VzIHRoZSBuZXcgZmlsdGVyIGNvbnN0aXR1dGUgYSBjb25mbGljdD9cbnRyZWUuRmlsdGVyc2V0LnByb3RvdHlwZS5jb25mbGljdCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBrZXkgPSBmaWx0ZXIua2V5LnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlID0gZmlsdGVyLnZhbC50b1N0cmluZygpO1xuXG4gICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkpIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAvLyBpZiAoYT1iKSAmJiAoYT1jKVxuICAgIC8vIGlmIChhPWIpICYmIChhIT1iKVxuICAgIC8vIG9yIChhIT1iKSAmJiAoYT1iKVxuICAgIGlmICgoZmlsdGVyLm9wID09PSAnPScgJiYgdGhpcy5maWx0ZXJzW2tleSArICc9J10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB2YWx1ZSAhPSB0aGlzLmZpbHRlcnNba2V5ICsgJz0nXS52YWwudG9TdHJpbmcoKSkgfHxcbiAgICAgICAgKGZpbHRlci5vcCA9PT0gJyE9JyAmJiB0aGlzLmZpbHRlcnNba2V5ICsgJz0nXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZhbHVlID09IHRoaXMuZmlsdGVyc1trZXkgKyAnPSddLnZhbC50b1N0cmluZygpKSB8fFxuICAgICAgICAoZmlsdGVyLm9wID09PSAnPScgJiYgdGhpcy5maWx0ZXJzW2tleSArICchPSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmFsdWUgPT0gdGhpcy5maWx0ZXJzW2tleSArICchPSddLnZhbC50b1N0cmluZygpKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyLnRvU3RyaW5nKCkgKyAnIGFkZGVkIHRvICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnIHByb2R1Y2VzIGFuIGludmFsaWQgZmlsdGVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBPbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiBmb3IgZmlsdGVycyB0aGF0IGhhdmUgYmVlbiBjbGVhcmVkIGJ5IC5hZGRhYmxlKCkuXG50cmVlLkZpbHRlcnNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmlsdGVyLCBlbnYpIHtcbiAgICB2YXIga2V5ID0gZmlsdGVyLmtleS50b1N0cmluZygpLFxuICAgICAgICBpZCxcbiAgICAgICAgb3AgPSBmaWx0ZXIub3AsXG4gICAgICAgIGNvbmZsaWN0ID0gdGhpcy5jb25mbGljdChmaWx0ZXIpLFxuICAgICAgICBudW12YWw7XG5cbiAgICBpZiAoY29uZmxpY3QpIHJldHVybiBjb25mbGljdDtcblxuICAgIGlmIChvcCA9PT0gJz0nKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2ldLmtleSA9PSBrZXkpIGRlbGV0ZSB0aGlzLmZpbHRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc9J10gPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyE9Jykge1xuICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJyE9JyArIGZpbHRlci52YWxdID0gZmlsdGVyO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICc9ficpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzW2tleSArICc9ficgKyBmaWx0ZXIudmFsXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPicpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG90aGVyIGZpbHRlcnMgdGhhdCBhcmUgYWxzbyA+XG4gICAgICAgIC8vIGJ1dCBhcmUgbGVzcyB0aGFuIHRoaXMgb25lLCB0aGV5IGRvbid0IG1hdHRlciwgc29cbiAgICAgICAgLy8gcmVtb3ZlIHRoZW0uXG4gICAgICAgIGZvciAodmFyIGogaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2pdLmtleSA9PSBrZXkgJiYgdGhpcy5maWx0ZXJzW2pdLnZhbCA8PSBmaWx0ZXIudmFsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPj0nKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBudW12YWwgPSAoK3RoaXMuZmlsdGVyc1trXS52YWwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW2tdLmtleSA9PSBrZXkgJiYgbnVtdmFsIDwgZmlsdGVyLnZhbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF07XG4gICAgICAgICAgICBmaWx0ZXIub3AgPSAnPic7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJz4nXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc1trZXkgKyAnPj0nXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AgPT09ICc8Jykge1xuICAgICAgICBmb3IgKHZhciBsIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgbnVtdmFsID0gKCt0aGlzLmZpbHRlcnNbbF0udmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1tsXS5rZXkgPT0ga2V5ICYmIG51bXZhbCA+PSBmaWx0ZXIudmFsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1tsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnPD0nKSB7XG4gICAgICAgIGZvciAodmFyIG0gaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBudW12YWwgPSAoK3RoaXMuZmlsdGVyc1ttXS52YWwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJzW21dLmtleSA9PSBrZXkgJiYgbnVtdmFsID4gZmlsdGVyLnZhbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNbbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyc1trZXkgKyAnIT0nICsgZmlsdGVyLnZhbF07XG4gICAgICAgICAgICBmaWx0ZXIub3AgPSAnPCc7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNba2V5ICsgJzwnXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc1trZXkgKyAnPD0nXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLl9nZXRGb250U2V0ID0gZnVuY3Rpb24oZW52LCBmb250cykge1xuICAgIHZhciBmb250S2V5ID0gZm9udHMuam9pbignJyk7XG4gICAgaWYgKGVudi5fZm9udE1hcCAmJiBlbnYuX2ZvbnRNYXBbZm9udEtleV0pIHtcbiAgICAgICAgcmV0dXJuIGVudi5fZm9udE1hcFtmb250S2V5XTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2ZvbnRzZXQgPSBuZXcgdHJlZS5Gb250U2V0KGVudiwgZm9udHMpO1xuICAgIGVudi5lZmZlY3RzLnB1c2gobmV3X2ZvbnRzZXQpO1xuICAgIGlmICghZW52Ll9mb250TWFwKSBlbnYuX2ZvbnRNYXAgPSB7fTtcbiAgICBlbnYuX2ZvbnRNYXBbZm9udEtleV0gPSBuZXdfZm9udHNldDtcbiAgICByZXR1cm4gbmV3X2ZvbnRzZXQ7XG59O1xuXG50cmVlLkZvbnRTZXQgPSBmdW5jdGlvbiBGb250U2V0KGVudiwgZm9udHMpIHtcbiAgICB0aGlzLmZvbnRzID0gZm9udHM7XG4gICAgdGhpcy5uYW1lID0gJ2ZvbnRzZXQtJyArIGVudi5lZmZlY3RzLmxlbmd0aDtcbn07XG5cbnRyZWUuRm9udFNldC5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICByZXR1cm4gJzxGb250U2V0IG5hbWU9XCInICtcbiAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgJ1wiPlxcbicgK1xuICAgICAgICB0aGlzLmZvbnRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgPEZvbnQgZmFjZS1uYW1lPVwiJyArIGYgKydcIi8+JztcbiAgICAgICAgfSkuam9pbignXFxuJykgK1xuICAgICAgICAnXFxuPC9Gb250U2V0Pic7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwidmFyIHRyZWUgPSByZXF1aXJlKCcuLi90cmVlJyk7XG5cbi8vIFN0b3JhZ2UgZm9yIEZyYW1lIG9mZnNldCB2YWx1ZVxuLy8gYW5kIHN0b3JlcyB0aGVtIGFzIGJpdC1zZXF1ZW5jZXMgc28gdGhhdCB0aGV5IGNhbiBiZSBjb21iaW5lZCxcbi8vIGludmVydGVkLCBhbmQgY29tcGFyZWQgcXVpY2tseS5cbnRyZWUuRnJhbWVPZmZzZXQgPSBmdW5jdGlvbihvcCwgdmFsdWUsIGluZGV4KSB7XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIGlmICh2YWx1ZSA+IHRyZWUuRnJhbWVPZmZzZXQubWF4IHx8IHZhbHVlIDw9IDApIHtcbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbWVzc2FnZTogJ09ubHkgZnJhbWUtb2Zmc2V0IGxldmVscyBiZXR3ZWVuIDEgYW5kICcgK1xuICAgICAgICAgICAgICAgIHRyZWUuRnJhbWVPZmZzZXQubWF4ICsgJyBzdXBwb3J0ZWQuJyxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcCAhPT0gJz0nKSB7XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdvbmx5ID0gb3BlcmF0b3IgaXMgc3VwcG9ydGVkIGZvciBmcmFtZS1vZmZzZXQnLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnRyZWUuRnJhbWVPZmZzZXQubWF4ID0gMzI7XG50cmVlLkZyYW1lT2Zmc2V0Lm5vbmUgPSAwO1xuXG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLkltYWdlRmlsdGVyID0gZnVuY3Rpb24gSW1hZ2VGaWx0ZXIoZmlsdGVyLCBhcmdzKSB7XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgdGhpcy5hcmdzID0gYXJncyB8fCBudWxsO1xufTtcblxudHJlZS5JbWFnZUZpbHRlci5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICdpbWFnZWZpbHRlcicsXG4gICAgZXY6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyICsgJygnICsgdGhpcy5hcmdzLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbiAodHJlZSkge1xudHJlZS5JbnZhbGlkID0gZnVuY3Rpb24gSW52YWxpZChjaHVuaywgaW5kZXgsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudHlwZSA9ICdzeW50YXgnO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJJbnZhbGlkIGNvZGU6IFwiICsgdGhpcy5jaHVuaztcbn07XG5cbnRyZWUuSW52YWxpZC5wcm90b3R5cGUuaXMgPSAnaW52YWxpZCc7XG5cbnRyZWUuSW52YWxpZC5wcm90b3R5cGUuZXYgPSBmdW5jdGlvbihlbnYpIHtcbiAgICBlbnYuZXJyb3Ioe1xuICAgICAgICBjaHVuazogdGhpcy5jaHVuayxcbiAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgIHR5cGU6ICdzeW50YXgnLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIGNvZGU6IFwiICsgdGhpcy5jaHVua1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzOiAndW5kZWZpbmVkJ1xuICAgIH07XG59O1xufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuS2V5d29yZCA9IGZ1bmN0aW9uIEtleXdvcmQodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdmFyIHNwZWNpYWwgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6ICdjb2xvcicsXG4gICAgICAgICd0cnVlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAnZmFsc2UnOiAnYm9vbGVhbidcbiAgICB9O1xuICAgIHRoaXMuaXMgPSBzcGVjaWFsW3ZhbHVlXSA/IHNwZWNpYWxbdmFsdWVdIDogJ2tleXdvcmQnO1xufTtcbnRyZWUuS2V5d29yZC5wcm90b3R5cGUgPSB7XG4gICAgZXY6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5MYXllclhNTCA9IGZ1bmN0aW9uKG9iaiwgc3R5bGVzKSB7XG4gICAgdmFyIGRzb3B0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb2JqLkRhdGFzb3VyY2UpIHtcbiAgICAgICAgZHNvcHRpb25zLnB1c2goJzxQYXJhbWV0ZXIgbmFtZT1cIicgKyBpICsgJ1wiPjwhW0NEQVRBWycgK1xuICAgICAgICAgICAgb2JqLkRhdGFzb3VyY2VbaV0gKyAnXV0+PC9QYXJhbWV0ZXI+Jyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3Bfc3RyaW5nID0gJyc7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmoucHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcCA9PT0gJ21pbnpvb20nKSB7XG4gICAgICAgICAgICBwcm9wX3N0cmluZyArPSAnICBtYXh6b29tPVwiJyArIHRyZWUuWm9vbS5yYW5nZXNbb2JqLnByb3BlcnRpZXNbcHJvcF1dICsgJ1wiXFxuJztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnbWF4em9vbScpIHtcbiAgICAgICAgICAgIHByb3Bfc3RyaW5nICs9ICcgIG1pbnpvb209XCInICsgdHJlZS5ab29tLnJhbmdlc1tvYmoucHJvcGVydGllc1twcm9wXSsxXSArICdcIlxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wX3N0cmluZyArPSAnICAnICsgcHJvcCArICc9XCInICsgb2JqLnByb3BlcnRpZXNbcHJvcF0gKyAnXCJcXG4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICc8TGF5ZXInICtcbiAgICAgICAgJyBuYW1lPVwiJyArIG9iai5uYW1lICsgJ1wiXFxuJyArXG4gICAgICAgIHByb3Bfc3RyaW5nICtcbiAgICAgICAgKCh0eXBlb2Ygb2JqLnN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpID8gJycgOiAnICBzdGF0dXM9XCInICsgb2JqLnN0YXR1cyArICdcIlxcbicpICtcbiAgICAgICAgKCh0eXBlb2Ygb2JqLnNycyA9PT0gJ3VuZGVmaW5lZCcpID8gJycgOiAnICBzcnM9XCInICsgb2JqLnNycyArICdcIicpICsgJz5cXG4gICAgJyArXG4gICAgICAgIHN0eWxlcy5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnPFN0eWxlTmFtZT4nICsgcyArICc8L1N0eWxlTmFtZT4nO1xuICAgICAgICB9KS5qb2luKCdcXG4gICAgJykgK1xuICAgICAgICAoZHNvcHRpb25zLmxlbmd0aCA/XG4gICAgICAgICdcXG4gICAgPERhdGFzb3VyY2U+XFxuICAgICAgICcgK1xuICAgICAgICBkc29wdGlvbnMuam9pbignXFxuICAgICAgICcpICtcbiAgICAgICAgJ1xcbiAgICA8L0RhdGFzb3VyY2U+XFxuJ1xuICAgICAgICA6ICcnKSArXG4gICAgICAgICcgIDwvTGF5ZXI+XFxuJztcbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIvLyBBIGxpdGVyYWwgaXMgYSBsaXRlcmFsIHN0cmluZyBmb3IgTWFwbmlrIC0gdGhlXG4vLyByZXN1bHQgb2YgdGhlIGNvbWJpbmF0aW9uIG9mIGEgYHRyZWUuRmllbGRgIHdpdGggYW55XG4vLyBvdGhlciB0eXBlLlxuKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5MaXRlcmFsID0gZnVuY3Rpb24gRmllbGQoY29udGVudCkge1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xuICAgIHRoaXMuaXMgPSAnZmllbGQnO1xufTtcblxudHJlZS5MaXRlcmFsLnByb3RvdHlwZSA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgJ2V2JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIvLyBBbiBvcGVyYXRpb24gaXMgYW4gZXhwcmVzc2lvbiB3aXRoIGFuIG9wIGluIGJldHdlZW4gdHdvIG9wZXJhbmRzLFxuLy8gbGlrZSAyICsgMS5cbihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuT3BlcmF0aW9uID0gZnVuY3Rpb24gT3BlcmF0aW9uKG9wLCBvcGVyYW5kcywgaW5kZXgpIHtcbiAgICB0aGlzLm9wID0gb3AudHJpbSgpO1xuICAgIHRoaXMub3BlcmFuZHMgPSBvcGVyYW5kcztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuXG50cmVlLk9wZXJhdGlvbi5wcm90b3R5cGUuaXMgPSAnb3BlcmF0aW9uJztcblxudHJlZS5PcGVyYXRpb24ucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oZW52KSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wZXJhbmRzWzBdLmV2KGVudiksXG4gICAgICAgIGIgPSB0aGlzLm9wZXJhbmRzWzFdLmV2KGVudiksXG4gICAgICAgIHRlbXA7XG5cbiAgICBpZiAoYS5pcyA9PT0gJ3VuZGVmaW5lZCcgfHwgYi5pcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChhIGluc3RhbmNlb2YgdHJlZS5EaW1lbnNpb24gJiYgYiBpbnN0YW5jZW9mIHRyZWUuQ29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMub3AgPT09ICcqJyB8fCB0aGlzLm9wID09PSAnKycpIHtcbiAgICAgICAgICAgIHRlbXAgPSBiLCBiID0gYSwgYSA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiT3BlcmF0aW9uRXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IHN1YnN0cmFjdCBvciBkaXZpZGUgYSBjb2xvciBmcm9tIGEgbnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBjb25jYXRlbmF0ZSBwbGFpbiBzdHJpbmdzLCBiZWNhdXNlIHRoaXMgaXMgZWFzaWx5XG4gICAgLy8gcHJlLXByb2Nlc3NlZFxuICAgIGlmIChhIGluc3RhbmNlb2YgdHJlZS5RdW90ZWQgJiYgYiBpbnN0YW5jZW9mIHRyZWUuUXVvdGVkICYmIHRoaXMub3AgIT09ICcrJykge1xuICAgICAgICBlbnYuZXJyb3Ioe1xuICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IHN1YnRyYWN0LCBkaXZpZGUsIG9yIG11bHRpcGx5IHN0cmluZ3MuXCIsXG4gICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICB0eXBlOiAncnVudGltZScsXG4gICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRmllbGRzLCBsaXRlcmFscywgZGltZW5zaW9ucywgYW5kIHF1b3RlZCBzdHJpbmdzIGNhbiBiZSBjb21iaW5lZC5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIHRyZWUuRmllbGQgfHwgYiBpbnN0YW5jZW9mIHRyZWUuRmllbGQgfHxcbiAgICAgICAgYSBpbnN0YW5jZW9mIHRyZWUuTGl0ZXJhbCB8fCBiIGluc3RhbmNlb2YgdHJlZS5MaXRlcmFsKSB7XG4gICAgICAgIGlmIChhLmlzID09PSAnY29sb3InIHx8IGIuaXMgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNhbid0IHN1YnRyYWN0LCBkaXZpZGUsIG9yIG11bHRpcGx5IGNvbG9ycyBpbiBleHByZXNzaW9ucy5cIixcbiAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd1bmRlZmluZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkxpdGVyYWwoYS5ldihlbnYpLnRvU3RyaW5nKHRydWUpICsgdGhpcy5vcCArIGIuZXYoZW52KS50b1N0cmluZyh0cnVlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5vcGVyYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBkbyBtYXRoIHdpdGggdHlwZSAnICsgYS5pcyArICcuJyxcbiAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgIHR5cGU6ICdydW50aW1lJyxcbiAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpczogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICB2YWx1ZTogJ3VuZGVmaW5lZCdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5vcGVyYXRlKGVudiwgdGhpcy5vcCwgYik7XG59O1xuXG50cmVlLm9wZXJhdGUgPSBmdW5jdGlvbihvcCwgYSwgYikge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAnKyc6IHJldHVybiBhICsgYjtcbiAgICAgICAgY2FzZSAnLSc6IHJldHVybiBhIC0gYjtcbiAgICAgICAgY2FzZSAnKic6IHJldHVybiBhICogYjtcbiAgICAgICAgY2FzZSAnJSc6IHJldHVybiBhICUgYjtcbiAgICAgICAgY2FzZSAnLyc6IHJldHVybiBhIC8gYjtcbiAgICB9XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5RdW90ZWQgPSBmdW5jdGlvbiBRdW90ZWQoY29udGVudCkge1xuICAgIHRoaXMudmFsdWUgPSBjb250ZW50IHx8ICcnO1xufTtcblxudHJlZS5RdW90ZWQucHJvdG90eXBlID0ge1xuICAgIGlzOiAnc3RyaW5nJyxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihxdW90ZXMpIHtcbiAgICAgICAgdmFyIGVzY2FwZWRWYWx1ZSA9IHRoaXMudmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIHZhciB4bWx2YWx1ZSA9IGVzY2FwZWRWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJy9nLCAnXFxcXFxcJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXD4vZywgJyZndDsnKTtcbiAgICAgICAgcmV0dXJuIChxdW90ZXMgPT09IHRydWUpID8gXCInXCIgKyB4bWx2YWx1ZSArIFwiJ1wiIDogZXNjYXBlZFZhbHVlO1xuICAgIH0sXG5cbiAgICAnZXYnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9wZXJhdGU6IGZ1bmN0aW9uKGVudiwgb3AsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5RdW90ZWQodHJlZS5vcGVyYXRlKG9wLCB0aGlzLnRvU3RyaW5nKCksIG90aGVyLnRvU3RyaW5nKHRoaXMuY29udGFpbnNfZmllbGQpKSk7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIi8vIENhcnRvIHB1bGxzIGluIGEgcmVmZXJlbmNlIGZyb20gdGhlIGBtYXBuaWstcmVmZXJlbmNlYFxuLy8gbW9kdWxlLiBUaGlzIGZpbGUgYnVpbGRzIGluZGV4ZXMgZnJvbSB0aGF0IGZpbGUgZm9yIGl0cyB2YXJpb3VzXG4vLyBvcHRpb25zLCBhbmQgcHJvdmlkZXMgdmFsaWRhdGlvbiBtZXRob2RzIGZvciBwcm9wZXJ0eTogdmFsdWVcbi8vIGNvbWJpbmF0aW9ucy5cbihmdW5jdGlvbih0cmVlKSB7XG5cbnZhciBfID0gZ2xvYmFsLl8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpLFxuICAgIHJlZiA9IHt9O1xuXG5yZWYuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZWYuZGF0YSA9IGRhdGE7XG4gICAgcmVmLnNlbGVjdG9yX2NhY2hlID0gZ2VuZXJhdGVTZWxlY3RvckNhY2hlKGRhdGEpO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMgPSBnZW5lcmF0ZU1hcG5pa0Z1bmN0aW9ucyhkYXRhKTtcblxuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMubWF0cml4ID0gWzZdO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMudHJhbnNsYXRlID0gWzEsIDJdO1xuICAgIHJlZi5tYXBuaWtGdW5jdGlvbnMuc2NhbGUgPSBbMSwgMl07XG4gICAgcmVmLm1hcG5pa0Z1bmN0aW9ucy5yb3RhdGUgPSBbMSwgM107XG4gICAgcmVmLm1hcG5pa0Z1bmN0aW9ucy5za2V3WCA9IFsxXTtcbiAgICByZWYubWFwbmlrRnVuY3Rpb25zLnNrZXdZID0gWzFdO1xuXG4gICAgcmVmLnJlcXVpcmVkX2NhY2hlID0gZ2VuZXJhdGVSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSk7XG59O1xuXG5yZWYuc2V0VmVyc2lvbiA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICB2YXIgbWFwbmlrX3JlZmVyZW5jZSA9IHJlcXVpcmUoJ21hcG5pay1yZWZlcmVuY2UnKTtcbiAgICBpZiAobWFwbmlrX3JlZmVyZW5jZS52ZXJzaW9uLmhhc093blByb3BlcnR5KHZlcnNpb24pKSB7XG4gICAgICAgIHJlZi5zZXREYXRhKG1hcG5pa19yZWZlcmVuY2UudmVyc2lvblt2ZXJzaW9uXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5yZWYuc2VsZWN0b3JEYXRhID0gZnVuY3Rpb24oc2VsZWN0b3IsIGkpIHtcbiAgICBpZiAocmVmLnNlbGVjdG9yX2NhY2hlW3NlbGVjdG9yXSkgcmV0dXJuIHJlZi5zZWxlY3Rvcl9jYWNoZVtzZWxlY3Rvcl1baV07XG59O1xuXG5yZWYudmFsaWRTZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiAhIXJlZi5zZWxlY3Rvcl9jYWNoZVtzZWxlY3Rvcl07IH07XG5yZWYuc2VsZWN0b3JOYW1lID0gZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHJlZi5zZWxlY3RvckRhdGEoc2VsZWN0b3IsIDIpOyB9O1xucmVmLnNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHJlZi5zZWxlY3RvckRhdGEoc2VsZWN0b3IsIDApOyB9O1xucmVmLnN5bWJvbGl6ZXIgPSBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gcmVmLnNlbGVjdG9yRGF0YShzZWxlY3RvciwgMSk7IH07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VsZWN0b3JDYWNoZShkYXRhKSB7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBkYXRhLnN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gZGF0YS5zeW1ib2xpemVyc1tpXSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc3ltYm9saXplcnNbaV1bal0uaGFzT3duUHJvcGVydHkoJ2NzcycpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhbZGF0YS5zeW1ib2xpemVyc1tpXVtqXS5jc3NdID0gW2RhdGEuc3ltYm9saXplcnNbaV1bal0sIGksIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXBuaWtGdW5jdGlvbnMoZGF0YSkge1xuICAgIHZhciBmdW5jdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpIGluIGRhdGEuc3ltYm9saXplcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBkYXRhLnN5bWJvbGl6ZXJzW2ldKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zeW1ib2xpemVyc1tpXVtqXS50eXBlID09PSAnZnVuY3Rpb25zJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGF0YS5zeW1ib2xpemVyc1tpXVtqXS5mdW5jdGlvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gZGF0YS5zeW1ib2xpemVyc1tpXVtqXS5mdW5jdGlvbnNba107XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1tmblswXV0gPSBmblsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9ucztcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSkge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIGZvciAodmFyIHN5bWJvbGl6ZXJfbmFtZSBpbiBkYXRhLnN5bWJvbGl6ZXJzKSB7XG4gICAgICAgIGNhY2hlW3N5bWJvbGl6ZXJfbmFtZV0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBkYXRhLnN5bWJvbGl6ZXJzW3N5bWJvbGl6ZXJfbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN5bWJvbGl6ZXJzW3N5bWJvbGl6ZXJfbmFtZV1bal0ucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtzeW1ib2xpemVyX25hbWVdLnB1c2goZGF0YS5zeW1ib2xpemVyc1tzeW1ib2xpemVyX25hbWVdW2pdLmNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xufVxuXG5yZWYucmVxdWlyZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3ltYm9saXplcl9uYW1lLCBydWxlcykge1xuICAgIHZhciByZXEgPSByZWYucmVxdWlyZWRfY2FjaGVbc3ltYm9saXplcl9uYW1lXTtcbiAgICBmb3IgKHZhciBpIGluIHJlcSkge1xuICAgICAgICBpZiAoIShyZXFbaV0gaW4gcnVsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Byb3BlcnR5ICcgKyByZXFbaV0gKyAnIHJlcXVpcmVkIGZvciBkZWZpbmluZyAnICtcbiAgICAgICAgICAgICAgICBzeW1ib2xpemVyX25hbWUgKyAnIHN0eWxlcy4nO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVE9ETzogZmluaXNoIGltcGxlbWVudGF0aW9uIC0gdGhpcyBpcyBkZWFkIGNvZGVcbnJlZi5fdmFsaWRhdGVWYWx1ZSA9IHtcbiAgICAnZm9udCc6IGZ1bmN0aW9uKGVudiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVudi52YWxpZGF0aW9uX2RhdGEgJiYgZW52LnZhbGlkYXRpb25fZGF0YS5mb250cykge1xuICAgICAgICAgICAgcmV0dXJuIGVudi52YWxpZGF0aW9uX2RhdGEuZm9udHMuaW5kZXhPZih2YWx1ZSkgIT0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnJlZi5pc0ZvbnQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiByZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnZhbGlkYXRlID09ICdmb250Jztcbn07XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk4MjkyN1xucmVmLmVkaXREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7IG1hdHJpeFtpXSA9IFtpXTsgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHsgbWF0cml4WzBdW2pdID0gajsgfVxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChiLmNoYXJBdChpLTEpID09IGEuY2hhckF0KGotMSkpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaS0xXVtqLTFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaS0xXVtqLTFdICsgMSwgLy8gc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqLTFdICsgMSwgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeFtpLTFdW2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25zKHZhbHVlLCBzZWxlY3Rvcikge1xuICAgIGlmICh2YWx1ZS52YWx1ZVswXS5pcyA9PT0gJ3N0cmluZycpIHJldHVybiB0cnVlO1xuICAgIGZvciAodmFyIGkgaW4gdmFsdWUudmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiB2YWx1ZS52YWx1ZVtpXS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlW2ldLnZhbHVlW2pdLmlzICE9PSAnY2FsbCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBmID0gXy5maW5kKHJlZlxuICAgICAgICAgICAgICAgIC5zZWxlY3RvcihzZWxlY3RvcikuZnVuY3Rpb25zLCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4WzBdID09IHZhbHVlLnZhbHVlW2ldLnZhbHVlW2pdLm5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIShmICYmIGZbMV0gPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmaWx0ZXIgaXMgdW5rbm93biBvciBnaXZlbiBhbiBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGlmICghZiB8fCBmWzFdICE9PSB2YWx1ZS52YWx1ZVtpXS52YWx1ZVtqXS5hcmdzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQodmFsdWUsIHNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiByZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiByZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnR5cGVcbiAgICAgICAgICAgIC5pbmRleE9mKHZhbHVlLnZhbHVlWzBdLnZhbHVlKSAhPT0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxsb3cgdW5xdW90ZWQga2V5d29yZHMgYXMgc3RyaW5nc1xuICAgICAgICByZXR1cm4gcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09PSAnc3RyaW5nJztcbiAgICB9XG59XG5cbnJlZi52YWxpZFZhbHVlID0gZnVuY3Rpb24oZW52LCBzZWxlY3RvciwgdmFsdWUpIHtcbiAgICB2YXIgaSwgajtcbiAgICAvLyBUT0RPOiBoYW5kbGUgaW4gcmV1c2FibGUgd2F5XG4gICAgaWYgKCFyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnZhbHVlWzBdLmlzID09ICdrZXl3b3JkJykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVLZXl3b3JkKHZhbHVlLCBzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS52YWx1ZVswXS5pcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBjYXVnaHQgZWFybGllciBpbiB0aGUgY2hhaW4gLSBpZ25vcmUgaGVyZSBzbyB0aGF0XG4gICAgICAgIC8vIGVycm9yIGlzIG5vdCBvdmVycmlkZGVuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09ICdudW1iZXJzJykge1xuICAgICAgICBmb3IgKGkgaW4gdmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZVtpXS5pcyAhPT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSAndGFncycpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXZhbHVlLnZhbHVlWzBdLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWVbMF0uaXMgPT09ICd0YWcnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS52YWx1ZVswXS52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlWzBdLnZhbHVlW2ldLmlzICE9PSAndGFnJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09ICdmdW5jdGlvbnMnKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgeW91IGNhbiBzcGVjaWZ5IGEgc3RyaW5nIGZvciBgZnVuY3Rpb25zYC1jb21wYXRpYmxlXG4gICAgICAgIC8vIHZhbHVlcywgdGhvdWdoIHRoZXkgd2lsbCBub3QgYmUgdmFsaWRhdGVkLlxuICAgICAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbnModmFsdWUsIHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgICBpZiAodmFsdWUudmFsdWVbMF0uaXMgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgIHZhbHVlLnZhbHVlWzBdLnJvdW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHJlZi5zZWxlY3RvcihzZWxlY3RvcikuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZi5zZWxlY3RvcihzZWxlY3RvcikudHlwZSA9PSB2YWx1ZS52YWx1ZVtpXS5pcyAmJlxuICAgICAgICAgICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fdmFsaWRhdGVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZWYuc2VsZWN0b3Ioc2VsZWN0b3IpLnZhbGlkYXRlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbnYsIHZhbHVlLnZhbHVlW2ldLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmLnNlbGVjdG9yKHNlbGVjdG9yKS50eXBlID09IHZhbHVlLnZhbHVlWzBdLmlzO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudHJlZS5SZWZlcmVuY2UgPSByZWY7XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuLy8gYSBydWxlIGlzIGEgc2luZ2xlIHByb3BlcnR5IGFuZCB2YWx1ZSBjb21iaW5hdGlvbiwgb3IgdmFyaWFibGVcbi8vIG5hbWUgYW5kIHZhbHVlIGNvbWJpbmF0aW9uLCBsaWtlXG4vLyBwb2x5Z29uLW9wYWNpdHk6IDEuMDsgb3IgQG9wYWNpdHk6IDEuMDtcbnRyZWUuUnVsZSA9IGZ1bmN0aW9uIFJ1bGUobmFtZSwgdmFsdWUsIGluZGV4LCBmaWxlbmFtZSkge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy8nKTtcbiAgICB0aGlzLm5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICB0aGlzLmluc3RhbmNlID0gcGFydHMubGVuZ3RoID8gcGFydHNbMF0gOiAnX19kZWZhdWx0X18nO1xuICAgIHRoaXMudmFsdWUgPSAodmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhbHVlKSA/XG4gICAgICAgIHZhbHVlIDogbmV3IHRyZWUuVmFsdWUoW3ZhbHVlXSk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuc3ltYm9saXplciA9IHRyZWUuUmVmZXJlbmNlLnN5bWJvbGl6ZXIodGhpcy5uYW1lKTtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgdGhpcy52YXJpYWJsZSA9IChuYW1lLmNoYXJBdCgwKSA9PT0gJ0AnKTtcbn07XG5cbnRyZWUuUnVsZS5wcm90b3R5cGUuaXMgPSAncnVsZSc7XG5cbnRyZWUuUnVsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRyZWUuUnVsZS5wcm90b3R5cGUpO1xuICAgIGNsb25lLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY2xvbmUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIGNsb25lLmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBjbG9uZS5pbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG4gICAgY2xvbmUuc3ltYm9saXplciA9IHRoaXMuc3ltYm9saXplcjtcbiAgICBjbG9uZS5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgY2xvbmUudmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbnRyZWUuUnVsZS5wcm90b3R5cGUudXBkYXRlSUQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pZCA9IHRoaXMuem9vbSArICcjJyArIHRoaXMuaW5zdGFuY2UgKyAnIycgKyB0aGlzLm5hbWU7XG59O1xuXG50cmVlLlJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdbJyArIHRyZWUuWm9vbS50b1N0cmluZyh0aGlzLnpvb20pICsgJ10gJyArIHRoaXMubmFtZSArICc6ICcgKyB0aGlzLnZhbHVlO1xufTtcblxuZnVuY3Rpb24gZ2V0TWVhbihuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yX2NhY2hlKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gW2YsIHRyZWUuUmVmZXJlbmNlLmVkaXREaXN0YW5jZShuYW1lLCBmKV07XG4gICAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSk7XG59XG5cbi8vIHNlY29uZCBhcmd1bWVudCwgaWYgdHJ1ZSwgb3V0cHV0cyB0aGUgdmFsdWUgb2YgdGhpc1xuLy8gcnVsZSB3aXRob3V0IHRoZSB1c3VhbCBhdHRyaWJ1dGU9XCJjb250ZW50XCIgd3JhcHBpbmcuIFJpZ2h0XG4vLyBub3cgdGhpcyBpcyBqdXN0IGZvciB0aGUgVGV4dFN5bWJvbGl6ZXIsIGJ1dCBhcHBsaWVzIHRvIG90aGVyXG4vLyBwcm9wZXJ0aWVzIGluIHJlZmVyZW5jZS5qc29uIHdoaWNoIHNwZWNpZnkgc2VyaWFsaXphdGlvbj1jb250ZW50XG50cmVlLlJ1bGUucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24oZW52LCBjb250ZW50LCBzZXAsIGZvcm1hdCkge1xuICAgIGlmICghdHJlZS5SZWZlcmVuY2UudmFsaWRTZWxlY3Rvcih0aGlzLm5hbWUpKSB7XG4gICAgICAgIHZhciBtZWFuID0gZ2V0TWVhbih0aGlzLm5hbWUpO1xuICAgICAgICB2YXIgbWVhbl9tZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChtZWFuWzBdWzFdIDwgMykge1xuICAgICAgICAgICAgbWVhbl9tZXNzYWdlID0gJy4gRGlkIHlvdSBtZWFuICcgKyBtZWFuWzBdWzBdICsgJz8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnYuZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbnJlY29nbml6ZWQgcnVsZTogXCIgKyB0aGlzLm5hbWUgKyBtZWFuX21lc3NhZ2UsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgIHR5cGU6ICdzeW50YXgnLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLnZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYWx1ZSkgJiZcbiAgICAgICAgIXRyZWUuUmVmZXJlbmNlLnZhbGlkVmFsdWUoZW52LCB0aGlzLm5hbWUsIHRoaXMudmFsdWUpKSB7XG4gICAgICAgIGlmICghdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VucmVjb2duaXplZCBwcm9wZXJ0eTogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ludGF4JyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWU7XG4gICAgICAgICAgICBpZiAodHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS52YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lID0gdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS52YWxpZGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyZWUuUmVmZXJlbmNlLnNlbGVjdG9yKHRoaXMubmFtZSkudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0eXBlbmFtZSA9ICdrZXl3b3JkIChvcHRpb25zOiAnICsgdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS50eXBlLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lID0gdHJlZS5SZWZlcmVuY2Uuc2VsZWN0b3IodGhpcy5uYW1lKS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgdmFsdWUgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnLCB0aGUgdHlwZSAnICsgdHlwZW5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnIGlzIGV4cGVjdGVkLiAnICsgdGhpcy52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICcgKG9mIHR5cGUgJyArIHRoaXMudmFsdWUudmFsdWVbMF0uaXMgKyAnKSAnICtcbiAgICAgICAgICAgICAgICAgICAgJyB3YXMgZ2l2ZW4uJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ludGF4JyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICh0cmVlLlJlZmVyZW5jZS5pc0ZvbnQodGhpcy5uYW1lKSAmJiB0aGlzLnZhbHVlLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGYgPSB0cmVlLl9nZXRGb250U2V0KGVudiwgdGhpcy52YWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiAnZm9udHNldC1uYW1lPVwiJyArIGYubmFtZSArICdcIic7XG4gICAgfSBlbHNlIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKGVudiwgdGhpcy5uYW1lLCBzZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmVlLlJlZmVyZW5jZS5zZWxlY3Rvck5hbWUodGhpcy5uYW1lKSArXG4gICAgICAgICAgICAnPVwiJyArXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnRvU3RyaW5nKGVudiwgdGhpcy5uYW1lKSArXG4gICAgICAgICAgICAnXCInO1xuICAgIH1cbn07XG5cbi8vIFRPRE86IFJ1bGUgZXYgY2hhaW4gc2hvdWxkIGFkZCBmb250c2V0cyB0byBlbnYuZnJhbWVzXG50cmVlLlJ1bGUucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgdHJlZS5SdWxlKHRoaXMubmFtZSxcbiAgICAgICAgdGhpcy52YWx1ZS5ldihjb250ZXh0KSxcbiAgICAgICAgdGhpcy5pbmRleCxcbiAgICAgICAgdGhpcy5maWxlbmFtZSk7XG59O1xuXG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5SdWxlc2V0ID0gZnVuY3Rpb24gUnVsZXNldChzZWxlY3RvcnMsIHJ1bGVzKSB7XG4gICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIC8vIHN0YXRpYyBjYWNoZSBvZiBmaW5kKCkgZnVuY3Rpb25cbiAgICB0aGlzLl9sb29rdXBzID0ge307XG59O1xudHJlZS5SdWxlc2V0LnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3J1bGVzZXQnLFxuICAgICdldic6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHJ1bGVzZXQgPSBuZXcgdHJlZS5SdWxlc2V0KHRoaXMuc2VsZWN0b3JzLCB0aGlzLnJ1bGVzLnNsaWNlKDApKTtcbiAgICAgICAgcnVsZXNldC5yb290ID0gdGhpcy5yb290O1xuXG4gICAgICAgIC8vIHB1c2ggdGhlIGN1cnJlbnQgcnVsZXNldCB0byB0aGUgZnJhbWVzIHN0YWNrXG4gICAgICAgIGVudi5mcmFtZXMudW5zaGlmdChydWxlc2V0KTtcblxuICAgICAgICAvLyBFdmFsdWF0ZSBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgZm9yIChpID0gMCwgcnVsZTsgaSA8IHJ1bGVzZXQucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlc2V0LnJ1bGVzW2ldO1xuICAgICAgICAgICAgcnVsZXNldC5ydWxlc1tpXSA9IHJ1bGUuZXYgPyBydWxlLmV2KGVudikgOiBydWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9wIHRoZSBzdGFja1xuICAgICAgICBlbnYuZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XG4gICAgfSxcbiAgICBtYXRjaDogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDA7XG4gICAgfSxcbiAgICB2YXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVzKSB7IHJldHVybiB0aGlzLl92YXJpYWJsZXM7IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzID0gdGhpcy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24oaGFzaCwgcikge1xuICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgdHJlZS5SdWxlICYmIHIudmFyaWFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFtyLm5hbWVdID0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZhcmlhYmxlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcygpW25hbWVdO1xuICAgIH0sXG4gICAgcnVsZXNldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcnVsZXNldHMpIHsgcmV0dXJuIHRoaXMuX3J1bGVzZXRzOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzZXRzID0gdGhpcy5ydWxlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHJldHVybiAociBpbnN0YW5jZW9mIHRyZWUuUnVsZXNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIHNlbGYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYgfHwgdGhpcztcbiAgICAgICAgdmFyIHJ1bGVzID0gW10sIHJ1bGUsIG1hdGNoLFxuICAgICAgICAgICAga2V5ID0gc2VsZWN0b3IudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2xvb2t1cHMpIHsgcmV0dXJuIHRoaXMuX2xvb2t1cHNba2V5XTsgfVxuXG4gICAgICAgIHRoaXMucnVsZXNldHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIGlmIChydWxlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlLnNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKHJ1bGUuc2VsZWN0b3JzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJ1bGVzLCBydWxlLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyB0cmVlLlNlbGVjdG9yKG51bGwsIG51bGwsIG51bGwsIHNlbGVjdG9yLmVsZW1lbnRzLnNsaWNlKDEpKSwgc2VsZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9va3Vwc1trZXldID0gcnVsZXM7XG4gICAgfSxcbiAgICAvLyBab29tcyBjYW4gdXNlIHZhcmlhYmxlcy4gVGhpcyByZXBsYWNlcyB0cmVlLlpvb20gb2JqZWN0cyBvbiBzZWxlY3RvcnNcbiAgICAvLyB3aXRoIHNpbXBsZSBiaXQtYXJyYXlzIHRoYXQgd2UgY2FuIGNvbXBhcmUgZWFzaWx5LlxuICAgIGV2Wm9vbXM6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgenZhbCA9IHRyZWUuWm9vbS5hbGw7XG4gICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IHRoaXMuc2VsZWN0b3JzW2ldLnpvb20ubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICB6dmFsID0genZhbCAmIHRoaXMuc2VsZWN0b3JzW2ldLnpvb21bel0uZXYoZW52KS56b29tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnNbaV0uem9vbSA9IHp2YWw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKHJlc3VsdCwgcGFyZW50cywgZW52KSB7XG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSBbXSwgaSwgajtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZW52LmZyYW1lcyA9IGVudi5mcmFtZXMuY29uY2F0KHRoaXMucnVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV2YWx1YXRlIHpvb20gdmFyaWFibGVzIG9uIHRoaXMgb2JqZWN0LlxuICAgICAgICB0aGlzLmV2Wm9vbXMoZW52KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLnNlbGVjdG9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZC5maWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBpbnRlcm5hbCBpbmNvbnNpc3RlbmN5P1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW52YWxpZCBmaWx0ZXJzZXQuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXJlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZWRGaWx0ZXJzID0gcGFyZW50LmZpbHRlcnMuY2xvbmVXaXRoKGNoaWxkLmZpbHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2VkRmlsdGVycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVycyBjb3VsZCBiZSBhZGRlZCwgYnV0IHRoZXkgZGlkbid0IGNoYW5nZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlcnMuIFRoaXMgbWVhbnMgdGhhdCB3ZSBvbmx5IGhhdmUgdG8gY2xvbmUgd2hlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHpvb20gbGV2ZWxzIG9yIHRoZSBhdHRhY2htZW50IGlzIGRpZmZlcmVudCB0b28uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Lnpvb20gPT09IChwYXJlbnQuem9vbSAmIGNoaWxkLnpvb20pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZyYW1lX29mZnNldCA9PT0gY2hpbGQuZnJhbWVfb2Zmc2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmF0dGFjaG1lbnQgPT09IGNoaWxkLmF0dGFjaG1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMuam9pbigpID09PSBjaGlsZC5lbGVtZW50cy5qb2luKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRGaWx0ZXJzID0gcGFyZW50LmZpbHRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1lcmdlZEZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtZXJnZWQgZmlsdGVycyBhcmUgaW52YWxpZCwgdGhhdCBtZWFucyB3ZSBkb24ndFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBjbG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0cmVlLlNlbGVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmZpbHRlcnMgPSBtZXJnZWRGaWx0ZXJzO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS56b29tID0gcGFyZW50Lnpvb20gJiBjaGlsZC56b29tO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5mcmFtZV9vZmZzZXQgPSBjaGlsZC5mcmFtZV9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmVsZW1lbnRzID0gcGFyZW50LmVsZW1lbnRzLmNvbmNhdChjaGlsZC5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuYXR0YWNobWVudCAmJiBjaGlsZC5hdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5hdHRhY2htZW50ID0gcGFyZW50LmF0dGFjaG1lbnQgKyAnLycgKyBjaGlsZC5hdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2xvbmUuYXR0YWNobWVudCA9IGNoaWxkLmF0dGFjaG1lbnQgfHwgcGFyZW50LmF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmNvbmRpdGlvbnMgPSBwYXJlbnQuY29uZGl0aW9ucyArIGNoaWxkLmNvbmRpdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGNsb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBydWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFueSBuZXN0ZWQgcnVsZXNldHNcbiAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlc2V0KSB7XG4gICAgICAgICAgICAgICAgcnVsZS5mbGF0dGVuKHJlc3VsdCwgc2VsZWN0b3JzLCBlbnYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgdHJlZS5SdWxlKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIHRyZWUuSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVudi5lcnJvcihydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHJ1bGVzLmxlbmd0aCA/IHJ1bGVzWzBdLmluZGV4IDogZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZvciBzcGVjaWZpY2l0eSBzb3J0LCB1c2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBydWxlIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBkZWZpbmluZyBhdHRhY2htZW50cyB0aGF0IGFyZSB1bmRlciBjdXJyZW50IGVsZW1lbnQgYXMgYSBkZXNjZW5kYW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rvci5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnNbaV0uaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyB0cmVlLkRlZmluaXRpb24oc2VsZWN0b3JzW2ldLCBydWxlcy5zbGljZSgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG59KShyZXF1aXJlKCcuLi90cmVlJykpO1xuIiwiKGZ1bmN0aW9uKHRyZWUpIHtcblxudHJlZS5TZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKGZpbHRlcnMsIHpvb20sIGZyYW1lX29mZnNldCwgZWxlbWVudHMsIGF0dGFjaG1lbnQsIGNvbmRpdGlvbnMsIGluZGV4KSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzIHx8IFtdO1xuICAgIHRoaXMuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycyB8fCB7fTtcbiAgICB0aGlzLmZyYW1lX29mZnNldCA9IGZyYW1lX29mZnNldDtcbiAgICB0aGlzLnpvb20gPSB0eXBlb2Ygem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyB6b29tIDogdHJlZS5ab29tLmFsbDtcbiAgICB0aGlzLmNvbmRpdGlvbnMgPSBjb25kaXRpb25zO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbn07XG5cbi8vIERldGVybWluZSB0aGUgc3BlY2lmaWNpdHkgb2YgdGhpcyBzZWxlY3RvclxuLy8gYmFzZWQgb24gdGhlIHNwZWNpZmljaXR5IG9mIGl0cyBlbGVtZW50cyAtIGNhbGxpbmdcbi8vIEVsZW1lbnQuc3BlY2lmaWNpdHkoKSBpbiBvcmRlciB0byBkbyBzb1xuLy9cbi8vIFtJRCwgQ2xhc3MsIEZpbHRlcnMsIFBvc2l0aW9uIGluIGRvY3VtZW50XVxudHJlZS5TZWxlY3Rvci5wcm90b3R5cGUuc3BlY2lmaWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgZSkge1xuICAgICAgICB2YXIgc3BlYyA9IGUuc3BlY2lmaWNpdHkoKTtcbiAgICAgICAgbWVtb1swXSArPSBzcGVjWzBdO1xuICAgICAgICBtZW1vWzFdICs9IHNwZWNbMV07XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFswLCAwLCB0aGlzLmNvbmRpdGlvbnMsIHRoaXMuaW5kZXhdKTtcbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xudmFyIF8gPSBnbG9iYWwuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vIEdpdmVuIGEgc3R5bGUncyBuYW1lLCBhdHRhY2htZW50LCBkZWZpbml0aW9ucywgYW5kIGFuIGVudmlyb25tZW50IG9iamVjdCxcbi8vIHJldHVybiBhIHN0cmluZ2lmaWVkIHN0eWxlIGZvciBNYXBuaWtcbnRyZWUuU3R5bGVYTUwgPSBmdW5jdGlvbihuYW1lLCBhdHRhY2htZW50LCBkZWZpbml0aW9ucywgZW52KSB7XG4gICAgdmFyIGV4aXN0aW5nID0ge307XG4gICAgdmFyIGltYWdlX2ZpbHRlcnMgPSBbXSwgaW1hZ2VfZmlsdGVyc19pbmZsYXRlID0gW10sIGRpcmVjdF9pbWFnZV9maWx0ZXJzID0gW10sIGNvbXBfb3AgPSBbXSwgb3BhY2l0eSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZpbml0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRlZmluaXRpb25zW2ldLnJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ2ltYWdlLWZpbHRlcnMnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VfZmlsdGVycy5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXS5uYW1lID09PSAnaW1hZ2UtZmlsdGVycy1pbmZsYXRlJykge1xuICAgICAgICAgICAgICAgIGltYWdlX2ZpbHRlcnNfaW5mbGF0ZS5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXS5uYW1lID09PSAnZGlyZWN0LWltYWdlLWZpbHRlcnMnKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0X2ltYWdlX2ZpbHRlcnMucHVzaChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0ubmFtZSA9PT0gJ2NvbXAtb3AnKSB7XG4gICAgICAgICAgICAgICAgY29tcF9vcC5wdXNoKGRlZmluaXRpb25zW2ldLnJ1bGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uc1tpXS5ydWxlc1tqXS5uYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5LnB1c2goZGVmaW5pdGlvbnNbaV0ucnVsZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVzID0gZGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24udG9YTUwoZW52LCBleGlzdGluZyk7XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0cnNfeG1sID0gJyc7XG5cbiAgICBpZiAoaW1hZ2VfZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgaW1hZ2UtZmlsdGVycz1cIicgKyBfLmNoYWluKGltYWdlX2ZpbHRlcnMpXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlkZW50aWNhbCBmaWx0ZXJzIGZyb20gYmVpbmcgZHVwbGljYXRlZCBpbiB0aGUgc3R5bGVcbiAgICAgICAgICAgIC51bmlxKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGkuaWQ7IH0pLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICByZXR1cm4gZi5ldihlbnYpLnRvWE1MKGVudiwgdHJ1ZSwgJywnLCAnaW1hZ2UtZmlsdGVyJyk7XG4gICAgICAgIH0pLnZhbHVlKCkuam9pbignLCcpICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAoaW1hZ2VfZmlsdGVyc19pbmZsYXRlLmxlbmd0aCkge1xuICAgICAgICBhdHRyc194bWwgKz0gJyBpbWFnZS1maWx0ZXJzLWluZmxhdGU9XCInICsgaW1hZ2VfZmlsdGVyc19pbmZsYXRlWzBdLnZhbHVlLmV2KGVudikudG9TdHJpbmcoKSArICdcIic7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdF9pbWFnZV9maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBhdHRyc194bWwgKz0gJyBkaXJlY3QtaW1hZ2UtZmlsdGVycz1cIicgKyBfLmNoYWluKGRpcmVjdF9pbWFnZV9maWx0ZXJzKVxuICAgICAgICAgICAgLy8gcHJldmVudCBpZGVudGljYWwgZmlsdGVycyBmcm9tIGJlaW5nIGR1cGxpY2F0ZWQgaW4gdGhlIHN0eWxlXG4gICAgICAgICAgICAudW5pcShmdW5jdGlvbihpKSB7IHJldHVybiBpLmlkOyB9KS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIGYuZXYoZW52KS50b1hNTChlbnYsIHRydWUsICcsJywgJ2RpcmVjdC1pbWFnZS1maWx0ZXInKTtcbiAgICAgICAgfSkudmFsdWUoKS5qb2luKCcsJykgKyAnXCInO1xuICAgIH1cblxuICAgIGlmIChjb21wX29wLmxlbmd0aCAmJiBjb21wX29wWzBdLnZhbHVlLmV2KGVudikudmFsdWUgIT0gJ3NyYy1vdmVyJykge1xuICAgICAgICBhdHRyc194bWwgKz0gJyBjb21wLW9wPVwiJyArIGNvbXBfb3BbMF0udmFsdWUuZXYoZW52KS50b1N0cmluZygpICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAob3BhY2l0eS5sZW5ndGggJiYgb3BhY2l0eVswXS52YWx1ZS5ldihlbnYpLnZhbHVlICE9IDEpIHtcbiAgICAgICAgYXR0cnNfeG1sICs9ICcgb3BhY2l0eT1cIicgKyBvcGFjaXR5WzBdLnZhbHVlLmV2KGVudikudG9TdHJpbmcoKSArICdcIic7XG4gICAgfVxuICAgIHZhciBydWxlX3N0cmluZyA9IHJ1bGVzLmpvaW4oJycpO1xuICAgIGlmICghYXR0cnNfeG1sICYmICFydWxlX3N0cmluZykgcmV0dXJuICcnO1xuICAgIHJldHVybiAnPFN0eWxlIG5hbWU9XCInICsgbmFtZSArICdcIiBmaWx0ZXItbW9kZT1cImZpcnN0XCInICsgYXR0cnNfeG1sICsgJz5cXG4nICsgcnVsZV9zdHJpbmcgKyAnPC9TdHlsZT4nO1xufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuVVJMID0gZnVuY3Rpb24gVVJMKHZhbCwgcGF0aHMpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgIHRoaXMucGF0aHMgPSBwYXRocztcbn07XG5cbnRyZWUuVVJMLnByb3RvdHlwZSA9IHtcbiAgICBpczogJ3VyaScsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZXY6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuVVJMKHRoaXMudmFsdWUuZXYoY3R4KSwgdGhpcy5wYXRocyk7XG4gICAgfVxufTtcblxufSkocmVxdWlyZSgnLi4vdHJlZScpKTtcbiIsIihmdW5jdGlvbih0cmVlKSB7XG5cbnRyZWUuVmFsdWUgPSBmdW5jdGlvbiBWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5cbnRyZWUuVmFsdWUucHJvdG90eXBlID0ge1xuICAgIGlzOiAndmFsdWUnLFxuICAgIGV2OiBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXS5ldihlbnYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlZhbHVlKHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5ldihlbnYpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW52LCBzZWxlY3Rvciwgc2VwLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvU3RyaW5nKGVudiwgZm9ybWF0KTtcbiAgICAgICAgfSkuam9pbihzZXAgfHwgJywgJyk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKHRyZWUuVmFsdWUucHJvdG90eXBlKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgb2JqLnZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgpO1xuICAgICAgICBlbHNlIG9iai52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIG9iai5pcyA9IHRoaXMuaXM7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIHRvSlM6IGZ1bmN0aW9uKGVudikge1xuICAgICAgLy92YXIgdiA9IHRoaXMudmFsdWVbMF0udmFsdWVbMF07XG4gICAgICB2YXIgdmFsID0gdGhpcy5ldihlbnYpO1xuICAgICAgdmFyIHYgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgIGlmKHZhbC5pcyA9PT0gXCJjb2xvclwiIHx8IHZhbC5pcyA9PT0gJ3VyaScgfHwgdmFsLmlzID09PSAnc3RyaW5nJyB8fCB2YWwuaXMgPT09ICdrZXl3b3JkJykge1xuICAgICAgICB2ID0gXCInXCIgKyB2ICsgXCInXCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5pcyA9PT0gJ2ZpZWxkJykge1xuICAgICAgICAvLyByZXBsYWNlIFt2YXJpYWJsZV0gYnkgY3R4Wyd2YXJpYWJsZSddXG4gICAgICAgIHYgPSB2LnJlcGxhY2UoL1xcWyguKilcXF0vZywgXCJkYXRhWyckMSddXCIpO1xuICAgICAgfWVsc2UgaWYgKHZhbC5pcyA9PT0gJ2NhbGwnKSB7XG4gICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBuYW1lOiB2YWwubmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IHZhbC5hcmdzXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gXCJfdmFsdWUgPSBcIiArIHYgKyBcIjtcIjtcbiAgICB9XG5cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCIoZnVuY3Rpb24odHJlZSkge1xuXG50cmVlLlZhcmlhYmxlID0gZnVuY3Rpb24gVmFyaWFibGUobmFtZSwgaW5kZXgsIGZpbGVuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xufTtcblxudHJlZS5WYXJpYWJsZS5wcm90b3R5cGUgPSB7XG4gICAgaXM6ICd2YXJpYWJsZScsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH0sXG4gICAgZXY6IGZ1bmN0aW9uKGVudikge1xuICAgICAgICB2YXIgdmFyaWFibGUsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgbmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgICBpZiAodGhpcy5fY3NzKSByZXR1cm4gdGhpcy5fY3NzO1xuXG4gICAgICAgIHZhciB0aGlzZnJhbWUgPSBlbnYuZnJhbWVzLmZpbHRlcihmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICByZXR1cm4gZi5uYW1lID09IHRoaXMubmFtZTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXNmcmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzZnJhbWVbMF0udmFsdWUuZXYoZW52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudi5lcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ3ZhcmlhYmxlICcgKyB0aGlzLm5hbWUgKyAnIGlzIHVuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXM6ICd1bmRlZmluZWQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0pKHJlcXVpcmUoJy4uL3RyZWUnKSk7XG4iLCJ2YXIgdHJlZSA9IHJlcXVpcmUoJy4uL3RyZWUnKTtcblxuLy8gU3RvcmFnZSBmb3Igem9vbSByYW5nZXMuIE9ubHkgc3VwcG9ydHMgY29udGludW91cyByYW5nZXMsXG4vLyBhbmQgc3RvcmVzIHRoZW0gYXMgYml0LXNlcXVlbmNlcyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvbWJpbmVkLFxuLy8gaW52ZXJ0ZWQsIGFuZCBjb21wYXJlZCBxdWlja2x5LlxudHJlZS5ab29tID0gZnVuY3Rpb24ob3AsIHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMub3AgPSBvcDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxudHJlZS5ab29tLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG50cmVlLlpvb20ucHJvdG90eXBlLmV2ID0gZnVuY3Rpb24oZW52KSB7XG4gICAgdmFyIHN0YXJ0ID0gMCxcbiAgICAgICAgZW5kID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQodGhpcy52YWx1ZS5ldihlbnYpLnRvU3RyaW5nKCksIDEwKSxcbiAgICAgICAgem9vbSA9IDA7XG5cbiAgICBpZiAodmFsdWUgPiB0cmVlLlpvb20ubWF4Wm9vbSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgZW52LmVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdPbmx5IHpvb20gbGV2ZWxzIGJldHdlZW4gMCBhbmQgJyArXG4gICAgICAgICAgICAgICAgdHJlZS5ab29tLm1heFpvb20gKyAnIHN1cHBvcnRlZC4nLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLm9wKSB7XG4gICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgdGhpcy56b29tID0gMSA8PCB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHN0YXJ0ID0gdmFsdWUgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIHN0YXJ0ID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICBlbmQgPSB2YWx1ZSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgZW5kID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdHJlZS5ab29tLm1heFpvb207IGkrKykge1xuICAgICAgICBpZiAoaSA+PSBzdGFydCAmJiBpIDw9IGVuZCkge1xuICAgICAgICAgICAgem9vbSB8PSAoMSA8PCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxudHJlZS5ab29tLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnpvb207XG59O1xuXG4vLyBDb3ZlcnMgYWxsIHpvb21sZXZlbHMgZnJvbSAwIHRvIDIyXG50cmVlLlpvb20uYWxsID0gMHg3RkZGRkY7XG5cbnRyZWUuWm9vbS5tYXhab29tID0gMjI7XG5cbnRyZWUuWm9vbS5yYW5nZXMgPSB7XG4gICAgIDA6IDEwMDAwMDAwMDAsXG4gICAgIDE6IDUwMDAwMDAwMCxcbiAgICAgMjogMjAwMDAwMDAwLFxuICAgICAzOiAxMDAwMDAwMDAsXG4gICAgIDQ6IDUwMDAwMDAwLFxuICAgICA1OiAyNTAwMDAwMCxcbiAgICAgNjogMTI1MDAwMDAsXG4gICAgIDc6IDY1MDAwMDAsXG4gICAgIDg6IDMwMDAwMDAsXG4gICAgIDk6IDE1MDAwMDAsXG4gICAgMTA6IDc1MDAwMCxcbiAgICAxMTogNDAwMDAwLFxuICAgIDEyOiAyMDAwMDAsXG4gICAgMTM6IDEwMDAwMCxcbiAgICAxNDogNTAwMDAsXG4gICAgMTU6IDI1MDAwLFxuICAgIDE2OiAxMjUwMCxcbiAgICAxNzogNTAwMCxcbiAgICAxODogMjUwMCxcbiAgICAxOTogMTUwMCxcbiAgICAyMDogNzUwLFxuICAgIDIxOiA1MDAsXG4gICAgMjI6IDI1MCxcbiAgICAyMzogMTAwXG59O1xuXG4vLyBPbmx5IHdvcmtzIGZvciBzaW5nbGUgcmFuZ2Ugem9vbXMuIGBbWFhYLi4uLlhYWFhYLi4uLi4uLi4uXWAgaXMgaW52YWxpZC5cbnRyZWUuWm9vbS5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29uZGl0aW9ucyA9IFtdO1xuICAgIGlmICh0aGlzLnpvb20gIT0gdHJlZS5ab29tLmFsbCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBudWxsLCBlbmQgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0cmVlLlpvb20ubWF4Wm9vbTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56b29tICYgKDEgPDwgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA+IDApIGNvbmRpdGlvbnMucHVzaCgnICAgIDxNYXhTY2FsZURlbm9taW5hdG9yPicgK1xuICAgICAgICAgICAgdHJlZS5ab29tLnJhbmdlc1tzdGFydF0gKyAnPC9NYXhTY2FsZURlbm9taW5hdG9yPlxcbicpO1xuICAgICAgICBpZiAoZW5kIDwgMjIpIGNvbmRpdGlvbnMucHVzaCgnICAgIDxNaW5TY2FsZURlbm9taW5hdG9yPicgK1xuICAgICAgICAgICAgdHJlZS5ab29tLnJhbmdlc1tlbmQgKyAxXSArICc8L01pblNjYWxlRGVub21pbmF0b3I+XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb25zO1xufTtcblxudHJlZS5ab29tLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0cmVlLlpvb20ubWF4Wm9vbTsgaSsrKSB7XG4gICAgICAgIHN0ciArPSAodGhpcy56b29tICYgKDEgPDwgaSkpID8gJ1gnIDogJy4nO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICBleGlzdHNTeW5jID0gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jIHx8IHJlcXVpcmUoJ3BhdGgnKS5leGlzdHNTeW5jO1xuXG4vLyBMb2FkIGFsbCBzdGF0ZWQgdmVyc2lvbnMgaW50byB0aGUgbW9kdWxlIGV4cG9ydHNcbm1vZHVsZS5leHBvcnRzLnZlcnNpb24gPSB7fTtcblxudmFyIHJlZnMgPSBbXG4gJzIuMC4wJyxcbiAnMi4wLjEnLFxuICcyLjAuMicsXG4gJzIuMS4wJyxcbiAnMi4xLjEnLFxuICcyLjIuMCcsXG4gJzIuMy4wJyxcbiAnMy4wLjAnXG5dO1xuXG5yZWZzLm1hcChmdW5jdGlvbih2ZXJzaW9uKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMudmVyc2lvblt2ZXJzaW9uXSA9IHJlcXVpcmUocGF0aC5qb2luKF9fZGlybmFtZSwgdmVyc2lvbiwgJ3JlZmVyZW5jZS5qc29uJykpO1xuICAgIHZhciBkc19wYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgdmVyc2lvbiwgJ2RhdGFzb3VyY2VzLmpzb24nKTtcbiAgICBpZiAoZXhpc3RzU3luYyhkc19wYXRoKSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy52ZXJzaW9uW3ZlcnNpb25dLmRhdGFzb3VyY2VzID0gcmVxdWlyZShkc19wYXRoKS5kYXRhc291cmNlcztcbiAgICB9XG59KTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuNi4wXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXG4gIHZhciBicmVha2VyID0ge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLFxuICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjYuMCc7XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gIHZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGluZGV4ID0ga2V5cyA/IGtleXNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtpbmRleF07XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2luZGV4XSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmaWx0ZXJgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9LCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgLy8gU2VlIFtXZWJLaXQgQnVnIDgwNzk3XShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODA3OTcpXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYW4gYXJyYXksIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmFuZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaHVmZmxlZCA9IFtdO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmIChvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBsb29rdXAgaXRlcmF0b3JzLlxuICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldLnB1c2godmFsdWUpIDogcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbbWlkXSkgPCB2YWx1ZSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgaWYgKG4gPCAwKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIG91dHB1dCkge1xuICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgfVxuICAgIGVhY2goaW5wdXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICBzaGFsbG93ID8gcHVzaC5hcHBseShvdXRwdXQsIHZhbHVlKSA6IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFuIGFycmF5IGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBlYWNoKGFycmF5LCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAocHJlZGljYXRlKGVsZW0pID8gcGFzcyA6IGZhaWwpLnB1c2goZWxlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkgOiBhcnJheTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZWFjaChpbml0aWFsLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShfLmZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmV2ZXJ5KHJlc3QsIGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBfLmNvbnRhaW5zKG90aGVyLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3VtZW50cywgJ2xlbmd0aCcpLmNvbmNhdCgwKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmd1bWVudHMsICcnICsgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSxcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gIC8vIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gKGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHtcbiAgICAgIHJldHVybiBoYXNJbmRleCA/IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0sIGZyb20pIDogYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGktLSkgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlKGlkeCA8IGxlbmd0aCkge1xuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy5cbiAgdmFyIGN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT09IF8pIGFyZ3NbaV0gPSBhcmd1bWVudHNbcG9zaXRpb24rK107XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSkgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09PSBhdHRycykgcmV0dXJuIHRydWU7IC8vYXZvaWQgY29tcGFyaW5nIGFuIG9iamVjdCB0byBpdHNlbGYuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgZXNjYXBlOiB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjeDI3OydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdCc6ICAgICAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcmVuZGVyO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTsgfSk7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJjYXJ0b1wiLFxuICBcInZlcnNpb25cIjogXCIwLjE1LjEtY2RiMVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQ2FydG9DU1MgU3R5bGVzaGVldCBDb21waWxlclwiLFxuICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jYXJ0b2RiL2NhcnRvXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by5naXRcIlxuICB9LFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2FydG9EQlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2NhcnRvZGIuY29tL1wiXG4gIH0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwibWFwc1wiLFxuICAgIFwiY3NzXCIsXG4gICAgXCJzdHlsZXNoZWV0c1wiXG4gIF0sXG4gIFwiY29udHJpYnV0b3JzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJUb20gTWFjV3JpZ2h0XCIsXG4gICAgICBcImVtYWlsXCI6IFwibWFjd3JpZ2h0QGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJLb25zdGFudGluIEvDpGZlclwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJBbGV4aXMgU2VsbGllclwiLFxuICAgICAgXCJlbWFpbFwiOiBcInNlbGZAY2xvdWRoZWFkLm5ldFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJSYXVsIE9jaG9hXCIsXG4gICAgICBcImVtYWlsXCI6IFwicm9jaG9hQGNhcnRvZGIuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIkphdmkgU2FudGFuYVwiLFxuICAgICAgXCJlbWFpbFwiOiBcImpzYW50YW5hQGNhcnRvZGIuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwibGljZW5zZXNcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIkFwYWNoZVwiXG4gICAgfVxuICBdLFxuICBcImJpblwiOiB7XG4gICAgXCJjYXJ0b1wiOiBcIi4vYmluL2NhcnRvXCJcbiAgfSxcbiAgXCJtYW5cIjogW1xuICAgIFwiLi9tYW4vY2FydG8uMVwiXG4gIF0sXG4gIFwibWFpblwiOiBcIi4vbGliL2NhcnRvL2luZGV4XCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjQueFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInVuZGVyc2NvcmVcIjogXCJ+MS42LjBcIixcbiAgICBcIm1hcG5pay1yZWZlcmVuY2VcIjogXCJ+Ni4wLjJcIixcbiAgICBcIm9wdGltaXN0XCI6IFwifjAuNi4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibW9jaGFcIjogXCIxLjEyLnhcIixcbiAgICBcImpzaGludFwiOiBcIjAuMi54XCIsXG4gICAgXCJzYXhcIjogXCIwLjEueFwiLFxuICAgIFwiaXN0YW5idWxcIjogXCJ+MC4yLjE0XCIsXG4gICAgXCJjb3ZlcmFsbHNcIjogXCJ+Mi4xMC4xXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwifjcuMC4wXCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCIxLjMuM1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJwcmV0ZXN0XCI6IFwibnBtIGluc3RhbGxcIixcbiAgICBcInRlc3RcIjogXCJtb2NoYSAtUiBzcGVjXCIsXG4gICAgXCJjb3ZlcmFnZVwiOiBcImlzdGFuYnVsIGNvdmVyIC4vbm9kZV9tb2R1bGVzLy5iaW4vX21vY2hhICYmIGNvdmVyYWxscyA8IC4vY292ZXJhZ2UvbGNvdi5pbmZvXCJcbiAgfSxcbiAgXCJyZWFkbWVcIjogXCIjIENhcnRvQ1NTXFxuXFxuWyFbQnVpbGQgU3RhdHVzXShodHRwczovL3NlY3VyZS50cmF2aXMtY2kub3JnL21hcGJveC9jYXJ0by5wbmcpXShodHRwOi8vdHJhdmlzLWNpLm9yZy9tYXBib3gvY2FydG8pXFxuXFxuSXMgYXMgc3R5bGVzaGVldCByZW5kZXJlciBmb3IgamF2YXNjcmlwdCwgSXQncyBhbiBldm9sdXRpb24gb2YgdGhlIE1hcG5payByZW5kZXJlciBmcm9tIE1hcGJveC5cXG5QbGVhc2UsIHNlZSBvcmlnaW5hbCBbTWFwYm94IHJlcG9dKGh0dHA6Ly9naXRodWIuY29tL21hcGJveC9jYXJ0bykgZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGNyZWRpdHNcXG5cXG4jIyBRdWljayBTdGFydFxcblxcbmBgYGphdmFzY3JpcHRcXG4vLyBzaGFkZXIgaXMgYSBDYXJ0b0NTUyBvYmplY3RcXG5cXG52YXIgY2FydG9jc3MgPSBbXFxuICAgICcjbGF5ZXIgeycsXFxuICAgICcgbWFya2VyLXdpZHRoOiBbcHJvcGVydHldJyxcXG4gICAgJyBtYXJrZXItZmlsbDogcmVkJyxcXG4gICAgJ30nXFxuXS5qb2luKCcnKVxcbnZhciBzaGFkZXIgPSBuZXcgY2FydG8uUmVuZGVyZXJKUygpLnJlbmRlcihjYXJ0b2Nzcyk7XFxudmFyIGxheWVycyA9IHNoYWRlci5nZXRMYXllcnMoKVxcbmZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcXG4gICAgY29uc29sZS5sb2coXFxcImxheWVyIG5hbWU6IFxcXCIsIGxheWVyLmZ1bGxOYW1lKCkpXFxuICAgIGNvbnNvbGUubG9nKFxcXCItIGZyYW1lczogXFxcIiwgbGF5ZXIuZnJhbWVzKCkpXFxuICAgIGNvbnNvbGUubG9nKFxcXCItIGF0dGFjaG1lbnQ6IFxcXCIsIGxheWVyLmF0dGFjaG1lbnQoKSlcXG5cXG4gICAgdmFyIGxheWVyU2hhZGVyID0gbGF5ZXIuZ2V0U3R5bGUoeyBwcm9wZXJ0eTogMSB9LCB7IHpvb206IDEwIH0pXFxuICAgIGNvbnNvbGUubG9nKGxheWVyU2hhZGVyWydtYXJrZXItd2lkdGgnXSkgLy8gMVxcbiAgICBjb25zb2xlLmxvZyhsYXllclNoYWRlclsnbWFya2VyLWZpbGwnXSkgLy8gI0ZGMDAwMFxcbn1cXG5cXG5gYGBcXG5cXG4jIEFQSVxcblxcbiMjIFJlbmRlcmVySlNcXG5cXG4jIyMgcmVuZGVyKGNhcnRvY3NzKVxcblxcbiMjIENhcnRvQ1NTXFxuXFxuY29tcGlsZWQgY2FydG9jc3Mgb2JqZWN0XFxuXFxuIyMjIGdldExheWVyc1xcblxcbnJldHVybiB0aGUgbGF5ZXJzLCBhbiBhcnJheSBvZiBgYENhcnRvQ1NTLkxheWVyYGAgb2JqZWN0XFxuXFxuIyMjIGdldERlZmF1bHRcXG5cXG5yZXR1cm4gdGhlIGRlZmF1bHQgbGF5ZXIgKGBgQ2FydG9DU1MuTGF5ZXJgYCksIHVzdWFsbHkgdGhlIE1hcCBsYXllclxcblxcblxcbiMjIyBmaW5kTGF5ZXIod2hlcmUpXFxuXFxuZmluZCBhIGxheWVyIHVzaW5nIHdoZXJlIG9iamVjdC5cXG5cXG5gYGBcXG5zaGFkZXIuZmluZExheWVyKHsgbmFtZTogJ3Rlc3QnIH0pXFxuYGBgXFxuXFxuIyMgQ2FydG9DU1MuTGF5ZXJcXG5cXG4jIyMgZ2V0U3R5bGUocHJvcHMsIGNvbnRleHQpXFxuXFxucmV0dXJuIHRoZSBldmFsdWF0ZWQgc3R5bGU6XFxuICAgIC0gcHJvcHM6IG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgbmVlZGVkIHRvIHJlbmRlciB0aGUgc3R5bGUuIElmIHRoZSBjYXJ0b2NzcyBzdHlsZSB1c2VzXFxuICAgICAgc29tZSB2YXJpYWJsZXMgdGhleSBzaG91bGQgYmUgcGFzc2VkIGluIHRoaXMgb2JqZWN0XFxuICAgIC0gY29udGV4dDogcmVuZGVyaW5nIGNvbnRleHQgdmFyaWFibGVzIGxpa2UgYGB6b29tYGAgb3IgYW5pbWF0aW9uIGBgZnJhbWVgYFxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbiMjIFJlZmVyZW5jZSBEb2N1bWVudGF0aW9uXFxuXFxuKiBbbWFwYm94LmNvbS9jYXJ0b10oaHR0cDovL21hcGJveC5jb20vY2FydG8vKVxcblxcblxcblwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1kXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY2FydG9kYi9jYXJ0by9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NhcnRvZGIvY2FydG8jcmVhZG1lXCIsXG4gIFwiX2lkXCI6IFwiY2FydG9AMC4xNS4xLWNkYjFcIixcbiAgXCJfc2hhc3VtXCI6IFwiNjI1MzRjMjk3NWNiZWUwNzNmMTBjNmMxNGEwYzdlODg5Yzk0NjllN1wiLFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9DYXJ0b0RCL2NhcnRvL2FyY2hpdmUvbWFzdGVyLnRhci5nelwiLFxuICBcIl9mcm9tXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0NhcnRvREIvY2FydG8vYXJjaGl2ZS9tYXN0ZXIudGFyLmd6XCJcbn1cbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4vKipcbiAqIGJhc2UgbGF5ZXIgZm9yIGFsbCBnb29nbGUgbWFwc1xuICovXG52YXIgR01hcHNMYXllclZpZXcgPSBmdW5jdGlvbihsYXllck1vZGVsLCBnbWFwc0xheWVyLCBnbWFwc01hcCkge1xuICB0aGlzLmdtYXBzTGF5ZXIgPSBnbWFwc0xheWVyO1xuICB0aGlzLm1hcCA9IHRoaXMuZ21hcHNNYXAgPSBnbWFwc01hcDtcbiAgdGhpcy5tb2RlbCA9IGxheWVyTW9kZWw7XG4gIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuICB0aGlzLnR5cGUgPSBsYXllck1vZGVsLmdldCgndHlwZScpIHx8IGxheWVyTW9kZWwuZ2V0KCdraW5kJyk7XG4gIHRoaXMudHlwZSA9IHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpO1xufTtcblxuXy5leHRlbmQoR01hcHNMYXllclZpZXcucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMpO1xuXy5leHRlbmQoR01hcHNMYXllclZpZXcucHJvdG90eXBlLCB7XG5cbiAgLy8gaGFjayBmdW5jdGlvbiB0byBzZWFyY2ggbGF5ZXIgaW5zaWRlIGdvb2dsZSBtYXBzIGxheWVyc1xuICBfc2VhcmNoTGF5ZXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHRoaXMuZ21hcHNNYXAub3ZlcmxheU1hcFR5cGVzLmZvckVhY2goXG4gICAgICBmdW5jdGlvbihsYXllciwgaSkge1xuICAgICAgICBpZiAobGF5ZXIgPT0gc2VsZikge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZW1vdmUgbGF5ZXIgZnJvbSB0aGUgbWFwIGFuZCB1bmJpbmQgZXZlbnRzXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmKCF0aGlzLmlzQmFzZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkeCA9IHRoaXMuX3NlYXJjaExheWVySW5kZXgoKTtcbiAgICAgIGlmKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuZ21hcHNNYXAub3ZlcmxheU1hcFR5cGVzLnJlbW92ZUF0KGlkeCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZ21hcHNMYXllci5zZXRNYXApe1xuICAgICAgICB0aGlzLmdtYXBzTGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbC51bmJpbmQobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAgICB0aGlzLnVuYmluZCgpO1xuICAgIH1cbiAgfSxcblxuICByZWZyZXNoVmlldzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vcmVzZXQgdG8gdXBkYXRlXG4gICAgaWYodGhpcy5pc0Jhc2UpIHtcbiAgICAgIHZhciBhID0gJ19iYXNlTGF5ZXInO1xuICAgICAgdGhpcy5nbWFwc01hcC5zZXRNYXBUeXBlSWQobnVsbCk7XG4gICAgICB0aGlzLmdtYXBzTWFwLm1hcFR5cGVzLnNldChhLCB0aGlzLmdtYXBzTGF5ZXIpO1xuICAgICAgdGhpcy5nbWFwc01hcC5zZXRNYXBUeXBlSWQoYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLl9zZWFyY2hMYXllckluZGV4KCk7XG4gICAgICBpZihpZHggPj0gMCkge1xuICAgICAgICB0aGlzLmdtYXBzTWFwLm92ZXJsYXlNYXBUeXBlcy5zZXRBdChpZHgsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWxvYWQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnJlZnJlc2hWaWV3KCkgOyB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbigpIHsgdGhpcy5yZWZyZXNoVmlldygpOyB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdNYXBzTGF5ZXJWaWV3O1xuIiwiLy8gRGVwZW5kcyBvbiBjYXJ0b2RiIHN0YW5kYXJkIGJ1bmRsZSBiZWluZyBsb2FkZWQgYW5kIHByZXNlbnQgaW4gZ2xvYmFsIG5hbWVzcGFjZVxudmFyIHRvcnF1ZSA9IHJlcXVpcmUoJ3RvcnF1ZS5qcycpO1xudmFyIGNkYiA9IHdpbmRvdy5jZGI7XG52YXIgXyA9IGNkYi5fO1xudmFyIEJhY2tib25lID0gY2RiLkJhY2tib25lO1xuXG52YXIgR01hcHNMYXllclZpZXcgPSByZXF1aXJlKCdjZGIvZ2VvL2dtYXBzL2dtYXBzLWxheWVyLXZpZXcnKTtcbnZhciBDYXJ0b0RCTG9nbyA9IGNkYi5nZW8uY29tbW9uLkNhcnRvREJMb2dvO1xuXG52YXIgR01hcHNUb3JxdWVMYXllclZpZXcgPSBmdW5jdGlvbihsYXllck1vZGVsLCBnbWFwc01hcCkge1xuXG4gIHZhciBleHRyYSA9IGxheWVyTW9kZWwuZ2V0KCdleHRyYV9wYXJhbXMnKTtcbiAgR01hcHNMYXllclZpZXcuY2FsbCh0aGlzLCBsYXllck1vZGVsLCB0aGlzLCBnbWFwc01hcCk7XG5cbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fZ2V0UXVlcnkobGF5ZXJNb2RlbCk7XG4gIHRvcnF1ZS5HTWFwc1RvcnF1ZUxheWVyLmNhbGwodGhpcywge1xuICAgICAgdGFibGU6IGxheWVyTW9kZWwuZ2V0KCd0YWJsZV9uYW1lJyksXG4gICAgICB1c2VyOiBsYXllck1vZGVsLmdldCgndXNlcl9uYW1lJyksXG4gICAgICBjb2x1bW46IGxheWVyTW9kZWwuZ2V0KCdwcm9wZXJ0eScpLFxuICAgICAgYmxlbmRtb2RlOiBsYXllck1vZGVsLmdldCgndG9ycXVlLWJsZW5kLW1vZGUnKSxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICAvL1RPRE86IG1hbmFnZSB0aW1lIGNvbHVtbnNcbiAgICAgIGNvdW50Ynk6ICdjb3VudChjYXJ0b2RiX2lkKScsXG4gICAgICBzcWxfYXBpX2RvbWFpbjogbGF5ZXJNb2RlbC5nZXQoJ3NxbF9hcGlfZG9tYWluJyksXG4gICAgICBzcWxfYXBpX3Byb3RvY29sOiBsYXllck1vZGVsLmdldCgnc3FsX2FwaV9wcm90b2NvbCcpLFxuICAgICAgc3FsX2FwaV9wb3J0OiBsYXllck1vZGVsLmdldCgnc3FsX2FwaV9wb3J0JyksXG4gICAgICB0aWxlcl9wcm90b2NvbDogbGF5ZXJNb2RlbC5nZXQoJ3RpbGVyX3Byb3RvY29sJyksXG4gICAgICB0aWxlcl9kb21haW46IGxheWVyTW9kZWwuZ2V0KCd0aWxlcl9kb21haW4nKSxcbiAgICAgIHRpbGVyX3BvcnQ6IGxheWVyTW9kZWwuZ2V0KCd0aWxlcl9wb3J0JyksXG4gICAgICBtYXBzX2FwaV90ZW1wbGF0ZTogbGF5ZXJNb2RlbC5nZXQoJ21hcHNfYXBpX3RlbXBsYXRlJyksXG4gICAgICBzdGF0X3RhZzogbGF5ZXJNb2RlbC5nZXQoJ3N0YXRfdGFnJyksXG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogbGF5ZXJNb2RlbC5nZXQoJ3RvcnF1ZS1kdXJhdGlvbicpLFxuICAgICAgc3RlcHM6IGxheWVyTW9kZWwuZ2V0KCd0b3JxdWUtc3RlcHMnKSxcbiAgICAgIHNxbDogcXVlcnksXG4gICAgICB2aXNpYmxlOiBsYXllck1vZGVsLmdldCgndmlzaWJsZScpLFxuICAgICAgZXh0cmFfcGFyYW1zOiB7XG4gICAgICAgIGFwaV9rZXk6IGV4dHJhID8gZXh0cmEubWFwX2tleTogJydcbiAgICAgIH0sXG4gICAgICBtYXA6IGdtYXBzTWFwLFxuICAgICAgY2FydG9kYl9sb2dvOiBsYXllck1vZGVsLmdldCgnY2FydG9kYl9sb2dvJyksXG4gICAgICBhdHRyaWJ1dGlvbjogbGF5ZXJNb2RlbC5nZXQoJ2F0dHJpYnV0aW9uJyksXG4gICAgICBjYXJ0b2NzczogbGF5ZXJNb2RlbC5nZXQoJ2NhcnRvY3NzJykgfHwgbGF5ZXJNb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSxcbiAgICAgIG5hbWVkX21hcDogbGF5ZXJNb2RlbC5nZXQoJ25hbWVkX21hcCcpLFxuICAgICAgYXV0aF90b2tlbjogbGF5ZXJNb2RlbC5nZXQoJ2F1dGhfdG9rZW4nKSxcbiAgICAgIG5vX2NkbjogbGF5ZXJNb2RlbC5nZXQoJ25vX2NkbicpLFxuICAgICAgbG9vcDogbGF5ZXJNb2RlbC5nZXQoJ2xvb3AnKSA9PT0gZmFsc2U/IGZhbHNlOiB0cnVlLFxuICB9KTtcblxuICAvL3RoaXMuc2V0Q2FydG9DU1ModGhpcy5tb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSk7XG4gIGlmIChsYXllck1vZGVsLmdldCgndmlzaWJsZScpKSB7XG4gICAgdGhpcy5wbGF5KCk7XG4gIH1cblxuICBsYXllck1vZGVsLmluaXRGb3JUb3JxdWVMYXllclZpZXcodGhpcyk7XG59O1xuXG5fLmV4dGVuZChcbiAgR01hcHNUb3JxdWVMYXllclZpZXcucHJvdG90eXBlLFxuICBHTWFwc0xheWVyVmlldy5wcm90b3R5cGUsXG4gIHRvcnF1ZS5HTWFwc1RvcnF1ZUxheWVyLnByb3RvdHlwZSxcbiAge1xuXG4gIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5tb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpO1xuICAgIGlmKGNoYW5nZWQgPT09IGZhbHNlKSByZXR1cm47XG4gICAgY2hhbmdlZC50aWxlX3N0eWxlICYmIHRoaXMuc2V0Q2FydG9DU1ModGhpcy5tb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSk7XG4gICAgaWYgKCdxdWVyeScgaW4gY2hhbmdlZCB8fCAncXVlcnlfd3JhcHBlcicgaW4gY2hhbmdlZCkge1xuICAgICAgdGhpcy5zZXRTUUwodGhpcy5fZ2V0UXVlcnkodGhpcy5tb2RlbCkpO1xuICAgIH1cbiAgICBpZiAoJ3Zpc2libGUnIGluIGNoYW5nZWQpXG4gICAgICB0aGlzLm1vZGVsLmdldCgndmlzaWJsZScpID8gdGhpcy5zaG93KCk6IHRoaXMuaGlkZSgpO1xuICB9LFxuXG4gIF9nZXRRdWVyeTogZnVuY3Rpb24obGF5ZXJNb2RlbCkge1xuICAgIHZhciBxdWVyeSA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeScpO1xuICAgIHZhciBxdyA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeV93cmFwcGVyJyk7XG4gICAgaWYocXcpIHtcbiAgICAgIHF1ZXJ5ID0gXy50ZW1wbGF0ZShxdykoeyBzcWw6IHF1ZXJ5IHx8ICgnc2VsZWN0ICogZnJvbSAnICsgbGF5ZXJNb2RlbC5nZXQoJ3RhYmxlX25hbWUnKSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfSxcblxuICByZWZyZXNoVmlldzogZnVuY3Rpb24oKSB7XG4gICAgLy9UT0RPOiB1cGRhdGUgc2NyZWVuXG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uKCkge1xuICAgIHRvcnF1ZS5HTWFwc1RvcnF1ZUxheWVyLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzKTtcbiAgICAvLyBBZGQgQ2FydG9EQiBsb2dvXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXJ0b2RiX2xvZ28gIT0gZmFsc2UpXG4gICAgICBDYXJ0b0RCTG9nby5hZGRXYWR1cyh7IGxlZnQ6IDc0LCBib3R0b206OCB9LCAyMDAwLCB0aGlzLm1hcC5nZXREaXYoKSlcbiAgfSxcblxuICBvblRpbGVzTG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAvL3RoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIEJhY2tib25lLkV2ZW50cy50cmlnZ2VyLmNhbGwodGhpcywgJ2xvYWQnKTtcbiAgfSxcblxuICBvblRpbGVzTG9hZGluZzogZnVuY3Rpb24oKSB7XG4gICAgQmFja2JvbmUuRXZlbnRzLnRyaWdnZXIuY2FsbCh0aGlzLCAnbG9hZGluZycpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdNYXBzVG9ycXVlTGF5ZXJWaWV3O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4vKipcbiAqIGJhc2UgbGF5ZXIgZm9yIGFsbCBsZWFmbGV0IGxheWVyc1xuICovXG52YXIgTGVhZmxldExheWVyVmlldyA9IGZ1bmN0aW9uKGxheWVyTW9kZWwsIGxlYWZsZXRMYXllciwgbGVhZmxldE1hcCkge1xuICB0aGlzLmxlYWZsZXRMYXllciA9IGxlYWZsZXRMYXllcjtcbiAgdGhpcy5sZWFmbGV0TWFwID0gbGVhZmxldE1hcDtcbiAgdGhpcy5tb2RlbCA9IGxheWVyTW9kZWw7XG5cbiAgdGhpcy5zZXRNb2RlbChsYXllck1vZGVsKTtcblxuICB0aGlzLnR5cGUgPSBsYXllck1vZGVsLmdldCgndHlwZScpIHx8IGxheWVyTW9kZWwuZ2V0KCdraW5kJyk7XG4gIHRoaXMudHlwZSA9IHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpO1xufTtcblxuXy5leHRlbmQoTGVhZmxldExheWVyVmlldy5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cyk7XG5fLmV4dGVuZChMZWFmbGV0TGF5ZXJWaWV3LnByb3RvdHlwZSwge1xuXG4gIHNldE1vZGVsOiBmdW5jdGlvbihtb2RlbCkge1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLnVuYmluZCgnY2hhbmdlJywgdGhpcy5fbW9kZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMubW9kZWwuYmluZCgnY2hhbmdlJywgdGhpcy5fbW9kZWxVcGRhdGVkLCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogcmVtb3ZlIGxheWVyIGZyb20gdGhlIG1hcCBhbmQgdW5iaW5kIGV2ZW50c1xuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxlYWZsZXRNYXAucmVtb3ZlTGF5ZXIodGhpcy5sZWFmbGV0TGF5ZXIpO1xuICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlJywgdGhpcyk7XG4gICAgdGhpcy5tb2RlbC51bmJpbmQobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgfSxcblxuICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVhZmxldExheWVyLnJlZHJhdygpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlYWZsZXRMYXllclZpZXc7XG4iLCIvLyBOT1RFIHRoaXMgaXMgT05MWSB1c2VkIGZvciB0b3JxdWUgYnVuZGxlIEFORCB0aGUgbGVhZmxldC5zcGVjLmpzLCB0aGF0IGFzc3VtZWQgdG9ycXVlIGxpYiB0byBiZSBsb2FkZWQpXG4vLyBEZXBlbmRzIG9uIGNhcnRvZGIgdG8gYmUgbG9hZGVkIGFuZCBwcmVzZW50IGluIGdsb2JhbCBuYW1lc3BhY2UuXG52YXIgY2RiID0gd2luZG93LmNkYjtcbnZhciBMID0gY2RiLkw7XG52YXIgXyA9IGNkYi5fO1xudmFyIHV0aWwgPSBjZGIuY29yZS51dGlsO1xudmFyIExlYWZsZXRMYXllclZpZXcgPSByZXF1aXJlKCdjZGIvZ2VvL2xlYWZsZXQvbGVhZmxldC1sYXllci12aWV3Jyk7XG52YXIgQ2FydG9EQkxvZ28gPSBjZGIuZ2VvLmNvbW1vbi5DYXJ0b0RCTG9nbztcblxuLyoqXG4gKiBsZWFmbGV0IHRvcnF1ZSBsYXllclxuICovXG52YXIgTGVhZmxldFRvcnF1ZUxheWVyID0gTC5Ub3JxdWVMYXllci5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGxheWVyTW9kZWwsIGxlYWZsZXRNYXApIHtcbiAgICB2YXIgZXh0cmEgPSBsYXllck1vZGVsLmdldCgnZXh0cmFfcGFyYW1zJyk7XG5cbiAgICB2YXIgcXVlcnkgPSB0aGlzLl9nZXRRdWVyeShsYXllck1vZGVsKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGJhc2UgbGF5ZXJzXG4gICAgTC5Ub3JxdWVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHtcbiAgICAgIHRhYmxlOiBsYXllck1vZGVsLmdldCgndGFibGVfbmFtZScpLFxuICAgICAgdXNlcjogbGF5ZXJNb2RlbC5nZXQoJ3VzZXJfbmFtZScpLFxuICAgICAgY29sdW1uOiBsYXllck1vZGVsLmdldCgncHJvcGVydHknKSxcbiAgICAgIGJsZW5kbW9kZTogbGF5ZXJNb2RlbC5nZXQoJ3RvcnF1ZS1ibGVuZC1tb2RlJyksXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgLy9UT0RPOiBtYW5hZ2UgdGltZSBjb2x1bW5zXG4gICAgICBjb3VudGJ5OiAnY291bnQoY2FydG9kYl9pZCknLFxuICAgICAgc3FsX2FwaV9kb21haW46IGxheWVyTW9kZWwuZ2V0KCdzcWxfYXBpX2RvbWFpbicpLFxuICAgICAgc3FsX2FwaV9wcm90b2NvbDogbGF5ZXJNb2RlbC5nZXQoJ3NxbF9hcGlfcHJvdG9jb2wnKSxcbiAgICAgIHNxbF9hcGlfcG9ydDogbGF5ZXJNb2RlbC5nZXQoJ3NxbF9hcGlfcG9ydCcpLFxuICAgICAgdGlsZXJfcHJvdG9jb2w6IGxheWVyTW9kZWwuZ2V0KCd0aWxlcl9wcm90b2NvbCcpLFxuICAgICAgdGlsZXJfZG9tYWluOiBsYXllck1vZGVsLmdldCgndGlsZXJfZG9tYWluJyksXG4gICAgICB0aWxlcl9wb3J0OiBsYXllck1vZGVsLmdldCgndGlsZXJfcG9ydCcpLFxuICAgICAgbWFwc19hcGlfdGVtcGxhdGU6IGxheWVyTW9kZWwuZ2V0KCdtYXBzX2FwaV90ZW1wbGF0ZScpLFxuICAgICAgc3RhdF90YWc6IGxheWVyTW9kZWwuZ2V0KCdzdGF0X3RhZycpLFxuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGxheWVyTW9kZWwuZ2V0KCd0b3JxdWUtZHVyYXRpb24nKSxcbiAgICAgIHN0ZXBzOiBsYXllck1vZGVsLmdldCgndG9ycXVlLXN0ZXBzJyksXG4gICAgICBzcWw6IHF1ZXJ5LFxuICAgICAgdmlzaWJsZTogbGF5ZXJNb2RlbC5nZXQoJ3Zpc2libGUnKSxcbiAgICAgIGV4dHJhX3BhcmFtczoge1xuICAgICAgICBhcGlfa2V5OiBleHRyYSA/IGV4dHJhLm1hcF9rZXk6ICcnXG4gICAgICB9LFxuICAgICAgY2FydG9kYl9sb2dvOiBsYXllck1vZGVsLmdldCgnY2FydG9kYl9sb2dvJyksXG4gICAgICBhdHRyaWJ1dGlvbjogbGF5ZXJNb2RlbC5nZXQoJ2F0dHJpYnV0aW9uJyksXG4gICAgICBjYXJ0b2NzczogbGF5ZXJNb2RlbC5nZXQoJ2NhcnRvY3NzJykgfHwgbGF5ZXJNb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSxcbiAgICAgIG5hbWVkX21hcDogbGF5ZXJNb2RlbC5nZXQoJ25hbWVkX21hcCcpLFxuICAgICAgYXV0aF90b2tlbjogbGF5ZXJNb2RlbC5nZXQoJ2F1dGhfdG9rZW4nKSxcbiAgICAgIG5vX2NkbjogbGF5ZXJNb2RlbC5nZXQoJ25vX2NkbicpLFxuICAgICAgZHluYW1pY19jZG46IGxheWVyTW9kZWwuZ2V0KCdkeW5hbWljX2NkbicpLFxuICAgICAgbG9vcDogbGF5ZXJNb2RlbC5nZXQoJ2xvb3AnKSA9PT0gZmFsc2U/IGZhbHNlOiB0cnVlLFxuICAgICAgaW5zdGFuY2lhdGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXJ0b2NzcyA9IGxheWVyTW9kZWwuZ2V0KCdjYXJ0b2NzcycpIHx8IGxheWVyTW9kZWwuZ2V0KCd0aWxlX3N0eWxlJyk7XG5cbiAgICAgICAgcmV0dXJuICdfY2RiY3RfJyArIHV0aWwudW5pcXVlQ2FsbGJhY2tOYW1lKGNhcnRvY3NzICsgcXVlcnkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgTGVhZmxldExheWVyVmlldy5jYWxsKHRoaXMsIGxheWVyTW9kZWwsIHRoaXMsIGxlYWZsZXRNYXApO1xuXG4gICAgLy8gbWF0Y2ggbGVhZmxldCBldmVudHMgd2l0aCBiYWNrYm9uZSBldmVudHNcbiAgICB0aGlzLmZpcmUgPSB0aGlzLnRyaWdnZXI7XG5cbiAgICAvL3RoaXMuc2V0Q2FydG9DU1MobGF5ZXJNb2RlbC5nZXQoJ3RpbGVfc3R5bGUnKSk7XG4gICAgaWYgKGxheWVyTW9kZWwuZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cblxuICAgIHRoaXMuYmluZCgndGlsZXNMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kKCd0aWxlc0xvYWRpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGluZycpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgbGF5ZXJNb2RlbC5pbml0Rm9yVG9ycXVlTGF5ZXJWaWV3KHRoaXMpO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICBMLlRvcnF1ZUxheWVyLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzLCBbbWFwXSk7XG4gICAgLy8gQWRkIENhcnRvREIgbG9nb1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY2FydG9kYl9sb2dvICE9IGZhbHNlKVxuICAgICAgQ2FydG9EQkxvZ28uYWRkV2FkdXMoeyBsZWZ0OjgsIGJvdHRvbTo4IH0sIDAsIG1hcC5fY29udGFpbmVyKVxuICB9LFxuXG4gIF9nZXRRdWVyeTogZnVuY3Rpb24obGF5ZXJNb2RlbCkge1xuICAgIHZhciBxdWVyeSA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeScpO1xuICAgIHZhciBxdyA9IGxheWVyTW9kZWwuZ2V0KCdxdWVyeV93cmFwcGVyJyk7XG4gICAgaWYocXcpIHtcbiAgICAgIHF1ZXJ5ID0gXy50ZW1wbGF0ZShxdykoeyBzcWw6IHF1ZXJ5IHx8ICgnc2VsZWN0ICogZnJvbSAnICsgbGF5ZXJNb2RlbC5nZXQoJ3RhYmxlX25hbWUnKSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfSxcblxuICBfbW9kZWxVcGRhdGVkOiBmdW5jdGlvbihtb2RlbCkge1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5tb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpO1xuICAgIGlmKGNoYW5nZWQgPT09IGZhbHNlKSByZXR1cm47XG4gICAgLypcbiAgICBjaGFuZ2VkLnRpbGVfc3R5bGUgJiYgdGhpcy5zZXRDYXJ0b0NTUyh0aGlzLm1vZGVsLmdldCgndGlsZV9zdHlsZScpKTtcbiAgICBpZiAoJ3F1ZXJ5JyBpbiBjaGFuZ2VkIHx8ICdxdWVyeV93cmFwcGVyJyBpbiBjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldFNRTCh0aGlzLl9nZXRRdWVyeSh0aGlzLm1vZGVsKSk7XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAoJ3Zpc2libGUnIGluIGNoYW5nZWQpXG4gICAgICB0aGlzLm1vZGVsLmdldCgndmlzaWJsZScpID8gdGhpcy5zaG93KCk6IHRoaXMuaGlkZSgpO1xuXG4gICAgaWYgKCd1cmxzJyBpbiBjaGFuZ2VkKSB7XG4gICAgICAvLyBSRUFMIEhBQ0tcbiAgICAgIHRoaXMucHJvdmlkZXIudGVtcGxhdGVVcmwgPSB0aGlzLm1vZGVsLmdldCgndXJscycpLnRpbGVzWzBdO1xuICAgICAgdGhpcy5wcm92aWRlci5fc2V0UmVhZHkodHJ1ZSk7XG4gICAgICB0aGlzLl9yZWxvYWRUaWxlcygpO1xuICAgIH1cbiAgfVxufSk7XG5cbl8uZXh0ZW5kKExlYWZsZXRUb3JxdWVMYXllci5wcm90b3R5cGUsIExlYWZsZXRMYXllclZpZXcucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWFmbGV0VG9ycXVlTGF5ZXI7XG4iLCJ2YXIgdG9ycXVlID0gd2luZG93LnRvcnF1ZSA9IHJlcXVpcmUoJ3RvcnF1ZS5qcycpOyAvLyBzdGFuZGFsb25lIHRvcnF1ZSBsaWIsIHJlcXVpcmVkIGZvciBnbWFwcy9sZWFmbGV0IGxheWVyIHZpZXdcblxuLy8gR2V0IGFuZCBtdXRhdGUgdGhlIGdsb2JhbCBjZGIgb2JqZWN0LCBhZGQgZXhwZWN0ZWQgb2JqZWN0cyBmb3IgZ21hcHMvbGVhZmxldCBpZiBwcmVzZW50OlxudmFyIGNkYiA9IHdpbmRvdy5jZGI7XG5pZiAoIWNkYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NhcnRvZGIuanMgaXMgcmVxdWlyZWQgZm9yIHRoaXMgbGliIHRvIHdvcmssIGxvYWQgaXQgYmVmb3JlIHRoaXMgb25lJyk7XG59XG5cbmlmICh0eXBlb2YgZ29vZ2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ29vZ2xlLm1hcHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNkYi5nZW8uR01hcHNUb3JxdWVMYXllclZpZXcgPSByZXF1aXJlKCcuL2dlby9nbWFwcy9nbWFwcy10b3JxdWUtbGF5ZXItdmlldycpO1xufVxuXG5jZGIuZ2VvLkxlYWZsZXRUb3JxdWVMYXllciA9IHJlcXVpcmUoJy4vZ2VvL2xlYWZsZXQvbGVhZmxldC10b3JxdWUtbGF5ZXInKTtcblxuY2RiLm1vZHVsZUxvYWQoJ3RvcnF1ZScsIHRvcnF1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdG9ycXVlO1xuIl19
